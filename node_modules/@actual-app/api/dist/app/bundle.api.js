/******/ (() => {
    /******/ var __webpack_modules__ = ({
        /***/ "./node_modules/@rschedule/core/es2015/generators.js": 
        /*!***********************************************************!*\
          !*** ./node_modules/@rschedule/core/es2015/generators.js ***!
          \***********************************************************/
        /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony export */ __webpack_require__.d(__webpack_exports__, {
                /* harmony export */ AddOperator: () => ( /* binding */AddOperator),
                /* harmony export */ Calendar: () => ( /* binding */Calendar),
                /* harmony export */ Collection: () => ( /* binding */Collection),
                /* harmony export */ CollectionIterator: () => ( /* binding */CollectionIterator),
                /* harmony export */ Dates: () => ( /* binding */Dates),
                /* harmony export */ IntersectionOperator: () => ( /* binding */IntersectionOperator),
                /* harmony export */ MergeDurationOperator: () => ( /* binding */MergeDurationOperator),
                /* harmony export */ MergeDurationOperatorError: () => ( /* binding */MergeDurationOperatorError),
                /* harmony export */ OccurrenceGenerator: () => ( /* binding */OccurrenceGenerator),
                /* harmony export */ OccurrenceIterator: () => ( /* binding */OccurrenceIterator),
                /* harmony export */ Operator: () => ( /* binding */Operator),
                /* harmony export */ Rule: () => ( /* binding */Rule),
                /* harmony export */ RuleBase: () => ( /* binding */RuleBase),
                /* harmony export */ Schedule: () => ( /* binding */Schedule),
                /* harmony export */ ScheduleBase: () => ( /* binding */ScheduleBase),
                /* harmony export */ SplitDurationOperator: () => ( /* binding */SplitDurationOperator),
                /* harmony export */ SplitDurationOperatorError: () => ( /* binding */SplitDurationOperatorError),
                /* harmony export */ SubtractOperator: () => ( /* binding */SubtractOperator),
                /* harmony export */ UniqueOperator: () => ( /* binding */UniqueOperator),
                /* harmony export */ add: () => ( /* binding */add),
                /* harmony export */ intersection: () => ( /* binding */intersection),
                /* harmony export */ mergeDuration: () => ( /* binding */mergeDuration),
                /* harmony export */ splitDuration: () => ( /* binding */splitDuration),
                /* harmony export */ subtract: () => ( /* binding */subtract),
                /* harmony export */ unique: () => ( /* binding */unique)
                /* harmony export */ 
            });
            /* harmony import */ var _rschedule_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @rschedule/core */ "./node_modules/@rschedule/core/es2015/main.js");
            class OccurrenceGenerator {
                constructor(args = {}) {
                    this.timezone = args.timezone !== undefined ? args.timezone : null;
                    this.maxDuration = args.maxDuration || 0;
                }
                /** Returns the first occurrence or, if there are no occurrences, null. */
                get firstDate() {
                    if (this._firstDate !== undefined)
                        return this._firstDate;
                    const start = this._run().next().value;
                    this._firstDate = start ? this.dateAdapter.fromDateTime(start) : null;
                    return this._firstDate;
                }
                /** If generator is infinite, returns `null`. Otherwise returns the end date */
                get lastDate() {
                    if (this._lastDate !== undefined)
                        return this._lastDate;
                    if (this.isInfinite) {
                        this._lastDate = null;
                        return null;
                    }
                    const end = this._run({ reverse: true }).next().value;
                    this._lastDate = end ? this.dateAdapter.fromDateTime(end) : null;
                    return this._lastDate;
                }
                pipe(...operators) {
                    return operators.reduce((prev, curr) => curr({ base: prev, timezone: this.timezone }), this);
                }
                /**
                   * Processes the object's rules/dates and returns an iterable for the occurrences.
                   *
                   * Options object:
                   * - `start` the date to begin iteration on
                   * - `end` the date to end iteration on
                   * - `take` the max number of dates to take before ending iteration
                   * - `reverse` whether to iterate in reverse or not
                   *
                   * Examples:
                   *
                   * ```
                   * const iterator = schedule.occurrences({ start: new Date(), take: 5 });
                   
                   * for (const date of iterator) {
                   *   // do stuff
                   * }
                
                   * iterator.toArray() // returns Date array
                   * iterator.next().value // returns next Date
                   * ```
                   *
                   */
                occurrences(args = {}) {
                    return new OccurrenceIterator(this, this.normalizeOccurrencesArgs(args));
                }
                /**
                 * Iterates over the object's occurrences and bundles them into collections
                 * with a specified granularity (default is `"YEARLY"`). Make sure to
                 * read about each option & combination of options below.
                 *
                 * Options object:
                 *   - start?: DateAdapter
                 *   - end?: DateAdapter
                 *   - take?: number
                 *   - reverse?: NOT SUPPORTED
                 *   - granularity?: CollectionsGranularity
                 *   - weekStart?: DateAdapter.Weekday
                 *   - skipEmptyPeriods?: boolean
                 *
                 * Returned `Collection` object:
                 *
                 *   - `dates` property containing an array of DateAdapter objects.
                 *   - `granularity` property containing the granularity.
                 *     - `CollectionsGranularity` === `RuleOptions.Frequency`.
                 *     - default is `"YEARLY"`
                 *   - `periodStart` property containing a DateAdapter equal to the period's
                 *     start time.
                 *   - `periodEnd` property containing a DateAdapter equal to the period's
                 *     end time.
                 *
                 * #### Details:
                 *
                 * `collections()` always returns full periods. This means that the `start` argument is
                 * transformed to be the start of whatever period the `start` argument is in, and the
                 * `end` argument is transformed to be the end of whatever period the `end` argument is
                 * in.
                 *
                 * - Example: with granularity `"YEARLY"`, the `start` argument will be transformed to be the
                 *   start of the year passed in the `start` argument, and the `end` argument will be transformed
                 *   to be the end of the year passed in the `end` argument.
                 *
                 * By default, the `periodStart` value of `Collection` objects produced by this method increments linearly.
                 * This means the returned `Collection#dates` property may have length 0. This can be changed by
                 * passing the `skipEmptyPeriods: true` option, in which case the `periodStart` from one collection to the
                 * next can "jump".
                 *
                 * - Example 1: if your object's first occurrence is 2019/2/1 (February 1st) and you call
                 *   `collection({skipEmptyPeriods: true, granularity: 'DAILY', start: new Date(2019,0,1)})`
                 *   (so starting on January 1st), the first Collection produced will have a `periodStart` in February.
                 *
                 * - Example 2: if your object's first occurrence is 2019/2/1 (February 1st) and you call
                 *   `collection({granularity: 'DAILY', start: new Date(2019,0,1)})`
                 *   (so starting on January 1st), the first collection produced will have a `Collection#periodStart`
                 *   of January 1st and have `Collection#dates === []`. Similarly, the next 30 collections produced
                 *   (Jan 2nd - 31st) will all contain an empty array for the `dates` property. Then the February 1st
                 *   `Collection` will contain dates.
                 *
                 * When giving a `take` argument to `collections()`, you are specifying
                 * the number of `Collection` objects to return (rather than occurrences).
                 *
                 * When choosing a granularity of `"WEEKLY"`, the `weekStart` option is required.
                 *
                 * When choosing a granularity of `"MONTHLY"`:
                 *
                 * - If the `weekStart` option *is not* present, will generate collections with
                 *   the `periodStart` and `periodEnd` at the beginning and end of each month.
                 *
                 * - If the `weekStart` option *is* present, will generate collections with the
                 *   `periodStart` equal to the start of the first week of the month, and the
                 *   `periodEnd` equal to the end of the last week of the month. This behavior could be
                 *   desired when rendering opportunities in a calendar view, where the calendar renders
                 *   full weeks (which may result in the calendar displaying dates in the
                 *   previous or next months).
                 *
                 */
                collections(args = {}) {
                    return new CollectionIterator(this, this.normalizeCollectionsArgs(args));
                }
                /**
                 * Returns true if an occurrence starts on or between the provided start/end
                 * datetimes. If the `excludeEnds` option is provided, then occurrences
                 * equal to the start/end times are ignored.
                 *
                 * If the occurrence generator has a duration, and `excludeEnds !== true`,
                 * and a `maxDuration` argument is supplied (either in the constructor or
                 * here), then any occurrence that's time overlaps with the start/end times
                 * return true.
                 */
                occursBetween(startInput, endInput, options = {}) {
                    const start = this.normalizeDateInput(startInput);
                    const end = this.normalizeDateInput(endInput);
                    if (this.hasDuration && !options.excludeEnds) {
                        const maxDuration = this.getMaxDuration('occursBetween', options);
                        const iterator = this._run({
                            start: start.subtract(maxDuration, 'millisecond'),
                            end,
                            reverse: true,
                        });
                        for (const day of iterator) {
                            if (day.end.isBefore(start))
                                continue;
                            return true;
                        }
                        return false;
                    }
                    for (const day of this._run({ start, end })) {
                        if (options.excludeEnds) {
                            if (day.isEqual(start)) {
                                continue;
                            }
                            if (day.isEqual(end)) {
                                break;
                            }
                        }
                        return true;
                    }
                    return false;
                }
                occursOn(rawArgs) {
                    const args = this.normalizeOccursOnArgs(rawArgs);
                    if (args.weekday) {
                        if (this.isInfinite && !args.before) {
                            throw new _rschedule_core__WEBPACK_IMPORTED_MODULE_0__.ArgumentError('When calling `occursOn()` with a `weekday` argument ' +
                                'and an occurrence object that has infinite occurrences, ' +
                                'you must include a `before` argument as well.');
                        }
                        const start = args.after && (args.excludeEnds ? args.after.add(1, 'day') : args.after);
                        const end = args.before && (args.excludeEnds ? args.before.subtract(1, 'day') : args.before);
                        const iterator = this._run({ start, end });
                        let date = iterator.next().value;
                        if (!date)
                            return false;
                        while (date) {
                            if (date.get('weekday') === args.weekday) {
                                return true;
                            }
                            date = iterator.next({
                                skipToDate: date
                                    .add((0, _rschedule_core__WEBPACK_IMPORTED_MODULE_0__.getDifferenceBetweenWeekdays)(date.get('weekday'), args.weekday), 'day')
                                    .granularity('day'),
                            }).value;
                        }
                        return false;
                    }
                    if (!args.date) {
                        throw new _rschedule_core__WEBPACK_IMPORTED_MODULE_0__.ArgumentError(`"occursOn()" must be called with either a "date" or "weekday" argument`);
                    }
                    if (this.hasDuration) {
                        const maxDuration = this.getMaxDuration('occursOn', args);
                        const iterator = this._run({
                            start: args.date.subtract(maxDuration, 'millisecond'),
                            end: args.date,
                        });
                        for (const date of iterator) {
                            if (date.end.isBefore(args.date))
                                continue;
                            if (date.isAfter(args.date))
                                return false;
                            return true;
                        }
                        return false;
                    }
                    for (const day of this._run({ start: args.date, end: args.date })) {
                        return !!day;
                    }
                    return false;
                }
                /**
                 * Returns true if an occurrence starts after the provided datetime.
                 * If the `excludeStart` option is provided, then occurrences
                 * equal to the provided datetime are ignored.
                 *
                 * If the occurrence generator has a duration, and `excludeStart !== true`,
                 * and a `maxDuration` argument is supplied (either in the constructor or
                 * here), then any occurrence that's end time is after/equal to the provided
                 * datetime return true.
                 */
                occursAfter(date, options = {}) {
                    const adapter = this.normalizeDateInput(date);
                    if (this.hasDuration && !options.excludeStart) {
                        const maxDuration = this.getMaxDuration('occursAfter', options);
                        const iterator = this._run({
                            start: adapter.subtract(maxDuration, 'millisecond'),
                        });
                        for (const date of iterator) {
                            if (date.end.isBefore(adapter))
                                continue;
                            return true;
                        }
                        return false;
                    }
                    for (const day of this._run({ start: adapter })) {
                        if (options.excludeStart && day.isEqual(adapter)) {
                            continue;
                        }
                        return true;
                    }
                    return false;
                }
                /**
                 * Returns true if an occurrence starts before the provided datetime.
                 * If the `excludeStart` option is provided, then occurrences
                 * equal to the provided datetime are ignored.
                 *
                 * If the occurrence generator has a duration, and `excludeStart` is
                 * also provided, then this will only return true if an occurrence
                 * both starts and ends before the provided datetime.
                 */
                occursBefore(date, options = {}) {
                    const adapter = this.normalizeDateInput(date);
                    if (this.hasDuration && options.excludeStart) {
                        for (const day of this._run({ end: adapter, reverse: true })) {
                            if (day.end.isAfterOrEqual(adapter))
                                continue;
                            return true;
                        }
                        return false;
                    }
                    for (const day of this._run({ end: adapter, reverse: true })) {
                        if (options.excludeStart && day.isEqual(adapter)) {
                            continue;
                        }
                        return true;
                    }
                    return false;
                }
                get dateAdapter() {
                    return _rschedule_core__WEBPACK_IMPORTED_MODULE_0__.DateAdapterBase.adapter;
                }
                normalizeOccurrencesArgs(rawArgs) {
                    return Object.assign(Object.assign({}, rawArgs), {
                        start: this.normalizeDateInput(rawArgs.start),
                        end: this.normalizeDateInput(rawArgs.end),
                    });
                }
                normalizeCollectionsArgs(rawArgs) {
                    if (rawArgs.reverse !== undefined) {
                        throw new _rschedule_core__WEBPACK_IMPORTED_MODULE_0__.ArgumentError('`collections()` does not support the `reverse` option at this time.');
                    }
                    return Object.assign(Object.assign({}, rawArgs), {
                        start: this.normalizeDateInput(rawArgs.start),
                        end: this.normalizeDateInput(rawArgs.end),
                    });
                }
                normalizeOccursOnArgs(rawArgs = {}) {
                    return Object.assign(Object.assign({}, rawArgs), {
                        date: this.normalizeDateInput(rawArgs.date),
                        after: this.normalizeDateInput(rawArgs.after),
                        before: this.normalizeDateInput(rawArgs.before),
                        excludeDates: rawArgs.excludeDates && rawArgs.excludeDates.map(date => this.normalizeDateInput(date)),
                    });
                }
                normalizeRunArgs(args) {
                    return Object.assign(Object.assign({}, args), {
                        start: this.normalizeDateInput(args.start),
                        end: this.normalizeDateInput(args.end),
                    });
                }
                normalizeDateInput(date) {
                    return date ? (0, _rschedule_core__WEBPACK_IMPORTED_MODULE_0__.dateInputToDateTime)(date, this.timezone) : undefined;
                }
                normalizeDateInputToAdapter(date) {
                    if (!date)
                        return;
                    return (0, _rschedule_core__WEBPACK_IMPORTED_MODULE_0__.dateInputToDateAdapter)(date);
                }
                normalizeRunOutput(date) {
                    return (0, _rschedule_core__WEBPACK_IMPORTED_MODULE_0__.normalizeDateTimeTimezone)(date, this.timezone);
                }
                getMaxDuration(method, options) {
                    const maxDuration = options.maxDuration || this.maxDuration;
                    if (!Number.isInteger(maxDuration)) {
                        throw new _rschedule_core__WEBPACK_IMPORTED_MODULE_0__.ArgumentError(`When an occurrence generator ` +
                            `has a duration, a 'maxDuration' argument must be supplied ` +
                            `to ${method}().`);
                    }
                    return maxDuration;
                }
            }
            class OccurrenceIterator {
                constructor(iterable, args) {
                    this.iterable = iterable;
                    this.args = args;
                    // Need to assert the return type of these methods to prevent typescript from
                    // incorrectly reducing them to `DateAdapterBase & { generators: G }`.
                    this[Symbol.iterator] = () => this.occurrenceIterator();
                    this.iterator = iterable._run(args);
                    this.isInfinite = iterable.isInfinite;
                }
                next(args) {
                    return this.occurrenceIterator(args).next();
                }
                toArray() {
                    if (this.args.end || this.args.take || !this.isInfinite) {
                        return Array.from(this.occurrenceIterator());
                    }
                    throw new _rschedule_core__WEBPACK_IMPORTED_MODULE_0__.InfiniteLoopError('OccurrenceIterator#toArray() can only be called if the iterator ' +
                        'is not infinite, or you provide and `end` argument, or you provide ' +
                        'a `take` argument.');
                }
                *occurrenceIterator(rawArgs) {
                    let args = this.normalizeRunArgs(rawArgs);
                    let date = this.iterator.next(args).value;
                    while (date) {
                        const yieldArgs = yield this.normalizeDateOutput(date);
                        args = this.normalizeRunArgs(yieldArgs);
                        date = this.iterator.next(args).value;
                    }
                    return undefined;
                }
                normalizeRunArgs(args) {
                    return {
                        skipToDate: this.normalizeDateInput(args && args.skipToDate),
                    };
                }
                normalizeDateInput(date) {
                    return date ? (0, _rschedule_core__WEBPACK_IMPORTED_MODULE_0__.dateInputToDateTime)(date, this.iterable.timezone) : undefined;
                }
                normalizeDateOutput(date) {
                    if (!date)
                        return;
                    return date ? _rschedule_core__WEBPACK_IMPORTED_MODULE_0__.DateAdapterBase.adapter.fromDateTime(date) : undefined;
                }
            }
            class Collection {
                constructor(dates = [], granularity, periodStart, periodEnd) {
                    this.dates = dates;
                    this.granularity = granularity;
                    this.periodStart = periodStart;
                    this.periodEnd = periodEnd;
                }
            }
            class CollectionIterator {
                constructor(iterable, args) {
                    this.iterable = iterable;
                    this.args = args;
                    this.granularity = 'year';
                    this[Symbol.iterator] = () => this.iterator;
                    if (args.granularity) {
                        this.granularity = args.granularity;
                        if (this.granularity === 'week' && !args.weekStart) {
                            throw new Error('"week" granularity requires `weekStart` arg');
                        }
                    }
                    if (args.weekStart) {
                        this.weekStart = args.weekStart;
                    }
                    if (args.reverse) {
                        throw new Error('`OccurrenceGenerator#collections()` does not support iterating in reverse. ' +
                            'Though `OccurrenceGenerator#occurrences()` does support iterating in reverse.');
                    }
                    // Set the end arg, if present, to the end of the period.
                    this.args = Object.assign(Object.assign({}, args), {
                        start: args.start || iterable._run().next().value,
                        end: args.end && this.getPeriod(args.end).end,
                    });
                    this.startDate =
                        (this.args.start && this.normalizeDateOutput(this.getPeriod(this.args.start).start)) || null;
                    this.iterator = this.collectionIterator();
                }
                next() {
                    return this.iterator.next();
                }
                /**
                 * While `next()` and `[Symbol.iterator]` both share state,
                 * `toArray()` does not share state and always returns the whole
                 * collections array.
                 */
                toArray() {
                    if (this.args.end || this.args.take || !this.iterable.isInfinite) {
                        const collections = [];
                        for (const collection of this.collectionIterator()) {
                            collections.push(collection);
                        }
                        return collections;
                    }
                    throw new _rschedule_core__WEBPACK_IMPORTED_MODULE_0__.InfiniteLoopError('CollectionIterator#toArray() can only be called if the iterator ' +
                        'is not infinite, or you provide and `end` argument, or you provide ' +
                        'a `take` argument.');
                }
                normalizeDateOutput(date) {
                    if (!date)
                        return;
                    return _rschedule_core__WEBPACK_IMPORTED_MODULE_0__.DateAdapterBase.adapter.fromDateTime(date);
                }
                *collectionIterator() {
                    if (!this.startDate)
                        return;
                    let iterator = this.occurrenceIterator();
                    let date = iterator.next().value;
                    if (!date)
                        return;
                    // `period` === `periodStart` unless the granularity
                    // is `MONTHLY` and a `weekStart` param was provided. In this case,
                    // period holds a date === the first of the current month while
                    // periodStart holds a date === the beginning of the first week of the month
                    // (which might be in the the previous month). Read the
                    // `OccurrenceGenerator#collections()` description for more info.
                    let period = this.getPeriod(this.args.start);
                    let dates = [];
                    let index = 0;
                    while (date && (this.args.take === undefined || this.args.take > index)) {
                        while (date && date.isBeforeOrEqual(period.end)) {
                            dates.push(date);
                            date = iterator.next().value;
                        }
                        yield new Collection(dates.map(date => this.normalizeDateOutput(date)), this.granularity, this.normalizeDateOutput(period.start), this.normalizeDateOutput(period.end));
                        if (!date)
                            return;
                        dates = [];
                        period = !this.args.skipEmptyPeriods
                            ? this.getPeriod(this.incrementPeriod(period.period))
                            : this.getPeriod(date);
                        // With these args, periods may overlap and the same date may show up
                        // in two periods. Because of this, we need to reset the iterator
                        // (otherwise it won't return a date it has already returned).
                        if (this.granularity === 'month' && this.weekStart) {
                            iterator = this.iterable._run({
                                start: period.start,
                                end: this.args.end,
                            });
                            date = iterator.next().value;
                        }
                        index++;
                    }
                }
                getPeriod(date) {
                    let start;
                    let end;
                    let period;
                    if (this.granularity === 'month' && this.weekStart) {
                        start = date.granularity('month').granularity('week', { weekStart: this.weekStart });
                        end = date.endGranularity('month').endGranularity('week', { weekStart: this.weekStart });
                        period = date.granularity('month');
                    }
                    else {
                        start = date.granularity(this.granularity, { weekStart: this.weekStart });
                        end = date.endGranularity(this.granularity, { weekStart: this.weekStart });
                        period = start;
                    }
                    return { start, end, period };
                }
                incrementPeriod(date) {
                    return date.add(1, this.granularity);
                }
                occurrenceIterator() {
                    let start = this.args.start || this.iterable._run().next().value;
                    if (!start)
                        return this.iterable._run(this.args);
                    start = this.getPeriod(start).start;
                    return this.iterable._run({
                        start,
                        end: this.args.end,
                    });
                }
            }
            class Operator extends OccurrenceGenerator {
                constructor(streams, config) {
                    super(config);
                    this.streams = streams;
                    this.config = config;
                    this.timezone = config.timezone;
                    this.streams = streams.map(stream => stream instanceof Operator ? stream : stream.set('timezone', this.timezone));
                    this.isInfinite = this.calculateIsInfinite();
                    this.hasDuration = this.calculateHasDuration();
                }
                normalizeDateInput(date) {
                    if (!date)
                        return;
                    return (0, _rschedule_core__WEBPACK_IMPORTED_MODULE_0__.dateInputToDateTime)(date, this.timezone);
                }
                normalizeRunOutput(date) {
                    return (0, _rschedule_core__WEBPACK_IMPORTED_MODULE_0__.normalizeDateTimeTimezone)(date, this.timezone);
                }
            }
            /**
             * Simple class that lets us access the `value`, `runArgs`, and `done`
             * status of an OccurrenceGenerator iterator
             */
            class IterableWrapper {
                constructor(generator, runArgs) {
                    this.runArgs = runArgs;
                    this.stream = generator._run(this.runArgs);
                    this.next();
                }
                next(args) {
                    const { done, value } = this.stream.next(args);
                    this.done = typeof done === 'boolean' ? done : true;
                    this.value = value;
                    return { done, value };
                }
            }
            function processYieldArgs(streams, options = {}, yieldArgs = {}) {
                if (!yieldArgs.skipToDate || streams.length === 0)
                    return;
                // check for invalid `skipToDate` option
                if (options.reverse
                    ? streams.every(s => s.value.isBeforeOrEqual(yieldArgs.skipToDate))
                    : streams.every(s => s.value.isAfterOrEqual(yieldArgs.skipToDate))) {
                    throw new Error('A provided `skipToDate` option must be greater than the last yielded date ' +
                        '(or smaller, in the case of reverse iteration)');
                }
                for (const stream of streams) {
                    if (stream.done)
                        continue; // no point in calling `next()`
                    if (options.reverse
                        ? stream.value.isBeforeOrEqual(yieldArgs.skipToDate)
                        : stream.value.isAfterOrEqual(yieldArgs.skipToDate)) {
                        // This can happen there are two streams and one stream starts after the other finishes.
                        // Or, when iterating in reverse, when one stream ends before the other starts.
                        // In this case we don't want to call `next()` because it will throw an error.
                        // In both of these cases, calling `next()` won't do anything anyway.
                        continue;
                    }
                    stream.next(yieldArgs);
                }
            }
            /** sorts ascending with completed iterables at the end */
            function streamsComparer(a, b) {
                if (a.done && b.done)
                    return 0;
                if (a.done)
                    return 1;
                if (b.done)
                    return -1;
                if (a.value.isAfter(b.value))
                    return 1;
                return -1;
            }
            /** sorts descending with completed iterables at the start */
            function streamsReverseComparer(a, b) {
                if (a.done && b.done)
                    return 0;
                if (a.done)
                    return -1;
                if (b.done)
                    return 1;
                if (a.value.isAfter(b.value))
                    return -1;
                return 1;
            }
            function selectNextIterable(streams, options = {}, yieldArgs = {}) {
                processYieldArgs(streams, options, yieldArgs);
                return streams
                    .sort(options.reverse ? streamsReverseComparer : streamsComparer)
                    .filter(s => !s.done)
                    .shift();
            }
            function selectLastIterable(streams, options = {}, yieldArgs = {}) {
                processYieldArgs(streams, options, yieldArgs);
                return streams
                    .sort(options.reverse ? streamsReverseComparer : streamsComparer)
                    .filter(s => !s.done)
                    .pop();
            }
            /**
             * An operator function which accepts a spread of occurrence generators
             * and adds their occurrences to the output.
             *
             * @param streams a spread of occurrence generators
             */
            function add(...streams) {
                return options => new AddOperator(streams, options);
            }
            class AddOperator extends Operator {
                set(_, value) {
                    return new AddOperator(this.streams.map(stream => stream.set('timezone', value)), Object.assign(Object.assign({}, this.config), {
                        base: this.config.base && this.config.base.set('timezone', value),
                        timezone: value,
                    }));
                }
                *_run(args = {}) {
                    const wrappedStreams = this.streams.map(input => new IterableWrapper(input, args));
                    if (this.config.base) {
                        wrappedStreams.push(new IterableWrapper(this.config.base, args));
                    }
                    if (wrappedStreams.length === 0)
                        return;
                    let stream = selectNextIterable(wrappedStreams, args);
                    while (stream && !stream.done) {
                        // yield the current stream's value
                        const yieldArgs = yield this.normalizeRunOutput(stream.value);
                        if (!(yieldArgs && yieldArgs.skipToDate)) {
                            // iterate the current stream
                            stream.next();
                        }
                        // select the next stream
                        stream = selectNextIterable(wrappedStreams, args, yieldArgs);
                    }
                }
                calculateIsInfinite() {
                    return ((this.config.base && this.config.base.isInfinite) ||
                        this.streams.some(stream => stream.isInfinite));
                }
                calculateHasDuration() {
                    const streamsDuration = this.streams.every(stream => stream.hasDuration);
                    if (!this.config.base)
                        return streamsDuration;
                    return this.config.base.hasDuration && streamsDuration;
                }
            }
            class Calendar extends OccurrenceGenerator {
                /**
                 *
                 * Create a new Calendar object with the specified options.
                 *
                 * ### Options
                 *
                 * - **timezone**: The timezone that yielded occurrences should be *displayed* in.
                 *   Note, this one affects the *displayed* timezone of yielded occurrences.
                 *   For rules, occurrences are first found using the unmodified rule
                 *   config (including whatever timezone the `start` datetime is defined
                 *   in), and then converted to the timezone specified here before being
                 *   yielded. By default, the timezone is *local* time (`null`). So if you don't
                 *   want your rules to be displayed in local time, you must supply a
                 *   timezone argument.
                 * - **data**: arbitrary data you can associate with this Calendar. This
                 *   is the only mutable property of `Calendar` objects.
                 * - **maxDuration**: currently unused.
                 * - **schedules**: either an occurrence generator, or an array of occurrence generators, which should
                 *   be used to build up this Calendar's occurrences. The Calendar will display the union of occurrences
                 *   its schedules produce.
                 *
                 */
                constructor(args = {}) {
                    super(args);
                    this.schedules = [];
                    this.data = args.data;
                    if (args.schedules) {
                        this.schedules = Array.isArray(args.schedules) ? args.schedules : [args.schedules];
                        this.schedules = this.schedules.map(schedule => schedule.set('timezone', this.timezone));
                    }
                    this.isInfinite = this.schedules.some(schedule => schedule.isInfinite);
                    this.hasDuration = this.schedules.every(schedule => schedule.hasDuration);
                }
                occurrences(args = {}) {
                    return new OccurrenceIterator(this, this.normalizeOccurrencesArgs(args));
                }
                collections(args = {}) {
                    return new CollectionIterator(this, this.normalizeCollectionsArgs(args));
                }
                set(prop, value, options) {
                    if (prop === 'timezone') {
                        return new Calendar({
                            schedules: this.schedules.map(schedule => schedule.set(prop, value, options)),
                            data: this.data,
                            timezone: value,
                            maxDuration: this.maxDuration,
                        });
                    }
                    else if (prop === 'schedules') {
                        return new Calendar({
                            schedules: Array.isArray(value) ? value : [value],
                            data: this.data,
                            timezone: this.timezone,
                            maxDuration: this.maxDuration,
                        });
                    }
                    throw new _rschedule_core__WEBPACK_IMPORTED_MODULE_0__.ArgumentError('Unknown value for `prop`: ' + `"${prop}"`);
                }
                *_run(args = {}) {
                    if (this.schedules.length === 0)
                        return;
                    const count = args.take;
                    delete args.take;
                    let iterator;
                    if (this.schedules.length === 1) {
                        iterator = this.schedules[0]._run(args);
                    }
                    else {
                        iterator = new AddOperator(this.schedules, {
                            timezone: this.timezone,
                        })._run(args);
                    }
                    let date = iterator.next().value;
                    let index = 0;
                    while (date && (count === undefined || count > index)) {
                        date = date.add(this, 'generator');
                        const yieldArgs = yield this.normalizeRunOutput(date);
                        date = iterator.next(yieldArgs).value;
                        index++;
                    }
                    return undefined;
                }
            }
            class Dates extends OccurrenceGenerator {
                constructor(args = {}) {
                    super(args);
                    this.adapters = [];
                    this.isInfinite = false;
                    this.maxDuration = 0;
                    this.datetimes = [];
                    this.data = args.data;
                    if (args.dates) {
                        this.adapters = args.dates.map(date => {
                            let adapter = this.normalizeDateInputToAdapter(date);
                            if (args.duration && !adapter.duration) {
                                adapter = adapter.set('duration', args.duration);
                            }
                            return adapter.set('timezone', this.timezone);
                        });
                        this.datetimes = this.adapters.map(adapter => adapter.toDateTime());
                    }
                    this.hasDuration = this.datetimes.every(date => !!date.duration);
                    if (this.hasDuration) {
                        this.maxDuration = this.adapters.reduce((prev, curr) => (curr.duration > prev ? curr.duration : prev), 0);
                    }
                }
                get length() {
                    return this.adapters.length;
                }
                /** Returns the first occurrence or, if there are no occurrences, null. */
                get firstDate() {
                    return this.adapters[0] || null;
                }
                /** Returns the last occurrence or, if there are no occurrences, null. */
                get lastDate() {
                    return this.adapters[this.length - 1] || null;
                }
                occurrences(args = {}) {
                    return new OccurrenceIterator(this, this.normalizeOccurrencesArgs(args));
                }
                collections(args = {}) {
                    return new CollectionIterator(this, this.normalizeCollectionsArgs(args));
                }
                add(value) {
                    return new Dates({
                        dates: [...this.adapters, value],
                        timezone: this.timezone,
                        data: this.data,
                    });
                }
                remove(value) {
                    const dates = this.adapters.slice();
                    const input = this.normalizeDateInputToAdapter(value);
                    const index = dates.findIndex(date => date.valueOf() === input.valueOf());
                    if (index >= 0) {
                        dates.splice(index, 1);
                    }
                    return new Dates({
                        dates,
                        timezone: this.timezone,
                        data: this.data,
                    });
                }
                set(prop, value, options = {}) {
                    let timezone = this.timezone;
                    let dates = this.adapters.slice();
                    if (prop === 'timezone') {
                        if (value === this.timezone)
                            return this;
                        else if (options.keepLocalTime) {
                            dates = this.adapters.map(adapter => {
                                const json = adapter.toJSON();
                                json.timezone = value;
                                return this.dateAdapter.fromJSON(json);
                            });
                        }
                        timezone = value;
                    }
                    else if (prop === 'dates') {
                        dates = value;
                    }
                    else if (prop === 'duration') {
                        dates = dates.map(date => date.set('duration', value || 0));
                    }
                    else {
                        throw new _rschedule_core__WEBPACK_IMPORTED_MODULE_0__.ArgumentError(`Unexpected prop argument "${prop}". Accepted values are "timezone" or "dates"`);
                    }
                    return new Dates({
                        dates,
                        data: this.data,
                        timezone,
                    });
                }
                filter(fn) {
                    return new Dates({
                        dates: this.adapters.filter(fn),
                        data: this.data,
                        timezone: this.timezone,
                    });
                }
                *_run(args = {}) {
                    let dates = this.datetimes.sort(_rschedule_core__WEBPACK_IMPORTED_MODULE_0__.dateTimeSortComparer);
                    if (args.start) {
                        dates = dates.filter(date => date.isAfterOrEqual(args.start));
                    }
                    if (args.end) {
                        dates = dates.filter(date => date.isBeforeOrEqual(args.end));
                    }
                    if (args.reverse) {
                        dates = dates.slice().reverse();
                    }
                    if (args.take) {
                        dates = dates.slice(0, args.take);
                    }
                    const dateCache = dates.slice();
                    let date = dateCache.shift();
                    let yieldArgs;
                    while (date) {
                        if (yieldArgs &&
                            yieldArgs.skipToDate &&
                            (args.reverse ? yieldArgs.skipToDate.isBefore(date) : yieldArgs.skipToDate.isAfter(date))) {
                            date = dateCache.shift();
                            continue;
                        }
                        date = date.add(this, 'generator');
                        yieldArgs = yield this.normalizeRunOutput(date);
                        // Here, we are matching the behavior of the RecurrenceRulesIterator
                        if (yieldArgs &&
                            yieldArgs.skipToDate &&
                            (args.reverse
                                ? yieldArgs.skipToDate.isAfterOrEqual(date)
                                : yieldArgs.skipToDate.isBeforeOrEqual(date))) {
                            throw new Error('A provided `skipToDate` option must be greater than the last yielded date ' +
                                '(or smaller, in the case of reverse iteration)');
                        }
                        date = dateCache.shift();
                    }
                    return undefined;
                }
            }
            class InvalidDateAdapterError extends Error {
            }
            let dateAdapterConfig;
            class DateAdapterBase {
                constructor(_date, options) {
                    /**
                     * The metadata property is intended to store arbitrary data
                     * related to this DateAdapter. Unlike other properties, the
                     * metadata property is intended to be mutable.
                     */
                    this.metadata = {};
                    this.duration = (options && options.duration) || 0;
                    this.generators = (options && options.generators && options.generators.slice()) || [];
                    if (!Number.isInteger(this.duration) || this.duration < 0) {
                        throw new InvalidDateAdapterError('duration must be a non-negative integer');
                    }
                }
                static set adapter(value) {
                    if (dateAdapterConfig) {
                        throw new Error(`"${dateAdapterConfig.name}" has already been configured.`);
                    }
                    dateAdapterConfig = value;
                }
                static get adapter() {
                    if (!dateAdapterConfig) {
                        throw new Error('No date adapter has been configured. See rSchedule docs.');
                    }
                    return dateAdapterConfig;
                }
                static isDate(_object) {
                    throw unimplementedError('isDate()');
                }
                static fromDate(_date, _options) {
                    throw unimplementedError('fromDate()');
                }
                static fromJSON(_json) {
                    throw unimplementedError('fromJSON()');
                }
                static fromDateTime(_datetime) {
                    throw unimplementedError('fromDateTime()');
                }
                /**
                 * Returns a string in simplified extended ISO format (ISO 8601).
                 *
                 * _Note: this method is intended for testing and its
                 * implementation isn't particularly performant._
                 */
                toISOString() {
                    return this.set('timezone', 'UTC')
                        .toDateTime()
                        .toISOString();
                }
                toDateTime() {
                    const date = DateTime.fromJSON(Object.assign(Object.assign({}, this.toJSON()), {
                        generators: this.generators,
                        metadata: this.metadata,
                    }));
                    return date;
                }
            }
            DateAdapterBase.hasTimezoneSupport = false;
            function unimplementedError(name) {
                return new Error(`You must implement the "${name}" method for this DateAdapter class`);
            }
            var DateAdapter;
            (function (DateAdapter) {
                DateAdapter.WEEKDAYS = ['SU', 'MO', 'TU', 'WE', 'TH', 'FR', 'SA'];
                DateAdapter.MILLISECONDS_IN_SECOND = 1000;
                DateAdapter.MILLISECONDS_IN_MINUTE = DateAdapter.MILLISECONDS_IN_SECOND * 60;
                DateAdapter.MILLISECONDS_IN_HOUR = DateAdapter.MILLISECONDS_IN_MINUTE * 60;
                DateAdapter.MILLISECONDS_IN_DAY = DateAdapter.MILLISECONDS_IN_HOUR * 24;
                DateAdapter.MILLISECONDS_IN_WEEK = DateAdapter.MILLISECONDS_IN_DAY * 7;
            })(DateAdapter || (DateAdapter = {}));
            class InvalidDateTimeError extends Error {
            }
            class DateTime {
                constructor(date, timezone, duration, generators, options = {}) {
                    this.metadata = {};
                    this.date = new Date(date);
                    this.timezone = timezone || null;
                    this.duration = duration || 0;
                    this.generators = (generators && generators.slice()) || [];
                    if (!Number.isInteger(this.duration) || this.duration < 0) {
                        throw new InvalidDateTimeError('duration must be a non-negative integer');
                    }
                    if (options.metadata) {
                        Object.assign(this.metadata, options.metadata);
                    }
                    this.assertIsValid();
                }
                // /**
                //  * Similar to `Array.isArray()`, `isInstance()` provides a surefire method
                //  * of determining if an object is a `DateTime` by checking against the
                //  * global symbol registry.
                //  */
                // static isInstance(object: any): object is DateTime {
                //   return !!(object && object[DATETIME_ID]);
                // }
                static fromJSON(json) {
                    const date = new Date(Date.UTC(json.year, json.month - 1, json.day, json.hour, json.minute, json.second, json.millisecond));
                    return new DateTime(date, json.timezone, json.duration, json.generators, {
                        metadata: json.metadata,
                    });
                }
                static fromDateAdapter(adapter) {
                    return DateTime.fromJSON(Object.assign(Object.assign({}, adapter.toJSON()), {
                        generators: adapter.generators,
                        metadata: adapter.metadata,
                    }));
                }
                /**
                 * Returns `undefined` if `duration` is `0`. Else returns
                 * the `end` date.
                 */
                get end() {
                    if (!this.duration)
                        return;
                    if (this._end)
                        return this._end;
                    this._end = this.add(this.duration, 'millisecond');
                    return this._end;
                }
                // While we constrain the argument to be another DateAdapter in typescript
                // we handle the case of someone passing in another type of object in javascript
                isEqual(object) {
                    if (!object) {
                        return false;
                    }
                    assertSameTimeZone(this, object);
                    return this.valueOf() === object.valueOf();
                }
                isBefore(object) {
                    assertSameTimeZone(this, object);
                    return this.valueOf() < object.valueOf();
                }
                isBeforeOrEqual(object) {
                    assertSameTimeZone(this, object);
                    return this.valueOf() <= object.valueOf();
                }
                isAfter(object) {
                    assertSameTimeZone(this, object);
                    return this.valueOf() > object.valueOf();
                }
                isAfterOrEqual(object) {
                    assertSameTimeZone(this, object);
                    return this.valueOf() >= object.valueOf();
                }
                isOccurring(object) {
                    if (!this.duration) {
                        throw new Error('DateTime#isOccurring() is only applicable to DateTimes with durations');
                    }
                    assertSameTimeZone(this, object);
                    return (object.isAfterOrEqual(this) && object.isBeforeOrEqual(this.add(this.duration, 'millisecond')));
                }
                add(amount, unit) {
                    switch (unit) {
                        case 'generator': {
                            const generators = this.generators.slice();
                            generators.unshift(amount);
                            return new DateTime(this.date, this.timezone, this.duration, generators);
                        }
                        case 'year':
                            return this.forkDateTime(addUTCYears(this.date, amount));
                        case 'month':
                            return this.forkDateTime(addUTCMonths(this.date, amount));
                        case 'week':
                            return this.forkDateTime(addUTCWeeks(this.date, amount));
                        case 'day':
                            return this.forkDateTime(addUTCDays(this.date, amount));
                        case 'hour':
                            return this.forkDateTime(addUTCHours(this.date, amount));
                        case 'minute':
                            return this.forkDateTime(addUTCMinutes(this.date, amount));
                        case 'second':
                            return this.forkDateTime(addUTCSeconds(this.date, amount));
                        case 'millisecond':
                            return this.forkDateTime(addUTCMilliseconds(this.date, amount));
                        default:
                            throw new Error('Invalid unit provided to `DateTime#add`');
                    }
                }
                subtract(amount, unit) {
                    switch (unit) {
                        case 'year':
                            return this.forkDateTime(subUTCYears(this.date, amount));
                        case 'month':
                            return this.forkDateTime(subUTCMonths(this.date, amount));
                        case 'week':
                            return this.forkDateTime(subUTCWeeks(this.date, amount));
                        case 'day':
                            return this.forkDateTime(subUTCDays(this.date, amount));
                        case 'hour':
                            return this.forkDateTime(subUTCHours(this.date, amount));
                        case 'minute':
                            return this.forkDateTime(subUTCMinutes(this.date, amount));
                        case 'second':
                            return this.forkDateTime(subUTCSeconds(this.date, amount));
                        case 'millisecond':
                            return this.forkDateTime(subUTCMilliseconds(this.date, amount));
                        default:
                            throw new Error('Invalid unit provided to `DateTime#subtract`');
                    }
                }
                get(unit) {
                    switch (unit) {
                        case 'year':
                            return this.date.getUTCFullYear();
                        case 'month':
                            return this.date.getUTCMonth() + 1;
                        case 'yearday':
                            return getUTCYearDay(this.date);
                        case 'weekday':
                            return DateAdapter.WEEKDAYS[this.date.getUTCDay()];
                        case 'day':
                            return this.date.getUTCDate();
                        case 'hour':
                            return this.date.getUTCHours();
                        case 'minute':
                            return this.date.getUTCMinutes();
                        case 'second':
                            return this.date.getUTCSeconds();
                        case 'millisecond':
                            return this.date.getUTCMilliseconds();
                        default:
                            throw new Error('Invalid unit provided to `DateTime#set`');
                    }
                }
                set(unit, value) {
                    if (unit === 'duration') {
                        return new DateTime(this.date, this.timezone, value, this.generators);
                    }
                    if (unit === 'generators') {
                        return new DateTime(this.date, this.timezone, this.duration, value);
                    }
                    let date = new Date(this.date);
                    switch (unit) {
                        case 'year':
                            date.setUTCFullYear(value);
                            break;
                        case 'month': {
                            // If the current day of the month
                            // is greater than days in the month we are moving to, we need to also
                            // set the day to the end of that month.
                            const length = monthLength(value, date.getUTCFullYear());
                            const day = date.getUTCDate();
                            if (day > length) {
                                date.setUTCDate(1);
                                date.setUTCMonth(value);
                                date = subUTCDays(date, 1);
                            }
                            else {
                                date.setUTCMonth(value - 1);
                            }
                            break;
                        }
                        case 'day':
                            date.setUTCDate(value);
                            break;
                        case 'hour':
                            date.setUTCHours(value);
                            break;
                        case 'minute':
                            date.setUTCMinutes(value);
                            break;
                        case 'second':
                            date.setUTCSeconds(value);
                            break;
                        case 'millisecond':
                            date.setUTCMilliseconds(value);
                            break;
                        default:
                            throw new Error('Invalid unit provided to `DateTime#set`');
                    }
                    return this.forkDateTime(date);
                }
                granularity(granularity, opt = {}) {
                    let date = this.forkDateTime(this.date);
                    switch (granularity) {
                        case 'year':
                            date = date.set('month', 1);
                        case 'month':
                            date = date.set('day', 1);
                            break;
                        case 'week':
                            date = setDateToStartOfWeek(date, opt.weekStart);
                    }
                    switch (granularity) {
                        case 'year':
                        case 'month':
                        case 'week':
                        case 'day':
                            date = date.set('hour', 0);
                        case 'hour':
                            date = date.set('minute', 0);
                        case 'minute':
                            date = date.set('second', 0);
                        case 'second':
                            date = date.set('millisecond', 0);
                        case 'millisecond':
                            return date;
                        default:
                            throw new Error('Invalid granularity provided to `DateTime#granularity`: ' + granularity);
                    }
                }
                endGranularity(granularity, opt = {}) {
                    let date = this.forkDateTime(this.date);
                    switch (granularity) {
                        case 'year':
                            date = date.set('month', 12);
                        case 'month':
                            date = date.set('day', monthLength(date.get('month'), date.get('year')));
                            break;
                        case 'week':
                            date = setDateToEndOfWeek(date, opt.weekStart);
                    }
                    switch (granularity) {
                        case 'year':
                        case 'month':
                        case 'week':
                        case 'day':
                            date = date.set('hour', 23);
                        case 'hour':
                            date = date.set('minute', 59);
                        case 'minute':
                            date = date.set('second', 59);
                        case 'second':
                            date = date.set('millisecond', 999);
                        case 'millisecond':
                            return date;
                        default:
                            throw new Error('Invalid granularity provided to `DateTime#granularity`: ' + granularity);
                    }
                }
                toISOString() {
                    return this.date.toISOString();
                }
                toDateTime() {
                    return this;
                }
                toJSON() {
                    const json = {
                        timezone: this.timezone,
                        year: this.get('year'),
                        month: this.get('month'),
                        day: this.get('day'),
                        hour: this.get('hour'),
                        minute: this.get('minute'),
                        second: this.get('second'),
                        millisecond: this.get('millisecond'),
                    };
                    if (this.duration) {
                        json.duration = this.duration;
                    }
                    return json;
                }
                valueOf() {
                    return this.date.valueOf();
                }
                assertIsValid() {
                    if (isNaN(this.valueOf())) {
                        throw new InvalidDateTimeError('DateTime has invalid date.');
                    }
                    return true;
                }
                forkDateTime(date) {
                    return new DateTime(date, this.timezone, this.duration, this.generators);
                }
            }
            function assertSameTimeZone(x, y) {
                if (x.timezone !== y.timezone) {
                    throw new InvalidDateTimeError('Attempted to compare a datetime to another date in a different timezone: ' +
                        JSON.stringify(x) +
                        ' and ' +
                        JSON.stringify(y));
                }
                return true;
            }
            function setDateToStartOfWeek(date, wkst) {
                const index = orderedWeekdays(wkst).indexOf(date.get('weekday'));
                return date.subtract(index, 'day');
            }
            function setDateToEndOfWeek(date, wkst) {
                const index = orderedWeekdays(wkst).indexOf(date.get('weekday'));
                return date.add(6 - index, 'day');
            }
            function orderedWeekdays(wkst = 'SU') {
                const wkdays = DateAdapter.WEEKDAYS.slice();
                let index = wkdays.indexOf(wkst);
                while (index !== 0) {
                    shiftArray(wkdays);
                    index--;
                }
                return wkdays;
            }
            function shiftArray(array, from = 'first') {
                if (array.length === 0) {
                    return array;
                }
                else if (from === 'first') {
                    array.push(array.shift());
                }
                else {
                    array.unshift(array.pop());
                }
                return array;
            }
            /**
             * Returns the days in the given month.
             *
             * @param month base-1
             * @param year
             */
            function monthLength(month, year) {
                const block = {
                    1: 31,
                    2: getDaysInFebruary(year),
                    3: 31,
                    4: 30,
                    5: 31,
                    6: 30,
                    7: 31,
                    8: 31,
                    9: 30,
                    10: 31,
                    11: 30,
                    12: 31,
                };
                return block[month];
            }
            function getDaysInFebruary(year) {
                return isLeapYear(year) ? 29 : 28;
            }
            // taken from date-fn
            function isLeapYear(year) {
                return year % 400 === 0 || (year % 4 === 0 && year % 100 !== 0);
            }
            function getUTCYearDay(now) {
                const start = new Date(Date.UTC(now.getUTCFullYear(), 0, 1));
                const diff = now.valueOf() - start.valueOf();
                return 1 + Math.floor(diff / DateAdapter.MILLISECONDS_IN_DAY);
            }
            /**
             * These functions are basically lifted from `date-fns`, but changed
             * to use the UTC date methods, which `date-fns` doesn't support.
             */
            function toInteger(input) {
                if (input === null || input === true || input === false) {
                    return NaN;
                }
                const int = Number(input);
                if (isNaN(int)) {
                    return int;
                }
                return int < 0 ? Math.ceil(int) : Math.floor(int);
            }
            function addMilliseconds(dirtyDate, dirtyAmount) {
                if (arguments.length < 2) {
                    throw new TypeError('2 arguments required, but only ' + arguments.length + ' present');
                }
                const timestamp = dirtyDate.valueOf();
                const amount = toInteger(dirtyAmount);
                return new Date(timestamp + amount);
            }
            function addUTCYears(date, input) {
                const amount = toInteger(input);
                return addUTCMonths(date, amount * 12);
            }
            function addUTCMonths(date, input) {
                const amount = toInteger(input);
                date = new Date(date);
                const desiredMonth = date.getUTCMonth() + amount;
                const dateWithDesiredMonth = new Date(0);
                dateWithDesiredMonth.setUTCFullYear(date.getUTCFullYear(), desiredMonth, 1);
                dateWithDesiredMonth.setUTCHours(0, 0, 0, 0);
                const daysInMonth = monthLength(dateWithDesiredMonth.getUTCMonth() + 1, dateWithDesiredMonth.getUTCFullYear());
                // Set the last day of the new month
                // if the original date was the last day of the longer month
                date.setUTCMonth(desiredMonth, Math.min(daysInMonth, date.getUTCDate()));
                return date;
            }
            function addUTCWeeks(date, input) {
                const amount = toInteger(input);
                const days = amount * 7;
                return addUTCDays(date, days);
            }
            function addUTCDays(date, input) {
                // by adding milliseconds rather than days, we supress the native Date object's automatic
                // daylight savings time conversions which we don't want in UTC mode
                return addUTCMilliseconds(date, toInteger(input) * DateAdapter.MILLISECONDS_IN_DAY);
            }
            function addUTCHours(date, input) {
                const amount = toInteger(input);
                return addMilliseconds(date, amount * DateAdapter.MILLISECONDS_IN_HOUR);
            }
            function addUTCMinutes(date, input) {
                const amount = toInteger(input);
                return addMilliseconds(date, amount * DateAdapter.MILLISECONDS_IN_MINUTE);
            }
            function addUTCSeconds(date, input) {
                const amount = toInteger(input);
                return addMilliseconds(date, amount * DateAdapter.MILLISECONDS_IN_SECOND);
            }
            function addUTCMilliseconds(date, input) {
                const amount = toInteger(input);
                const timestamp = date.getTime();
                return new Date(timestamp + amount);
            }
            function subUTCYears(date, amount) {
                return addUTCYears(date, -amount);
            }
            function subUTCMonths(date, amount) {
                return addUTCMonths(date, -amount);
            }
            function subUTCWeeks(date, amount) {
                return addUTCWeeks(date, -amount);
            }
            function subUTCDays(date, amount) {
                return addUTCDays(date, -amount);
            }
            function subUTCHours(date, amount) {
                return addUTCHours(date, -amount);
            }
            function subUTCMinutes(date, amount) {
                return addUTCMinutes(date, -amount);
            }
            function subUTCSeconds(date, amount) {
                return addUTCSeconds(date, -amount);
            }
            function subUTCMilliseconds(date, amount) {
                return addUTCMilliseconds(date, -amount);
            }
            // export function normalizeDateInput<T extends DateAdapter>(
            //   dateAdapter: DateAdapterConstructor<T>,
            //   input: DateInput<T>,
            //   timezone: string | null,
            // ): DateTime {
            //   if (input instanceof DateTime) {
            //     if (input.timezone !== timezone) {
            //       return dateAdapter
            //         .fromDateTime(input)
            //         .set('timezone', timezone)
            //         .toDateTime();
            //     }
            //     return input;
            //   }
            //   return input instanceof DateAdapter
            //     ? input.set('timezone', timezone).toDateTime()
            //     : new dateAdapter(input).toDateTime();
            // }
            function normalizeDateTimeTimezone(date, timezone) {
                if (date.timezone !== timezone) {
                    return DateAdapterBase.adapter
                        .fromDateTime(date)
                        .set('timezone', timezone)
                        .toDateTime();
                }
                return date;
            }
            class RuleBase extends OccurrenceGenerator {
                constructor(recurrenceRules, config, options = {}) {
                    super(options);
                    this.recurrenceRules = recurrenceRules;
                    this.options = (0, _rschedule_core__WEBPACK_IMPORTED_MODULE_0__.cloneRuleOptions)(config);
                    this.normOptions = (0, _rschedule_core__WEBPACK_IMPORTED_MODULE_0__.normalizeRuleOptions)(this.recurrenceRules, this.options);
                    this.timezone =
                        options.timezone !== undefined ? options.timezone : this.normOptions.start.timezone;
                    this.data = options.data;
                    this.hasDuration = !!config.duration;
                    if (this.hasDuration)
                        this.duration = config.duration;
                    this.isInfinite = this.normOptions.end === undefined && this.normOptions.count === undefined;
                }
                occurrences(args = {}) {
                    return new OccurrenceIterator(this, this.normalizeOccurrencesArgs(args));
                }
                collections(args = {}) {
                    return new CollectionIterator(this, this.normalizeCollectionsArgs(args));
                }
                *_run(rawArgs = {}) {
                    const args = this.normalizeRunArgs(rawArgs);
                    const iterator = new _rschedule_core__WEBPACK_IMPORTED_MODULE_0__.RecurrenceRulesIterator((0, _rschedule_core__WEBPACK_IMPORTED_MODULE_0__.recurrenceRulesReducer)(this.recurrenceRules), this.normOptions, args);
                    let date = iterator.next().value;
                    let index = 0;
                    while (date && (args.take === undefined || index < args.take)) {
                        index++;
                        date = date.add(this, 'generator');
                        const yieldArgs = yield this.normalizeRunOutput(date);
                        if (yieldArgs === null || yieldArgs === void 0 ? void 0 : yieldArgs.skipToDate) {
                            // The RecurrenceRuleIterator might have a different timezone from the rule.
                            // Because of this, the yieldArgs will not properly be normalized by the
                            // OccurrenceIterator, so we need to do it here
                            date = iterator.next(Object.assign(Object.assign({}, yieldArgs), {
                                skipToDate: normalizeDateTimeTimezone(yieldArgs.skipToDate, iterator.start.timezone),
                            })).value;
                        }
                        else {
                            // theoretically, the yieldArgs are undefined here
                            // maybe in the future there will be other yieldArg options though
                            date = iterator.next(yieldArgs).value;
                        }
                    }
                    return undefined;
                }
            }
            class Rule extends RuleBase {
                /**
                 * Create a new Rule object with the specified rule config and options.
                 *
                 * ### Options
                 *
                 * - **timezone**: the timezone that yielded occurrences should be in. Note,
                 *   this does not change the rule config. Occurrences are first found using
                 *   the unmodified rule config, and then converted to the timezone specified
                 *   here before being yielded.
                 * - **data**: arbitrary data you can associate with this rule. This
                 *   is the only mutable property of `Rule` objects.
                 *
                 * ### Rule Config
                 *
                 * - #### frequency
                 *
                 *   The frequency rule part identifies the type of recurrence rule. Valid values
                 *   include `"SECONDLY"`, `"MINUTELY"`, `"HOURLY"`, `"DAILY"`, `"WEEKLY"`,
                 *   `"MONTHLY"`, or `"YEARLY"`.
                 *
                 * - #### start
                 *
                 *   The start of the rule (not necessarily the first occurrence).
                 *   Either a `DateAdapter` instance, date object, or `DateTime` object.
                 *   The type of date object depends on the `DateAdapter` class used for this
                 *   `Rule`.
                 *
                 * - #### end?
                 *
                 *   The end of the rule (not necessarily the last occurrence).
                 *   Either a `DateAdapter` instance, date object, or `DateTime` object.
                 *   The type of date object depends on the `DateAdapter` class used for this
                 *   `Rule`.
                 *
                 * - #### duration?
                 *
                 *   A length of time expressed in milliseconds.
                 *
                 * - #### interval?
                 *
                 *   The interval rule part contains a positive integer representing at
                 *   which intervals the recurrence rule repeats. The default value is
                 *   `1`, meaning every second for a SECONDLY rule, every minute for a
                 *   MINUTELY rule, every hour for an HOURLY rule, every day for a
                 *   DAILY rule, every week for a WEEKLY rule, every month for a
                 *   MONTHLY rule, and every year for a YEARLY rule. For example,
                 *   within a DAILY rule, a value of `8` means every eight days.
                 *
                 * - #### count?
                 *
                 *   The count rule part defines the number of occurrences at which to
                 *   range-bound the recurrence. `count` and `end` are both two different
                 *   ways of specifying how a recurrence completes.
                 *
                 * - #### weekStart?
                 *
                 *   The weekStart rule part specifies the day on which the workweek starts.
                 *   Valid values are `"MO"`, `"TU"`, `"WE"`, `"TH"`, `"FR"`, `"SA"`, and `"SU"`.
                 *   This is significant when a WEEKLY rule has an interval greater than 1,
                 *   and a `byDayOfWeek` rule part is specified. The
                 *   default value is `"MO"`.
                 *
                 * - #### bySecondOfMinute?
                 *
                 *   The bySecondOfMinute rule part expects an array of seconds
                 *   within a minute. Valid values are 0 to 60.
                 *
                 * - #### byMinuteOfHour?
                 *
                 *   The byMinuteOfHour rule part expects an array of minutes within an hour.
                 *   Valid values are 0 to 59.
                 *
                 * - #### byHourOfDay?
                 *
                 *   The byHourOfDay rule part expects an array of hours of the day.
                 *   Valid values are 0 to 23.
                 *
                 * - #### byDayOfWeek?
                 *
                 *   *note: the byDayOfWeek rule part is kinda complex. Blame the ICAL spec.*
                 *
                 *   The byDayOfWeek rule part expects an array. Each array entry can
                 *   be a day of the week (`"SU"`, `"MO"` , `"TU"`, `"WE"`, `"TH"`,
                 *   `"FR"`, `"SA"`). If the rule's `frequency` is either MONTHLY or YEARLY,
                 *   Any entry can also be a tuple where the first value of the tuple is a
                 *   day of the week and the second value is an positive/negative integer
                 *   (e.g. `["SU", 1]`). In this case, the number indicates the nth occurrence of
                 *   the specified day within the MONTHLY or YEARLY rule.
                 *
                 *   The behavior of byDayOfWeek changes depending on the `frequency`
                 *   of the rule.
                 *
                 *   Within a MONTHLY rule, `["MO", 1]` represents the first Monday
                 *   within the month, whereas `["MO", -1]` represents the last Monday
                 *   of the month.
                 *
                 *   Within a YEARLY rule, the numeric value in a byDayOfWeek tuple entry
                 *   corresponds to an offset within the month when the byMonthOfYear rule part is
                 *   present, and corresponds to an offset within the year otherwise.
                 *
                 *   Regardless of rule `frequency`, if a byDayOfWeek entry is a string
                 *   (rather than a tuple), it means "all of these days" within the specified
                 *   frequency (e.g. within a MONTHLY rule, `"MO"` represents all Mondays within
                 *   the month).
                 *
                 * - #### byDayOfMonth?
                 *
                 *   The byDayOfMonth rule part expects an array of days
                 *   of the month. Valid values are 1 to 31 or -31 to -1.
                 *
                 *   For example, -10 represents the tenth to the last day of the month.
                 *   The byDayOfMonth rule part *must not* be specified when the rule's
                 *   `frequency` is set to WEEKLY.
                 *
                 * - #### byMonthOfYear?
                 *
                 *   The byMonthOfYear rule part expects an array of months
                 *   of the year. Valid values are 1 to 12.
                 *
                 */
                constructor(config, options = {}) {
                    super(Rule.recurrenceRules, config, options);
                }
                set(prop, value, tzoptions = {}) {
                    let options = (0, _rschedule_core__WEBPACK_IMPORTED_MODULE_0__.cloneRuleOptions)(this.options);
                    let timezone = this.timezone;
                    if (prop === 'timezone') {
                        if (value === this.timezone && !tzoptions.keepLocalTime)
                            return this;
                        else if (tzoptions.keepLocalTime) {
                            const json = this.normalizeDateInput(options.start).toJSON();
                            json.timezone = value;
                            const adapter = this.dateAdapter.fromJSON(json);
                            // prettier-ignore
                            options.start =
                                options.start instanceof this.dateAdapter ? adapter :
                                    options.start instanceof _rschedule_core__WEBPACK_IMPORTED_MODULE_0__.DateTime ? adapter.toDateTime() :
                                        adapter.date;
                        }
                        timezone = value;
                    }
                    else if (prop === 'options') {
                        options = value;
                    }
                    else {
                        options[prop] = value;
                    }
                    return new Rule(options, {
                        data: this.data,
                        maxDuration: this.maxDuration,
                        timezone,
                    });
                }
            }
            Rule.recurrenceRules = [];
            class ScheduleBase extends OccurrenceGenerator {
                /**
                 * Create a new Schedule object with the specified options.
                 *
                 * The order of precidence for rrules, rdates, exrules, and exdates is:
                 *
                 * 1. rrules are included
                 * 2. exrules are excluded
                 * 3. rdates are included
                 * 4. exdates are excluded
                 *
                 */
                constructor(options) {
                    super(options);
                    this.data = options.data;
                }
                occurrences(args = {}) {
                    return new OccurrenceIterator(this, this.normalizeOccurrencesArgs(args));
                }
                collections(args = {}) {
                    return new CollectionIterator(this, this.normalizeCollectionsArgs(args));
                }
                *_run(args = {}) {
                    const count = args.take;
                    delete args.take;
                    const iterator = this.occurrenceStream._run(args);
                    let date = iterator.next().value;
                    let index = 0;
                    while (date && (count === undefined || count > index)) {
                        date = date.add(this, 'generator');
                        const yieldArgs = yield this.normalizeRunOutput(date);
                        date = iterator.next(yieldArgs).value;
                        index++;
                    }
                    return undefined;
                }
            }
            /**
             * An operator function which accepts a spread of occurrence generators
             * and removes their occurrences from the output.
             *
             * @param streams a spread of occurrence generators
             */
            function subtract(...streams) {
                return options => new SubtractOperator(streams, options);
            }
            class SubtractOperator extends Operator {
                /** Not actually used but necessary for IRunnable interface */
                set(_, value) {
                    return new SubtractOperator(this.streams.map(stream => stream.set('timezone', value)), Object.assign(Object.assign({}, this.config), {
                        base: this.config.base && this.config.base.set('timezone', value),
                        timezone: value,
                    }));
                }
                *_run(args = {}) {
                    if (!this.config.base)
                        return;
                    const inclusion = new IterableWrapper(this.config.base, args);
                    const exclusion = new IterableWrapper(new AddOperator(this.streams, {
                        timezone: this.config.timezone,
                    }), args);
                    cycleStreams(inclusion, exclusion, args);
                    while (!inclusion.done) {
                        const yieldArgs = yield this.normalizeRunOutput(inclusion.value);
                        if (!(yieldArgs && yieldArgs.skipToDate)) {
                            inclusion.next();
                        }
                        cycleStreams(inclusion, exclusion, args, yieldArgs);
                    }
                }
                calculateIsInfinite() {
                    return !!(this.config.base && this.config.base.isInfinite);
                }
                calculateHasDuration() {
                    return !!(this.config.base && this.config.base.hasDuration);
                }
            }
            function cycleStreams(inclusion, exclusion, options = {}, yieldArgs = {}) {
                processYieldArgs([inclusion, exclusion], options, yieldArgs);
                iterateExclusion(inclusion, exclusion, options);
                while (!inclusion.done && !exclusion.done && inclusion.value.isEqual(exclusion.value)) {
                    inclusion.next();
                    iterateExclusion(inclusion, exclusion, options);
                }
            }
            function iterateExclusion(inclusion, exclusion, options = {}) {
                if (options.reverse) {
                    while (!exclusion.done && !inclusion.done && exclusion.value.isAfter(inclusion.value)) {
                        exclusion.next();
                    }
                    return;
                }
                while (!exclusion.done && !inclusion.done && exclusion.value.isBefore(inclusion.value)) {
                    exclusion.next();
                }
            }
            /**
             * An operator function which deduplicates an occurrence stream. Occurrence
             * `duration` is currently ignored.
             */
            function unique() {
                return options => new UniqueOperator([], options);
            }
            class UniqueOperator extends Operator {
                /** Not actually used but necessary for IRunnable interface */
                set(_, value) {
                    return new UniqueOperator([], Object.assign(Object.assign({}, this.config), {
                        base: this.config.base && this.config.base.set('timezone', value),
                        timezone: value,
                    }));
                }
                *_run(args = {}) {
                    if (!this.config.base)
                        return;
                    const stream = new IterableWrapper(this.config.base, args);
                    while (!stream.done) {
                        const yieldArgs = yield this.normalizeRunOutput(stream.value);
                        const lastValue = stream.value;
                        // iterate the current stream
                        stream.next(yieldArgs);
                        while (!(yieldArgs && yieldArgs.skipToDate) &&
                            !stream.done &&
                            stream.value.isEqual(lastValue)) {
                            stream.next();
                        }
                    }
                }
                calculateIsInfinite() {
                    return !!(this.config.base && this.config.base.isInfinite);
                }
                calculateHasDuration() {
                    return !!(this.config.base && this.config.base.hasDuration);
                }
            }
            class Schedule extends ScheduleBase {
                /**
                 * Create a new Schedule object with the specified options.
                 *
                 * The order of precidence for rrules, rdates, exrules, and exdates is:
                 *
                 * 1. rrules are included
                 * 2. exrules are excluded
                 * 3. rdates are included
                 * 4. exdates are excluded
                 *
                 * ### Options
                 *
                 * - **timezone**: The timezone that yielded occurrences should be *displayed* in.
                 *   Note, this one affects the *displayed* timezone of yielded occurrences.
                 *   For rules, occurrences are first found using the unmodified rule
                 *   config (including whatever timezone the `start` datetime is defined
                 *   in), and then converted to the timezone specified here before being
                 *   yielded. By default, the timezone is *local* time (`null`). So if you don't
                 *   want your rules to be displayed in local time, you must supply a
                 *   timezone argument.
                 * - **data**: arbitrary data you can associate with this Schedule. This
                 *   is the only mutable property of `Schedule` objects.
                 * - **maxDuration**: currently unused.
                 * - **rrules**: rules specifying when occurrences happen. See the "Rule Config"
                 *   section below.
                 * - **rdates**: individual dates that should be _included_ in the schedule.
                 * - **exdates**: individual dates that should be _excluded_ from the schedule.
                 * - **exrules**: rules specifying when occurrences shouldn't happen. See the
                 *   "Rule Config" section below.
                 *
                 * ### Rule Config
                 *
                 * - #### frequency
                 *
                 *   The frequency rule part identifies the type of recurrence rule. Valid values
                 *   include `"SECONDLY"`, `"MINUTELY"`, `"HOURLY"`, `"DAILY"`, `"WEEKLY"`,
                 *   `"MONTHLY"`, or `"YEARLY"`.
                 *
                 * - #### start
                 *
                 *   The start of the rule (not necessarily the first occurrence).
                 *   Either a `DateAdapter` instance, date object, or `DateTime` object.
                 *   The type of date object depends on the `DateAdapter` class used for this
                 *   `Rule`.
                 *
                 * - #### end?
                 *
                 *   The end of the rule (not necessarily the last occurrence).
                 *   Either a `DateAdapter` instance, date object, or `DateTime` object.
                 *   The type of date object depends on the `DateAdapter` class used for this
                 *   `Rule`.
                 *
                 * - #### duration?
                 *
                 *   A length of time expressed in milliseconds.
                 *
                 * - #### interval?
                 *
                 *   The interval rule part contains a positive integer representing at
                 *   which intervals the recurrence rule repeats. The default value is
                 *   `1`, meaning every second for a SECONDLY rule, every minute for a
                 *   MINUTELY rule, every hour for an HOURLY rule, every day for a
                 *   DAILY rule, every week for a WEEKLY rule, every month for a
                 *   MONTHLY rule, and every year for a YEARLY rule. For example,
                 *   within a DAILY rule, a value of `8` means every eight days.
                 *
                 * - #### count?
                 *
                 *   The count rule part defines the number of occurrences at which to
                 *   range-bound the recurrence. `count` and `end` are both two different
                 *   ways of specifying how a recurrence completes.
                 *
                 * - #### weekStart?
                 *
                 *   The weekStart rule part specifies the day on which the workweek starts.
                 *   Valid values are `"MO"`, `"TU"`, `"WE"`, `"TH"`, `"FR"`, `"SA"`, and `"SU"`.
                 *   This is significant when a WEEKLY rule has an interval greater than 1,
                 *   and a `byDayOfWeek` rule part is specified. The
                 *   default value is `"MO"`.
                 *
                 * - #### bySecondOfMinute?
                 *
                 *   The bySecondOfMinute rule part expects an array of seconds
                 *   within a minute. Valid values are 0 to 60.
                 *
                 * - #### byMinuteOfHour?
                 *
                 *   The byMinuteOfHour rule part expects an array of minutes within an hour.
                 *   Valid values are 0 to 59.
                 *
                 * - #### byHourOfDay?
                 *
                 *   The byHourOfDay rule part expects an array of hours of the day.
                 *   Valid values are 0 to 23.
                 *
                 * - #### byDayOfWeek?
                 *
                 *   *note: the byDayOfWeek rule part is kinda complex. Blame the ICAL spec.*
                 *
                 *   The byDayOfWeek rule part expects an array. Each array entry can
                 *   be a day of the week (`"SU"`, `"MO"` , `"TU"`, `"WE"`, `"TH"`,
                 *   `"FR"`, `"SA"`). If the rule's `frequency` is either MONTHLY or YEARLY,
                 *   Any entry can also be a tuple where the first value of the tuple is a
                 *   day of the week and the second value is an positive/negative integer
                 *   (e.g. `["SU", 1]`). In this case, the number indicates the nth occurrence of
                 *   the specified day within the MONTHLY or YEARLY rule.
                 *
                 *   The behavior of byDayOfWeek changes depending on the `frequency`
                 *   of the rule.
                 *
                 *   Within a MONTHLY rule, `["MO", 1]` represents the first Monday
                 *   within the month, whereas `["MO", -1]` represents the last Monday
                 *   of the month.
                 *
                 *   Within a YEARLY rule, the numeric value in a byDayOfWeek tuple entry
                 *   corresponds to an offset within the month when the byMonthOfYear rule part is
                 *   present, and corresponds to an offset within the year otherwise.
                 *
                 *   Regardless of rule `frequency`, if a byDayOfWeek entry is a string
                 *   (rather than a tuple), it means "all of these days" within the specified
                 *   frequency (e.g. within a MONTHLY rule, `"MO"` represents all Mondays within
                 *   the month).
                 *
                 * - #### byDayOfMonth?
                 *
                 *   The byDayOfMonth rule part expects an array of days
                 *   of the month. Valid values are 1 to 31 or -31 to -1.
                 *
                 *   For example, -10 represents the tenth to the last day of the month.
                 *   The byDayOfMonth rule part *must not* be specified when the rule's
                 *   `frequency` is set to WEEKLY.
                 *
                 * - #### byMonthOfYear?
                 *
                 *   The byMonthOfYear rule part expects an array of months
                 *   of the year. Valid values are 1 to 12.
                 *
                 */
                constructor(options = {}) {
                    super(options);
                    this.rrules = [];
                    this.exrules = [];
                    for (const prop of ['rrules', 'exrules']) {
                        const arg = options[prop];
                        if (arg) {
                            this[prop] = arg.map(ruleArgs => {
                                if (ruleArgs instanceof Rule) {
                                    return ruleArgs.set('timezone', this.timezone);
                                }
                                else {
                                    return new Rule(ruleArgs, {
                                        timezone: this.timezone,
                                    });
                                }
                            });
                        }
                    }
                    for (const prop of ['rdates', 'exdates']) {
                        const arg = options[prop];
                        if (arg) {
                            this[prop] =
                                arg instanceof Dates
                                    ? arg.set('timezone', this.timezone)
                                    : new Dates({
                                        dates: arg,
                                        timezone: this.timezone,
                                    });
                        }
                        else {
                            this[prop] = new Dates({
                                timezone: this.timezone,
                            });
                        }
                    }
                    this.hasDuration =
                        this.rrules.every(rule => rule.hasDuration) &&
                            this.exrules.every(rule => rule.hasDuration) &&
                            this.rdates.hasDuration &&
                            this.exdates.hasDuration;
                    this.isInfinite = this.rrules.some(rule => rule.isInfinite);
                    this.occurrenceStream = [
                        add(...this.rrules),
                        subtract(...this.exrules),
                        add(this.rdates),
                        subtract(this.exdates),
                        unique(),
                    ].reduce((prev, curr) => curr({ base: prev, timezone: this.timezone }), undefined);
                }
                add(prop, value) {
                    const rrules = this.rrules.slice();
                    const exrules = this.exrules.slice();
                    let rdates = this.rdates;
                    let exdates = this.exdates;
                    switch (prop) {
                        case 'rrule':
                            rrules.push(value);
                            break;
                        case 'exrule':
                            exrules.push(value);
                            break;
                        case 'rdate':
                            rdates = this.rdates.add(value);
                            break;
                        case 'exdate':
                            exdates = this.exdates.add(value);
                            break;
                    }
                    return new Schedule({
                        timezone: this.timezone,
                        data: this.data,
                        rrules,
                        exrules,
                        rdates,
                        exdates,
                    });
                }
                remove(prop, value) {
                    let rrules = this.rrules;
                    let exrules = this.exrules;
                    let rdates = this.rdates;
                    let exdates = this.exdates;
                    switch (prop) {
                        case 'rrule':
                            rrules = rrules.filter(rule => rule !== value);
                            break;
                        case 'exrule':
                            exrules = exrules.filter(rule => rule !== value);
                            break;
                        case 'rdate':
                            rdates = this.rdates.remove(value);
                            break;
                        case 'exdate':
                            exdates = this.exdates.remove(value);
                            break;
                    }
                    return new Schedule({
                        timezone: this.timezone,
                        data: this.data,
                        rrules,
                        exrules,
                        rdates,
                        exdates,
                    });
                }
                set(prop, value, options = {}) {
                    let timezone = this.timezone;
                    let rrules = this.rrules;
                    let exrules = this.exrules;
                    let rdates = this.rdates;
                    let exdates = this.exdates;
                    switch (prop) {
                        case 'timezone':
                            if (value === this.timezone && !options.keepLocalTime)
                                return this;
                            else if (options.keepLocalTime) {
                                rrules = rrules.map(rule => rule.set('timezone', value, options));
                                exrules = exrules.map(rule => rule.set('timezone', value, options));
                                rdates = rdates.set('timezone', value, options);
                                exdates = exdates.set('timezone', value, options);
                            }
                            timezone = value;
                            break;
                        case 'rrules':
                            rrules = value;
                            break;
                        case 'exrules':
                            exrules = value;
                            break;
                        case 'rdates':
                            rdates = value;
                            break;
                        case 'exdates':
                            exdates = value;
                            break;
                    }
                    return new Schedule({
                        timezone,
                        data: this.data,
                        rrules,
                        exrules,
                        rdates,
                        exdates,
                    });
                }
            }
            /**
             * An operator function, which takes a spread of occurrence generators and only
             * returns the dates which intersect every occurrence generator.
             *
             * Because it's possible for all the generators to never intersect,
             * and because the intersection operator can't detect this lack of intersection,
             * you must call `intersection()` with a `{maxFailedIterations: number}` argument.
             * For convenience, you can globally set `RScheduleConfig.defaultMaxFailedIterations`.
             * Without further information, I'd probably set `defaultMaxFailedIterations = 50`.
             *
             * The `maxFailedIterations` argument caps the number of iterations the operator will
             * run through without finding a single valid occurrence. If this number is reached, the operator will
             * stop iterating (preventing a possible infinite loop).
             *
             * - Note: `maxFailedIterations` caps the number of iterations which
             *   *fail to turn up a single valid occurrence*. Every time a valid occurrence is returned,
             *   the current iteration count is reset to 0.
             *
             */
            function intersection(args) {
                return options => new IntersectionOperator(args, options);
            }
            class IntersectionOperator extends Operator {
                constructor(args, config) {
                    super(args.streams, config);
                    if (this.isInfinite) {
                        this.maxFailedIterations =
                            args.maxFailedIterations || IntersectionOperator.defaultMaxFailedIterations;
                        if (!this.maxFailedIterations) {
                            throw new _rschedule_core__WEBPACK_IMPORTED_MODULE_0__.ArgumentError('The IntersectionOperator must be provided ' +
                                'a `maxFailedIterations` argument when it is built from schedules of infinite length. ' +
                                'This argument is used to ensure that the IntersectionOperator does not enter ' +
                                'an infinite loop because the underlying schedules never intersect. ' +
                                'If the `maxFailedIterations` count is reached it will be assumed that ' +
                                'all valid occurrences have been found and iteration will end without error.' +
                                'Without additional information, "50" is probably a good ' +
                                '`maxFailedIterations` value. ' +
                                'If the schedules are not of infinite length, `maxFailedIterations` is ignored. ' +
                                'Note also that you can provide a `defaultMaxFailedIterations` number via ' +
                                'IntersectionOperator.defaultMaxFailedIterations.');
                        }
                    }
                }
                set(_, value) {
                    return new IntersectionOperator({
                        maxFailedIterations: this.maxFailedIterations,
                        streams: this.streams.map(stream => stream.set('timezone', value)),
                    }, Object.assign(Object.assign({}, this.config), {
                        base: this.config.base && this.config.base.set('timezone', value),
                        timezone: value,
                    }));
                }
                *_run(args = {}) {
                    const streams = this.streams.map(stream => new IterableWrapper(stream, args));
                    if (this.config.base) {
                        streams.push(new IterableWrapper(this.config.base, args));
                    }
                    if (streams.length === 0)
                        return;
                    const hasEndDate = !!(!this.isInfinite || args.reverse || args.end);
                    if (!cycleStreams$1(streams, undefined, Object.assign(Object.assign({}, args), {
                        hasEndDate,
                        iteration: 0,
                        maxIterations: this.maxFailedIterations,
                    }))) {
                        return;
                    }
                    let stream = selectNextIterable(streams, args);
                    while (stream) {
                        const yieldArgs = yield this.normalizeRunOutput(stream.value);
                        const lastValidDate = stream.value;
                        if (!(yieldArgs === null || yieldArgs === void 0 ? void 0 : yieldArgs.skipToDate)) {
                            // iterate the current stream
                            stream.next();
                        }
                        if (!cycleStreams$1(streams, lastValidDate, Object.assign(Object.assign({}, args), {
                            hasEndDate,
                            iteration: 0,
                            maxIterations: this.maxFailedIterations,
                        }), yieldArgs)) {
                            return;
                        }
                        // The call to `cycleStreams()`, above, has already called
                        // selectNextIterable with the `yieldArgs`
                        stream = selectNextIterable(streams, args);
                    }
                }
                calculateIsInfinite() {
                    // Note: Array#every() === true when length === 0
                    if (!this.config.base) {
                        if (this.streams.length === 0)
                            return false;
                        return this.streams.every(stream => stream.isInfinite);
                    }
                    else if (this.streams.length === 0)
                        return this.config.base.isInfinite;
                    return this.config.base.isInfinite && this.streams.every(stream => stream.isInfinite);
                }
                calculateHasDuration() {
                    const streamsDuration = this.streams.every(stream => stream.hasDuration);
                    if (!this.config.base)
                        return streamsDuration;
                    return this.config.base.hasDuration && streamsDuration;
                }
            }
            function cycleStreams$1(streams, lastValidDate, options, yieldArgs) {
                const next = selectNextIterable(streams, options, yieldArgs);
                if (!next)
                    return false;
                if (lastValidDate && next.value.isEqual(lastValidDate))
                    return true;
                if (streams.some(stream => stream.done))
                    return false;
                if (streams.every(stream => stream.value.isEqual(next.value)))
                    return true;
                options.iteration++;
                if (options.maxIterations && !options.hasEndDate && options.iteration > options.maxIterations) {
                    return false;
                }
                // Since not all of the streams are equal, we grab the last stream...
                const last = selectLastIterable(streams, options);
                // ...and skip all the other streams so they are equal or past the last one
                streams.forEach(stream => {
                    // Because streams can have multiple, identical dates in a row,
                    // we don't want to `skipToDate` if the provided date is equal to the current date.
                    if (last.value.isEqual(stream.value))
                        return;
                    stream.next({ skipToDate: last.value });
                });
                // then we repeat
                return cycleStreams$1(streams, lastValidDate, options);
            }
            class DurationIterableWrapper extends IterableWrapper {
                constructor(generator, runArgs) {
                    super(generator, runArgs);
                    this.workingValue = this.value;
                    this.next();
                }
            }
            class MergeDurationOperatorError extends Error {
            }
            /**
             * An operator function which takes an occurrence stream with
             * `hasDuration === true` and merges occurrences which have overlapping
             * start and end times.
             *
             * Because it's possible for all the occurrences in the stream to have
             * overlapping start and end times, you must provide a `maxDuration`
             * argument that represents the maximum possible duration for a single
             * occurrence. If this duration is exceeded, a `MergeDurationOperatorError`
             * will be thrown.
             *
             * - For your convenience, you can globally set a default
             *   `MergeDurationOperator#maxDuration` via
             *   `RScheduleConfig.MergeDurationOperator.defaultMaxDuration`.
             *
             * Usage example:
             *
             * ```typescript
             * const MILLISECONDS_IN_HOUR = 1000 * 60 * 60;
             *
             * const dates = new Dates({
             *   dates: [
             *     new StandardDateAdapter(new Date(2010, 10, 10, 13), { duration: MILLISECONDS_IN_HOUR * 1 }),
             *     new StandardDateAdapter(new Date(2010, 10, 11, 13), { duration: MILLISECONDS_IN_HOUR * 2 }),
             *     new StandardDateAdapter(new Date(2010, 10, 11, 14), { duration: MILLISECONDS_IN_HOUR * 2 }),
             *     new StandardDateAdapter(new Date(2010, 10, 12, 13), { duration: MILLISECONDS_IN_HOUR * 1 }),
             *   ],
             *   dateAdpter: StandardDateAdapter,
             * }).pipe(
             *   mergeDuration({
             *     maxDuration: MILLISECONDS_IN_HOUR * 24
             *   })
             * )
             *
             * dates.occurrences().toArray() === [
             *   new StandardDateAdapter(new Date(2010, 10, 10, 13), { duration: MILLISECONDS_IN_HOUR * 1 }),
             *   new StandardDateAdapter(new Date(2010, 10, 11, 13), { duration: MILLISECONDS_IN_HOUR * 3 }),
             *   new StandardDateAdapter(new Date(2010, 10, 12, 13), { duration: MILLISECONDS_IN_HOUR * 1 }),
             * ]
             * ```
             */
            function mergeDuration(args) {
                return options => new MergeDurationOperator(args, options);
            }
            class MergeDurationOperator extends Operator {
                constructor(args, config) {
                    super([], config);
                    this.maxDuration = args.maxDuration;
                    if (config.base && !config.base.hasDuration) {
                        throw new _rschedule_core__WEBPACK_IMPORTED_MODULE_0__.ArgumentError('Base stream provided to MergeDurationOperator does not have an associated duration. ' +
                            'The MergeDurationOperator can only be used with streams which have a duration. ');
                    }
                }
                /** Not actually used but necessary for IRunnable interface */
                set(_, value) {
                    return new MergeDurationOperator({
                        maxDuration: this.maxDuration,
                    }, Object.assign(Object.assign({}, this.config), {
                        base: this.config.base && this.config.base.set('timezone', value),
                        timezone: value,
                    }));
                }
                _run(args = {}) {
                    return args.reverse ? this.reverseRun(args) : this.forwardRun(args);
                }
                calculateIsInfinite() {
                    return !!(this.config.base && this.config.base.isInfinite);
                }
                calculateHasDuration() {
                    return true;
                }
                *forwardRun(args = {}) {
                    if (!this.config.base)
                        return;
                    // We want to find occurrences that end after the provided
                    // `start` time even if they begin before the provided `start`
                    // time. Because of this, we must begin iterating `maxDuration`
                    // before the provided start time.
                    let checkFromStart = args.start;
                    if (args.start) {
                        checkFromStart = args.start.subtract(this.maxDuration, 'millisecond');
                    }
                    let checkFromEnd = args.end;
                    if (args.end) {
                        checkFromEnd = args.end.add(this.maxDuration, 'millisecond');
                    }
                    const stream = new DurationIterableWrapper(this.config.base, Object.assign(Object.assign({}, args), { start: checkFromStart, end: checkFromEnd }));
                    let yieldArgs;
                    // checking `stream.workingValue` because when `stream.done === true`
                    // `stream.workingValue` will not have been yielded yet
                    while (stream.workingValue) {
                        // TODO(@john.carroll.p): figure out how to handle `DateTime#generators` for merged `DateTimes`
                        while (!stream.done && stream.workingValue.end.isAfterOrEqual(stream.value)) {
                            if (stream.workingValue.duration > this.maxDuration) {
                                throw new MergeDurationOperatorError(`MergeDurationOperatorError: Occurrence duration exceeded maxDuration of ` +
                                    this.maxDuration);
                            }
                            if (stream.value.end.isAfter(stream.workingValue.end)) {
                                const diff = stream.value.end.valueOf() - stream.workingValue.end.valueOf();
                                stream.workingValue = stream.workingValue.set('duration', stream.workingValue.duration + diff);
                            }
                            stream.next();
                        }
                        // check to make sure the occurrence we are about to yield ends after the
                        // provided start time.
                        if (args.start && stream.workingValue.end.isBefore(args.start)) {
                            stream.workingValue = stream.value;
                            stream.next();
                            continue;
                        }
                        // make sure the occurrence we are about to yield ends after the
                        // provided skipToDate
                        if ((yieldArgs === null || yieldArgs === void 0 ? void 0 : yieldArgs.skipToDate) &&
                            stream.workingValue.end.isBefore(yieldArgs.skipToDate)) {
                            stream.workingValue = stream.value;
                            stream.next();
                            continue;
                        }
                        // make sure we are not after the user requested `end` time.
                        if (args.end && stream.workingValue && stream.workingValue.isAfter(args.end)) {
                            break;
                        }
                        if (stream.workingValue.duration > this.maxDuration) {
                            throw new MergeDurationOperatorError(`MergeDurationOperatorError: Occurrence duration exceeded maxDuration of ` +
                                this.maxDuration);
                        }
                        yieldArgs = yield this.normalizeRunOutput(stream.workingValue);
                        if ((yieldArgs === null || yieldArgs === void 0 ? void 0 : yieldArgs.skipToDate) &&
                            stream.workingValue.isAfterOrEqual(yieldArgs.skipToDate)) {
                            throw new Error('A provided `skipToDate` option must be greater than the last yielded date ' +
                                '(or smaller, in the case of reverse iteration)');
                        }
                        stream.workingValue = stream.value;
                        stream.next();
                    }
                }
                *reverseRun(args = {}) {
                    if (!this.config.base)
                        return;
                    // We want to find occurrences that end after the provided
                    // `start` time even if they begin before the provided `start`
                    // time. Because of this, we must begin iterating `maxDuration`
                    // before the provided start time.
                    let checkFromStart = args.start;
                    if (args.start) {
                        checkFromStart = args.start.subtract(this.maxDuration, 'millisecond');
                    }
                    let checkFromEnd = args.end;
                    if (args.end) {
                        checkFromEnd = args.end.add(this.maxDuration, 'millisecond');
                    }
                    const stream = new DurationIterableWrapper(this.config.base, Object.assign(Object.assign({}, args), { start: checkFromStart, end: checkFromEnd }));
                    let yieldArgs;
                    // checking `stream.workingValue` because when `stream.done === true`
                    // `stream.workingValue` will not have been yielded yet
                    while (stream.workingValue) {
                        // TODO(@john.carroll.p): figure out how to handle `DateTime#generators` for merged `DateTimes`
                        while (!stream.done && stream.workingValue.isBeforeOrEqual(stream.value.end)) {
                            if (stream.workingValue.duration > this.maxDuration) {
                                throw new MergeDurationOperatorError(`MergeDurationOperatorError: Occurrence duration exceeded maxDuration of ` +
                                    this.maxDuration);
                            }
                            if (stream.value.isBefore(stream.workingValue) ||
                                stream.value.end.isAfter(stream.workingValue.end)) {
                                if (stream.value.end.isAfter(stream.workingValue.end)) {
                                    // `stream.workingValue` is a subset of `stream.value`
                                    // so simply replace `stream.workingValue` with `stream.value`
                                    stream.workingValue = stream.value;
                                }
                                else {
                                    const diff = stream.workingValue.valueOf() - stream.value.valueOf();
                                    stream.workingValue = stream.value.set('duration', stream.workingValue.duration + diff);
                                }
                            }
                            stream.next();
                        }
                        // check to make sure the occurrence we are about to yield starts before the
                        // provided start time.
                        if (args.start && stream.workingValue.end.isBefore(args.start)) {
                            break;
                        }
                        if (yieldArgs &&
                            yieldArgs.skipToDate &&
                            stream.workingValue.end.isBefore(yieldArgs.skipToDate)) {
                            stream.workingValue = stream.value;
                            stream.next();
                            continue;
                        }
                        // make sure we are not after the user requested `end` time.
                        if (args.end && stream.workingValue && stream.workingValue.isAfter(args.end)) {
                            stream.workingValue = stream.value;
                            stream.next();
                            continue;
                        }
                        if (stream.workingValue.duration > this.maxDuration) {
                            throw new MergeDurationOperatorError(`MergeDurationOperatorError: Occurrence duration exceeded maxDuration of ` +
                                this.maxDuration);
                        }
                        yieldArgs = yield this.normalizeRunOutput(stream.workingValue);
                        if (yieldArgs &&
                            yieldArgs.skipToDate &&
                            stream.workingValue.end.isBeforeOrEqual(yieldArgs.skipToDate)) {
                            throw new Error('A provided `skipToDate` option must be greater than the last yielded date ' +
                                '(or smaller, in the case of reverse iteration)');
                        }
                        stream.workingValue = stream.value;
                        stream.next();
                    }
                }
            }
            class SplitDurationOperatorError extends Error {
            }
            /**
             * An operator function which takes an occurrence stream with
             * `hasDuration === true` and passes occurrences through a splitting
             * function. One usecase for this operator is to dynamically break up
             * occurrences with a large duration into several smaller occurrences.
             *
             * You must provide a `maxDuration` argument that represents the
             * maximum possible duration for a single occurrence. If this
             * duration is exceeded, a `SplitDurationOperatorError` will be
             * thrown.
             *
             * - For your convenience, you can globally set a default
             *   `SplitDurationOperator#maxDuration` via
             *   `RScheduleConfig.SplitDurationOperator.defaultMaxDuration`.
             *
             * Usage example:
             *
             * ```typescript
             * const MILLISECONDS_IN_HOUR = 1000 * 60 * 60;
             *
             * const splitFn = (date: DateTime) => {
             *   if (date.duration > MILLISECONDS_IN_HOUR) {
             *     const diff = date.duration! / 2;
             *
             *     return [
             *       date.set('duration', diff),
             *       date.add(diff, 'millisecond').set('duration', diff),
             *     ];
             *   }
             *
             *   return [date];
             * };
             *
             * const dates = new Dates({
             *   dates: [
             *     new StandardDateAdapter(new Date(2010, 10, 10, 13), { duration: MILLISECONDS_IN_HOUR * 1 }),
             *     new StandardDateAdapter(new Date(2010, 10, 11, 13), { duration: MILLISECONDS_IN_HOUR * 2 }),
             *   ],
             *   dateAdpter: StandardDateAdapter,
             * }).pipe(
             *   splitDuration({
             *     splitFn,
             *     maxDuration: MILLISECONDS_IN_HOUR * 1
             *   })
             * )
             *
             * expect(dates.occurrences().toArray()).toEqual([
             *   new StandardDateAdapter(new Date(2010, 10, 10, 13), { duration: MILLISECONDS_IN_HOUR * 1 }),
             *   new StandardDateAdapter(new Date(2010, 10, 11, 13), { duration: MILLISECONDS_IN_HOUR * 1 }),
             *   new StandardDateAdapter(new Date(2010, 10, 11, 14), { duration: MILLISECONDS_IN_HOUR * 1 }),
             * ])
             * ```
             */
            function splitDuration(args) {
                return options => new SplitDurationOperator(args, options);
            }
            class SplitDurationOperator extends Operator {
                constructor(args, config) {
                    super([], config);
                    this.splitFn = args.splitFn;
                    this.maxDuration = args.maxDuration;
                    if (config.base && !config.base.hasDuration) {
                        throw new _rschedule_core__WEBPACK_IMPORTED_MODULE_0__.ArgumentError('Base stream provided to SplitDurationOperator does not have an associated duration. ' +
                            'The SplitDurationOperator can only be used with streams which have a duration.');
                    }
                }
                /** Not actually used but necessary for IRunnable interface */
                set(_, value) {
                    return new SplitDurationOperator({
                        maxDuration: this.maxDuration,
                        splitFn: this.splitFn,
                    }, Object.assign(Object.assign({}, this.config), {
                        base: this.config.base && this.config.base.set('timezone', value),
                        timezone: value,
                    }));
                }
                *_run(args = {}) {
                    if (!this.config.base)
                        return;
                    const reverse = args.reverse || false;
                    // We want to find occurrences that end after the provided
                    // `start` time even if they begin before the provided `start`
                    // time. Because of this, we add `maxDuration` to
                    // the provided start time.
                    let checkFromStart = args.start;
                    if (args.start) {
                        checkFromStart = args.start.subtract(this.maxDuration, 'millisecond');
                    }
                    // same goes for `end` time as with `start` time.
                    let checkFromEnd = args.end;
                    if (args.end) {
                        checkFromEnd = args.end.add(this.maxDuration, 'millisecond');
                    }
                    const stream = new IterableWrapper(this.config.base, Object.assign(Object.assign({}, args), { start: checkFromStart, end: checkFromEnd }));
                    let yieldArgs;
                    const datesBucket = [];
                    while (!stream.done || (datesBucket[0] && datesBucket[0][0])) {
                        /**
                         * Example:
                         * 10am - 2pm -> 10am - 12pm, 12pm - 2pm
                         * 11am - 3pm -> 11am - 1pm, 1pm - 3pm
                         * 2pm - 4pm -> 2pm - 3pm, 3pm - 4pm
                         */
                        if (!(datesBucket[0] && datesBucket[0][0])) {
                            // we're out of dates
                            datesBucket.push(this.splitDate(stream.value, reverse));
                            stream.next();
                        }
                        while (!stream.done &&
                            (reverse
                                ? datesBucket[0].some(date => date.isBeforeOrEqual(stream.value.end))
                                : datesBucket[0].some(date => date.isAfterOrEqual(stream.value)))) {
                            datesBucket.push(this.splitDate(stream.value, reverse));
                            stream.next();
                        }
                        let selectedDate = datesBucket[0] && datesBucket[0][0];
                        let bucketIndex = -1;
                        let selectedBucketIndex = 0;
                        let dateIndex = -1;
                        let selectedDateIndex = 0;
                        // find the next date as well as its location in the datesBucket
                        for (const bucket of datesBucket) {
                            bucketIndex++;
                            dateIndex = -1;
                            for (const date of bucket) {
                                dateIndex++;
                                let dateShouldComeNext;
                                if (reverse) {
                                    dateShouldComeNext =
                                        date.isAfter(selectedDate) ||
                                            (date.isEqual(selectedDate) && date.duration > selectedDate.duration);
                                }
                                else {
                                    dateShouldComeNext =
                                        date.isBefore(selectedDate) ||
                                            (date.isEqual(selectedDate) && date.duration < selectedDate.duration);
                                }
                                if (dateShouldComeNext) {
                                    selectedDate = date;
                                    selectedBucketIndex = bucketIndex;
                                    selectedDateIndex = dateIndex;
                                    break;
                                }
                            }
                        }
                        datesBucket[selectedBucketIndex].splice(selectedDateIndex, 1);
                        if (datesBucket[selectedBucketIndex].length === 0) {
                            datesBucket.splice(selectedBucketIndex, 1);
                        }
                        // If we've been yieldedArgs from the last cycle, check to see
                        // that the selectedDate honors the `skipToDate` requirement
                        // if not, discard this selectedDate
                        if (yieldArgs &&
                            yieldArgs.skipToDate &&
                            selectedDate &&
                            !datePastEnd(selectedDate, args) &&
                            !datePastSkipToDate(selectedDate, yieldArgs.skipToDate, args)) {
                            continue;
                        }
                        // because we subtracted `maxDuration` to the base iterator's start time,
                        // check to make sure the selectedDate we are about to yield should
                        // actually be yielded (it may be before the provided `start` time).
                        // If not, discard the selectedDate.
                        if (args.start && selectedDate.end.isBefore(args.start)) {
                            if (reverse)
                                break;
                            continue;
                        }
                        // because we added `maxDuration` to the base iterator's end time,
                        // check to make sure the selectedDate we are about to yield should
                        // actually be yielded (it may be after the provided `end` time).
                        // If not, end iteration.
                        if (args.end && selectedDate.isAfter(args.end)) {
                            if (reverse)
                                continue;
                            break;
                        }
                        if (selectedDate.duration > this.maxDuration) {
                            throw new SplitDurationOperatorError(`SplitDurationOperatorError: Occurrence duration exceeded maxDuration of ` +
                                this.maxDuration);
                        }
                        yieldArgs = yield this.normalizeRunOutput(selectedDate);
                        if (yieldArgs &&
                            yieldArgs.skipToDate &&
                            (args.reverse
                                ? selectedDate.isBeforeOrEqual(yieldArgs.skipToDate)
                                : selectedDate.isAfterOrEqual(yieldArgs.skipToDate))) {
                            throw new Error('A provided `skipToDate` option must be greater than the last yielded date ' +
                                '(or smaller, in the case of reverse iteration)');
                        }
                    }
                }
                calculateIsInfinite() {
                    return !!(this.config.base && this.config.base.isInfinite);
                }
                calculateHasDuration() {
                    return true;
                }
                splitDate(date, reverse) {
                    const dates = this.splitFn(date);
                    let valid;
                    if (dates.length === 0) {
                        valid = false;
                    }
                    else if (dates.length === 1) {
                        valid = date.duration === dates[0].duration;
                    }
                    else {
                        valid = date.duration === dates.reduce((prev, curr) => prev + curr.duration, 0);
                    }
                    if (!valid) {
                        throw new Error('The provided SplitDurationOperator split function ' +
                            'must return an array of DateTimes with length > 0 ' +
                            'where the total duration of the new dates equals the duration of ' +
                            'the original date.');
                    }
                    dates.sort(_rschedule_core__WEBPACK_IMPORTED_MODULE_0__.dateTimeSortComparer);
                    if (reverse) {
                        dates.reverse();
                    }
                    return dates;
                }
            }
            function datePastEnd(date, options) {
                return !!(options.reverse
                    ? options.start && date.isBefore(options.start)
                    : options.end && date.isAfter(options.end));
            }
            function datePastSkipToDate(date, skipToDate, options) {
                return !!(options.reverse ? skipToDate.isAfterOrEqual(date) : skipToDate.isBeforeOrEqual(date));
            }
            /***/ 
        }),
        /***/ "./node_modules/@rschedule/core/es2015/main.js": 
        /*!*****************************************************!*\
          !*** ./node_modules/@rschedule/core/es2015/main.js ***!
          \*****************************************************/
        /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony export */ __webpack_require__.d(__webpack_exports__, {
                /* harmony export */ ArgumentError: () => ( /* binding */ArgumentError),
                /* harmony export */ DateAdapter: () => ( /* binding */DateAdapter),
                /* harmony export */ DateAdapterBase: () => ( /* binding */DateAdapterBase),
                /* harmony export */ DateTime: () => ( /* binding */DateTime),
                /* harmony export */ InfiniteLoopError: () => ( /* binding */InfiniteLoopError),
                /* harmony export */ InvalidDateAdapterError: () => ( /* binding */InvalidDateAdapterError),
                /* harmony export */ InvalidDateTime: () => ( /* binding */InvalidDateTime),
                /* harmony export */ InvalidDateTimeError: () => ( /* binding */InvalidDateTimeError),
                /* harmony export */ RecurrenceRuleError: () => ( /* binding */RecurrenceRuleError),
                /* harmony export */ RecurrenceRulesIterator: () => ( /* binding */RecurrenceRulesIterator),
                /* harmony export */ RuleOptionError: () => ( /* binding */RuleOptionError),
                /* harmony export */ ValidDateTime: () => ( /* binding */ValidDateTime),
                /* harmony export */ cloneJSON: () => ( /* binding */cloneJSON),
                /* harmony export */ cloneRuleOptions: () => ( /* binding */cloneRuleOptions),
                /* harmony export */ dateInputToDateAdapter: () => ( /* binding */dateInputToDateAdapter),
                /* harmony export */ dateInputToDateTime: () => ( /* binding */dateInputToDateTime),
                /* harmony export */ dateTimeSortComparer: () => ( /* binding */dateTimeSortComparer),
                /* harmony export */ freqToGranularity: () => ( /* binding */freqToGranularity),
                /* harmony export */ getDaysInYear: () => ( /* binding */getDaysInYear),
                /* harmony export */ getDifferenceBetweenWeekdays: () => ( /* binding */getDifferenceBetweenWeekdays),
                /* harmony export */ isLeapYear: () => ( /* binding */isLeapYear),
                /* harmony export */ normalizeDateTimeTimezone: () => ( /* binding */normalizeDateTimeTimezone),
                /* harmony export */ normalizeRuleOptions: () => ( /* binding */normalizeRuleOptions),
                /* harmony export */ numberSortComparer: () => ( /* binding */numberSortComparer),
                /* harmony export */ orderedWeekdays: () => ( /* binding */orderedWeekdays),
                /* harmony export */ recurrenceRulesReducer: () => ( /* binding */recurrenceRulesReducer),
                /* harmony export */ uniqDateTimes: () => ( /* binding */uniqDateTimes)
                /* harmony export */ 
            });
            class InvalidDateAdapterError extends Error {
            }
            let dateAdapterConfig;
            class DateAdapterBase {
                constructor(_date, options) {
                    /**
                     * The metadata property is intended to store arbitrary data
                     * related to this DateAdapter. Unlike other properties, the
                     * metadata property is intended to be mutable.
                     */
                    this.metadata = {};
                    this.duration = (options && options.duration) || 0;
                    this.generators = (options && options.generators && options.generators.slice()) || [];
                    if (!Number.isInteger(this.duration) || this.duration < 0) {
                        throw new InvalidDateAdapterError('duration must be a non-negative integer');
                    }
                }
                static set adapter(value) {
                    if (dateAdapterConfig) {
                        throw new Error(`"${dateAdapterConfig.name}" has already been configured.`);
                    }
                    dateAdapterConfig = value;
                }
                static get adapter() {
                    if (!dateAdapterConfig) {
                        throw new Error('No date adapter has been configured. See rSchedule docs.');
                    }
                    return dateAdapterConfig;
                }
                static isDate(_object) {
                    throw unimplementedError('isDate()');
                }
                static fromDate(_date, _options) {
                    throw unimplementedError('fromDate()');
                }
                static fromJSON(_json) {
                    throw unimplementedError('fromJSON()');
                }
                static fromDateTime(_datetime) {
                    throw unimplementedError('fromDateTime()');
                }
                /**
                 * Returns a string in simplified extended ISO format (ISO 8601).
                 *
                 * _Note: this method is intended for testing and its
                 * implementation isn't particularly performant._
                 */
                toISOString() {
                    return this.set('timezone', 'UTC')
                        .toDateTime()
                        .toISOString();
                }
                toDateTime() {
                    const date = DateTime.fromJSON(Object.assign(Object.assign({}, this.toJSON()), {
                        generators: this.generators,
                        metadata: this.metadata,
                    }));
                    return date;
                }
            }
            DateAdapterBase.hasTimezoneSupport = false;
            function unimplementedError(name) {
                return new Error(`You must implement the "${name}" method for this DateAdapter class`);
            }
            var DateAdapter;
            (function (DateAdapter) {
                DateAdapter.WEEKDAYS = ['SU', 'MO', 'TU', 'WE', 'TH', 'FR', 'SA'];
                DateAdapter.MILLISECONDS_IN_SECOND = 1000;
                DateAdapter.MILLISECONDS_IN_MINUTE = DateAdapter.MILLISECONDS_IN_SECOND * 60;
                DateAdapter.MILLISECONDS_IN_HOUR = DateAdapter.MILLISECONDS_IN_MINUTE * 60;
                DateAdapter.MILLISECONDS_IN_DAY = DateAdapter.MILLISECONDS_IN_HOUR * 24;
                DateAdapter.MILLISECONDS_IN_WEEK = DateAdapter.MILLISECONDS_IN_DAY * 7;
            })(DateAdapter || (DateAdapter = {}));
            class InvalidDateTimeError extends Error {
            }
            class DateTime {
                constructor(date, timezone, duration, generators, options = {}) {
                    this.metadata = {};
                    this.date = new Date(date);
                    this.timezone = timezone || null;
                    this.duration = duration || 0;
                    this.generators = (generators && generators.slice()) || [];
                    if (!Number.isInteger(this.duration) || this.duration < 0) {
                        throw new InvalidDateTimeError('duration must be a non-negative integer');
                    }
                    if (options.metadata) {
                        Object.assign(this.metadata, options.metadata);
                    }
                    this.assertIsValid();
                }
                // /**
                //  * Similar to `Array.isArray()`, `isInstance()` provides a surefire method
                //  * of determining if an object is a `DateTime` by checking against the
                //  * global symbol registry.
                //  */
                // static isInstance(object: any): object is DateTime {
                //   return !!(object && object[DATETIME_ID]);
                // }
                static fromJSON(json) {
                    const date = new Date(Date.UTC(json.year, json.month - 1, json.day, json.hour, json.minute, json.second, json.millisecond));
                    return new DateTime(date, json.timezone, json.duration, json.generators, {
                        metadata: json.metadata,
                    });
                }
                static fromDateAdapter(adapter) {
                    return DateTime.fromJSON(Object.assign(Object.assign({}, adapter.toJSON()), {
                        generators: adapter.generators,
                        metadata: adapter.metadata,
                    }));
                }
                /**
                 * Returns `undefined` if `duration` is `0`. Else returns
                 * the `end` date.
                 */
                get end() {
                    if (!this.duration)
                        return;
                    if (this._end)
                        return this._end;
                    this._end = this.add(this.duration, 'millisecond');
                    return this._end;
                }
                // While we constrain the argument to be another DateAdapter in typescript
                // we handle the case of someone passing in another type of object in javascript
                isEqual(object) {
                    if (!object) {
                        return false;
                    }
                    assertSameTimeZone(this, object);
                    return this.valueOf() === object.valueOf();
                }
                isBefore(object) {
                    assertSameTimeZone(this, object);
                    return this.valueOf() < object.valueOf();
                }
                isBeforeOrEqual(object) {
                    assertSameTimeZone(this, object);
                    return this.valueOf() <= object.valueOf();
                }
                isAfter(object) {
                    assertSameTimeZone(this, object);
                    return this.valueOf() > object.valueOf();
                }
                isAfterOrEqual(object) {
                    assertSameTimeZone(this, object);
                    return this.valueOf() >= object.valueOf();
                }
                isOccurring(object) {
                    if (!this.duration) {
                        throw new Error('DateTime#isOccurring() is only applicable to DateTimes with durations');
                    }
                    assertSameTimeZone(this, object);
                    return (object.isAfterOrEqual(this) && object.isBeforeOrEqual(this.add(this.duration, 'millisecond')));
                }
                add(amount, unit) {
                    switch (unit) {
                        case 'generator': {
                            const generators = this.generators.slice();
                            generators.unshift(amount);
                            return new DateTime(this.date, this.timezone, this.duration, generators);
                        }
                        case 'year':
                            return this.forkDateTime(addUTCYears(this.date, amount));
                        case 'month':
                            return this.forkDateTime(addUTCMonths(this.date, amount));
                        case 'week':
                            return this.forkDateTime(addUTCWeeks(this.date, amount));
                        case 'day':
                            return this.forkDateTime(addUTCDays(this.date, amount));
                        case 'hour':
                            return this.forkDateTime(addUTCHours(this.date, amount));
                        case 'minute':
                            return this.forkDateTime(addUTCMinutes(this.date, amount));
                        case 'second':
                            return this.forkDateTime(addUTCSeconds(this.date, amount));
                        case 'millisecond':
                            return this.forkDateTime(addUTCMilliseconds(this.date, amount));
                        default:
                            throw new Error('Invalid unit provided to `DateTime#add`');
                    }
                }
                subtract(amount, unit) {
                    switch (unit) {
                        case 'year':
                            return this.forkDateTime(subUTCYears(this.date, amount));
                        case 'month':
                            return this.forkDateTime(subUTCMonths(this.date, amount));
                        case 'week':
                            return this.forkDateTime(subUTCWeeks(this.date, amount));
                        case 'day':
                            return this.forkDateTime(subUTCDays(this.date, amount));
                        case 'hour':
                            return this.forkDateTime(subUTCHours(this.date, amount));
                        case 'minute':
                            return this.forkDateTime(subUTCMinutes(this.date, amount));
                        case 'second':
                            return this.forkDateTime(subUTCSeconds(this.date, amount));
                        case 'millisecond':
                            return this.forkDateTime(subUTCMilliseconds(this.date, amount));
                        default:
                            throw new Error('Invalid unit provided to `DateTime#subtract`');
                    }
                }
                get(unit) {
                    switch (unit) {
                        case 'year':
                            return this.date.getUTCFullYear();
                        case 'month':
                            return this.date.getUTCMonth() + 1;
                        case 'yearday':
                            return getUTCYearDay(this.date);
                        case 'weekday':
                            return DateAdapter.WEEKDAYS[this.date.getUTCDay()];
                        case 'day':
                            return this.date.getUTCDate();
                        case 'hour':
                            return this.date.getUTCHours();
                        case 'minute':
                            return this.date.getUTCMinutes();
                        case 'second':
                            return this.date.getUTCSeconds();
                        case 'millisecond':
                            return this.date.getUTCMilliseconds();
                        default:
                            throw new Error('Invalid unit provided to `DateTime#set`');
                    }
                }
                set(unit, value) {
                    if (unit === 'duration') {
                        return new DateTime(this.date, this.timezone, value, this.generators);
                    }
                    if (unit === 'generators') {
                        return new DateTime(this.date, this.timezone, this.duration, value);
                    }
                    let date = new Date(this.date);
                    switch (unit) {
                        case 'year':
                            date.setUTCFullYear(value);
                            break;
                        case 'month': {
                            // If the current day of the month
                            // is greater than days in the month we are moving to, we need to also
                            // set the day to the end of that month.
                            const length = monthLength(value, date.getUTCFullYear());
                            const day = date.getUTCDate();
                            if (day > length) {
                                date.setUTCDate(1);
                                date.setUTCMonth(value);
                                date = subUTCDays(date, 1);
                            }
                            else {
                                date.setUTCMonth(value - 1);
                            }
                            break;
                        }
                        case 'day':
                            date.setUTCDate(value);
                            break;
                        case 'hour':
                            date.setUTCHours(value);
                            break;
                        case 'minute':
                            date.setUTCMinutes(value);
                            break;
                        case 'second':
                            date.setUTCSeconds(value);
                            break;
                        case 'millisecond':
                            date.setUTCMilliseconds(value);
                            break;
                        default:
                            throw new Error('Invalid unit provided to `DateTime#set`');
                    }
                    return this.forkDateTime(date);
                }
                granularity(granularity, opt = {}) {
                    let date = this.forkDateTime(this.date);
                    switch (granularity) {
                        case 'year':
                            date = date.set('month', 1);
                        case 'month':
                            date = date.set('day', 1);
                            break;
                        case 'week':
                            date = setDateToStartOfWeek(date, opt.weekStart);
                    }
                    switch (granularity) {
                        case 'year':
                        case 'month':
                        case 'week':
                        case 'day':
                            date = date.set('hour', 0);
                        case 'hour':
                            date = date.set('minute', 0);
                        case 'minute':
                            date = date.set('second', 0);
                        case 'second':
                            date = date.set('millisecond', 0);
                        case 'millisecond':
                            return date;
                        default:
                            throw new Error('Invalid granularity provided to `DateTime#granularity`: ' + granularity);
                    }
                }
                endGranularity(granularity, opt = {}) {
                    let date = this.forkDateTime(this.date);
                    switch (granularity) {
                        case 'year':
                            date = date.set('month', 12);
                        case 'month':
                            date = date.set('day', monthLength(date.get('month'), date.get('year')));
                            break;
                        case 'week':
                            date = setDateToEndOfWeek(date, opt.weekStart);
                    }
                    switch (granularity) {
                        case 'year':
                        case 'month':
                        case 'week':
                        case 'day':
                            date = date.set('hour', 23);
                        case 'hour':
                            date = date.set('minute', 59);
                        case 'minute':
                            date = date.set('second', 59);
                        case 'second':
                            date = date.set('millisecond', 999);
                        case 'millisecond':
                            return date;
                        default:
                            throw new Error('Invalid granularity provided to `DateTime#granularity`: ' + granularity);
                    }
                }
                toISOString() {
                    return this.date.toISOString();
                }
                toDateTime() {
                    return this;
                }
                toJSON() {
                    const json = {
                        timezone: this.timezone,
                        year: this.get('year'),
                        month: this.get('month'),
                        day: this.get('day'),
                        hour: this.get('hour'),
                        minute: this.get('minute'),
                        second: this.get('second'),
                        millisecond: this.get('millisecond'),
                    };
                    if (this.duration) {
                        json.duration = this.duration;
                    }
                    return json;
                }
                valueOf() {
                    return this.date.valueOf();
                }
                assertIsValid() {
                    if (isNaN(this.valueOf())) {
                        throw new InvalidDateTimeError('DateTime has invalid date.');
                    }
                    return true;
                }
                forkDateTime(date) {
                    return new DateTime(date, this.timezone, this.duration, this.generators);
                }
            }
            function assertSameTimeZone(x, y) {
                if (x.timezone !== y.timezone) {
                    throw new InvalidDateTimeError('Attempted to compare a datetime to another date in a different timezone: ' +
                        JSON.stringify(x) +
                        ' and ' +
                        JSON.stringify(y));
                }
                return true;
            }
            function setDateToStartOfWeek(date, wkst) {
                const index = orderedWeekdays(wkst).indexOf(date.get('weekday'));
                return date.subtract(index, 'day');
            }
            function setDateToEndOfWeek(date, wkst) {
                const index = orderedWeekdays(wkst).indexOf(date.get('weekday'));
                return date.add(6 - index, 'day');
            }
            function dateTimeSortComparer(a, b) {
                if (a.isAfter(b))
                    return 1;
                if (a.isBefore(b))
                    return -1;
                if (a.duration && b.duration) {
                    if (a.duration > b.duration)
                        return 1;
                    if (a.duration < b.duration)
                        return -1;
                }
                return 0;
            }
            function uniqDateTimes(dates) {
                return Array.from(new Map(dates.map(date => [date.toISOString(), date])).values());
            }
            function orderedWeekdays(wkst = 'SU') {
                const wkdays = DateAdapter.WEEKDAYS.slice();
                let index = wkdays.indexOf(wkst);
                while (index !== 0) {
                    shiftArray(wkdays);
                    index--;
                }
                return wkdays;
            }
            function shiftArray(array, from = 'first') {
                if (array.length === 0) {
                    return array;
                }
                else if (from === 'first') {
                    array.push(array.shift());
                }
                else {
                    array.unshift(array.pop());
                }
                return array;
            }
            function getDifferenceBetweenWeekdays(x, y) {
                if (x === y)
                    return 0;
                const result = DateAdapter.WEEKDAYS.indexOf(x) - DateAdapter.WEEKDAYS.indexOf(y);
                return result > 0 ? 7 - result : Math.abs(result);
            }
            /**
             * Returns the days in the given month.
             *
             * @param month base-1
             * @param year
             */
            function monthLength(month, year) {
                const block = {
                    1: 31,
                    2: getDaysInFebruary(year),
                    3: 31,
                    4: 30,
                    5: 31,
                    6: 30,
                    7: 31,
                    8: 31,
                    9: 30,
                    10: 31,
                    11: 30,
                    12: 31,
                };
                return block[month];
            }
            function getDaysInFebruary(year) {
                return isLeapYear(year) ? 29 : 28;
            }
            // taken from date-fn
            function isLeapYear(year) {
                return year % 400 === 0 || (year % 4 === 0 && year % 100 !== 0);
            }
            function getDaysInYear(year) {
                return isLeapYear(year) ? 366 : 365;
            }
            function getUTCYearDay(now) {
                const start = new Date(Date.UTC(now.getUTCFullYear(), 0, 1));
                const diff = now.valueOf() - start.valueOf();
                return 1 + Math.floor(diff / DateAdapter.MILLISECONDS_IN_DAY);
            }
            /**
             * These functions are basically lifted from `date-fns`, but changed
             * to use the UTC date methods, which `date-fns` doesn't support.
             */
            function toInteger(input) {
                if (input === null || input === true || input === false) {
                    return NaN;
                }
                const int = Number(input);
                if (isNaN(int)) {
                    return int;
                }
                return int < 0 ? Math.ceil(int) : Math.floor(int);
            }
            function addMilliseconds(dirtyDate, dirtyAmount) {
                if (arguments.length < 2) {
                    throw new TypeError('2 arguments required, but only ' + arguments.length + ' present');
                }
                const timestamp = dirtyDate.valueOf();
                const amount = toInteger(dirtyAmount);
                return new Date(timestamp + amount);
            }
            function addUTCYears(date, input) {
                const amount = toInteger(input);
                return addUTCMonths(date, amount * 12);
            }
            function addUTCMonths(date, input) {
                const amount = toInteger(input);
                date = new Date(date);
                const desiredMonth = date.getUTCMonth() + amount;
                const dateWithDesiredMonth = new Date(0);
                dateWithDesiredMonth.setUTCFullYear(date.getUTCFullYear(), desiredMonth, 1);
                dateWithDesiredMonth.setUTCHours(0, 0, 0, 0);
                const daysInMonth = monthLength(dateWithDesiredMonth.getUTCMonth() + 1, dateWithDesiredMonth.getUTCFullYear());
                // Set the last day of the new month
                // if the original date was the last day of the longer month
                date.setUTCMonth(desiredMonth, Math.min(daysInMonth, date.getUTCDate()));
                return date;
            }
            function addUTCWeeks(date, input) {
                const amount = toInteger(input);
                const days = amount * 7;
                return addUTCDays(date, days);
            }
            function addUTCDays(date, input) {
                // by adding milliseconds rather than days, we supress the native Date object's automatic
                // daylight savings time conversions which we don't want in UTC mode
                return addUTCMilliseconds(date, toInteger(input) * DateAdapter.MILLISECONDS_IN_DAY);
            }
            function addUTCHours(date, input) {
                const amount = toInteger(input);
                return addMilliseconds(date, amount * DateAdapter.MILLISECONDS_IN_HOUR);
            }
            function addUTCMinutes(date, input) {
                const amount = toInteger(input);
                return addMilliseconds(date, amount * DateAdapter.MILLISECONDS_IN_MINUTE);
            }
            function addUTCSeconds(date, input) {
                const amount = toInteger(input);
                return addMilliseconds(date, amount * DateAdapter.MILLISECONDS_IN_SECOND);
            }
            function addUTCMilliseconds(date, input) {
                const amount = toInteger(input);
                const timestamp = date.getTime();
                return new Date(timestamp + amount);
            }
            function subUTCYears(date, amount) {
                return addUTCYears(date, -amount);
            }
            function subUTCMonths(date, amount) {
                return addUTCMonths(date, -amount);
            }
            function subUTCWeeks(date, amount) {
                return addUTCWeeks(date, -amount);
            }
            function subUTCDays(date, amount) {
                return addUTCDays(date, -amount);
            }
            function subUTCHours(date, amount) {
                return addUTCHours(date, -amount);
            }
            function subUTCMinutes(date, amount) {
                return addUTCMinutes(date, -amount);
            }
            function subUTCSeconds(date, amount) {
                return addUTCSeconds(date, -amount);
            }
            function subUTCMilliseconds(date, amount) {
                return addUTCMilliseconds(date, -amount);
            }
            class ArgumentError extends Error {
            }
            class InfiniteLoopError extends Error {
            }
            function numberSortComparer(a, b) {
                if (a > b) {
                    return 1;
                }
                else if (b > a) {
                    return -1;
                }
                else {
                    return 0;
                }
            }
            function freqToGranularity(freq) {
                switch (freq) {
                    case 'YEARLY':
                        return 'year';
                    case 'MONTHLY':
                        return 'month';
                    case 'WEEKLY':
                        return 'week';
                    case 'DAILY':
                        return 'day';
                    case 'HOURLY':
                        return 'hour';
                    case 'MINUTELY':
                        return 'minute';
                    case 'SECONDLY':
                        return 'second';
                    case 'MILLISECONDLY':
                        return 'millisecond';
                    default:
                        throw new Error('unknown freq passed to freqToGranularity()');
                }
            }
            function cloneJSON(json) {
                return JSON.parse(JSON.stringify(json));
            }
            function dateInputToDateAdapter(date) {
                // prettier-ignore
                return date instanceof DateTime ? DateAdapterBase.adapter.fromDateTime(date) :
                    date instanceof DateAdapterBase ? date :
                        DateAdapterBase.adapter.fromDate(date);
            }
            function dateInputToDateTime(date, timezone) {
                if (date instanceof DateTime) {
                    if (date.timezone !== timezone) {
                        return DateAdapterBase.adapter
                            .fromDateTime(date)
                            .set('timezone', timezone)
                            .toDateTime();
                    }
                    return date;
                }
                return date instanceof DateAdapterBase
                    ? date.set('timezone', timezone).toDateTime()
                    : DateAdapterBase.adapter
                        .fromDate(date)
                        .set('timezone', timezone)
                        .toDateTime();
            }
            // export function normalizeDateInput<T extends DateAdapter>(
            //   dateAdapter: DateAdapterConstructor<T>,
            //   input: DateInput<T>,
            //   timezone: string | null,
            // ): DateTime {
            //   if (input instanceof DateTime) {
            //     if (input.timezone !== timezone) {
            //       return dateAdapter
            //         .fromDateTime(input)
            //         .set('timezone', timezone)
            //         .toDateTime();
            //     }
            //     return input;
            //   }
            //   return input instanceof DateAdapter
            //     ? input.set('timezone', timezone).toDateTime()
            //     : new dateAdapter(input).toDateTime();
            // }
            function normalizeDateTimeTimezone(date, timezone) {
                if (date.timezone !== timezone) {
                    return DateAdapterBase.adapter
                        .fromDateTime(date)
                        .set('timezone', timezone)
                        .toDateTime();
                }
                return date;
            }
            class RuleOptionError extends Error {
            }
            function normalizeDefaultOptions(options) {
                let start;
                if (options.start instanceof DateTime) {
                    start = options.start;
                }
                else if (options.start instanceof DateAdapterBase) {
                    start = options.start.toDateTime();
                }
                else if (DateAdapterBase.adapter.isDate(options.start)) {
                    start = DateAdapterBase.adapter.fromDate(options.start).toDateTime();
                }
                else {
                    throw new RuleOptionError('"start" must be either a `DateAdapter` instance or an instance of the ' +
                        'date a DateAdapter is wrapping (e.g. `StandardDateAdapter` wraps a `Date`)');
                }
                let end;
                if (options.end) {
                    if (options.end instanceof DateTime) {
                        end = options.end;
                    }
                    else if (options.end instanceof DateAdapterBase) {
                        end = options.end.toDateTime();
                    }
                    else if (DateAdapterBase.adapter.isDate(options.end)) {
                        end = DateAdapterBase.adapter.fromDate(options.end).toDateTime();
                    }
                    else {
                        throw new RuleOptionError('"end" must be either be `undefined`, a `DateAdapter` instance, or an instance of the ' +
                            'date a DateAdapter is wrapping (e.g. `StandardDateAdapter` wraps a `Date`)');
                    }
                }
                if (options.duration !== undefined) {
                    if (!Number.isInteger(options.duration)) {
                        throw new RuleOptionError('"duration" expects a whole number');
                    }
                    if (options.duration <= 0) {
                        throw new RuleOptionError('"duration" must be greater than 0');
                    }
                }
                if (options.count !== undefined) {
                    if (!Number.isInteger(options.count)) {
                        throw new RuleOptionError('"count" must be a whole number');
                    }
                    if (options.count < 0) {
                        throw new RuleOptionError('"count" must be greater than 0');
                    }
                }
                if (options.end !== undefined && options.count !== undefined) {
                    throw new RuleOptionError('"end" and "count" cannot both be present');
                }
                return {
                    start,
                    end,
                    count: options.count,
                    duration: options.duration,
                };
            }
            function normalizeRuleOptions(recurrenceModules, options) {
                const normOptions = normalizeDefaultOptions(options);
                const startOptions = cloneJSON(options);
                recurrenceModules.forEach(mod => {
                    mod.normalizeOptions(startOptions, normOptions);
                });
                Object.keys(normOptions).forEach(key => {
                    if (normOptions[key] === undefined) {
                        delete normOptions[key];
                    }
                });
                return normOptions;
            }
            function cloneRuleOptions(options) {
                const obj = cloneJSON(options);
                obj.start = options.start;
                if (options.end)
                    obj.end = options.end;
                return obj;
            }
            class RecurrenceRuleError extends Error {
            }
            class ValidDateTime {
                constructor(date) {
                    this.date = date;
                }
            }
            class InvalidDateTime {
                constructor(date) {
                    this.date = date;
                }
            }
            function recurrenceRulesReducer(rules) {
                return iterator => rules.reduce((prev, curr) => {
                    const rule = curr.get(iterator);
                    if (rule)
                        prev.push(rule);
                    return prev;
                }, []);
            }
            class RecurrenceRulesIterator {
                constructor(recurrenceRules, options, args) {
                    this.options = options;
                    this.args = args;
                    this.rules = [];
                    this.iterator =
                        // prettier-ignore
                        this.options.count === undefined ? this.iterate() :
                            this.args.reverse ? this.iterateWithReverseCount() :
                                this.iterateWithCount();
                    this.options = Object.assign(Object.assign({}, cloneJSON(options)), {
                        start: options.start,
                        end: options.end,
                    });
                    this.reverse = (this.options.count === undefined && args.reverse) || false;
                    const { start, end } = this.normalizeDateTimeArgs(args);
                    if (options.count !== undefined) {
                        this.start = options.start;
                    }
                    else if (start && options.start) {
                        this.start = start.isAfterOrEqual(options.start) ? start : options.start;
                    }
                    else {
                        this.start = start || options.start;
                    }
                    if (end && options.end) {
                        this.end = end.isBeforeOrEqual(options.end) ? end : options.end;
                    }
                    else {
                        this.end = end || options.end;
                    }
                    if (this.args.reverse && !(options.count !== undefined || this.end)) {
                        throw new Error('When iterating in reverse, the rule must have an `end` or `count` ' +
                            'property or you must provide an `end` argument.');
                    }
                    this.isInfinite = !this.end && this.options.count === undefined;
                    this.hasDuration = !!this.options.duration;
                    this.rules = Array.isArray(recurrenceRules) ? recurrenceRules : recurrenceRules(this);
                }
                [Symbol.iterator]() {
                    return this.iterator;
                }
                next(args) {
                    return this.iterator.next(args);
                }
                /**
                 * In the pipe controller, we have an extra level of indirection with
                 * the `run()` and `iterate()` methods. The `iterate()` method is the
                 * method which actually runs the logic in the pipes. If we didn't
                 * need to account for the `count` property of a rule, we would *only*
                 * need the iterate method... so much simpler. But we do need to account
                 * for rules with a `count` property.
                 *
                 * Rules with a `count` property need to begin iteration at the beginning
                 * because the `count` is always from the rule's start time. So if someone
                 * passes in a new start time as an argument to a rule with `count`, we
                 * need to secretly iterate from the beginning, tracking the number of
                 * iterations, and then only start yielding dates when we reach the section
                 * the user cares about (or, if we hit our `count` quota, cancel iterating).
                 *
                 * Additionally, we need to handle iterating in reverse. In this case, we build
                 * up a cache of dates between the rule's start time and the reverse iteration
                 * start date. Once we hit the reverse iteration start date, we start
                 * yielding dates in the cache, in reverse order.
                 *
                 * In general, I imagine the count number, if used, will be small. But a large
                 * count will definitely have a negative performance affect. I don't think
                 * there's anything to be done about this.
                 */
                *iterateWithReverseCount() {
                    const dates = Array.from(this.iterateWithCount()).reverse();
                    let yieldArgs;
                    const dateCache = dates.slice();
                    let date = dateCache.shift();
                    while (date) {
                        if (yieldArgs && yieldArgs.skipToDate && date.isAfter(yieldArgs.skipToDate)) {
                            date = dateCache.shift();
                            continue;
                        }
                        yieldArgs = yield date;
                        if (yieldArgs && yieldArgs.skipToDate && yieldArgs.skipToDate.isAfterOrEqual(date)) {
                            throw new Error('A provided `skipToDate` option must be greater than the last yielded date ' +
                                '(or smaller, in the case of reverse iteration)');
                        }
                        date = dateCache.shift();
                    }
                    return undefined;
                }
                *iterateWithCount() {
                    if (this.options.count === 0)
                        return;
                    const iterable = this.iterate();
                    const start = this.args.start || this.start;
                    let date = iterable.next().value;
                    let index = 1;
                    let yieldArgs;
                    while (date && index <= this.options.count) {
                        index++;
                        if (date.isBefore(start)) {
                            date = iterable.next().value;
                            continue;
                        }
                        if (yieldArgs && yieldArgs.skipToDate && date.isBefore(yieldArgs.skipToDate)) {
                            date = iterable.next().value;
                            continue;
                        }
                        yieldArgs = yield date;
                        if (yieldArgs && yieldArgs.skipToDate && yieldArgs.skipToDate.isBeforeOrEqual(date)) {
                            throw new Error('A provided `skipToDate` option must be greater than the last yielded date ' +
                                '(or smaller, in the case of reverse iteration)');
                        }
                        date = iterable.next().value;
                    }
                    return undefined;
                }
                *iterate() {
                    let startingDate = this.start;
                    if (this.reverse)
                        startingDate = this.end;
                    let date = this.nextDate(startingDate);
                    while (date) {
                        const args = yield this.normalizeRunOutput(date);
                        if (args && args.skipToDate) {
                            if (this.reverse
                                ? args.skipToDate.isAfterOrEqual(date)
                                : args.skipToDate.isBeforeOrEqual(date)) {
                                // We cannot consistently skip backwards because after an iterator is "done"
                                // it always returns undefined and you cannot reset it. Theoretically, it would be
                                // fine to skip backwards if the iterator wasn't already "done", but this
                                // would be prone to user error so we simply disallow skipping backwards altogether.
                                throw new Error('A provided `skipToDate` option must be greater than the last yielded date ' +
                                    '(or smaller, in the case of reverse iteration)');
                            }
                            date = this.nextDate(args.skipToDate);
                        }
                        else {
                            date = this.nextDate(this.reverse ? date.subtract(1, 'millisecond') : date.add(1, 'millisecond'));
                        }
                    }
                    return undefined;
                }
                /**
                 * Loops through the recurrence rules until a valid date is found.
                 */
                nextDate(start) {
                    let result = this.runRules(start.set('generators', []));
                    if (this.isDatePastEnd(result.date))
                        return null;
                    let index = 0;
                    while (result instanceof InvalidDateTime && index < 50) {
                        result = this.runRules(result.date);
                        if (this.isDatePastEnd(result.date))
                            return null;
                        index++;
                    }
                    if (result instanceof InvalidDateTime) {
                        throw new RecurrenceRuleError(`Failed to find a matching occurrence in ${index} iterations. ` +
                            `Last iterated date: "${result.date.toISOString()}"`);
                    }
                    if (this.reverse ? start.isBefore(result.date) : start.isAfter(result.date)) {
                        throw new RecurrenceRuleError('An error occurred in a recurrence rule. If this happened using ' +
                            'the rSchedule provided recurrence rules, you should ' +
                            'open an issue in the rSchedule repo. The maintainer is going to ' +
                            'want to know how to recreate the error.');
                    }
                    return result.date;
                }
                /**
                 * Performs one run of the recurrence rules and returns the result.
                 * It's a slightly optimized reducer function.
                 */
                runRules(start) {
                    let result = new ValidDateTime(start);
                    for (const rule of this.rules) {
                        if (result instanceof InvalidDateTime) {
                            return result;
                        }
                        result = rule.run(result.date);
                    }
                    return result;
                }
                isDatePastEnd(date) {
                    return this.reverse ? date.isBefore(this.start) : this.end && date.isAfter(this.end);
                }
                normalizeRunOutput(date) {
                    return this.hasDuration ? date.set('duration', this.options.duration) : date;
                }
                normalizeDateTimeArgs(args) {
                    return {
                        start: args.start && normalizeDateTimeTimezone(args.start, this.options.start.timezone),
                        end: args.end && normalizeDateTimeTimezone(args.end, this.options.start.timezone),
                    };
                }
            }
            /***/ 
        }),
        /***/ "./node_modules/@rschedule/core/es2015/rules.js": 
        /*!******************************************************!*\
          !*** ./node_modules/@rschedule/core/es2015/rules.js ***!
          \******************************************************/
        /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony export */ __webpack_require__.d(__webpack_exports__, {
                /* harmony export */ ByDayOfMonthRule: () => ( /* binding */ByDayOfMonthRule),
                /* harmony export */ ByDayOfMonthRuleModule: () => ( /* binding */ByDayOfMonthRuleModule),
                /* harmony export */ ByDayOfWeekRule: () => ( /* binding */ByDayOfWeekRule),
                /* harmony export */ ByDayOfWeekRuleModule: () => ( /* binding */ByDayOfWeekRuleModule),
                /* harmony export */ ByHourOfDayRule: () => ( /* binding */ByHourOfDayRule),
                /* harmony export */ ByHourOfDayRuleModule: () => ( /* binding */ByHourOfDayRuleModule),
                /* harmony export */ ByMillisecondOfSecondRule: () => ( /* binding */ByMillisecondOfSecondRule),
                /* harmony export */ ByMillisecondOfSecondRuleModule: () => ( /* binding */ByMillisecondOfSecondRuleModule),
                /* harmony export */ ByMinuteOfHourRule: () => ( /* binding */ByMinuteOfHourRule),
                /* harmony export */ ByMinuteOfHourRuleModule: () => ( /* binding */ByMinuteOfHourRuleModule),
                /* harmony export */ ByMonthOfYearRule: () => ( /* binding */ByMonthOfYearRule),
                /* harmony export */ ByMonthOfYearRuleModule: () => ( /* binding */ByMonthOfYearRuleModule),
                /* harmony export */ BySecondOfMinuteRule: () => ( /* binding */BySecondOfMinuteRule),
                /* harmony export */ BySecondOfMinuteRuleModule: () => ( /* binding */BySecondOfMinuteRuleModule),
                /* harmony export */ FrequencyRule: () => ( /* binding */FrequencyRule),
                /* harmony export */ FrequencyRuleModule: () => ( /* binding */FrequencyRuleModule),
                /* harmony export */ ICAL_RULES: () => ( /* binding */ICAL_RULES),
                /* harmony export */ RevByDayOfMonthRule: () => ( /* binding */RevByDayOfMonthRule),
                /* harmony export */ RevByDayOfWeekRule: () => ( /* binding */RevByDayOfWeekRule),
                /* harmony export */ RevByHourOfDayRule: () => ( /* binding */RevByHourOfDayRule),
                /* harmony export */ RevByMillisecondOfSecondRule: () => ( /* binding */RevByMillisecondOfSecondRule),
                /* harmony export */ RevByMinuteOfHourRule: () => ( /* binding */RevByMinuteOfHourRule),
                /* harmony export */ RevByMonthOfYearRule: () => ( /* binding */RevByMonthOfYearRule),
                /* harmony export */ RevBySecondOfMinuteRule: () => ( /* binding */RevBySecondOfMinuteRule),
                /* harmony export */ RevFrequencyRule: () => ( /* binding */RevFrequencyRule),
                /* harmony export */ getPrevWeekdaysOfMonth: () => ( /* binding */getPrevWeekdaysOfMonth),
                /* harmony export */ getPrevWeekdaysOfYear: () => ( /* binding */getPrevWeekdaysOfYear)
                /* harmony export */ 
            });
            /* harmony import */ var _rschedule_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @rschedule/core */ "./node_modules/@rschedule/core/es2015/main.js");
            class RecurrenceRule {
                constructor(processor) {
                    this.processor = processor;
                    this.start = processor.start;
                    this.end = processor.end;
                    this.options = processor.options;
                }
            }
            class FrequencyRule extends RecurrenceRule {
                constructor(processor, initDate) {
                    super(processor);
                    this.initDate = initDate;
                    this.intervalUnit = (0, _rschedule_core__WEBPACK_IMPORTED_MODULE_0__.freqToGranularity)(this.options.frequency);
                    this.firstIntervalStartDate = this.normalizedStartDate(this.options.start);
                    this.intervalStartDate = this.firstIntervalStartDate;
                    this.intervalEndDate = this.normalizedEndDate(this.firstIntervalStartDate);
                    this.skipToInterval(this.initDate);
                }
                run(date) {
                    return this.validateDate(new _rschedule_core__WEBPACK_IMPORTED_MODULE_0__.ValidDateTime(date));
                }
                validateDate(arg) {
                    const { date } = arg;
                    if (arg instanceof _rschedule_core__WEBPACK_IMPORTED_MODULE_0__.ValidDateTime && this.dateIsWithinInterval(date)) {
                        return arg;
                    }
                    this.skipToInterval(date);
                    return new _rschedule_core__WEBPACK_IMPORTED_MODULE_0__.InvalidDateTime(
                    // if the interval is 1, date will always be within the interval
                    this.dateIsWithinInterval(date) ? date : this.setToCurrentInterval());
                }
                setToCurrentInterval() {
                    return this.intervalStartDate;
                }
                normalizedStartDate(date) {
                    if (this.options.frequency === 'WEEKLY') {
                        return date.granularity('week', { weekStart: this.options.weekStart });
                    }
                    return date.granularity(this.intervalUnit);
                }
                normalizedEndDate(start) {
                    switch (this.options.frequency) {
                        case 'YEARLY':
                            return start.add(1, 'year');
                        case 'MONTHLY':
                            return start.add(1, 'month');
                        case 'WEEKLY':
                            return start.add(1, 'week');
                        case 'DAILY':
                            return start.add(1, 'day');
                        case 'HOURLY':
                            return start.add(1, 'hour');
                        case 'MINUTELY':
                            return start.add(1, 'minute');
                        case 'SECONDLY':
                            return start.add(1, 'second');
                        case 'MILLISECONDLY':
                            return start.add(1, 'millisecond');
                        default:
                            throw new Error(`Unknown frequency ${this.options.frequency}`);
                    }
                }
                skipToInterval(date) {
                    const amount = this.intervalDifference(date);
                    this.intervalStartDate = this.firstIntervalStartDate.add(amount, this.intervalUnit);
                    this.intervalEndDate = this.normalizedEndDate(this.intervalStartDate);
                }
                dateIsWithinInterval(date) {
                    return this.intervalStartDate.isBeforeOrEqual(date) && this.intervalEndDate.isAfter(date);
                }
                intervalDifference(date) {
                    return intervalDifferenceBetweenDates({
                        first: this.firstIntervalStartDate,
                        second: date,
                        unit: this.intervalUnit,
                        interval: this.options.interval,
                        weekStart: this.options.weekStart,
                        direction: 'after',
                    });
                }
            }
            /**
             * Given the frequency (unit) and interval, this function finds
             * how many jumps forward the first date needs in order to equal
             * or exceed the second date.
             *
             * For example:
             *
             * 1. Unit is daily and interval is 1. The second date is 3 days
             *    after the first. This will return 3.
             * 2. Unit is yearly and interval is 1. The second date is 3 days
             *    after the first. This will return 0.
             * 3. Unit is yearly and interval is 3. The second date is 4 years
             *    after the first. This will return 6.
             */
            function intervalDifferenceBetweenDates({ first, second, unit, interval, weekStart, direction }) {
                let difference = (() => {
                    let intervalDuration;
                    let months;
                    switch (unit) {
                        case 'year':
                            months = (second.get('year') - first.get('year')) * 12;
                            months = months + second.get('month') - first.get('month');
                            return Math.floor(months / 12);
                        case 'month':
                            months = (second.get('year') - first.get('year')) * 12;
                            months = months + second.get('month') - first.get('month');
                            return months;
                        case 'week':
                            first = first.granularity('week', { weekStart });
                            intervalDuration = _rschedule_core__WEBPACK_IMPORTED_MODULE_0__.DateAdapter.MILLISECONDS_IN_WEEK;
                            break;
                        case 'day':
                            intervalDuration = _rschedule_core__WEBPACK_IMPORTED_MODULE_0__.DateAdapter.MILLISECONDS_IN_DAY;
                            break;
                        case 'hour':
                            intervalDuration = _rschedule_core__WEBPACK_IMPORTED_MODULE_0__.DateAdapter.MILLISECONDS_IN_HOUR;
                            break;
                        case 'minute':
                            intervalDuration = _rschedule_core__WEBPACK_IMPORTED_MODULE_0__.DateAdapter.MILLISECONDS_IN_MINUTE;
                            break;
                        case 'second':
                            intervalDuration = _rschedule_core__WEBPACK_IMPORTED_MODULE_0__.DateAdapter.MILLISECONDS_IN_SECOND;
                            break;
                        case 'millisecond':
                            intervalDuration = 1;
                            break;
                        default:
                            throw new Error('Unexpected `unit` value');
                    }
                    const diff = second.valueOf() - first.valueOf();
                    return Math.floor(diff / intervalDuration);
                })();
                const fn = direction === 'after' ? Math.ceil : Math.floor;
                difference = fn(difference / interval) * interval;
                return difference;
            }
            class RevFrequencyRule extends FrequencyRule {
                setToCurrentInterval() {
                    return this.intervalEndDate.subtract(1, 'millisecond');
                }
                intervalDifference(date) {
                    return intervalDifferenceBetweenDates({
                        first: this.firstIntervalStartDate,
                        second: date,
                        unit: this.intervalUnit,
                        interval: this.options.interval,
                        weekStart: this.options.weekStart,
                        direction: 'before',
                    });
                }
            }
            const FREQUENCIES = [
                'MILLISECONDLY',
                'SECONDLY',
                'MINUTELY',
                'HOURLY',
                'DAILY',
                'WEEKLY',
                'MONTHLY',
                'YEARLY',
            ];
            const FrequencyRuleModule = {
                name: 'FrequencyRule',
                get: processor => {
                    if (processor.options.byMillisecondOfSecond !== undefined ||
                        processor.options.frequency !== 'MILLISECONDLY') {
                        return null;
                    }
                    if (processor.reverse)
                        return new RevFrequencyRule(processor, processor.end);
                    return new FrequencyRule(processor, processor.start);
                },
                normalizeOptions: (options, norm) => {
                    if (!FREQUENCIES.includes(options.frequency)) {
                        throw new _rschedule_core__WEBPACK_IMPORTED_MODULE_0__.RuleOptionError(`"frequency" must be one of ${JSON.stringify(FREQUENCIES)}`);
                    }
                    if (options.interval !== undefined) {
                        if (!Number.isInteger(options.interval)) {
                            throw new _rschedule_core__WEBPACK_IMPORTED_MODULE_0__.RuleOptionError('"interval" expects a whole number');
                        }
                        if (options.interval < 1) {
                            throw new _rschedule_core__WEBPACK_IMPORTED_MODULE_0__.RuleOptionError('"interval" cannot be less than 1');
                        }
                    }
                    if (options.weekStart !== undefined) {
                        if (!_rschedule_core__WEBPACK_IMPORTED_MODULE_0__.DateAdapter.WEEKDAYS.includes(options.weekStart)) {
                            throw new _rschedule_core__WEBPACK_IMPORTED_MODULE_0__.RuleOptionError(`"weekStart" must be one of ${JSON.stringify(_rschedule_core__WEBPACK_IMPORTED_MODULE_0__.DateAdapter.WEEKDAYS)}`);
                        }
                    }
                    norm.frequency = options.frequency;
                    norm.interval = options.interval || 1;
                    norm.weekStart = options.weekStart || 'MO';
                },
                deps: () => [FrequencyRuleModule],
            };
            function ruleOptionFilled(option) {
                return Array.isArray(option) && option.length > 0;
            }
            const freqCache = new WeakMap();
            class RecurrenceRuleBase extends RecurrenceRule {
                constructor(processor) {
                    super(processor);
                    if (!freqCache.has(this.processor)) {
                        freqCache.set(this.processor, new FrequencyRule(processor, processor.start));
                    }
                    this.frequency = freqCache.get(this.processor);
                }
                validateDate(arg) {
                    return this.frequency.validateDate(arg);
                }
            }
            class RevRecurrenceRuleBase extends RecurrenceRule {
                constructor(processor) {
                    super(processor);
                    if (!freqCache.has(this.processor)) {
                        freqCache.set(this.processor, new RevFrequencyRule(processor, processor.end));
                    }
                    this.frequency = freqCache.get(this.processor);
                }
                validateDate(arg) {
                    return this.frequency.validateDate(arg);
                }
            }
            /**
             * Contains shared logic for ByHourOfDay, ByMinuteOfHour,
             * BySecondOfMinute, and ByMillisecondOfSecond reverse rule pipes
             */
            class RevByTimeOfUnitRule extends RevRecurrenceRuleBase {
                run(date) {
                    // e.g. const currentTime = date.get('hour');
                    const currentTime = date.get(this.granularity);
                    // e.g. for (const time of this.options.byHourOfDay) {
                    for (const time of this.option) {
                        if (currentTime < time)
                            continue;
                        if (currentTime === time) {
                            return this.validateDate(new _rschedule_core__WEBPACK_IMPORTED_MODULE_0__.ValidDateTime(date));
                        }
                        // e.g. return this.nextValidDate(args, date.endGranularity('day').set('hour', time));
                        return this.validateDate(new _rschedule_core__WEBPACK_IMPORTED_MODULE_0__.InvalidDateTime(date.endGranularity(this.baseGranularity).set(this.granularity, time)));
                    }
                    return this.validateDate(new _rschedule_core__WEBPACK_IMPORTED_MODULE_0__.InvalidDateTime(date
                        // e.g. .endGranularity('day')
                        .endGranularity(this.baseGranularity)
                        // e.g. .subtract(1, 'day')
                        .subtract(1, this.baseGranularity)
                        // e.g. .set('hour', this.options.byHourOfDay[0]);
                        .set(this.granularity, this.option[0])));
                }
            }
            class RevByMillisecondOfSecondRule extends RevByTimeOfUnitRule {
                constructor() {
                    super(...arguments);
                    this.baseGranularity = 'second';
                    this.granularity = 'millisecond';
                    this.option = this.options.byMillisecondOfSecond.slice().reverse();
                }
            }
            /**
             * Contains shared logic for ByHourOfDay, ByMinuteOfHour,
             * BySecondOfMinute, and ByMillisecondOfSecond rule pipes
             */
            class ByTimeOfUnitRule extends RecurrenceRuleBase {
                run(date) {
                    // e.g. const currentTime = date.get('hour');
                    const currentTime = date.get(this.granularity);
                    // e.g. for (const time of this.options.byHourOfDay) {
                    for (const time of this.option) {
                        if (currentTime > time)
                            continue;
                        if (currentTime === time) {
                            return this.validateDate(new _rschedule_core__WEBPACK_IMPORTED_MODULE_0__.ValidDateTime(date));
                        }
                        // e.g. return this.nextValidDate(args, date.granularity('day').set('hour', time));
                        return this.validateDate(new _rschedule_core__WEBPACK_IMPORTED_MODULE_0__.InvalidDateTime(date.granularity(this.baseGranularity).set(this.granularity, time)));
                    }
                    return this.validateDate(new _rschedule_core__WEBPACK_IMPORTED_MODULE_0__.InvalidDateTime(date
                        // e.g. .granularity('day')
                        .granularity(this.baseGranularity)
                        // e.g. .add(1, 'day')
                        .add(1, this.baseGranularity)
                        // e.g. .set('hour', this.options.byHourOfDay[0]);
                        .set(this.granularity, this.option[0])));
                }
            }
            class ByMillisecondOfSecondRule extends ByTimeOfUnitRule {
                constructor() {
                    super(...arguments);
                    this.baseGranularity = 'second';
                    this.granularity = 'millisecond';
                    this.option = this.options.byMillisecondOfSecond;
                }
            }
            const ByMillisecondOfSecondRuleModule = {
                name: 'ByMillisecondOfSecond',
                get: processor => {
                    if (processor.options.byMillisecondOfSecond === undefined)
                        return null;
                    if (processor.reverse)
                        return new RevByMillisecondOfSecondRule(processor);
                    return new ByMillisecondOfSecondRule(processor);
                },
                normalizeOptions: (options, norm) => {
                    if (options.byMillisecondOfSecond !== undefined) {
                        if (!ruleOptionFilled(options.byMillisecondOfSecond)) {
                            throw new _rschedule_core__WEBPACK_IMPORTED_MODULE_0__.RuleOptionError('"byMillisecondOfSecond" expects a non-empty array');
                        }
                        if (options.byMillisecondOfSecond.some(num => num < 0 || num > 999)) {
                            throw new _rschedule_core__WEBPACK_IMPORTED_MODULE_0__.RuleOptionError('"byMillisecondOfSecond" values must be >= 0 && <= 999');
                        }
                        norm.byMillisecondOfSecond = options.byMillisecondOfSecond;
                        norm.byMillisecondOfSecond.sort(_rschedule_core__WEBPACK_IMPORTED_MODULE_0__.numberSortComparer);
                    }
                    else if (options.frequency !== 'MILLISECONDLY') {
                        norm.byMillisecondOfSecond = [norm.start.get('millisecond')];
                    }
                },
                deps: () => [FrequencyRuleModule, ByMillisecondOfSecondRuleModule],
            };
            class RevBySecondOfMinuteRule extends RevByTimeOfUnitRule {
                constructor() {
                    super(...arguments);
                    this.baseGranularity = 'minute';
                    this.granularity = 'second';
                    this.option = this.options.bySecondOfMinute.slice().reverse();
                }
            }
            class BySecondOfMinuteRule extends ByTimeOfUnitRule {
                constructor() {
                    super(...arguments);
                    this.baseGranularity = 'minute';
                    this.granularity = 'second';
                    this.option = this.options.bySecondOfMinute;
                }
            }
            const BySecondOfMinuteRuleModule = {
                name: 'BySecondOfMinute',
                get: processor => {
                    if (processor.options.bySecondOfMinute === undefined)
                        return null;
                    if (processor.reverse)
                        return new RevBySecondOfMinuteRule(processor);
                    return new BySecondOfMinuteRule(processor);
                },
                normalizeOptions: (options, norm) => {
                    if (options.bySecondOfMinute !== undefined) {
                        if (!ruleOptionFilled(options.bySecondOfMinute)) {
                            throw new _rschedule_core__WEBPACK_IMPORTED_MODULE_0__.RuleOptionError('"bySecondOfMinute" expects a non-empty array');
                        }
                        if (options.bySecondOfMinute.some(num => num < 0 || num > 60)) {
                            throw new _rschedule_core__WEBPACK_IMPORTED_MODULE_0__.RuleOptionError('"bySecondOfMinute" values must be >= 0 && <= 60');
                        }
                        norm.bySecondOfMinute = options.bySecondOfMinute;
                        norm.bySecondOfMinute.sort(_rschedule_core__WEBPACK_IMPORTED_MODULE_0__.numberSortComparer);
                    }
                    else if (!['SECONDLY', 'MILLISECONDLY'].includes(options.frequency)) {
                        norm.bySecondOfMinute = [norm.start.get('second')];
                    }
                },
                deps: () => [FrequencyRuleModule, BySecondOfMinuteRuleModule, ByMillisecondOfSecondRuleModule],
            };
            class RevByMinuteOfHourRule extends RevByTimeOfUnitRule {
                constructor() {
                    super(...arguments);
                    this.baseGranularity = 'hour';
                    this.granularity = 'minute';
                    this.option = this.options.byMinuteOfHour.slice().reverse();
                }
            }
            class ByMinuteOfHourRule extends ByTimeOfUnitRule {
                constructor() {
                    super(...arguments);
                    this.baseGranularity = 'hour';
                    this.granularity = 'minute';
                    this.option = this.options.byMinuteOfHour;
                }
            }
            const ByMinuteOfHourRuleModule = {
                name: 'ByMinuteOfHour',
                get: processor => {
                    if (processor.options.byMinuteOfHour === undefined)
                        return null;
                    if (processor.reverse)
                        return new RevByMinuteOfHourRule(processor);
                    return new ByMinuteOfHourRule(processor);
                },
                normalizeOptions: (options, norm) => {
                    if (options.byMinuteOfHour !== undefined) {
                        if (!ruleOptionFilled(options.byMinuteOfHour)) {
                            throw new _rschedule_core__WEBPACK_IMPORTED_MODULE_0__.RuleOptionError('"byMinuteOfHour" expects a non-empty array');
                        }
                        if (options.byMinuteOfHour.some(num => num < 0 || num > 59)) {
                            throw new _rschedule_core__WEBPACK_IMPORTED_MODULE_0__.RuleOptionError('"byMinuteOfHour" values must be >= 0 && <= 59');
                        }
                        norm.byMinuteOfHour = options.byMinuteOfHour;
                        norm.byMinuteOfHour.sort(_rschedule_core__WEBPACK_IMPORTED_MODULE_0__.numberSortComparer);
                    }
                    else if (!['MINUTELY', 'SECONDLY', 'MILLISECONDLY'].includes(options.frequency)) {
                        norm.byMinuteOfHour = [norm.start.get('minute')];
                    }
                },
                deps: () => [
                    FrequencyRuleModule,
                    ByMinuteOfHourRuleModule,
                    BySecondOfMinuteRuleModule,
                    ByMillisecondOfSecondRuleModule,
                ],
            };
            class RevByHourOfDayRule extends RevByTimeOfUnitRule {
                constructor() {
                    super(...arguments);
                    this.baseGranularity = 'day';
                    this.granularity = 'hour';
                    this.option = this.options.byHourOfDay.slice().reverse();
                }
            }
            class ByHourOfDayRule extends ByTimeOfUnitRule {
                constructor() {
                    super(...arguments);
                    this.baseGranularity = 'day';
                    this.granularity = 'hour';
                    this.option = this.options.byHourOfDay;
                }
            }
            const ByHourOfDayRuleModule = {
                name: 'ByHourOfDay',
                get: processor => {
                    if (processor.options.byHourOfDay === undefined)
                        return null;
                    if (processor.reverse)
                        return new RevByHourOfDayRule(processor);
                    return new ByHourOfDayRule(processor);
                },
                normalizeOptions: (options, norm) => {
                    if (options.byHourOfDay !== undefined) {
                        if (!ruleOptionFilled(options.byHourOfDay)) {
                            throw new _rschedule_core__WEBPACK_IMPORTED_MODULE_0__.RuleOptionError('"byHourOfDay" expects a non-empty array');
                        }
                        if (options.byHourOfDay.some(num => num < 0 || num > 23)) {
                            throw new _rschedule_core__WEBPACK_IMPORTED_MODULE_0__.RuleOptionError('"byHourOfDay" values must be >= 0 && <= 23');
                        }
                        norm.byHourOfDay = options.byHourOfDay;
                        norm.byHourOfDay.sort(_rschedule_core__WEBPACK_IMPORTED_MODULE_0__.numberSortComparer);
                    }
                    else if (['YEARLY', 'MONTHLY', 'WEEKLY', 'DAILY'].includes(options.frequency)) {
                        norm.byHourOfDay = [norm.start.get('hour')];
                    }
                },
                deps: () => [
                    FrequencyRuleModule,
                    ByHourOfDayRuleModule,
                    ByMinuteOfHourRuleModule,
                    BySecondOfMinuteRuleModule,
                    ByMillisecondOfSecondRuleModule,
                ],
            };
            function getNextWeekday(date, weekday) {
                return date.add((0, _rschedule_core__WEBPACK_IMPORTED_MODULE_0__.getDifferenceBetweenWeekdays)(date.get('weekday'), weekday), 'day');
            }
            function getNthWeekdayOfMonth(date, weekday, nth) {
                let base = date.set('day', 1);
                if (nth < 0) {
                    base = base.add(1, 'month');
                }
                base = getNextWeekday(base, weekday);
                // when nth is negative, adding it will act as subtraction
                return nth < 0 ? base.add(nth, 'week') : base.add(nth - 1, 'week');
            }
            class ByDayOfMonthRule extends RecurrenceRuleBase {
                run(date) {
                    const normalizedByDayOfMonth = normalizeByDayOfMonth(date, this.options.byDayOfMonth, this.options.byDayOfWeek);
                    const currentDay = date.get('day');
                    for (const day of normalizedByDayOfMonth) {
                        if (currentDay > day)
                            continue;
                        if (currentDay === day) {
                            return this.validateDate(new _rschedule_core__WEBPACK_IMPORTED_MODULE_0__.ValidDateTime(date));
                        }
                        return this.validateDate(new _rschedule_core__WEBPACK_IMPORTED_MODULE_0__.InvalidDateTime(date.granularity('month').set('day', day)));
                    }
                    let next;
                    let nextMonth = date;
                    let index = 0;
                    while (!next && index < 30) {
                        nextMonth = nextMonth.granularity('month').add(1, 'month');
                        next = normalizeByDayOfMonth(nextMonth, this.options.byDayOfMonth, this.options.byDayOfWeek)[0];
                        index++;
                    }
                    if (index >= 13) {
                        throw new _rschedule_core__WEBPACK_IMPORTED_MODULE_0__.RecurrenceRuleError('byDayOfMonth Infinite while loop');
                    }
                    return this.validateDate(new _rschedule_core__WEBPACK_IMPORTED_MODULE_0__.InvalidDateTime(nextMonth.set('day', next)));
                }
            }
            /**
             * Does a few things:
             *
             * 1. filters out byDayOfMonth entries which are not applicable
             *    to current month
             * 2. negative entries to positive ones
             * 3. if a byDayOfWeek option is given, removes days which are
             *    not on the correct day of the week
             */
            function normalizeByDayOfMonth(date, byDayOfMonth, byDayOfWeek) {
                const lengthOfMonth = date.endGranularity('month').get('day');
                let normalizedByDayOfMonth = byDayOfMonth
                    .filter(day => lengthOfMonth >= Math.abs(day))
                    .map(day => (day > 0 ? day : lengthOfMonth + day + 1));
                if (byDayOfWeek) {
                    const base = date.granularity('month');
                    const filteredByDayOfMonth = [];
                    byDayOfWeek.forEach(entry => {
                        if (typeof entry === 'string') {
                            filteredByDayOfMonth.push(...normalizedByDayOfMonth.filter(day => base.set('day', day).get('weekday') === entry));
                            return;
                        }
                        const nthWeekdayOfMonth = getNthWeekdayOfMonth(date, ...entry).get('day');
                        if (normalizedByDayOfMonth.includes(nthWeekdayOfMonth)) {
                            filteredByDayOfMonth.push(nthWeekdayOfMonth);
                        }
                    });
                    normalizedByDayOfMonth = Array.from(new Set(filteredByDayOfMonth));
                }
                return normalizedByDayOfMonth.sort((a, b) => {
                    if (a > b)
                        return 1;
                    if (a < b)
                        return -1;
                    else
                        return 0;
                });
            }
            class RevByDayOfMonthRule extends RevRecurrenceRuleBase {
                run(date) {
                    const normalizedByDayOfMonth = normalizeByDayOfMonth(date, this.options.byDayOfMonth, this.options.byDayOfWeek).reverse();
                    const currentDay = date.get('day');
                    for (const day of normalizedByDayOfMonth) {
                        if (currentDay < day)
                            continue;
                        if (currentDay === day) {
                            return this.validateDate(new _rschedule_core__WEBPACK_IMPORTED_MODULE_0__.ValidDateTime(date));
                        }
                        return this.validateDate(new _rschedule_core__WEBPACK_IMPORTED_MODULE_0__.InvalidDateTime(date.endGranularity('month').set('day', day)));
                    }
                    let next;
                    let nextMonth = date;
                    let index = 0;
                    while (!next && index < 30) {
                        nextMonth = nextMonth.endGranularity('month').subtract(1, 'month');
                        next = normalizeByDayOfMonth(nextMonth, this.options.byDayOfMonth, this.options.byDayOfWeek).pop();
                        index++;
                    }
                    if (index >= 13) {
                        throw new _rschedule_core__WEBPACK_IMPORTED_MODULE_0__.RecurrenceRuleError('byDayOfMonth Infinite while loop');
                    }
                    return this.validateDate(new _rschedule_core__WEBPACK_IMPORTED_MODULE_0__.InvalidDateTime(nextMonth.set('day', next)));
                }
            }
            const ByDayOfMonthRuleModule = {
                name: 'ByDayOfMonth',
                get: processor => {
                    if (processor.options.byDayOfMonth === undefined)
                        return null;
                    if (processor.reverse)
                        return new RevByDayOfMonthRule(processor);
                    return new ByDayOfMonthRule(processor);
                },
                normalizeOptions: (options, norm) => {
                    if (options.byDayOfMonth !== undefined) {
                        if (options.frequency === 'WEEKLY') {
                            throw new _rschedule_core__WEBPACK_IMPORTED_MODULE_0__.RuleOptionError('when "frequency" is "WEEKLY", "byDayOfMonth" cannot be present');
                        }
                        if (!ruleOptionFilled(options.byDayOfMonth)) {
                            throw new _rschedule_core__WEBPACK_IMPORTED_MODULE_0__.RuleOptionError('"byDayOfMonth" expects a non-empty array');
                        }
                        if (options.byDayOfMonth.some(num => num === 0 || num < -31 || num > 31)) {
                            throw new _rschedule_core__WEBPACK_IMPORTED_MODULE_0__.RuleOptionError('"byDayOfMonth" values must be `num !== 0 && num <= 31 && num >= -31`');
                        }
                        norm.byDayOfMonth = options.byDayOfMonth.slice();
                    }
                    else if (!(ruleOptionFilled(options.byDayOfWeek) || ruleOptionFilled(options.byDayOfYear)) &&
                        ['YEARLY', 'MONTHLY'].includes(options.frequency)) {
                        norm.byDayOfMonth = [norm.start.get('day')];
                    }
                },
                deps: () => [
                    FrequencyRuleModule,
                    ByDayOfMonthRuleModule,
                    ByHourOfDayRuleModule,
                    ByMinuteOfHourRuleModule,
                    BySecondOfMinuteRuleModule,
                    ByMillisecondOfSecondRuleModule,
                ],
            };
            function getNthWeekdayOfYear(date, weekday, nth) {
                let base = date.set('month', 1).set('day', 1);
                if (nth < 0) {
                    base = base.add(1, 'year');
                }
                base = getNextWeekday(base, weekday);
                // when nth is negative, adding it will act as subtraction
                return nth < 0 ? base.add(nth, 'week') : base.add(nth - 1, 'week');
            }
            function getPreviousWeekday(date, weekday) {
                const diff = (0, _rschedule_core__WEBPACK_IMPORTED_MODULE_0__.getDifferenceBetweenWeekdays)(date.get('weekday'), weekday);
                return date.subtract(diff === 0 ? 0 : 7 - diff, 'day');
            }
            class RevByDayOfWeekRule extends RevRecurrenceRuleBase {
                run(date) {
                    if (this.options.frequency === 'YEARLY') {
                        return this.options.byMonthOfYear === undefined
                            ? this.expandYearly(date)
                            : this.expandMonthly(date);
                    }
                    else if (this.options.frequency === 'MONTHLY') {
                        return this.expandMonthly(date);
                    }
                    return this.expand(date);
                }
                expandYearly(date) {
                    let next = getPrevWeekdaysOfYear(date, this.options.byDayOfWeek)[0];
                    let index = 0;
                    let base = date;
                    // If we can't find a valid date this year,
                    // search the previous year. Only search the past 28 years.
                    // (the calendar repeats on a 28 year cycle, according
                    // to the internet).
                    while (!next && index < 28) {
                        index++;
                        base = base.granularity('year').subtract(1, 'millisecond');
                        next = getPrevWeekdaysOfYear(base, this.options.byDayOfWeek)[0];
                    }
                    if (!next) {
                        throw new _rschedule_core__WEBPACK_IMPORTED_MODULE_0__.RecurrenceRuleError('The byDayOfWeek rule appears to contain an impossible combination');
                    }
                    return this.result(date, next);
                }
                expandMonthly(date) {
                    let next = getPrevWeekdaysOfMonth(date, this.options.byDayOfWeek)[0];
                    let index = 0;
                    let base = date;
                    // TODO: performance improvment
                    // If, in the first year, a match isn't found, we should be able to
                    // jumpt to the previous leap year and check that. Or, if already on
                    // a leap year, we can just error immediately.
                    // If we can't find a valid date this month,
                    // search the previous month. Only search the past 4 years
                    // (to account for leap year).
                    while (!next && index < 50) {
                        index++;
                        base = base.granularity('month').subtract(1, 'millisecond');
                        next = getPrevWeekdaysOfMonth(base, this.options.byDayOfWeek)[0];
                    }
                    if (!next) {
                        throw new _rschedule_core__WEBPACK_IMPORTED_MODULE_0__.RecurrenceRuleError('The byDayOfWeek rule appears to contain an impossible combination');
                    }
                    return this.result(date, next);
                }
                expand(date) {
                    const next = this.options.byDayOfWeek
                        .map(weekday => getPreviousWeekday(date, weekday))
                        .sort(_rschedule_core__WEBPACK_IMPORTED_MODULE_0__.dateTimeSortComparer)
                        .pop();
                    return this.result(date, next);
                }
                result(date, next) {
                    if (next.isEqual(date)) {
                        return this.validateDate(new _rschedule_core__WEBPACK_IMPORTED_MODULE_0__.ValidDateTime(date));
                    }
                    return this.validateDate(new _rschedule_core__WEBPACK_IMPORTED_MODULE_0__.InvalidDateTime(next.endGranularity('day')));
                }
            }
            /** For each byDayOfWeek entry, find the previous DateTime */
            function getPrevWeekdaysOfYear(date, byDayOfWeek) {
                const normalizedNthWeekdaysOfYear = byDayOfWeek
                    .filter(entry => Array.isArray(entry))
                    .map(entry => getNthWeekdayOfYear(date, ...entry));
                const normalizedNextWeekdays = byDayOfWeek
                    .filter(entry => typeof entry === 'string')
                    .map(weekday => getPreviousWeekday(date, weekday))
                    .filter(entry => entry.get('year') === date.get('year'));
                return (0, _rschedule_core__WEBPACK_IMPORTED_MODULE_0__.uniqDateTimes)([...normalizedNthWeekdaysOfYear, ...normalizedNextWeekdays])
                    .filter(entry => entry.isBeforeOrEqual(date))
                    .sort(_rschedule_core__WEBPACK_IMPORTED_MODULE_0__.dateTimeSortComparer)
                    .reverse();
            }
            /** For each byDayOfWeek entry, find the previous DateTime */
            function getPrevWeekdaysOfMonth(date, byDayOfWeek) {
                const normalizedNthWeekdaysOfMonth = byDayOfWeek
                    .filter(entry => Array.isArray(entry))
                    .map(entry => getNthWeekdayOfMonth(date, ...entry));
                const normalizedNextWeekdays = byDayOfWeek
                    .filter(entry => typeof entry === 'string')
                    .map(weekday => getPreviousWeekday(date, weekday))
                    .filter(entry => entry.get('year') === date.get('year') && entry.get('month') === date.get('month'));
                return (0, _rschedule_core__WEBPACK_IMPORTED_MODULE_0__.uniqDateTimes)([...normalizedNthWeekdaysOfMonth, ...normalizedNextWeekdays])
                    .filter(entry => entry.isBeforeOrEqual(date))
                    .sort(_rschedule_core__WEBPACK_IMPORTED_MODULE_0__.dateTimeSortComparer)
                    .reverse();
            }
            class ByDayOfWeekRule extends RecurrenceRuleBase {
                run(date) {
                    if (this.options.frequency === 'YEARLY') {
                        return this.options.byMonthOfYear === undefined
                            ? this.expandYearly(date)
                            : this.expandMonthly(date);
                    }
                    else if (this.options.frequency === 'MONTHLY') {
                        return this.expandMonthly(date);
                    }
                    return this.expand(date);
                }
                expandYearly(date) {
                    let next = getNextWeekdaysOfYear(date, this.options.byDayOfWeek)[0];
                    let index = 0;
                    let base = date;
                    // If we can't find a valid date this year,
                    // search next year. Only search the next 28 years.
                    // (the calendar repeats on a 28 year cycle, according
                    // to the internet).
                    while (!next && index < 28) {
                        index++;
                        base = base.granularity('year').add(1, 'year');
                        next = getNextWeekdaysOfYear(base, this.options.byDayOfWeek)[0];
                    }
                    if (!next) {
                        throw new _rschedule_core__WEBPACK_IMPORTED_MODULE_0__.RecurrenceRuleError('The byDayOfWeek rule appears to contain an impossible combination');
                    }
                    return this.result(date, next);
                }
                expandMonthly(date) {
                    let next = getNextWeekdaysOfMonth(date, this.options.byDayOfWeek)[0];
                    let index = 0;
                    let base = date;
                    // TODO: performance improvment
                    // If, in the first year, a match isn't found, we should be able to
                    // jumpt to the next leap year and check that. Or, if already on
                    // a leap year, we can just error immediately.
                    // If we can't find a valid date this month,
                    // search the next month. Only search the next 4 years
                    // (to account for leap year).
                    while (!next && index < 50) {
                        index++;
                        base = base.granularity('month').add(1, 'month');
                        next = getNextWeekdaysOfMonth(base, this.options.byDayOfWeek)[0];
                    }
                    if (!next) {
                        throw new _rschedule_core__WEBPACK_IMPORTED_MODULE_0__.RecurrenceRuleError('The byDayOfWeek rule appears to contain an impossible combination');
                    }
                    return this.result(date, next);
                }
                expand(date) {
                    const next = this.options.byDayOfWeek
                        .map(weekday => getNextWeekday(date, weekday))
                        .sort(_rschedule_core__WEBPACK_IMPORTED_MODULE_0__.dateTimeSortComparer)[0];
                    return this.result(date, next);
                }
                result(date, next) {
                    if (next.isEqual(date)) {
                        return this.validateDate(new _rschedule_core__WEBPACK_IMPORTED_MODULE_0__.ValidDateTime(date));
                    }
                    return this.validateDate(new _rschedule_core__WEBPACK_IMPORTED_MODULE_0__.InvalidDateTime(next.granularity('day')));
                }
            }
            /** For each byDayOfWeek entry, find the next DateTime */
            function getNextWeekdaysOfYear(date, byDayOfWeek) {
                const normalizedNthWeekdaysOfYear = byDayOfWeek
                    .filter(entry => Array.isArray(entry))
                    .map(entry => getNthWeekdayOfYear(date, ...entry));
                const normalizedNextWeekdays = byDayOfWeek
                    .filter(entry => typeof entry === 'string')
                    .map(weekday => getNextWeekday(date, weekday))
                    .filter(entry => entry.get('year') === date.get('year'));
                return (0, _rschedule_core__WEBPACK_IMPORTED_MODULE_0__.uniqDateTimes)([...normalizedNthWeekdaysOfYear, ...normalizedNextWeekdays])
                    .filter(entry => entry.isAfterOrEqual(date))
                    .sort(_rschedule_core__WEBPACK_IMPORTED_MODULE_0__.dateTimeSortComparer);
            }
            /** For each byDayOfWeek entry, find the next DateTime */
            function getNextWeekdaysOfMonth(date, byDayOfWeek) {
                const normalizedNthWeekdaysOfMonth = byDayOfWeek
                    .filter(entry => Array.isArray(entry))
                    .map(entry => getNthWeekdayOfMonth(date, ...entry));
                const normalizedNextWeekdays = byDayOfWeek
                    .filter(entry => typeof entry === 'string')
                    .map(weekday => getNextWeekday(date, weekday))
                    .filter(entry => entry.get('year') === date.get('year') && entry.get('month') === date.get('month'));
                return (0, _rschedule_core__WEBPACK_IMPORTED_MODULE_0__.uniqDateTimes)([...normalizedNthWeekdaysOfMonth, ...normalizedNextWeekdays])
                    .filter(entry => entry.isAfterOrEqual(date))
                    .sort(_rschedule_core__WEBPACK_IMPORTED_MODULE_0__.dateTimeSortComparer);
            }
            const ByDayOfWeekRuleModule = {
                name: 'ByDayOfWeek',
                get: processor => {
                    if (processor.options.byDayOfWeek === undefined)
                        return null;
                    if (processor.reverse)
                        return new RevByDayOfWeekRule(processor);
                    return new ByDayOfWeekRule(processor);
                },
                normalizeOptions: (options, norm) => {
                    if (options.byDayOfWeek !== undefined) {
                        if (!ruleOptionFilled(options.byDayOfWeek)) {
                            throw new _rschedule_core__WEBPACK_IMPORTED_MODULE_0__.RuleOptionError('"byDayOfWeek" expects a non-empty array');
                        }
                        const invalidWeeday = options.byDayOfWeek.find(day => Array.isArray(day)
                            ? !_rschedule_core__WEBPACK_IMPORTED_MODULE_0__.DateAdapter.WEEKDAYS.includes(day[0])
                            : !_rschedule_core__WEBPACK_IMPORTED_MODULE_0__.DateAdapter.WEEKDAYS.includes(day));
                        if (invalidWeeday) {
                            throw new _rschedule_core__WEBPACK_IMPORTED_MODULE_0__.RuleOptionError(`"byDayOfWeek" expects weedays in the form ` +
                                `${JSON.stringify(_rschedule_core__WEBPACK_IMPORTED_MODULE_0__.DateAdapter.WEEKDAYS)} but "${invalidWeeday}" was provided`);
                        }
                        if (!['YEARLY', 'MONTHLY'].includes(options.frequency) &&
                            options.byDayOfWeek.some(weekday => Array.isArray(weekday))) {
                            throw new _rschedule_core__WEBPACK_IMPORTED_MODULE_0__.RuleOptionError('"byDayOfWeek" can only include a numeric value (i.e. `[string, number]`) when the "frequency" is ' +
                                'either "MONTHLY" or "YEARLY"');
                        }
                        if (options.frequency === 'MONTHLY' &&
                            options.byDayOfWeek.some(weekday => Array.isArray(weekday) && (weekday[1] < -31 || weekday[1] === 0 || weekday[1] > 31))) {
                            throw new _rschedule_core__WEBPACK_IMPORTED_MODULE_0__.RuleOptionError('when "frequency" is "MONTHLY", each "byDayOfWeek" can optionally only' +
                                ' have a numeric value >= -31 and <= 31 and !== 0');
                        }
                        if (options.frequency === 'YEARLY' &&
                            options.byDayOfWeek.some(weekday => Array.isArray(weekday) && (weekday[1] < -366 || weekday[1] === 0 || weekday[1] > 366))) {
                            throw new _rschedule_core__WEBPACK_IMPORTED_MODULE_0__.RuleOptionError('when "frequency" is "YEARLY", each "byDayOfWeek" can optionally only' +
                                ' have a numeric value >= -366 and <= 366 and !== 0');
                        }
                        norm.byDayOfWeek = options.byDayOfWeek;
                    }
                    else if (!ruleOptionFilled(options.byDayOfMonth) && options.frequency === 'WEEKLY') {
                        norm.byDayOfWeek = [norm.start.get('weekday')];
                    }
                },
                deps: () => [
                    FrequencyRuleModule,
                    ByDayOfWeekRuleModule,
                    ByHourOfDayRuleModule,
                    ByMinuteOfHourRuleModule,
                    BySecondOfMinuteRuleModule,
                    ByMillisecondOfSecondRuleModule,
                ],
            };
            class RevByMonthOfYearRule extends RevRecurrenceRuleBase {
                constructor() {
                    super(...arguments);
                    this.option = this.processor.options.byMonthOfYear.slice().reverse();
                }
                run(date) {
                    const currentMonth = date.get('month');
                    for (const month of this.option) {
                        if (currentMonth < month)
                            continue;
                        if (currentMonth === month) {
                            return this.validateDate(new _rschedule_core__WEBPACK_IMPORTED_MODULE_0__.ValidDateTime(date));
                        }
                        return this.validateDate(new _rschedule_core__WEBPACK_IMPORTED_MODULE_0__.InvalidDateTime(date.endGranularity('year').set('month', month)));
                    }
                    return this.validateDate(new _rschedule_core__WEBPACK_IMPORTED_MODULE_0__.InvalidDateTime(date
                        .endGranularity('year')
                        .subtract(1, 'year')
                        .set('month', this.option[0])));
                }
            }
            class ByMonthOfYearRule extends RecurrenceRuleBase {
                run(date) {
                    const currentMonth = date.get('month');
                    for (const month of this.options.byMonthOfYear) {
                        if (currentMonth > month)
                            continue;
                        if (currentMonth === month) {
                            return this.validateDate(new _rschedule_core__WEBPACK_IMPORTED_MODULE_0__.ValidDateTime(date));
                        }
                        return this.validateDate(new _rschedule_core__WEBPACK_IMPORTED_MODULE_0__.InvalidDateTime(date.granularity('year').set('month', month)));
                    }
                    return this.validateDate(new _rschedule_core__WEBPACK_IMPORTED_MODULE_0__.InvalidDateTime(date
                        .granularity('year')
                        .add(1, 'year')
                        .set('month', this.options.byMonthOfYear[0])));
                }
            }
            const ByMonthOfYearRuleModule = {
                name: 'ByMonthOfYear',
                get: processor => {
                    if (processor.options.byMonthOfYear === undefined)
                        return null;
                    if (processor.reverse) {
                        return new RevByMonthOfYearRule(processor);
                    }
                    return new ByMonthOfYearRule(processor);
                },
                normalizeOptions: (options, norm) => {
                    if (options.byMonthOfYear !== undefined) {
                        if (!ruleOptionFilled(options.byMonthOfYear)) {
                            throw new _rschedule_core__WEBPACK_IMPORTED_MODULE_0__.RuleOptionError('"byMonthOfYear" expects a non-empty array');
                        }
                        if (options.byMonthOfYear.some(num => num < 1 || num > 12)) {
                            throw new _rschedule_core__WEBPACK_IMPORTED_MODULE_0__.RuleOptionError('"byMonthOfYear" values must be `num >= 1 && num >= 12`');
                        }
                        norm.byMonthOfYear = options.byMonthOfYear.slice();
                        norm.byMonthOfYear.sort(_rschedule_core__WEBPACK_IMPORTED_MODULE_0__.numberSortComparer);
                    }
                    else if (!(ruleOptionFilled(options.byDayOfMonth) ||
                        ruleOptionFilled(options.byDayOfWeek) ||
                        ruleOptionFilled(options.byDayOfYear)) &&
                        options.frequency === 'YEARLY') {
                        norm.byMonthOfYear = [norm.start.get('month')];
                    }
                },
                deps: () => [
                    FrequencyRuleModule,
                    ByMonthOfYearRuleModule,
                    ByDayOfMonthRuleModule,
                    ByHourOfDayRuleModule,
                    ByMinuteOfHourRuleModule,
                    BySecondOfMinuteRuleModule,
                    ByMillisecondOfSecondRuleModule,
                ],
            };
            const ICAL_RULES = [
                FrequencyRuleModule,
                ByMonthOfYearRuleModule,
                ByDayOfMonthRuleModule,
                ByDayOfWeekRuleModule,
                ByHourOfDayRuleModule,
                ByMinuteOfHourRuleModule,
                BySecondOfMinuteRuleModule,
                ByMillisecondOfSecondRuleModule,
            ];
            /***/ 
        }),
        /***/ "./node_modules/@rschedule/json-tools/es2015/Schedule.js": 
        /*!***************************************************************!*\
          !*** ./node_modules/@rschedule/json-tools/es2015/Schedule.js ***!
          \***************************************************************/
        /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony import */ var _rschedule_core_generators__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @rschedule/core/generators */ "./node_modules/@rschedule/core/es2015/generators.js");
            /* harmony import */ var _rschedule_json_tools__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @rschedule/json-tools */ "./node_modules/@rschedule/json-tools/es2015/main.js");
            /* harmony import */ var _rschedule_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @rschedule/core */ "./node_modules/@rschedule/core/es2015/main.js");
            _rschedule_core_generators__WEBPACK_IMPORTED_MODULE_1__.Dates.prototype.toJSON = function serialize(opts = {}) {
                const json = {
                    type: 'Dates',
                    dates: this.adapters.map(adapter => adapter.toJSON()),
                };
                if (!opts.nested)
                    json.timezone = this.timezone;
                (0, _rschedule_json_tools__WEBPACK_IMPORTED_MODULE_0__.serializeDataToJSON)(this, json, opts);
                return json;
            };
            _rschedule_core_generators__WEBPACK_IMPORTED_MODULE_1__.Dates.fromJSON = function parse(json, options = {}) {
                if (json.type !== 'Dates') {
                    throw new _rschedule_json_tools__WEBPACK_IMPORTED_MODULE_0__.ParseJSONError('Invalid Dates JSON');
                }
                return new _rschedule_core_generators__WEBPACK_IMPORTED_MODULE_1__.Dates({
                    dates: json.dates.map(date => _rschedule_core__WEBPACK_IMPORTED_MODULE_2__.DateAdapterBase.adapter.fromJSON(date)),
                    data: typeof options.data === 'function' ? options.data(json) : json.data,
                    timezone: options.timezone || json.timezone,
                });
            };
            (0, _rschedule_json_tools__WEBPACK_IMPORTED_MODULE_0__.registerJSONSerializerFn)('Dates', _rschedule_core_generators__WEBPACK_IMPORTED_MODULE_1__.Dates.fromJSON);
            _rschedule_core_generators__WEBPACK_IMPORTED_MODULE_1__.Rule.prototype.toJSON = function serialize(opts = {}) {
                const json = {
                    type: 'Rule',
                    config: Object.assign(Object.assign({}, (0, _rschedule_core__WEBPACK_IMPORTED_MODULE_2__.cloneJSON)(this.options)), {
                        start: this.normalizeDateInput(this.options.start).toJSON(),
                    }),
                };
                if (this.options.end) {
                    json.config.end = this.normalizeDateInput(this.options.end).toJSON();
                }
                if (!opts.nested)
                    json.timezone = this.timezone;
                (0, _rschedule_json_tools__WEBPACK_IMPORTED_MODULE_0__.serializeDataToJSON)(this, json, opts);
                return json;
            };
            _rschedule_core_generators__WEBPACK_IMPORTED_MODULE_1__.Rule.fromJSON = function fromJSON(json, options = {}) {
                const config = Object.assign(Object.assign({}, json.config), {
                    start: _rschedule_core__WEBPACK_IMPORTED_MODULE_2__.DateAdapterBase.adapter.fromJSON(json.config.start),
                    end: json.config.end && _rschedule_core__WEBPACK_IMPORTED_MODULE_2__.DateAdapterBase.adapter.fromJSON(json.config.end),
                });
                return new _rschedule_core_generators__WEBPACK_IMPORTED_MODULE_1__.Rule(config, {
                    data: typeof options.data === 'function' ? options.data(json) : json.data,
                    timezone: options.timezone || json.timezone,
                });
            };
            (0, _rschedule_json_tools__WEBPACK_IMPORTED_MODULE_0__.registerJSONSerializerFn)('Rule', _rschedule_core_generators__WEBPACK_IMPORTED_MODULE_1__.Rule.fromJSON);
            _rschedule_core_generators__WEBPACK_IMPORTED_MODULE_1__.Schedule.prototype.toJSON = function serialize(opts = {}) {
                const json = {
                    type: 'Schedule',
                    rrules: this.rrules.map(rule => rule.toJSON(Object.assign(Object.assign({}, opts), { nested: true }))),
                    exrules: this.exrules.map(rule => rule.toJSON(Object.assign(Object.assign({}, opts), { nested: true }))),
                    rdates: this.rdates.toJSON(Object.assign(Object.assign({}, opts), { nested: true })),
                    exdates: this.exdates.toJSON(Object.assign(Object.assign({}, opts), { nested: true })),
                };
                if (!opts.nested)
                    json.timezone = this.timezone;
                (0, _rschedule_json_tools__WEBPACK_IMPORTED_MODULE_0__.serializeDataToJSON)(this, json, opts);
                return json;
            };
            _rschedule_core_generators__WEBPACK_IMPORTED_MODULE_1__.Schedule.fromJSON = function parse(json, options = {}) {
                if (json.type !== 'Schedule') {
                    throw new _rschedule_json_tools__WEBPACK_IMPORTED_MODULE_0__.ParseJSONError('Invalid Schedule JSON');
                }
                return new _rschedule_core_generators__WEBPACK_IMPORTED_MODULE_1__.Schedule({
                    rrules: json.rrules.map(rule => _rschedule_core_generators__WEBPACK_IMPORTED_MODULE_1__.Rule.fromJSON(rule, Object.assign({ timezone: json.timezone }, options))),
                    exrules: json.exrules.map(rule => _rschedule_core_generators__WEBPACK_IMPORTED_MODULE_1__.Rule.fromJSON(rule, Object.assign({ timezone: json.timezone }, options))),
                    rdates: _rschedule_core_generators__WEBPACK_IMPORTED_MODULE_1__.Dates.fromJSON(json.rdates, Object.assign({ timezone: json.timezone }, options)),
                    exdates: _rschedule_core_generators__WEBPACK_IMPORTED_MODULE_1__.Dates.fromJSON(json.exdates, Object.assign({ timezone: json.timezone }, options)),
                    data: typeof options.data === 'function' ? options.data(json) : json.data,
                    timezone: options.timezone || json.timezone,
                });
            };
            (0, _rschedule_json_tools__WEBPACK_IMPORTED_MODULE_0__.registerJSONSerializerFn)('Schedule', _rschedule_core_generators__WEBPACK_IMPORTED_MODULE_1__.Schedule.fromJSON);
            /***/ 
        }),
        /***/ "./node_modules/@rschedule/json-tools/es2015/main.js": 
        /*!***********************************************************!*\
          !*** ./node_modules/@rschedule/json-tools/es2015/main.js ***!
          \***********************************************************/
        /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony export */ __webpack_require__.d(__webpack_exports__, {
                /* harmony export */ ParseJSONError: () => ( /* binding */ParseJSONError),
                /* harmony export */ SerializeJSONError: () => ( /* binding */SerializeJSONError),
                /* harmony export */ registerJSONSerializerFn: () => ( /* binding */registerJSONSerializerFn),
                /* harmony export */ serializeDataToJSON: () => ( /* binding */serializeDataToJSON)
                /* harmony export */ 
            });
            /* harmony import */ var _rschedule_core_generators__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @rschedule/core/generators */ "./node_modules/@rschedule/core/es2015/generators.js");
            class ParseJSONError extends Error {
            }
            class SerializeJSONError extends Error {
            }
            _rschedule_core_generators__WEBPACK_IMPORTED_MODULE_0__.OccurrenceGenerator.JSON_FN_MAP = new Map();
            _rschedule_core_generators__WEBPACK_IMPORTED_MODULE_0__.OccurrenceGenerator.prototype.toJSON = function serialize(opts) {
                throw new SerializeJSONError(`To support smaller bundles, ${this.constructor.name}#toJSON() ` +
                    `must be manually added. See "@rschedule/json-tools" in the rSchedule docs.`);
            };
            _rschedule_core_generators__WEBPACK_IMPORTED_MODULE_0__.OccurrenceGenerator.fromJSON = function parse(json, options) {
                if (typeof json !== 'object' || json === null) {
                    throw new ParseJSONError(`Invalid json "${json}"`);
                }
                const fn = _rschedule_core_generators__WEBPACK_IMPORTED_MODULE_0__.OccurrenceGenerator.JSON_FN_MAP.get(json.type);
                if (!fn) {
                    throw new ParseJSONError(`Unknown rSchedule object type "${json.type}". Have you added a json serializer ` +
                        `for "${json.type}"? ` +
                        `See "@rschedule/json-tools" in the rSchedule docs.`);
                }
                return fn(json, options);
            };
            function serializeDataToJSON(gen, json, opt) {
                if (!opt.data)
                    return;
                if (opt.data === true) {
                    json.data = gen.data;
                }
                else {
                    json.data = opt.data(gen);
                }
                if (json.data === undefined)
                    delete json.data;
            }
            function registerJSONSerializerFn(name, fn) {
                _rschedule_core_generators__WEBPACK_IMPORTED_MODULE_0__.OccurrenceGenerator.JSON_FN_MAP.set(name, fn);
            }
            /***/ 
        }),
        /***/ "./node_modules/@rschedule/standard-date-adapter/es2015/main.js": 
        /*!**********************************************************************!*\
          !*** ./node_modules/@rschedule/standard-date-adapter/es2015/main.js ***!
          \**********************************************************************/
        /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony export */ __webpack_require__.d(__webpack_exports__, {
                /* harmony export */ StandardDateAdapter: () => ( /* binding */StandardDateAdapter)
                /* harmony export */ 
            });
            /* harmony import */ var _rschedule_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @rschedule/core */ "./node_modules/@rschedule/core/es2015/main.js");
            class StandardDateAdapter extends _rschedule_core__WEBPACK_IMPORTED_MODULE_0__.DateAdapterBase {
                constructor(date, options = {}) {
                    super(undefined, options);
                    if (!['UTC', null, undefined].includes(options.timezone)) {
                        throw new _rschedule_core__WEBPACK_IMPORTED_MODULE_0__.InvalidDateAdapterError(`StandardDateAdapter only supports "UTC" and ` +
                            `local time zones but "${options.timezone}" was provided.`);
                    }
                    this._date = new Date(date);
                    this.timezone = options.timezone !== undefined ? options.timezone : null;
                    if (options.metadata) {
                        Object.assign(this.metadata, options.metadata);
                    }
                    this.assertIsValid();
                }
                static isDate(object) {
                    return Object.prototype.toString.call(object) === '[object Date]';
                }
                static fromDate(date, options) {
                    return new StandardDateAdapter(date, options);
                }
                static fromJSON(json) {
                    const args = [
                        json.year,
                        json.month - 1,
                        json.day,
                        json.hour,
                        json.minute,
                        json.second,
                        json.millisecond,
                    ];
                    let date;
                    switch (json.timezone) {
                        case 'UTC': {
                            date = new StandardDateAdapter(new Date(Date.UTC(...args)), {
                                timezone: 'UTC',
                                duration: json.duration,
                            });
                            break;
                        }
                        case null: {
                            date = new StandardDateAdapter(new Date(...args), {
                                timezone: null,
                                duration: json.duration,
                            });
                            break;
                        }
                        default:
                            throw new _rschedule_core__WEBPACK_IMPORTED_MODULE_0__.InvalidDateAdapterError('The `StandardDateAdapter` only supports datetimes in ' +
                                `UTC or LOCAL (null) time. You provided a JSON object ` +
                                `with timezone "${json.timezone}".`);
                    }
                    if (json.metadata) {
                        Object.assign(date.metadata, json.metadata);
                    }
                    return date;
                }
                static fromDateTime(datetime) {
                    const date = StandardDateAdapter.fromJSON(datetime.toJSON());
                    date.generators.push(...datetime.generators);
                    if (datetime.metadata) {
                        Object.assign(date.metadata, datetime.metadata);
                    }
                    return date;
                }
                get date() {
                    return new Date(this._date);
                }
                get end() {
                    if (!this.duration)
                        return;
                    if (this._end)
                        return this._end;
                    this._end = StandardDateAdapter.fromDateTime(this.toDateTime().add(this.duration, 'millisecond')).date;
                    return this._end;
                }
                set(prop, value) {
                    if (prop === 'timezone') {
                        if (this.timezone === value)
                            return this;
                        else {
                            return new StandardDateAdapter(this._date, {
                                timezone: value,
                                duration: this.duration,
                                generators: this.generators,
                            });
                        }
                    }
                    else if (prop === 'duration') {
                        if (this.duration === value)
                            return this;
                        else {
                            return new StandardDateAdapter(this._date, {
                                timezone: this.timezone,
                                duration: value,
                                generators: this.generators,
                            });
                        }
                    }
                    throw new _rschedule_core__WEBPACK_IMPORTED_MODULE_0__.ArgumentError(`Unknown prop "${prop}" for StandardDateAdapter#set()`);
                }
                valueOf() {
                    return this._date.valueOf();
                }
                toJSON() {
                    let json;
                    if (this.timezone === 'UTC') {
                        json = {
                            timezone: this.timezone,
                            year: this._date.getUTCFullYear(),
                            month: this._date.getUTCMonth() + 1,
                            day: this._date.getUTCDate(),
                            hour: this._date.getUTCHours(),
                            minute: this._date.getUTCMinutes(),
                            second: this._date.getUTCSeconds(),
                            millisecond: this._date.getUTCMilliseconds(),
                        };
                    }
                    else {
                        json = {
                            timezone: this.timezone,
                            year: this._date.getFullYear(),
                            month: this._date.getMonth() + 1,
                            day: this._date.getDate(),
                            hour: this._date.getHours(),
                            minute: this._date.getMinutes(),
                            second: this._date.getSeconds(),
                            millisecond: this._date.getMilliseconds(),
                        };
                    }
                    if (this.duration) {
                        json.duration = this.duration;
                    }
                    return json;
                }
                assertIsValid() {
                    if (!StandardDateAdapter.isDate(this._date) || isNaN(this._date.valueOf())) {
                        throw new _rschedule_core__WEBPACK_IMPORTED_MODULE_0__.InvalidDateAdapterError('StandardDateAdapter has invalid date.');
                    }
                    else if (![null, 'UTC'].includes(this.timezone)) {
                        throw new _rschedule_core__WEBPACK_IMPORTED_MODULE_0__.InvalidDateAdapterError('StandardDateAdapter only supports local (null) and UTC timezones but ' +
                            `"${this.timezone}" was specified.`);
                    }
                    else if (this.duration && this.duration <= 0) {
                        throw new _rschedule_core__WEBPACK_IMPORTED_MODULE_0__.InvalidDateAdapterError('If provided, duration must be greater than 0.');
                    }
                    return true;
                }
            }
            StandardDateAdapter.hasTimezoneSupport = false;
            /***/ 
        }),
        /***/ "./node_modules/@rschedule/standard-date-adapter/es2015/setup.js": 
        /*!***********************************************************************!*\
          !*** ./node_modules/@rschedule/standard-date-adapter/es2015/setup.js ***!
          \***********************************************************************/
        /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony import */ var _rschedule_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @rschedule/core */ "./node_modules/@rschedule/core/es2015/main.js");
            /* harmony import */ var _rschedule_core_generators__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @rschedule/core/generators */ "./node_modules/@rschedule/core/es2015/generators.js");
            /* harmony import */ var _rschedule_core_rules_ICAL_RULES__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @rschedule/core/rules/ICAL_RULES */ "./node_modules/@rschedule/core/es2015/rules.js");
            /* harmony import */ var _rschedule_standard_date_adapter__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @rschedule/standard-date-adapter */ "./node_modules/@rschedule/standard-date-adapter/es2015/main.js");
            _rschedule_core__WEBPACK_IMPORTED_MODULE_0__.DateAdapterBase.adapter = _rschedule_standard_date_adapter__WEBPACK_IMPORTED_MODULE_1__.StandardDateAdapter;
            _rschedule_core_generators__WEBPACK_IMPORTED_MODULE_2__.Rule.recurrenceRules = _rschedule_core_rules_ICAL_RULES__WEBPACK_IMPORTED_MODULE_3__.ICAL_RULES;
            /***/ 
        }),
        /***/ "./node_modules/adm-zip/adm-zip.js": 
        /*!*****************************************!*\
          !*** ./node_modules/adm-zip/adm-zip.js ***!
          \*****************************************/
        /***/ ((module, __unused_webpack_exports, __webpack_require__) => {
            const Utils = __webpack_require__(/*! ./util */ "./node_modules/adm-zip/util/index.js");
            const pth = __webpack_require__(/*! path */ "path");
            const ZipEntry = __webpack_require__(/*! ./zipEntry */ "./node_modules/adm-zip/zipEntry.js");
            const ZipFile = __webpack_require__(/*! ./zipFile */ "./node_modules/adm-zip/zipFile.js");
            const get_Bool = (val, def) => (typeof val === "boolean" ? val : def);
            const get_Str = (val, def) => (typeof val === "string" ? val : def);
            const defaultOptions = {
                // option "noSort" : if true it disables files sorting
                noSort: false,
                // read entries during load (initial loading may be slower)
                readEntries: false,
                // default method is none
                method: Utils.Constants.NONE,
                // file system
                fs: null
            };
            module.exports = function (/**String*/ input, /** object */ options) {
                let inBuffer = null;
                // create object based default options, allowing them to be overwritten
                const opts = Object.assign(Object.create(null), defaultOptions);
                // test input variable
                if (input && "object" === typeof input) {
                    // if value is not buffer we accept it to be object with options
                    if (!(input instanceof Uint8Array)) {
                        Object.assign(opts, input);
                        input = opts.input ? opts.input : undefined;
                        if (opts.input)
                            delete opts.input;
                    }
                    // if input is buffer
                    if (Buffer.isBuffer(input)) {
                        inBuffer = input;
                        opts.method = Utils.Constants.BUFFER;
                        input = undefined;
                    }
                }
                // assign options
                Object.assign(opts, options);
                // instanciate utils filesystem
                const filetools = new Utils(opts);
                // if input is file name we retrieve its content
                if (input && "string" === typeof input) {
                    // load zip file
                    if (filetools.fs.existsSync(input)) {
                        opts.method = Utils.Constants.FILE;
                        opts.filename = input;
                        inBuffer = filetools.fs.readFileSync(input);
                    }
                    else {
                        throw new Error(Utils.Errors.INVALID_FILENAME);
                    }
                }
                // create variable
                const _zip = new ZipFile(inBuffer, opts);
                const { canonical, sanitize } = Utils;
                function getEntry(/**Object*/ entry) {
                    if (entry && _zip) {
                        var item;
                        // If entry was given as a file name
                        if (typeof entry === "string")
                            item = _zip.getEntry(entry);
                        // if entry was given as a ZipEntry object
                        if (typeof entry === "object" && typeof entry.entryName !== "undefined" && typeof entry.header !== "undefined")
                            item = _zip.getEntry(entry.entryName);
                        if (item) {
                            return item;
                        }
                    }
                    return null;
                }
                function fixPath(zipPath) {
                    const { join, normalize, sep } = pth.posix;
                    // convert windows file separators and normalize
                    return join(".", normalize(sep + zipPath.split("\\").join(sep) + sep));
                }
                return {
                    /**
                     * Extracts the given entry from the archive and returns the content as a Buffer object
                     * @param entry ZipEntry object or String with the full path of the entry
                     *
                     * @return Buffer or Null in case of error
                     */
                    readFile: function (/**Object*/ entry, /*String, Buffer*/ pass) {
                        var item = getEntry(entry);
                        return (item && item.getData(pass)) || null;
                    },
                    /**
                     * Asynchronous readFile
                     * @param entry ZipEntry object or String with the full path of the entry
                     * @param callback
                     *
                     * @return Buffer or Null in case of error
                     */
                    readFileAsync: function (/**Object*/ entry, /**Function*/ callback) {
                        var item = getEntry(entry);
                        if (item) {
                            item.getDataAsync(callback);
                        }
                        else {
                            callback(null, "getEntry failed for:" + entry);
                        }
                    },
                    /**
                     * Extracts the given entry from the archive and returns the content as plain text in the given encoding
                     * @param entry ZipEntry object or String with the full path of the entry
                     * @param encoding Optional. If no encoding is specified utf8 is used
                     *
                     * @return String
                     */
                    readAsText: function (/**Object*/ entry, /**String=*/ encoding) {
                        var item = getEntry(entry);
                        if (item) {
                            var data = item.getData();
                            if (data && data.length) {
                                return data.toString(encoding || "utf8");
                            }
                        }
                        return "";
                    },
                    /**
                     * Asynchronous readAsText
                     * @param entry ZipEntry object or String with the full path of the entry
                     * @param callback
                     * @param encoding Optional. If no encoding is specified utf8 is used
                     *
                     * @return String
                     */
                    readAsTextAsync: function (/**Object*/ entry, /**Function*/ callback, /**String=*/ encoding) {
                        var item = getEntry(entry);
                        if (item) {
                            item.getDataAsync(function (data, err) {
                                if (err) {
                                    callback(data, err);
                                    return;
                                }
                                if (data && data.length) {
                                    callback(data.toString(encoding || "utf8"));
                                }
                                else {
                                    callback("");
                                }
                            });
                        }
                        else {
                            callback("");
                        }
                    },
                    /**
                     * Remove the entry from the file or the entry and all it's nested directories and files if the given entry is a directory
                     *
                     * @param entry
                     */
                    deleteFile: function (/**Object*/ entry) {
                        // @TODO: test deleteFile
                        var item = getEntry(entry);
                        if (item) {
                            _zip.deleteEntry(item.entryName);
                        }
                    },
                    /**
                     * Adds a comment to the zip. The zip must be rewritten after adding the comment.
                     *
                     * @param comment
                     */
                    addZipComment: function (/**String*/ comment) {
                        // @TODO: test addZipComment
                        _zip.comment = comment;
                    },
                    /**
                     * Returns the zip comment
                     *
                     * @return String
                     */
                    getZipComment: function () {
                        return _zip.comment || "";
                    },
                    /**
                     * Adds a comment to a specified zipEntry. The zip must be rewritten after adding the comment
                     * The comment cannot exceed 65535 characters in length
                     *
                     * @param entry
                     * @param comment
                     */
                    addZipEntryComment: function (/**Object*/ entry, /**String*/ comment) {
                        var item = getEntry(entry);
                        if (item) {
                            item.comment = comment;
                        }
                    },
                    /**
                     * Returns the comment of the specified entry
                     *
                     * @param entry
                     * @return String
                     */
                    getZipEntryComment: function (/**Object*/ entry) {
                        var item = getEntry(entry);
                        if (item) {
                            return item.comment || "";
                        }
                        return "";
                    },
                    /**
                     * Updates the content of an existing entry inside the archive. The zip must be rewritten after updating the content
                     *
                     * @param entry
                     * @param content
                     */
                    updateFile: function (/**Object*/ entry, /**Buffer*/ content) {
                        var item = getEntry(entry);
                        if (item) {
                            item.setData(content);
                        }
                    },
                    /**
                     * Adds a file from the disk to the archive
                     *
                     * @param localPath File to add to zip
                     * @param zipPath Optional path inside the zip
                     * @param zipName Optional name for the file
                     */
                    addLocalFile: function (/**String*/ localPath, /**String=*/ zipPath, /**String=*/ zipName, /**String*/ comment) {
                        if (filetools.fs.existsSync(localPath)) {
                            // fix ZipPath
                            zipPath = zipPath ? fixPath(zipPath) : "";
                            // p - local file name
                            var p = localPath.split("\\").join("/").split("/").pop();
                            // add file name into zippath
                            zipPath += zipName ? zipName : p;
                            // read file attributes
                            const _attr = filetools.fs.statSync(localPath);
                            // add file into zip file
                            this.addFile(zipPath, filetools.fs.readFileSync(localPath), comment, _attr);
                        }
                        else {
                            throw new Error(Utils.Errors.FILE_NOT_FOUND.replace("%s", localPath));
                        }
                    },
                    /**
                     * Adds a local directory and all its nested files and directories to the archive
                     *
                     * @param localPath
                     * @param zipPath optional path inside zip
                     * @param filter optional RegExp or Function if files match will
                     *               be included.
                     * @param {number | object} attr - number as unix file permissions, object as filesystem Stats object
                     */
                    addLocalFolder: function (/**String*/ localPath, /**String=*/ zipPath, /**=RegExp|Function*/ filter, /**=number|object*/ attr) {
                        // Prepare filter
                        if (filter instanceof RegExp) {
                            // if filter is RegExp wrap it
                            filter = (function (rx) {
                                return function (filename) {
                                    return rx.test(filename);
                                };
                            })(filter);
                        }
                        else if ("function" !== typeof filter) {
                            // if filter is not function we will replace it
                            filter = function () {
                                return true;
                            };
                        }
                        // fix ZipPath
                        zipPath = zipPath ? fixPath(zipPath) : "";
                        // normalize the path first
                        localPath = pth.normalize(localPath);
                        if (filetools.fs.existsSync(localPath)) {
                            const items = filetools.findFiles(localPath);
                            const self = this;
                            if (items.length) {
                                items.forEach(function (filepath) {
                                    var p = pth.relative(localPath, filepath).split("\\").join("/"); //windows fix
                                    if (filter(p)) {
                                        var stats = filetools.fs.statSync(filepath);
                                        if (stats.isFile()) {
                                            self.addFile(zipPath + p, filetools.fs.readFileSync(filepath), "", attr ? attr : stats);
                                        }
                                        else {
                                            self.addFile(zipPath + p + "/", Buffer.alloc(0), "", attr ? attr : stats);
                                        }
                                    }
                                });
                            }
                        }
                        else {
                            throw new Error(Utils.Errors.FILE_NOT_FOUND.replace("%s", localPath));
                        }
                    },
                    /**
                     * Asynchronous addLocalFile
                     * @param localPath
                     * @param callback
                     * @param zipPath optional path inside zip
                     * @param filter optional RegExp or Function if files match will
                     *               be included.
                     */
                    addLocalFolderAsync: function (/*String*/ localPath, /*Function*/ callback, /*String*/ zipPath, /*RegExp|Function*/ filter) {
                        if (filter instanceof RegExp) {
                            filter = (function (rx) {
                                return function (filename) {
                                    return rx.test(filename);
                                };
                            })(filter);
                        }
                        else if ("function" !== typeof filter) {
                            filter = function () {
                                return true;
                            };
                        }
                        // fix ZipPath
                        zipPath = zipPath ? fixPath(zipPath) : "";
                        // normalize the path first
                        localPath = pth.normalize(localPath);
                        var self = this;
                        filetools.fs.open(localPath, "r", function (err) {
                            if (err && err.code === "ENOENT") {
                                callback(undefined, Utils.Errors.FILE_NOT_FOUND.replace("%s", localPath));
                            }
                            else if (err) {
                                callback(undefined, err);
                            }
                            else {
                                var items = filetools.findFiles(localPath);
                                var i = -1;
                                var next = function () {
                                    i += 1;
                                    if (i < items.length) {
                                        var filepath = items[i];
                                        var p = pth.relative(localPath, filepath).split("\\").join("/"); //windows fix
                                        p = p
                                            .normalize("NFD")
                                            .replace(/[\u0300-\u036f]/g, "")
                                            .replace(/[^\x20-\x7E]/g, ""); // accent fix
                                        if (filter(p)) {
                                            filetools.fs.stat(filepath, function (er0, stats) {
                                                if (er0)
                                                    callback(undefined, er0);
                                                if (stats.isFile()) {
                                                    filetools.fs.readFile(filepath, function (er1, data) {
                                                        if (er1) {
                                                            callback(undefined, er1);
                                                        }
                                                        else {
                                                            self.addFile(zipPath + p, data, "", stats);
                                                            next();
                                                        }
                                                    });
                                                }
                                                else {
                                                    self.addFile(zipPath + p + "/", Buffer.alloc(0), "", stats);
                                                    next();
                                                }
                                            });
                                        }
                                        else {
                                            process.nextTick(() => {
                                                next();
                                            });
                                        }
                                    }
                                    else {
                                        callback(true, undefined);
                                    }
                                };
                                next();
                            }
                        });
                    },
                    /**
                     *
                     * @param {string} localPath - path where files will be extracted
                     * @param {object} props - optional properties
                     * @param {string} props.zipPath - optional path inside zip
                     * @param {regexp, function} props.filter - RegExp or Function if files match will be included.
                     */
                    addLocalFolderPromise: function (/*String*/ localPath, /* object */ props) {
                        return new Promise((resolve, reject) => {
                            const { filter, zipPath } = Object.assign({}, props);
                            this.addLocalFolderAsync(localPath, (done, err) => {
                                if (err)
                                    reject(err);
                                if (done)
                                    resolve(this);
                            }, zipPath, filter);
                        });
                    },
                    /**
                     * Allows you to create a entry (file or directory) in the zip file.
                     * If you want to create a directory the entryName must end in / and a null buffer should be provided.
                     * Comment and attributes are optional
                     *
                     * @param {string} entryName
                     * @param {Buffer | string} content - file content as buffer or utf8 coded string
                     * @param {string} comment - file comment
                     * @param {number | object} attr - number as unix file permissions, object as filesystem Stats object
                     */
                    addFile: function (/**String*/ entryName, /**Buffer*/ content, /**String*/ comment, /**Number*/ attr) {
                        let entry = getEntry(entryName);
                        const update = entry != null;
                        // prepare new entry
                        if (!update) {
                            entry = new ZipEntry();
                            entry.entryName = entryName;
                        }
                        entry.comment = comment || "";
                        const isStat = "object" === typeof attr && attr instanceof filetools.fs.Stats;
                        // last modification time from file stats
                        if (isStat) {
                            entry.header.time = attr.mtime;
                        }
                        // Set file attribute
                        var fileattr = entry.isDirectory ? 0x10 : 0; // (MS-DOS directory flag)
                        // extended attributes field for Unix
                        // set file type either S_IFDIR / S_IFREG
                        let unix = entry.isDirectory ? 0x4000 : 0x8000;
                        if (isStat) {
                            // File attributes from file stats
                            unix |= 0xfff & attr.mode;
                        }
                        else if ("number" === typeof attr) {
                            // attr from given attr values
                            unix |= 0xfff & attr;
                        }
                        else {
                            // Default values:
                            unix |= entry.isDirectory ? 0o755 : 0o644; // permissions (drwxr-xr-x) or (-r-wr--r--)
                        }
                        fileattr = (fileattr | (unix << 16)) >>> 0; // add attributes
                        entry.attr = fileattr;
                        entry.setData(content);
                        if (!update)
                            _zip.setEntry(entry);
                    },
                    /**
                     * Returns an array of ZipEntry objects representing the files and folders inside the archive
                     *
                     * @return Array
                     */
                    getEntries: function () {
                        return _zip ? _zip.entries : [];
                    },
                    /**
                     * Returns a ZipEntry object representing the file or folder specified by ``name``.
                     *
                     * @param name
                     * @return ZipEntry
                     */
                    getEntry: function (/**String*/ name) {
                        return getEntry(name);
                    },
                    getEntryCount: function () {
                        return _zip.getEntryCount();
                    },
                    forEach: function (callback) {
                        return _zip.forEach(callback);
                    },
                    /**
                     * Extracts the given entry to the given targetPath
                     * If the entry is a directory inside the archive, the entire directory and it's subdirectories will be extracted
                     *
                     * @param entry ZipEntry object or String with the full path of the entry
                     * @param targetPath Target folder where to write the file
                     * @param maintainEntryPath If maintainEntryPath is true and the entry is inside a folder, the entry folder
                     *                          will be created in targetPath as well. Default is TRUE
                     * @param overwrite If the file already exists at the target path, the file will be overwriten if this is true.
                     *                  Default is FALSE
                     * @param keepOriginalPermission The file will be set as the permission from the entry if this is true.
                     *                  Default is FALSE
                     * @param outFileName String If set will override the filename of the extracted file (Only works if the entry is a file)
                     *
                     * @return Boolean
                     */
                    extractEntryTo: function (
                    /**Object*/ entry, 
                    /**String*/ targetPath, 
                    /**Boolean*/ maintainEntryPath, 
                    /**Boolean*/ overwrite, 
                    /**Boolean*/ keepOriginalPermission, 
                    /**String**/ outFileName) {
                        overwrite = get_Bool(overwrite, false);
                        keepOriginalPermission = get_Bool(keepOriginalPermission, false);
                        maintainEntryPath = get_Bool(maintainEntryPath, true);
                        outFileName = get_Str(outFileName, get_Str(keepOriginalPermission, undefined));
                        var item = getEntry(entry);
                        if (!item) {
                            throw new Error(Utils.Errors.NO_ENTRY);
                        }
                        var entryName = canonical(item.entryName);
                        var target = sanitize(targetPath, outFileName && !item.isDirectory ? outFileName : maintainEntryPath ? entryName : pth.basename(entryName));
                        if (item.isDirectory) {
                            var children = _zip.getEntryChildren(item);
                            children.forEach(function (child) {
                                if (child.isDirectory)
                                    return;
                                var content = child.getData();
                                if (!content) {
                                    throw new Error(Utils.Errors.CANT_EXTRACT_FILE);
                                }
                                var name = canonical(child.entryName);
                                var childName = sanitize(targetPath, maintainEntryPath ? name : pth.basename(name));
                                // The reverse operation for attr depend on method addFile()
                                const fileAttr = keepOriginalPermission ? child.header.fileAttr : undefined;
                                filetools.writeFileTo(childName, content, overwrite, fileAttr);
                            });
                            return true;
                        }
                        var content = item.getData();
                        if (!content)
                            throw new Error(Utils.Errors.CANT_EXTRACT_FILE);
                        if (filetools.fs.existsSync(target) && !overwrite) {
                            throw new Error(Utils.Errors.CANT_OVERRIDE);
                        }
                        // The reverse operation for attr depend on method addFile()
                        const fileAttr = keepOriginalPermission ? entry.header.fileAttr : undefined;
                        filetools.writeFileTo(target, content, overwrite, fileAttr);
                        return true;
                    },
                    /**
                     * Test the archive
                     *
                     */
                    test: function (pass) {
                        if (!_zip) {
                            return false;
                        }
                        for (var entry in _zip.entries) {
                            try {
                                if (entry.isDirectory) {
                                    continue;
                                }
                                var content = _zip.entries[entry].getData(pass);
                                if (!content) {
                                    return false;
                                }
                            }
                            catch (err) {
                                return false;
                            }
                        }
                        return true;
                    },
                    /**
                     * Extracts the entire archive to the given location
                     *
                     * @param targetPath Target location
                     * @param overwrite If the file already exists at the target path, the file will be overwriten if this is true.
                     *                  Default is FALSE
                     * @param keepOriginalPermission The file will be set as the permission from the entry if this is true.
                     *                  Default is FALSE
                     */
                    extractAllTo: function (/**String*/ targetPath, /**Boolean*/ overwrite, /**Boolean*/ keepOriginalPermission, /*String, Buffer*/ pass) {
                        overwrite = get_Bool(overwrite, false);
                        pass = get_Str(keepOriginalPermission, pass);
                        keepOriginalPermission = get_Bool(keepOriginalPermission, false);
                        if (!_zip) {
                            throw new Error(Utils.Errors.NO_ZIP);
                        }
                        _zip.entries.forEach(function (entry) {
                            var entryName = sanitize(targetPath, canonical(entry.entryName.toString()));
                            if (entry.isDirectory) {
                                filetools.makeDir(entryName);
                                return;
                            }
                            var content = entry.getData(pass);
                            if (!content) {
                                throw new Error(Utils.Errors.CANT_EXTRACT_FILE);
                            }
                            // The reverse operation for attr depend on method addFile()
                            const fileAttr = keepOriginalPermission ? entry.header.fileAttr : undefined;
                            filetools.writeFileTo(entryName, content, overwrite, fileAttr);
                            try {
                                filetools.fs.utimesSync(entryName, entry.header.time, entry.header.time);
                            }
                            catch (err) {
                                throw new Error(Utils.Errors.CANT_EXTRACT_FILE);
                            }
                        });
                    },
                    /**
                     * Asynchronous extractAllTo
                     *
                     * @param targetPath Target location
                     * @param overwrite If the file already exists at the target path, the file will be overwriten if this is true.
                     *                  Default is FALSE
                     * @param keepOriginalPermission The file will be set as the permission from the entry if this is true.
                     *                  Default is FALSE
                     * @param callback The callback will be executed when all entries are extracted successfully or any error is thrown.
                     */
                    extractAllToAsync: function (/**String*/ targetPath, /**Boolean*/ overwrite, /**Boolean*/ keepOriginalPermission, /**Function*/ callback) {
                        overwrite = get_Bool(overwrite, false);
                        if (typeof keepOriginalPermission === "function" && !callback)
                            callback = keepOriginalPermission;
                        keepOriginalPermission = get_Bool(keepOriginalPermission, false);
                        if (!callback) {
                            callback = function (err) {
                                throw new Error(err);
                            };
                        }
                        if (!_zip) {
                            callback(new Error(Utils.Errors.NO_ZIP));
                            return;
                        }
                        targetPath = pth.resolve(targetPath);
                        // convert entryName to
                        const getPath = (entry) => sanitize(targetPath, pth.normalize(canonical(entry.entryName.toString())));
                        const getError = (msg, file) => new Error(msg + ': "' + file + '"');
                        // separate directories from files
                        const dirEntries = [];
                        const fileEntries = new Set();
                        _zip.entries.forEach((e) => {
                            if (e.isDirectory) {
                                dirEntries.push(e);
                            }
                            else {
                                fileEntries.add(e);
                            }
                        });
                        // Create directory entries first synchronously
                        // this prevents race condition and assures folders are there before writing files
                        for (const entry of dirEntries) {
                            const dirPath = getPath(entry);
                            // The reverse operation for attr depend on method addFile()
                            const dirAttr = keepOriginalPermission ? entry.header.fileAttr : undefined;
                            try {
                                filetools.makeDir(dirPath);
                                if (dirAttr)
                                    filetools.fs.chmodSync(dirPath, dirAttr);
                                // in unix timestamp will change if files are later added to folder, but still
                                filetools.fs.utimesSync(dirPath, entry.header.time, entry.header.time);
                            }
                            catch (er) {
                                callback(getError("Unable to create folder", dirPath));
                            }
                        }
                        // callback wrapper, for some house keeping
                        const done = () => {
                            if (fileEntries.size === 0) {
                                callback();
                            }
                        };
                        // Extract file entries asynchronously
                        for (const entry of fileEntries.values()) {
                            const entryName = pth.normalize(canonical(entry.entryName.toString()));
                            const filePath = sanitize(targetPath, entryName);
                            entry.getDataAsync(function (content, err_1) {
                                if (err_1) {
                                    callback(new Error(err_1));
                                    return;
                                }
                                if (!content) {
                                    callback(new Error(Utils.Errors.CANT_EXTRACT_FILE));
                                }
                                else {
                                    // The reverse operation for attr depend on method addFile()
                                    const fileAttr = keepOriginalPermission ? entry.header.fileAttr : undefined;
                                    filetools.writeFileToAsync(filePath, content, overwrite, fileAttr, function (succ) {
                                        if (!succ) {
                                            callback(getError("Unable to write file", filePath));
                                            return;
                                        }
                                        filetools.fs.utimes(filePath, entry.header.time, entry.header.time, function (err_2) {
                                            if (err_2) {
                                                callback(getError("Unable to set times", filePath));
                                                return;
                                            }
                                            fileEntries.delete(entry);
                                            // call the callback if it was last entry
                                            done();
                                        });
                                    });
                                }
                            });
                        }
                        // call the callback if fileEntries was empty
                        done();
                    },
                    /**
                     * Writes the newly created zip file to disk at the specified location or if a zip was opened and no ``targetFileName`` is provided, it will overwrite the opened zip
                     *
                     * @param targetFileName
                     * @param callback
                     */
                    writeZip: function (/**String*/ targetFileName, /**Function*/ callback) {
                        if (arguments.length === 1) {
                            if (typeof targetFileName === "function") {
                                callback = targetFileName;
                                targetFileName = "";
                            }
                        }
                        if (!targetFileName && opts.filename) {
                            targetFileName = opts.filename;
                        }
                        if (!targetFileName)
                            return;
                        var zipData = _zip.compressToBuffer();
                        if (zipData) {
                            var ok = filetools.writeFileTo(targetFileName, zipData, true);
                            if (typeof callback === "function")
                                callback(!ok ? new Error("failed") : null, "");
                        }
                    },
                    writeZipPromise: function (/**String*/ targetFileName, /* object */ props) {
                        const { overwrite, perm } = Object.assign({ overwrite: true }, props);
                        return new Promise((resolve, reject) => {
                            // find file name
                            if (!targetFileName && opts.filename)
                                targetFileName = opts.filename;
                            if (!targetFileName)
                                reject("ADM-ZIP: ZIP File Name Missing");
                            this.toBufferPromise().then((zipData) => {
                                const ret = (done) => (done ? resolve(done) : reject("ADM-ZIP: Wasn't able to write zip file"));
                                filetools.writeFileToAsync(targetFileName, zipData, overwrite, perm, ret);
                            }, reject);
                        });
                    },
                    toBufferPromise: function () {
                        return new Promise((resolve, reject) => {
                            _zip.toAsyncBuffer(resolve, reject);
                        });
                    },
                    /**
                     * Returns the content of the entire zip file as a Buffer object
                     *
                     * @return Buffer
                     */
                    toBuffer: function (/**Function=*/ onSuccess, /**Function=*/ onFail, /**Function=*/ onItemStart, /**Function=*/ onItemEnd) {
                        this.valueOf = 2;
                        if (typeof onSuccess === "function") {
                            _zip.toAsyncBuffer(onSuccess, onFail, onItemStart, onItemEnd);
                            return null;
                        }
                        return _zip.compressToBuffer();
                    }
                };
            };
            /***/ 
        }),
        /***/ "./node_modules/adm-zip/headers/entryHeader.js": 
        /*!*****************************************************!*\
          !*** ./node_modules/adm-zip/headers/entryHeader.js ***!
          \*****************************************************/
        /***/ ((module, __unused_webpack_exports, __webpack_require__) => {
            var Utils = __webpack_require__(/*! ../util */ "./node_modules/adm-zip/util/index.js"), Constants = Utils.Constants;
            /* The central directory file header */
            module.exports = function () {
                var _verMade = 20, // v2.0
                _version = 10, // v1.0
                _flags = 0, _method = 0, _time = 0, _crc = 0, _compressedSize = 0, _size = 0, _fnameLen = 0, _extraLen = 0, _comLen = 0, _diskStart = 0, _inattr = 0, _attr = 0, _offset = 0;
                _verMade |= Utils.isWin ? 0x0a00 : 0x0300;
                // Set EFS flag since filename and comment fields are all by default encoded using UTF-8.
                // Without it file names may be corrupted for other apps when file names use unicode chars
                _flags |= Constants.FLG_EFS;
                var _dataHeader = {};
                function setTime(val) {
                    val = new Date(val);
                    _time =
                        (((val.getFullYear() - 1980) & 0x7f) << 25) | // b09-16 years from 1980
                            ((val.getMonth() + 1) << 21) | // b05-08 month
                            (val.getDate() << 16) | // b00-04 hour
                            // 2 bytes time
                            (val.getHours() << 11) | // b11-15 hour
                            (val.getMinutes() << 5) | // b05-10 minute
                            (val.getSeconds() >> 1); // b00-04 seconds divided by 2
                }
                setTime(+new Date());
                return {
                    get made() {
                        return _verMade;
                    },
                    set made(val) {
                        _verMade = val;
                    },
                    get version() {
                        return _version;
                    },
                    set version(val) {
                        _version = val;
                    },
                    get flags() {
                        return _flags;
                    },
                    set flags(val) {
                        _flags = val;
                    },
                    get method() {
                        return _method;
                    },
                    set method(val) {
                        switch (val) {
                            case Constants.STORED:
                                this.version = 10;
                            case Constants.DEFLATED:
                            default:
                                this.version = 20;
                        }
                        _method = val;
                    },
                    get time() {
                        return new Date(((_time >> 25) & 0x7f) + 1980, ((_time >> 21) & 0x0f) - 1, (_time >> 16) & 0x1f, (_time >> 11) & 0x1f, (_time >> 5) & 0x3f, (_time & 0x1f) << 1);
                    },
                    set time(val) {
                        setTime(val);
                    },
                    get crc() {
                        return _crc;
                    },
                    set crc(val) {
                        _crc = Math.max(0, val) >>> 0;
                    },
                    get compressedSize() {
                        return _compressedSize;
                    },
                    set compressedSize(val) {
                        _compressedSize = Math.max(0, val) >>> 0;
                    },
                    get size() {
                        return _size;
                    },
                    set size(val) {
                        _size = Math.max(0, val) >>> 0;
                    },
                    get fileNameLength() {
                        return _fnameLen;
                    },
                    set fileNameLength(val) {
                        _fnameLen = val;
                    },
                    get extraLength() {
                        return _extraLen;
                    },
                    set extraLength(val) {
                        _extraLen = val;
                    },
                    get commentLength() {
                        return _comLen;
                    },
                    set commentLength(val) {
                        _comLen = val;
                    },
                    get diskNumStart() {
                        return _diskStart;
                    },
                    set diskNumStart(val) {
                        _diskStart = Math.max(0, val) >>> 0;
                    },
                    get inAttr() {
                        return _inattr;
                    },
                    set inAttr(val) {
                        _inattr = Math.max(0, val) >>> 0;
                    },
                    get attr() {
                        return _attr;
                    },
                    set attr(val) {
                        _attr = Math.max(0, val) >>> 0;
                    },
                    // get Unix file permissions
                    get fileAttr() {
                        return _attr ? (((_attr >>> 0) | 0) >> 16) & 0xfff : 0;
                    },
                    get offset() {
                        return _offset;
                    },
                    set offset(val) {
                        _offset = Math.max(0, val) >>> 0;
                    },
                    get encripted() {
                        return (_flags & 1) === 1;
                    },
                    get entryHeaderSize() {
                        return Constants.CENHDR + _fnameLen + _extraLen + _comLen;
                    },
                    get realDataOffset() {
                        return _offset + Constants.LOCHDR + _dataHeader.fnameLen + _dataHeader.extraLen;
                    },
                    get dataHeader() {
                        return _dataHeader;
                    },
                    loadDataHeaderFromBinary: function (/*Buffer*/ input) {
                        var data = input.slice(_offset, _offset + Constants.LOCHDR);
                        // 30 bytes and should start with "PK\003\004"
                        if (data.readUInt32LE(0) !== Constants.LOCSIG) {
                            throw new Error(Utils.Errors.INVALID_LOC);
                        }
                        _dataHeader = {
                            // version needed to extract
                            version: data.readUInt16LE(Constants.LOCVER),
                            // general purpose bit flag
                            flags: data.readUInt16LE(Constants.LOCFLG),
                            // compression method
                            method: data.readUInt16LE(Constants.LOCHOW),
                            // modification time (2 bytes time, 2 bytes date)
                            time: data.readUInt32LE(Constants.LOCTIM),
                            // uncompressed file crc-32 value
                            crc: data.readUInt32LE(Constants.LOCCRC),
                            // compressed size
                            compressedSize: data.readUInt32LE(Constants.LOCSIZ),
                            // uncompressed size
                            size: data.readUInt32LE(Constants.LOCLEN),
                            // filename length
                            fnameLen: data.readUInt16LE(Constants.LOCNAM),
                            // extra field length
                            extraLen: data.readUInt16LE(Constants.LOCEXT)
                        };
                    },
                    loadFromBinary: function (/*Buffer*/ data) {
                        // data should be 46 bytes and start with "PK 01 02"
                        if (data.length !== Constants.CENHDR || data.readUInt32LE(0) !== Constants.CENSIG) {
                            throw new Error(Utils.Errors.INVALID_CEN);
                        }
                        // version made by
                        _verMade = data.readUInt16LE(Constants.CENVEM);
                        // version needed to extract
                        _version = data.readUInt16LE(Constants.CENVER);
                        // encrypt, decrypt flags
                        _flags = data.readUInt16LE(Constants.CENFLG);
                        // compression method
                        _method = data.readUInt16LE(Constants.CENHOW);
                        // modification time (2 bytes time, 2 bytes date)
                        _time = data.readUInt32LE(Constants.CENTIM);
                        // uncompressed file crc-32 value
                        _crc = data.readUInt32LE(Constants.CENCRC);
                        // compressed size
                        _compressedSize = data.readUInt32LE(Constants.CENSIZ);
                        // uncompressed size
                        _size = data.readUInt32LE(Constants.CENLEN);
                        // filename length
                        _fnameLen = data.readUInt16LE(Constants.CENNAM);
                        // extra field length
                        _extraLen = data.readUInt16LE(Constants.CENEXT);
                        // file comment length
                        _comLen = data.readUInt16LE(Constants.CENCOM);
                        // volume number start
                        _diskStart = data.readUInt16LE(Constants.CENDSK);
                        // internal file attributes
                        _inattr = data.readUInt16LE(Constants.CENATT);
                        // external file attributes
                        _attr = data.readUInt32LE(Constants.CENATX);
                        // LOC header offset
                        _offset = data.readUInt32LE(Constants.CENOFF);
                    },
                    dataHeaderToBinary: function () {
                        // LOC header size (30 bytes)
                        var data = Buffer.alloc(Constants.LOCHDR);
                        // "PK\003\004"
                        data.writeUInt32LE(Constants.LOCSIG, 0);
                        // version needed to extract
                        data.writeUInt16LE(_version, Constants.LOCVER);
                        // general purpose bit flag
                        data.writeUInt16LE(_flags, Constants.LOCFLG);
                        // compression method
                        data.writeUInt16LE(_method, Constants.LOCHOW);
                        // modification time (2 bytes time, 2 bytes date)
                        data.writeUInt32LE(_time, Constants.LOCTIM);
                        // uncompressed file crc-32 value
                        data.writeUInt32LE(_crc, Constants.LOCCRC);
                        // compressed size
                        data.writeUInt32LE(_compressedSize, Constants.LOCSIZ);
                        // uncompressed size
                        data.writeUInt32LE(_size, Constants.LOCLEN);
                        // filename length
                        data.writeUInt16LE(_fnameLen, Constants.LOCNAM);
                        // extra field length
                        data.writeUInt16LE(_extraLen, Constants.LOCEXT);
                        return data;
                    },
                    entryHeaderToBinary: function () {
                        // CEN header size (46 bytes)
                        var data = Buffer.alloc(Constants.CENHDR + _fnameLen + _extraLen + _comLen);
                        // "PK\001\002"
                        data.writeUInt32LE(Constants.CENSIG, 0);
                        // version made by
                        data.writeUInt16LE(_verMade, Constants.CENVEM);
                        // version needed to extract
                        data.writeUInt16LE(_version, Constants.CENVER);
                        // encrypt, decrypt flags
                        data.writeUInt16LE(_flags, Constants.CENFLG);
                        // compression method
                        data.writeUInt16LE(_method, Constants.CENHOW);
                        // modification time (2 bytes time, 2 bytes date)
                        data.writeUInt32LE(_time, Constants.CENTIM);
                        // uncompressed file crc-32 value
                        data.writeUInt32LE(_crc, Constants.CENCRC);
                        // compressed size
                        data.writeUInt32LE(_compressedSize, Constants.CENSIZ);
                        // uncompressed size
                        data.writeUInt32LE(_size, Constants.CENLEN);
                        // filename length
                        data.writeUInt16LE(_fnameLen, Constants.CENNAM);
                        // extra field length
                        data.writeUInt16LE(_extraLen, Constants.CENEXT);
                        // file comment length
                        data.writeUInt16LE(_comLen, Constants.CENCOM);
                        // volume number start
                        data.writeUInt16LE(_diskStart, Constants.CENDSK);
                        // internal file attributes
                        data.writeUInt16LE(_inattr, Constants.CENATT);
                        // external file attributes
                        data.writeUInt32LE(_attr, Constants.CENATX);
                        // LOC header offset
                        data.writeUInt32LE(_offset, Constants.CENOFF);
                        // fill all with
                        data.fill(0x00, Constants.CENHDR);
                        return data;
                    },
                    toJSON: function () {
                        const bytes = function (nr) {
                            return nr + " bytes";
                        };
                        return {
                            made: _verMade,
                            version: _version,
                            flags: _flags,
                            method: Utils.methodToString(_method),
                            time: this.time,
                            crc: "0x" + _crc.toString(16).toUpperCase(),
                            compressedSize: bytes(_compressedSize),
                            size: bytes(_size),
                            fileNameLength: bytes(_fnameLen),
                            extraLength: bytes(_extraLen),
                            commentLength: bytes(_comLen),
                            diskNumStart: _diskStart,
                            inAttr: _inattr,
                            attr: _attr,
                            offset: _offset,
                            entryHeaderSize: bytes(Constants.CENHDR + _fnameLen + _extraLen + _comLen)
                        };
                    },
                    toString: function () {
                        return JSON.stringify(this.toJSON(), null, "\t");
                    }
                };
            };
            /***/ 
        }),
        /***/ "./node_modules/adm-zip/headers/index.js": 
        /*!***********************************************!*\
          !*** ./node_modules/adm-zip/headers/index.js ***!
          \***********************************************/
        /***/ ((__unused_webpack_module, exports, __webpack_require__) => {
            exports.EntryHeader = __webpack_require__(/*! ./entryHeader */ "./node_modules/adm-zip/headers/entryHeader.js");
            exports.MainHeader = __webpack_require__(/*! ./mainHeader */ "./node_modules/adm-zip/headers/mainHeader.js");
            /***/ 
        }),
        /***/ "./node_modules/adm-zip/headers/mainHeader.js": 
        /*!****************************************************!*\
          !*** ./node_modules/adm-zip/headers/mainHeader.js ***!
          \****************************************************/
        /***/ ((module, __unused_webpack_exports, __webpack_require__) => {
            var Utils = __webpack_require__(/*! ../util */ "./node_modules/adm-zip/util/index.js"), Constants = Utils.Constants;
            /* The entries in the end of central directory */
            module.exports = function () {
                var _volumeEntries = 0, _totalEntries = 0, _size = 0, _offset = 0, _commentLength = 0;
                return {
                    get diskEntries() {
                        return _volumeEntries;
                    },
                    set diskEntries(/*Number*/ val) {
                        _volumeEntries = _totalEntries = val;
                    },
                    get totalEntries() {
                        return _totalEntries;
                    },
                    set totalEntries(/*Number*/ val) {
                        _totalEntries = _volumeEntries = val;
                    },
                    get size() {
                        return _size;
                    },
                    set size(/*Number*/ val) {
                        _size = val;
                    },
                    get offset() {
                        return _offset;
                    },
                    set offset(/*Number*/ val) {
                        _offset = val;
                    },
                    get commentLength() {
                        return _commentLength;
                    },
                    set commentLength(/*Number*/ val) {
                        _commentLength = val;
                    },
                    get mainHeaderSize() {
                        return Constants.ENDHDR + _commentLength;
                    },
                    loadFromBinary: function (/*Buffer*/ data) {
                        // data should be 22 bytes and start with "PK 05 06"
                        // or be 56+ bytes and start with "PK 06 06" for Zip64
                        if ((data.length !== Constants.ENDHDR || data.readUInt32LE(0) !== Constants.ENDSIG) &&
                            (data.length < Constants.ZIP64HDR || data.readUInt32LE(0) !== Constants.ZIP64SIG)) {
                            throw new Error(Utils.Errors.INVALID_END);
                        }
                        if (data.readUInt32LE(0) === Constants.ENDSIG) {
                            // number of entries on this volume
                            _volumeEntries = data.readUInt16LE(Constants.ENDSUB);
                            // total number of entries
                            _totalEntries = data.readUInt16LE(Constants.ENDTOT);
                            // central directory size in bytes
                            _size = data.readUInt32LE(Constants.ENDSIZ);
                            // offset of first CEN header
                            _offset = data.readUInt32LE(Constants.ENDOFF);
                            // zip file comment length
                            _commentLength = data.readUInt16LE(Constants.ENDCOM);
                        }
                        else {
                            // number of entries on this volume
                            _volumeEntries = Utils.readBigUInt64LE(data, Constants.ZIP64SUB);
                            // total number of entries
                            _totalEntries = Utils.readBigUInt64LE(data, Constants.ZIP64TOT);
                            // central directory size in bytes
                            _size = Utils.readBigUInt64LE(data, Constants.ZIP64SIZE);
                            // offset of first CEN header
                            _offset = Utils.readBigUInt64LE(data, Constants.ZIP64OFF);
                            _commentLength = 0;
                        }
                    },
                    toBinary: function () {
                        var b = Buffer.alloc(Constants.ENDHDR + _commentLength);
                        // "PK 05 06" signature
                        b.writeUInt32LE(Constants.ENDSIG, 0);
                        b.writeUInt32LE(0, 4);
                        // number of entries on this volume
                        b.writeUInt16LE(_volumeEntries, Constants.ENDSUB);
                        // total number of entries
                        b.writeUInt16LE(_totalEntries, Constants.ENDTOT);
                        // central directory size in bytes
                        b.writeUInt32LE(_size, Constants.ENDSIZ);
                        // offset of first CEN header
                        b.writeUInt32LE(_offset, Constants.ENDOFF);
                        // zip file comment length
                        b.writeUInt16LE(_commentLength, Constants.ENDCOM);
                        // fill comment memory with spaces so no garbage is left there
                        b.fill(" ", Constants.ENDHDR);
                        return b;
                    },
                    toJSON: function () {
                        // creates 0x0000 style output
                        const offset = function (nr, len) {
                            let offs = nr.toString(16).toUpperCase();
                            while (offs.length < len)
                                offs = "0" + offs;
                            return "0x" + offs;
                        };
                        return {
                            diskEntries: _volumeEntries,
                            totalEntries: _totalEntries,
                            size: _size + " bytes",
                            offset: offset(_offset, 4),
                            commentLength: _commentLength
                        };
                    },
                    toString: function () {
                        return JSON.stringify(this.toJSON(), null, "\t");
                    }
                };
            };
            // Misspelled 
            /***/ 
        }),
        /***/ "./node_modules/adm-zip/methods/deflater.js": 
        /*!**************************************************!*\
          !*** ./node_modules/adm-zip/methods/deflater.js ***!
          \**************************************************/
        /***/ ((module, __unused_webpack_exports, __webpack_require__) => {
            module.exports = function (/*Buffer*/ inbuf) {
                var zlib = __webpack_require__(/*! zlib */ "zlib");
                var opts = { chunkSize: (parseInt(inbuf.length / 1024) + 1) * 1024 };
                return {
                    deflate: function () {
                        return zlib.deflateRawSync(inbuf, opts);
                    },
                    deflateAsync: function (/*Function*/ callback) {
                        var tmp = zlib.createDeflateRaw(opts), parts = [], total = 0;
                        tmp.on("data", function (data) {
                            parts.push(data);
                            total += data.length;
                        });
                        tmp.on("end", function () {
                            var buf = Buffer.alloc(total), written = 0;
                            buf.fill(0);
                            for (var i = 0; i < parts.length; i++) {
                                var part = parts[i];
                                part.copy(buf, written);
                                written += part.length;
                            }
                            callback && callback(buf);
                        });
                        tmp.end(inbuf);
                    }
                };
            };
            /***/ 
        }),
        /***/ "./node_modules/adm-zip/methods/index.js": 
        /*!***********************************************!*\
          !*** ./node_modules/adm-zip/methods/index.js ***!
          \***********************************************/
        /***/ ((__unused_webpack_module, exports, __webpack_require__) => {
            exports.Deflater = __webpack_require__(/*! ./deflater */ "./node_modules/adm-zip/methods/deflater.js");
            exports.Inflater = __webpack_require__(/*! ./inflater */ "./node_modules/adm-zip/methods/inflater.js");
            exports.ZipCrypto = __webpack_require__(/*! ./zipcrypto */ "./node_modules/adm-zip/methods/zipcrypto.js");
            /***/ 
        }),
        /***/ "./node_modules/adm-zip/methods/inflater.js": 
        /*!**************************************************!*\
          !*** ./node_modules/adm-zip/methods/inflater.js ***!
          \**************************************************/
        /***/ ((module, __unused_webpack_exports, __webpack_require__) => {
            module.exports = function (/*Buffer*/ inbuf) {
                var zlib = __webpack_require__(/*! zlib */ "zlib");
                return {
                    inflate: function () {
                        return zlib.inflateRawSync(inbuf);
                    },
                    inflateAsync: function (/*Function*/ callback) {
                        var tmp = zlib.createInflateRaw(), parts = [], total = 0;
                        tmp.on("data", function (data) {
                            parts.push(data);
                            total += data.length;
                        });
                        tmp.on("end", function () {
                            var buf = Buffer.alloc(total), written = 0;
                            buf.fill(0);
                            for (var i = 0; i < parts.length; i++) {
                                var part = parts[i];
                                part.copy(buf, written);
                                written += part.length;
                            }
                            callback && callback(buf);
                        });
                        tmp.end(inbuf);
                    }
                };
            };
            /***/ 
        }),
        /***/ "./node_modules/adm-zip/methods/zipcrypto.js": 
        /*!***************************************************!*\
          !*** ./node_modules/adm-zip/methods/zipcrypto.js ***!
          \***************************************************/
        /***/ ((module, __unused_webpack_exports, __webpack_require__) => {
            "use strict";
            // node crypt, we use it for generate salt
            // eslint-disable-next-line node/no-unsupported-features/node-builtins
            const { randomFillSync } = __webpack_require__(/*! crypto */ "crypto");
            // generate CRC32 lookup table
            const crctable = new Uint32Array(256).map((t, crc) => {
                for (let j = 0; j < 8; j++) {
                    if (0 !== (crc & 1)) {
                        crc = (crc >>> 1) ^ 0xedb88320;
                    }
                    else {
                        crc >>>= 1;
                    }
                }
                return crc >>> 0;
            });
            // C-style uInt32 Multiply (discards higher bits, when JS multiply discards lower bits)
            const uMul = (a, b) => Math.imul(a, b) >>> 0;
            // crc32 byte single update (actually same function is part of utils.crc32 function :) )
            const crc32update = (pCrc32, bval) => {
                return crctable[(pCrc32 ^ bval) & 0xff] ^ (pCrc32 >>> 8);
            };
            // function for generating salt for encrytion header
            const genSalt = () => {
                if ("function" === typeof randomFillSync) {
                    return randomFillSync(Buffer.alloc(12));
                }
                else {
                    // fallback if function is not defined
                    return genSalt.node();
                }
            };
            // salt generation with node random function (mainly as fallback)
            genSalt.node = () => {
                const salt = Buffer.alloc(12);
                const len = salt.length;
                for (let i = 0; i < len; i++)
                    salt[i] = (Math.random() * 256) & 0xff;
                return salt;
            };
            // general config
            const config = {
                genSalt
            };
            // Class Initkeys handles same basic ops with keys
            function Initkeys(pw) {
                const pass = Buffer.isBuffer(pw) ? pw : Buffer.from(pw);
                this.keys = new Uint32Array([0x12345678, 0x23456789, 0x34567890]);
                for (let i = 0; i < pass.length; i++) {
                    this.updateKeys(pass[i]);
                }
            }
            Initkeys.prototype.updateKeys = function (byteValue) {
                const keys = this.keys;
                keys[0] = crc32update(keys[0], byteValue);
                keys[1] += keys[0] & 0xff;
                keys[1] = uMul(keys[1], 134775813) + 1;
                keys[2] = crc32update(keys[2], keys[1] >>> 24);
                return byteValue;
            };
            Initkeys.prototype.next = function () {
                const k = (this.keys[2] | 2) >>> 0; // key
                return (uMul(k, k ^ 1) >> 8) & 0xff; // decode
            };
            function make_decrypter(/*Buffer*/ pwd) {
                // 1. Stage initialize key
                const keys = new Initkeys(pwd);
                // return decrypter function
                return function (/*Buffer*/ data) {
                    // result - we create new Buffer for results
                    const result = Buffer.alloc(data.length);
                    let pos = 0;
                    // process input data
                    for (let c of data) {
                        //c ^= keys.next();
                        //result[pos++] = c; // decode & Save Value
                        result[pos++] = keys.updateKeys(c ^ keys.next()); // update keys with decoded byte
                    }
                    return result;
                };
            }
            function make_encrypter(/*Buffer*/ pwd) {
                // 1. Stage initialize key
                const keys = new Initkeys(pwd);
                // return encrypting function, result and pos is here so we dont have to merge buffers later
                return function (/*Buffer*/ data, /*Buffer*/ result, /* Number */ pos = 0) {
                    // result - we create new Buffer for results
                    if (!result)
                        result = Buffer.alloc(data.length);
                    // process input data
                    for (let c of data) {
                        const k = keys.next(); // save key byte
                        result[pos++] = c ^ k; // save val
                        keys.updateKeys(c); // update keys with decoded byte
                    }
                    return result;
                };
            }
            function decrypt(/*Buffer*/ data, /*Object*/ header, /*String, Buffer*/ pwd) {
                if (!data || !Buffer.isBuffer(data) || data.length < 12) {
                    return Buffer.alloc(0);
                }
                // 1. We Initialize and generate decrypting function
                const decrypter = make_decrypter(pwd);
                // 2. decrypt salt what is always 12 bytes and is a part of file content
                const salt = decrypter(data.slice(0, 12));
                // 3. does password meet expectations
                if (salt[11] !== header.crc >>> 24) {
                    throw "ADM-ZIP: Wrong Password";
                }
                // 4. decode content
                return decrypter(data.slice(12));
            }
            // lets add way to populate salt, NOT RECOMMENDED for production but maybe useful for testing general functionality
            function _salter(data) {
                if (Buffer.isBuffer(data) && data.length >= 12) {
                    // be aware - currently salting buffer data is modified
                    config.genSalt = function () {
                        return data.slice(0, 12);
                    };
                }
                else if (data === "node") {
                    // test salt generation with node random function
                    config.genSalt = genSalt.node;
                }
                else {
                    // if value is not acceptable config gets reset.
                    config.genSalt = genSalt;
                }
            }
            function encrypt(/*Buffer*/ data, /*Object*/ header, /*String, Buffer*/ pwd, /*Boolean*/ oldlike = false) {
                // 1. test data if data is not Buffer we make buffer from it
                if (data == null)
                    data = Buffer.alloc(0);
                // if data is not buffer be make buffer from it
                if (!Buffer.isBuffer(data))
                    data = Buffer.from(data.toString());
                // 2. We Initialize and generate encrypting function
                const encrypter = make_encrypter(pwd);
                // 3. generate salt (12-bytes of random data)
                const salt = config.genSalt();
                salt[11] = (header.crc >>> 24) & 0xff;
                // old implementations (before PKZip 2.04g) used two byte check
                if (oldlike)
                    salt[10] = (header.crc >>> 16) & 0xff;
                // 4. create output
                const result = Buffer.alloc(data.length + 12);
                encrypter(salt, result);
                // finally encode content
                return encrypter(data, result, 12);
            }
            module.exports = { decrypt, encrypt, _salter };
            /***/ 
        }),
        /***/ "./node_modules/adm-zip/util/constants.js": 
        /*!************************************************!*\
          !*** ./node_modules/adm-zip/util/constants.js ***!
          \************************************************/
        /***/ ((module) => {
            module.exports = {
                /* The local file header */
                LOCHDR: 30,
                LOCSIG: 0x04034b50,
                LOCVER: 4,
                LOCFLG: 6,
                LOCHOW: 8,
                LOCTIM: 10,
                LOCCRC: 14,
                LOCSIZ: 18,
                LOCLEN: 22,
                LOCNAM: 26,
                LOCEXT: 28,
                /* The Data descriptor */
                EXTSIG: 0x08074b50,
                EXTHDR: 16,
                EXTCRC: 4,
                EXTSIZ: 8,
                EXTLEN: 12,
                /* The central directory file header */
                CENHDR: 46,
                CENSIG: 0x02014b50,
                CENVEM: 4,
                CENVER: 6,
                CENFLG: 8,
                CENHOW: 10,
                CENTIM: 12,
                CENCRC: 16,
                CENSIZ: 20,
                CENLEN: 24,
                CENNAM: 28,
                CENEXT: 30,
                CENCOM: 32,
                CENDSK: 34,
                CENATT: 36,
                CENATX: 38,
                CENOFF: 42,
                /* The entries in the end of central directory */
                ENDHDR: 22,
                ENDSIG: 0x06054b50,
                ENDSUB: 8,
                ENDTOT: 10,
                ENDSIZ: 12,
                ENDOFF: 16,
                ENDCOM: 20,
                END64HDR: 20,
                END64SIG: 0x07064b50,
                END64START: 4,
                END64OFF: 8,
                END64NUMDISKS: 16,
                ZIP64SIG: 0x06064b50,
                ZIP64HDR: 56,
                ZIP64LEAD: 12,
                ZIP64SIZE: 4,
                ZIP64VEM: 12,
                ZIP64VER: 14,
                ZIP64DSK: 16,
                ZIP64DSKDIR: 20,
                ZIP64SUB: 24,
                ZIP64TOT: 32,
                ZIP64SIZB: 40,
                ZIP64OFF: 48,
                ZIP64EXTRA: 56,
                /* Compression methods */
                STORED: 0,
                SHRUNK: 1,
                REDUCED1: 2,
                REDUCED2: 3,
                REDUCED3: 4,
                REDUCED4: 5,
                IMPLODED: 6,
                // 7 reserved for Tokenizing compression algorithm
                DEFLATED: 8,
                ENHANCED_DEFLATED: 9,
                PKWARE: 10,
                // 11 reserved by PKWARE
                BZIP2: 12,
                // 13 reserved by PKWARE
                LZMA: 14,
                // 15-17 reserved by PKWARE
                IBM_TERSE: 18,
                IBM_LZ77: 19,
                AES_ENCRYPT: 99,
                /* General purpose bit flag */
                // values can obtained with expression 2**bitnr
                FLG_ENC: 1,
                FLG_COMP1: 2,
                FLG_COMP2: 4,
                FLG_DESC: 8,
                FLG_ENH: 16,
                FLG_PATCH: 32,
                FLG_STR: 64,
                // Bits 7-10: Currently unused.
                FLG_EFS: 2048,
                // Bit 12: Reserved by PKWARE for enhanced compression.
                // Bit 13: encrypted the Central Directory (patented).
                // Bits 14-15: Reserved by PKWARE.
                FLG_MSK: 4096,
                /* Load type */
                FILE: 2,
                BUFFER: 1,
                NONE: 0,
                /* 4.5 Extensible data fields */
                EF_ID: 0,
                EF_SIZE: 2,
                /* Header IDs */
                ID_ZIP64: 0x0001,
                ID_AVINFO: 0x0007,
                ID_PFS: 0x0008,
                ID_OS2: 0x0009,
                ID_NTFS: 0x000a,
                ID_OPENVMS: 0x000c,
                ID_UNIX: 0x000d,
                ID_FORK: 0x000e,
                ID_PATCH: 0x000f,
                ID_X509_PKCS7: 0x0014,
                ID_X509_CERTID_F: 0x0015,
                ID_X509_CERTID_C: 0x0016,
                ID_STRONGENC: 0x0017,
                ID_RECORD_MGT: 0x0018,
                ID_X509_PKCS7_RL: 0x0019,
                ID_IBM1: 0x0065,
                ID_IBM2: 0x0066,
                ID_POSZIP: 0x4690,
                EF_ZIP64_OR_32: 0xffffffff,
                EF_ZIP64_OR_16: 0xffff,
                EF_ZIP64_SUNCOMP: 0,
                EF_ZIP64_SCOMP: 8,
                EF_ZIP64_RHO: 16,
                EF_ZIP64_DSN: 24
            };
            /***/ 
        }),
        /***/ "./node_modules/adm-zip/util/errors.js": 
        /*!*********************************************!*\
          !*** ./node_modules/adm-zip/util/errors.js ***!
          \*********************************************/
        /***/ ((module) => {
            module.exports = {
                /* Header error messages */
                INVALID_LOC: "Invalid LOC header (bad signature)",
                INVALID_CEN: "Invalid CEN header (bad signature)",
                INVALID_END: "Invalid END header (bad signature)",
                /* ZipEntry error messages*/
                NO_DATA: "Nothing to decompress",
                BAD_CRC: "CRC32 checksum failed",
                FILE_IN_THE_WAY: "There is a file in the way: %s",
                UNKNOWN_METHOD: "Invalid/unsupported compression method",
                /* Inflater error messages */
                AVAIL_DATA: "inflate::Available inflate data did not terminate",
                INVALID_DISTANCE: "inflate::Invalid literal/length or distance code in fixed or dynamic block",
                TO_MANY_CODES: "inflate::Dynamic block code description: too many length or distance codes",
                INVALID_REPEAT_LEN: "inflate::Dynamic block code description: repeat more than specified lengths",
                INVALID_REPEAT_FIRST: "inflate::Dynamic block code description: repeat lengths with no first length",
                INCOMPLETE_CODES: "inflate::Dynamic block code description: code lengths codes incomplete",
                INVALID_DYN_DISTANCE: "inflate::Dynamic block code description: invalid distance code lengths",
                INVALID_CODES_LEN: "inflate::Dynamic block code description: invalid literal/length code lengths",
                INVALID_STORE_BLOCK: "inflate::Stored block length did not match one's complement",
                INVALID_BLOCK_TYPE: "inflate::Invalid block type (type == 3)",
                /* ADM-ZIP error messages */
                CANT_EXTRACT_FILE: "Could not extract the file",
                CANT_OVERRIDE: "Target file already exists",
                NO_ZIP: "No zip file was loaded",
                NO_ENTRY: "Entry doesn't exist",
                DIRECTORY_CONTENT_ERROR: "A directory cannot have content",
                FILE_NOT_FOUND: "File not found: %s",
                NOT_IMPLEMENTED: "Not implemented",
                INVALID_FILENAME: "Invalid filename",
                INVALID_FORMAT: "Invalid or unsupported zip format. No END header found"
            };
            /***/ 
        }),
        /***/ "./node_modules/adm-zip/util/fattr.js": 
        /*!********************************************!*\
          !*** ./node_modules/adm-zip/util/fattr.js ***!
          \********************************************/
        /***/ ((module, __unused_webpack_exports, __webpack_require__) => {
            const fs = (__webpack_require__(/*! ./fileSystem */ "./node_modules/adm-zip/util/fileSystem.js").require)();
            const pth = __webpack_require__(/*! path */ "path");
            fs.existsSync = fs.existsSync || pth.existsSync;
            module.exports = function (/*String*/ path) {
                var _path = path || "", _obj = newAttr(), _stat = null;
                function newAttr() {
                    return {
                        directory: false,
                        readonly: false,
                        hidden: false,
                        executable: false,
                        mtime: 0,
                        atime: 0
                    };
                }
                if (_path && fs.existsSync(_path)) {
                    _stat = fs.statSync(_path);
                    _obj.directory = _stat.isDirectory();
                    _obj.mtime = _stat.mtime;
                    _obj.atime = _stat.atime;
                    _obj.executable = (0o111 & _stat.mode) !== 0; // file is executable who ever har right not just owner
                    _obj.readonly = (0o200 & _stat.mode) === 0; // readonly if owner has no write right
                    _obj.hidden = pth.basename(_path)[0] === ".";
                }
                else {
                    console.warn("Invalid path: " + _path);
                }
                return {
                    get directory() {
                        return _obj.directory;
                    },
                    get readOnly() {
                        return _obj.readonly;
                    },
                    get hidden() {
                        return _obj.hidden;
                    },
                    get mtime() {
                        return _obj.mtime;
                    },
                    get atime() {
                        return _obj.atime;
                    },
                    get executable() {
                        return _obj.executable;
                    },
                    decodeAttributes: function () { },
                    encodeAttributes: function () { },
                    toJSON: function () {
                        return {
                            path: _path,
                            isDirectory: _obj.directory,
                            isReadOnly: _obj.readonly,
                            isHidden: _obj.hidden,
                            isExecutable: _obj.executable,
                            mTime: _obj.mtime,
                            aTime: _obj.atime
                        };
                    },
                    toString: function () {
                        return JSON.stringify(this.toJSON(), null, "\t");
                    }
                };
            };
            /***/ 
        }),
        /***/ "./node_modules/adm-zip/util/fileSystem.js": 
        /*!*************************************************!*\
          !*** ./node_modules/adm-zip/util/fileSystem.js ***!
          \*************************************************/
        /***/ ((__unused_webpack_module, exports, __webpack_require__) => {
            exports.require = function () {
                if (typeof process === "object" && process.versions && process.versions["electron"]) {
                    try {
                        const originalFs = __webpack_require__(Object(function webpackMissingModule() { var e = new Error("Cannot find module 'original-fs'"); e.code = 'MODULE_NOT_FOUND'; throw e; }()));
                        if (Object.keys(originalFs).length > 0) {
                            return originalFs;
                        }
                    }
                    catch (e) { }
                }
                return __webpack_require__(/*! fs */ "fs");
            };
            /***/ 
        }),
        /***/ "./node_modules/adm-zip/util/index.js": 
        /*!********************************************!*\
          !*** ./node_modules/adm-zip/util/index.js ***!
          \********************************************/
        /***/ ((module, __unused_webpack_exports, __webpack_require__) => {
            module.exports = __webpack_require__(/*! ./utils */ "./node_modules/adm-zip/util/utils.js");
            module.exports.Constants = __webpack_require__(/*! ./constants */ "./node_modules/adm-zip/util/constants.js");
            module.exports.Errors = __webpack_require__(/*! ./errors */ "./node_modules/adm-zip/util/errors.js");
            module.exports.FileAttr = __webpack_require__(/*! ./fattr */ "./node_modules/adm-zip/util/fattr.js");
            /***/ 
        }),
        /***/ "./node_modules/adm-zip/util/utils.js": 
        /*!********************************************!*\
          !*** ./node_modules/adm-zip/util/utils.js ***!
          \********************************************/
        /***/ ((module, __unused_webpack_exports, __webpack_require__) => {
            const fsystem = (__webpack_require__(/*! ./fileSystem */ "./node_modules/adm-zip/util/fileSystem.js").require)();
            const pth = __webpack_require__(/*! path */ "path");
            const Constants = __webpack_require__(/*! ./constants */ "./node_modules/adm-zip/util/constants.js");
            const Errors = __webpack_require__(/*! ./errors */ "./node_modules/adm-zip/util/errors.js");
            const isWin = typeof process === "object" && "win32" === process.platform;
            const is_Obj = (obj) => obj && typeof obj === "object";
            // generate CRC32 lookup table
            const crcTable = new Uint32Array(256).map((t, c) => {
                for (let k = 0; k < 8; k++) {
                    if ((c & 1) !== 0) {
                        c = 0xedb88320 ^ (c >>> 1);
                    }
                    else {
                        c >>>= 1;
                    }
                }
                return c >>> 0;
            });
            // UTILS functions
            function Utils(opts) {
                this.sep = pth.sep;
                this.fs = fsystem;
                if (is_Obj(opts)) {
                    // custom filesystem
                    if (is_Obj(opts.fs) && typeof opts.fs.statSync === "function") {
                        this.fs = opts.fs;
                    }
                }
            }
            module.exports = Utils;
            // INSTANCED functions
            Utils.prototype.makeDir = function (/*String*/ folder) {
                const self = this;
                // Sync - make directories tree
                function mkdirSync(/*String*/ fpath) {
                    let resolvedPath = fpath.split(self.sep)[0];
                    fpath.split(self.sep).forEach(function (name) {
                        if (!name || name.substr(-1, 1) === ":")
                            return;
                        resolvedPath += self.sep + name;
                        var stat;
                        try {
                            stat = self.fs.statSync(resolvedPath);
                        }
                        catch (e) {
                            self.fs.mkdirSync(resolvedPath);
                        }
                        if (stat && stat.isFile())
                            throw Errors.FILE_IN_THE_WAY.replace("%s", resolvedPath);
                    });
                }
                mkdirSync(folder);
            };
            Utils.prototype.writeFileTo = function (/*String*/ path, /*Buffer*/ content, /*Boolean*/ overwrite, /*Number*/ attr) {
                const self = this;
                if (self.fs.existsSync(path)) {
                    if (!overwrite)
                        return false; // cannot overwrite
                    var stat = self.fs.statSync(path);
                    if (stat.isDirectory()) {
                        return false;
                    }
                }
                var folder = pth.dirname(path);
                if (!self.fs.existsSync(folder)) {
                    self.makeDir(folder);
                }
                var fd;
                try {
                    fd = self.fs.openSync(path, "w", 438); // 0666
                }
                catch (e) {
                    self.fs.chmodSync(path, 438);
                    fd = self.fs.openSync(path, "w", 438);
                }
                if (fd) {
                    try {
                        self.fs.writeSync(fd, content, 0, content.length, 0);
                    }
                    finally {
                        self.fs.closeSync(fd);
                    }
                }
                self.fs.chmodSync(path, attr || 438);
                return true;
            };
            Utils.prototype.writeFileToAsync = function (/*String*/ path, /*Buffer*/ content, /*Boolean*/ overwrite, /*Number*/ attr, /*Function*/ callback) {
                if (typeof attr === "function") {
                    callback = attr;
                    attr = undefined;
                }
                const self = this;
                self.fs.exists(path, function (exist) {
                    if (exist && !overwrite)
                        return callback(false);
                    self.fs.stat(path, function (err, stat) {
                        if (exist && stat.isDirectory()) {
                            return callback(false);
                        }
                        var folder = pth.dirname(path);
                        self.fs.exists(folder, function (exists) {
                            if (!exists)
                                self.makeDir(folder);
                            self.fs.open(path, "w", 438, function (err, fd) {
                                if (err) {
                                    self.fs.chmod(path, 438, function () {
                                        self.fs.open(path, "w", 438, function (err, fd) {
                                            self.fs.write(fd, content, 0, content.length, 0, function () {
                                                self.fs.close(fd, function () {
                                                    self.fs.chmod(path, attr || 438, function () {
                                                        callback(true);
                                                    });
                                                });
                                            });
                                        });
                                    });
                                }
                                else if (fd) {
                                    self.fs.write(fd, content, 0, content.length, 0, function () {
                                        self.fs.close(fd, function () {
                                            self.fs.chmod(path, attr || 438, function () {
                                                callback(true);
                                            });
                                        });
                                    });
                                }
                                else {
                                    self.fs.chmod(path, attr || 438, function () {
                                        callback(true);
                                    });
                                }
                            });
                        });
                    });
                });
            };
            Utils.prototype.findFiles = function (/*String*/ path) {
                const self = this;
                function findSync(/*String*/ dir, /*RegExp*/ pattern, /*Boolean*/ recursive) {
                    if (typeof pattern === "boolean") {
                        recursive = pattern;
                        pattern = undefined;
                    }
                    let files = [];
                    self.fs.readdirSync(dir).forEach(function (file) {
                        var path = pth.join(dir, file);
                        if (self.fs.statSync(path).isDirectory() && recursive)
                            files = files.concat(findSync(path, pattern, recursive));
                        if (!pattern || pattern.test(path)) {
                            files.push(pth.normalize(path) + (self.fs.statSync(path).isDirectory() ? self.sep : ""));
                        }
                    });
                    return files;
                }
                return findSync(path, undefined, true);
            };
            Utils.prototype.getAttributes = function () { };
            Utils.prototype.setAttributes = function () { };
            // STATIC functions
            // crc32 single update (it is part of crc32)
            Utils.crc32update = function (crc, byte) {
                return crcTable[(crc ^ byte) & 0xff] ^ (crc >>> 8);
            };
            Utils.crc32 = function (buf) {
                if (typeof buf === "string") {
                    buf = Buffer.from(buf, "utf8");
                }
                // Generate crcTable
                if (!crcTable.length)
                    genCRCTable();
                let len = buf.length;
                let crc = ~0;
                for (let off = 0; off < len;)
                    crc = Utils.crc32update(crc, buf[off++]);
                // xor and cast as uint32 number
                return ~crc >>> 0;
            };
            Utils.methodToString = function (/*Number*/ method) {
                switch (method) {
                    case Constants.STORED:
                        return "STORED (" + method + ")";
                    case Constants.DEFLATED:
                        return "DEFLATED (" + method + ")";
                    default:
                        return "UNSUPPORTED (" + method + ")";
                }
            };
            // removes ".." style path elements
            Utils.canonical = function (/*string*/ path) {
                if (!path)
                    return "";
                // trick normalize think path is absolute
                var safeSuffix = pth.posix.normalize("/" + path.split("\\").join("/"));
                return pth.join(".", safeSuffix);
            };
            // make abolute paths taking prefix as root folder
            Utils.sanitize = function (/*string*/ prefix, /*string*/ name) {
                prefix = pth.resolve(pth.normalize(prefix));
                var parts = name.split("/");
                for (var i = 0, l = parts.length; i < l; i++) {
                    var path = pth.normalize(pth.join(prefix, parts.slice(i, l).join(pth.sep)));
                    if (path.indexOf(prefix) === 0) {
                        return path;
                    }
                }
                return pth.normalize(pth.join(prefix, pth.basename(name)));
            };
            // converts buffer, Uint8Array, string types to buffer
            Utils.toBuffer = function toBuffer(/*buffer, Uint8Array, string*/ input) {
                if (Buffer.isBuffer(input)) {
                    return input;
                }
                else if (input instanceof Uint8Array) {
                    return Buffer.from(input);
                }
                else {
                    // expect string all other values are invalid and return empty buffer
                    return typeof input === "string" ? Buffer.from(input, "utf8") : Buffer.alloc(0);
                }
            };
            Utils.readBigUInt64LE = function (/*Buffer*/ buffer, /*int*/ index) {
                var slice = Buffer.from(buffer.slice(index, index + 8));
                slice.swap64();
                return parseInt(`0x${slice.toString("hex")}`);
            };
            Utils.isWin = isWin; // Do we have windows system
            Utils.crcTable = crcTable;
            /***/ 
        }),
        /***/ "./node_modules/adm-zip/zipEntry.js": 
        /*!******************************************!*\
          !*** ./node_modules/adm-zip/zipEntry.js ***!
          \******************************************/
        /***/ ((module, __unused_webpack_exports, __webpack_require__) => {
            var Utils = __webpack_require__(/*! ./util */ "./node_modules/adm-zip/util/index.js"), Headers = __webpack_require__(/*! ./headers */ "./node_modules/adm-zip/headers/index.js"), Constants = Utils.Constants, Methods = __webpack_require__(/*! ./methods */ "./node_modules/adm-zip/methods/index.js");
            module.exports = function (/*Buffer*/ input) {
                var _entryHeader = new Headers.EntryHeader(), _entryName = Buffer.alloc(0), _comment = Buffer.alloc(0), _isDirectory = false, uncompressedData = null, _extra = Buffer.alloc(0);
                function getCompressedDataFromZip() {
                    if (!input || !Buffer.isBuffer(input)) {
                        return Buffer.alloc(0);
                    }
                    _entryHeader.loadDataHeaderFromBinary(input);
                    return input.slice(_entryHeader.realDataOffset, _entryHeader.realDataOffset + _entryHeader.compressedSize);
                }
                function crc32OK(data) {
                    // if bit 3 (0x08) of the general-purpose flags field is set, then the CRC-32 and file sizes are not known when the header is written
                    if ((_entryHeader.flags & 0x8) !== 0x8) {
                        if (Utils.crc32(data) !== _entryHeader.dataHeader.crc) {
                            return false;
                        }
                    }
                    else {
                        // @TODO: load and check data descriptor header
                        // The fields in the local header are filled with zero, and the CRC-32 and size are appended in a 12-byte structure
                        // (optionally preceded by a 4-byte signature) immediately after the compressed data:
                    }
                    return true;
                }
                function decompress(/*Boolean*/ async, /*Function*/ callback, /*String, Buffer*/ pass) {
                    if (typeof callback === "undefined" && typeof async === "string") {
                        pass = async;
                        async = void 0;
                    }
                    if (_isDirectory) {
                        if (async && callback) {
                            callback(Buffer.alloc(0), Utils.Errors.DIRECTORY_CONTENT_ERROR); //si added error.
                        }
                        return Buffer.alloc(0);
                    }
                    var compressedData = getCompressedDataFromZip();
                    if (compressedData.length === 0) {
                        // File is empty, nothing to decompress.
                        if (async && callback)
                            callback(compressedData);
                        return compressedData;
                    }
                    if (_entryHeader.encripted) {
                        if ("string" !== typeof pass && !Buffer.isBuffer(pass)) {
                            throw new Error("ADM-ZIP: Incompatible password parameter");
                        }
                        compressedData = Methods.ZipCrypto.decrypt(compressedData, _entryHeader, pass);
                    }
                    var data = Buffer.alloc(_entryHeader.size);
                    switch (_entryHeader.method) {
                        case Utils.Constants.STORED:
                            compressedData.copy(data);
                            if (!crc32OK(data)) {
                                if (async && callback)
                                    callback(data, Utils.Errors.BAD_CRC); //si added error
                                throw new Error(Utils.Errors.BAD_CRC);
                            }
                            else {
                                //si added otherwise did not seem to return data.
                                if (async && callback)
                                    callback(data);
                                return data;
                            }
                        case Utils.Constants.DEFLATED:
                            var inflater = new Methods.Inflater(compressedData);
                            if (!async) {
                                const result = inflater.inflate(data);
                                result.copy(data, 0);
                                if (!crc32OK(data)) {
                                    throw new Error(Utils.Errors.BAD_CRC + " " + _entryName.toString());
                                }
                                return data;
                            }
                            else {
                                inflater.inflateAsync(function (result) {
                                    result.copy(result, 0);
                                    if (callback) {
                                        if (!crc32OK(result)) {
                                            callback(result, Utils.Errors.BAD_CRC); //si added error
                                        }
                                        else {
                                            callback(result);
                                        }
                                    }
                                });
                            }
                            break;
                        default:
                            if (async && callback)
                                callback(Buffer.alloc(0), Utils.Errors.UNKNOWN_METHOD);
                            throw new Error(Utils.Errors.UNKNOWN_METHOD);
                    }
                }
                function compress(/*Boolean*/ async, /*Function*/ callback) {
                    if ((!uncompressedData || !uncompressedData.length) && Buffer.isBuffer(input)) {
                        // no data set or the data wasn't changed to require recompression
                        if (async && callback)
                            callback(getCompressedDataFromZip());
                        return getCompressedDataFromZip();
                    }
                    if (uncompressedData.length && !_isDirectory) {
                        var compressedData;
                        // Local file header
                        switch (_entryHeader.method) {
                            case Utils.Constants.STORED:
                                _entryHeader.compressedSize = _entryHeader.size;
                                compressedData = Buffer.alloc(uncompressedData.length);
                                uncompressedData.copy(compressedData);
                                if (async && callback)
                                    callback(compressedData);
                                return compressedData;
                            default:
                            case Utils.Constants.DEFLATED:
                                var deflater = new Methods.Deflater(uncompressedData);
                                if (!async) {
                                    var deflated = deflater.deflate();
                                    _entryHeader.compressedSize = deflated.length;
                                    return deflated;
                                }
                                else {
                                    deflater.deflateAsync(function (data) {
                                        compressedData = Buffer.alloc(data.length);
                                        _entryHeader.compressedSize = data.length;
                                        data.copy(compressedData);
                                        callback && callback(compressedData);
                                    });
                                }
                                deflater = null;
                                break;
                        }
                    }
                    else if (async && callback) {
                        callback(Buffer.alloc(0));
                    }
                    else {
                        return Buffer.alloc(0);
                    }
                }
                function readUInt64LE(buffer, offset) {
                    return (buffer.readUInt32LE(offset + 4) << 4) + buffer.readUInt32LE(offset);
                }
                function parseExtra(data) {
                    var offset = 0;
                    var signature, size, part;
                    while (offset < data.length) {
                        signature = data.readUInt16LE(offset);
                        offset += 2;
                        size = data.readUInt16LE(offset);
                        offset += 2;
                        part = data.slice(offset, offset + size);
                        offset += size;
                        if (Constants.ID_ZIP64 === signature) {
                            parseZip64ExtendedInformation(part);
                        }
                    }
                }
                //Override header field values with values from the ZIP64 extra field
                function parseZip64ExtendedInformation(data) {
                    var size, compressedSize, offset, diskNumStart;
                    if (data.length >= Constants.EF_ZIP64_SCOMP) {
                        size = readUInt64LE(data, Constants.EF_ZIP64_SUNCOMP);
                        if (_entryHeader.size === Constants.EF_ZIP64_OR_32) {
                            _entryHeader.size = size;
                        }
                    }
                    if (data.length >= Constants.EF_ZIP64_RHO) {
                        compressedSize = readUInt64LE(data, Constants.EF_ZIP64_SCOMP);
                        if (_entryHeader.compressedSize === Constants.EF_ZIP64_OR_32) {
                            _entryHeader.compressedSize = compressedSize;
                        }
                    }
                    if (data.length >= Constants.EF_ZIP64_DSN) {
                        offset = readUInt64LE(data, Constants.EF_ZIP64_RHO);
                        if (_entryHeader.offset === Constants.EF_ZIP64_OR_32) {
                            _entryHeader.offset = offset;
                        }
                    }
                    if (data.length >= Constants.EF_ZIP64_DSN + 4) {
                        diskNumStart = data.readUInt32LE(Constants.EF_ZIP64_DSN);
                        if (_entryHeader.diskNumStart === Constants.EF_ZIP64_OR_16) {
                            _entryHeader.diskNumStart = diskNumStart;
                        }
                    }
                }
                return {
                    get entryName() {
                        return _entryName.toString();
                    },
                    get rawEntryName() {
                        return _entryName;
                    },
                    set entryName(val) {
                        _entryName = Utils.toBuffer(val);
                        var lastChar = _entryName[_entryName.length - 1];
                        _isDirectory = lastChar === 47 || lastChar === 92;
                        _entryHeader.fileNameLength = _entryName.length;
                    },
                    get extra() {
                        return _extra;
                    },
                    set extra(val) {
                        _extra = val;
                        _entryHeader.extraLength = val.length;
                        parseExtra(val);
                    },
                    get comment() {
                        return _comment.toString();
                    },
                    set comment(val) {
                        _comment = Utils.toBuffer(val);
                        _entryHeader.commentLength = _comment.length;
                    },
                    get name() {
                        var n = _entryName.toString();
                        return _isDirectory
                            ? n
                                .substr(n.length - 1)
                                .split("/")
                                .pop()
                            : n.split("/").pop();
                    },
                    get isDirectory() {
                        return _isDirectory;
                    },
                    getCompressedData: function () {
                        return compress(false, null);
                    },
                    getCompressedDataAsync: function (/*Function*/ callback) {
                        compress(true, callback);
                    },
                    setData: function (value) {
                        uncompressedData = Utils.toBuffer(value);
                        if (!_isDirectory && uncompressedData.length) {
                            _entryHeader.size = uncompressedData.length;
                            _entryHeader.method = Utils.Constants.DEFLATED;
                            _entryHeader.crc = Utils.crc32(value);
                            _entryHeader.changed = true;
                        }
                        else {
                            // folders and blank files should be stored
                            _entryHeader.method = Utils.Constants.STORED;
                        }
                    },
                    getData: function (pass) {
                        if (_entryHeader.changed) {
                            return uncompressedData;
                        }
                        else {
                            return decompress(false, null, pass);
                        }
                    },
                    getDataAsync: function (/*Function*/ callback, pass) {
                        if (_entryHeader.changed) {
                            callback(uncompressedData);
                        }
                        else {
                            decompress(true, callback, pass);
                        }
                    },
                    set attr(attr) {
                        _entryHeader.attr = attr;
                    },
                    get attr() {
                        return _entryHeader.attr;
                    },
                    set header(/*Buffer*/ data) {
                        _entryHeader.loadFromBinary(data);
                    },
                    get header() {
                        return _entryHeader;
                    },
                    packHeader: function () {
                        // 1. create header (buffer)
                        var header = _entryHeader.entryHeaderToBinary();
                        var addpos = Utils.Constants.CENHDR;
                        // 2. add file name
                        _entryName.copy(header, addpos);
                        addpos += _entryName.length;
                        // 3. add extra data
                        if (_entryHeader.extraLength) {
                            _extra.copy(header, addpos);
                            addpos += _entryHeader.extraLength;
                        }
                        // 4. add file comment
                        if (_entryHeader.commentLength) {
                            _comment.copy(header, addpos);
                        }
                        return header;
                    },
                    toJSON: function () {
                        const bytes = function (nr) {
                            return "<" + ((nr && nr.length + " bytes buffer") || "null") + ">";
                        };
                        return {
                            entryName: this.entryName,
                            name: this.name,
                            comment: this.comment,
                            isDirectory: this.isDirectory,
                            header: _entryHeader.toJSON(),
                            compressedData: bytes(input),
                            data: bytes(uncompressedData)
                        };
                    },
                    toString: function () {
                        return JSON.stringify(this.toJSON(), null, "\t");
                    }
                };
            };
            /***/ 
        }),
        /***/ "./node_modules/adm-zip/zipFile.js": 
        /*!*****************************************!*\
          !*** ./node_modules/adm-zip/zipFile.js ***!
          \*****************************************/
        /***/ ((module, __unused_webpack_exports, __webpack_require__) => {
            const ZipEntry = __webpack_require__(/*! ./zipEntry */ "./node_modules/adm-zip/zipEntry.js");
            const Headers = __webpack_require__(/*! ./headers */ "./node_modules/adm-zip/headers/index.js");
            const Utils = __webpack_require__(/*! ./util */ "./node_modules/adm-zip/util/index.js");
            module.exports = function (/*Buffer|null*/ inBuffer, /** object */ options) {
                var entryList = [], entryTable = {}, _comment = Buffer.alloc(0), mainHeader = new Headers.MainHeader(), loadedEntries = false;
                // assign options
                const opts = Object.assign(Object.create(null), options);
                const { noSort } = opts;
                if (inBuffer) {
                    // is a memory buffer
                    readMainHeader(opts.readEntries);
                }
                else {
                    // none. is a new file
                    loadedEntries = true;
                }
                function iterateEntries(callback) {
                    const totalEntries = mainHeader.diskEntries; // total number of entries
                    let index = mainHeader.offset; // offset of first CEN header
                    for (let i = 0; i < totalEntries; i++) {
                        let tmp = index;
                        const entry = new ZipEntry(inBuffer);
                        entry.header = inBuffer.slice(tmp, (tmp += Utils.Constants.CENHDR));
                        entry.entryName = inBuffer.slice(tmp, (tmp += entry.header.fileNameLength));
                        index += entry.header.entryHeaderSize;
                        callback(entry);
                    }
                }
                function readEntries() {
                    loadedEntries = true;
                    entryTable = {};
                    entryList = new Array(mainHeader.diskEntries); // total number of entries
                    var index = mainHeader.offset; // offset of first CEN header
                    for (var i = 0; i < entryList.length; i++) {
                        var tmp = index, entry = new ZipEntry(inBuffer);
                        entry.header = inBuffer.slice(tmp, (tmp += Utils.Constants.CENHDR));
                        entry.entryName = inBuffer.slice(tmp, (tmp += entry.header.fileNameLength));
                        if (entry.header.extraLength) {
                            entry.extra = inBuffer.slice(tmp, (tmp += entry.header.extraLength));
                        }
                        if (entry.header.commentLength)
                            entry.comment = inBuffer.slice(tmp, tmp + entry.header.commentLength);
                        index += entry.header.entryHeaderSize;
                        entryList[i] = entry;
                        entryTable[entry.entryName] = entry;
                    }
                }
                function readMainHeader(/*Boolean*/ readNow) {
                    var i = inBuffer.length - Utils.Constants.ENDHDR, // END header size
                    max = Math.max(0, i - 0xffff), // 0xFFFF is the max zip file comment length
                    n = max, endStart = inBuffer.length, endOffset = -1, // Start offset of the END header
                    commentEnd = 0;
                    for (i; i >= n; i--) {
                        if (inBuffer[i] !== 0x50)
                            continue; // quick check that the byte is 'P'
                        if (inBuffer.readUInt32LE(i) === Utils.Constants.ENDSIG) {
                            // "PK\005\006"
                            endOffset = i;
                            commentEnd = i;
                            endStart = i + Utils.Constants.ENDHDR;
                            // We already found a regular signature, let's look just a bit further to check if there's any zip64 signature
                            n = i - Utils.Constants.END64HDR;
                            continue;
                        }
                        if (inBuffer.readUInt32LE(i) === Utils.Constants.END64SIG) {
                            // Found a zip64 signature, let's continue reading the whole zip64 record
                            n = max;
                            continue;
                        }
                        if (inBuffer.readUInt32LE(i) === Utils.Constants.ZIP64SIG) {
                            // Found the zip64 record, let's determine it's size
                            endOffset = i;
                            endStart = i + Utils.readBigUInt64LE(inBuffer, i + Utils.Constants.ZIP64SIZE) + Utils.Constants.ZIP64LEAD;
                            break;
                        }
                    }
                    if (!~endOffset)
                        throw new Error(Utils.Errors.INVALID_FORMAT);
                    mainHeader.loadFromBinary(inBuffer.slice(endOffset, endStart));
                    if (mainHeader.commentLength) {
                        _comment = inBuffer.slice(commentEnd + Utils.Constants.ENDHDR);
                    }
                    if (readNow)
                        readEntries();
                }
                function sortEntries() {
                    if (entryList.length > 1 && !noSort) {
                        entryList.sort((a, b) => a.entryName.toLowerCase().localeCompare(b.entryName.toLowerCase()));
                    }
                }
                return {
                    /**
                     * Returns an array of ZipEntry objects existent in the current opened archive
                     * @return Array
                     */
                    get entries() {
                        if (!loadedEntries) {
                            readEntries();
                        }
                        return entryList;
                    },
                    /**
                     * Archive comment
                     * @return {String}
                     */
                    get comment() {
                        return _comment.toString();
                    },
                    set comment(val) {
                        _comment = Utils.toBuffer(val);
                        mainHeader.commentLength = _comment.length;
                    },
                    getEntryCount: function () {
                        if (!loadedEntries) {
                            return mainHeader.diskEntries;
                        }
                        return entryList.length;
                    },
                    forEach: function (callback) {
                        if (!loadedEntries) {
                            iterateEntries(callback);
                            return;
                        }
                        entryList.forEach(callback);
                    },
                    /**
                     * Returns a reference to the entry with the given name or null if entry is inexistent
                     *
                     * @param entryName
                     * @return ZipEntry
                     */
                    getEntry: function (/*String*/ entryName) {
                        if (!loadedEntries) {
                            readEntries();
                        }
                        return entryTable[entryName] || null;
                    },
                    /**
                     * Adds the given entry to the entry list
                     *
                     * @param entry
                     */
                    setEntry: function (/*ZipEntry*/ entry) {
                        if (!loadedEntries) {
                            readEntries();
                        }
                        entryList.push(entry);
                        entryTable[entry.entryName] = entry;
                        mainHeader.totalEntries = entryList.length;
                    },
                    /**
                     * Removes the entry with the given name from the entry list.
                     *
                     * If the entry is a directory, then all nested files and directories will be removed
                     * @param entryName
                     */
                    deleteEntry: function (/*String*/ entryName) {
                        if (!loadedEntries) {
                            readEntries();
                        }
                        var entry = entryTable[entryName];
                        if (entry && entry.isDirectory) {
                            var _self = this;
                            this.getEntryChildren(entry).forEach(function (child) {
                                if (child.entryName !== entryName) {
                                    _self.deleteEntry(child.entryName);
                                }
                            });
                        }
                        entryList.splice(entryList.indexOf(entry), 1);
                        delete entryTable[entryName];
                        mainHeader.totalEntries = entryList.length;
                    },
                    /**
                     *  Iterates and returns all nested files and directories of the given entry
                     *
                     * @param entry
                     * @return Array
                     */
                    getEntryChildren: function (/*ZipEntry*/ entry) {
                        if (!loadedEntries) {
                            readEntries();
                        }
                        if (entry && entry.isDirectory) {
                            const list = [];
                            const name = entry.entryName;
                            const len = name.length;
                            entryList.forEach(function (zipEntry) {
                                if (zipEntry.entryName.substr(0, len) === name) {
                                    list.push(zipEntry);
                                }
                            });
                            return list;
                        }
                        return [];
                    },
                    /**
                     * Returns the zip file
                     *
                     * @return Buffer
                     */
                    compressToBuffer: function () {
                        if (!loadedEntries) {
                            readEntries();
                        }
                        sortEntries();
                        const dataBlock = [];
                        const entryHeaders = [];
                        let totalSize = 0;
                        let dindex = 0;
                        mainHeader.size = 0;
                        mainHeader.offset = 0;
                        for (const entry of entryList) {
                            // compress data and set local and entry header accordingly. Reason why is called first
                            const compressedData = entry.getCompressedData();
                            // 1. construct data header
                            entry.header.offset = dindex;
                            const dataHeader = entry.header.dataHeaderToBinary();
                            const entryNameLen = entry.rawEntryName.length;
                            // 1.2. postheader - data after data header
                            const postHeader = Buffer.alloc(entryNameLen + entry.extra.length);
                            entry.rawEntryName.copy(postHeader, 0);
                            postHeader.copy(entry.extra, entryNameLen);
                            // 2. offsets
                            const dataLength = dataHeader.length + postHeader.length + compressedData.length;
                            dindex += dataLength;
                            // 3. store values in sequence
                            dataBlock.push(dataHeader);
                            dataBlock.push(postHeader);
                            dataBlock.push(compressedData);
                            // 4. construct entry header
                            const entryHeader = entry.packHeader();
                            entryHeaders.push(entryHeader);
                            // 5. update main header
                            mainHeader.size += entryHeader.length;
                            totalSize += dataLength + entryHeader.length;
                        }
                        totalSize += mainHeader.mainHeaderSize; // also includes zip file comment length
                        // point to end of data and beginning of central directory first record
                        mainHeader.offset = dindex;
                        dindex = 0;
                        const outBuffer = Buffer.alloc(totalSize);
                        // write data blocks
                        for (const content of dataBlock) {
                            content.copy(outBuffer, dindex);
                            dindex += content.length;
                        }
                        // write central directory entries
                        for (const content of entryHeaders) {
                            content.copy(outBuffer, dindex);
                            dindex += content.length;
                        }
                        // write main header
                        const mh = mainHeader.toBinary();
                        if (_comment) {
                            _comment.copy(mh, Utils.Constants.ENDHDR); // add zip file comment
                        }
                        mh.copy(outBuffer, dindex);
                        return outBuffer;
                    },
                    toAsyncBuffer: function (/*Function*/ onSuccess, /*Function*/ onFail, /*Function*/ onItemStart, /*Function*/ onItemEnd) {
                        try {
                            if (!loadedEntries) {
                                readEntries();
                            }
                            sortEntries();
                            const dataBlock = [];
                            const entryHeaders = [];
                            let totalSize = 0;
                            let dindex = 0;
                            mainHeader.size = 0;
                            mainHeader.offset = 0;
                            const compress2Buffer = function (entryLists) {
                                if (entryLists.length) {
                                    const entry = entryLists.pop();
                                    const name = entry.entryName + entry.extra.toString();
                                    if (onItemStart)
                                        onItemStart(name);
                                    entry.getCompressedDataAsync(function (compressedData) {
                                        if (onItemEnd)
                                            onItemEnd(name);
                                        entry.header.offset = dindex;
                                        // data header
                                        const dataHeader = entry.header.dataHeaderToBinary();
                                        const postHeader = Buffer.alloc(name.length, name);
                                        const dataLength = dataHeader.length + postHeader.length + compressedData.length;
                                        dindex += dataLength;
                                        dataBlock.push(dataHeader);
                                        dataBlock.push(postHeader);
                                        dataBlock.push(compressedData);
                                        const entryHeader = entry.packHeader();
                                        entryHeaders.push(entryHeader);
                                        mainHeader.size += entryHeader.length;
                                        totalSize += dataLength + entryHeader.length;
                                        compress2Buffer(entryLists);
                                    });
                                }
                                else {
                                    totalSize += mainHeader.mainHeaderSize; // also includes zip file comment length
                                    // point to end of data and beginning of central directory first record
                                    mainHeader.offset = dindex;
                                    dindex = 0;
                                    const outBuffer = Buffer.alloc(totalSize);
                                    dataBlock.forEach(function (content) {
                                        content.copy(outBuffer, dindex); // write data blocks
                                        dindex += content.length;
                                    });
                                    entryHeaders.forEach(function (content) {
                                        content.copy(outBuffer, dindex); // write central directory entries
                                        dindex += content.length;
                                    });
                                    const mh = mainHeader.toBinary();
                                    if (_comment) {
                                        _comment.copy(mh, Utils.Constants.ENDHDR); // add zip file comment
                                    }
                                    mh.copy(outBuffer, dindex); // write main header
                                    onSuccess(outBuffer);
                                }
                            };
                            compress2Buffer(entryList);
                        }
                        catch (e) {
                            onFail(e);
                        }
                    }
                };
            };
            /***/ 
        }),
        /***/ "./node_modules/array-buffer-byte-length/index.js": 
        /*!********************************************************!*\
          !*** ./node_modules/array-buffer-byte-length/index.js ***!
          \********************************************************/
        /***/ ((module, __unused_webpack_exports, __webpack_require__) => {
            "use strict";
            var callBound = __webpack_require__(/*! call-bind/callBound */ "./node_modules/call-bind/callBound.js");
            var $byteLength = callBound('ArrayBuffer.prototype.byteLength', true);
            var isArrayBuffer = __webpack_require__(/*! is-array-buffer */ "./node_modules/is-array-buffer/index.js");
            module.exports = function byteLength(ab) {
                if (!isArrayBuffer(ab)) {
                    return NaN;
                }
                return $byteLength ? $byteLength(ab) : ab.byteLength;
            }; // in node < 0.11, byteLength is an own nonconfigurable property
            /***/ 
        }),
        /***/ "./node_modules/call-bind/callBound.js": 
        /*!*********************************************!*\
          !*** ./node_modules/call-bind/callBound.js ***!
          \*********************************************/
        /***/ ((module, __unused_webpack_exports, __webpack_require__) => {
            "use strict";
            var GetIntrinsic = __webpack_require__(/*! get-intrinsic */ "./node_modules/get-intrinsic/index.js");
            var callBind = __webpack_require__(/*! ./ */ "./node_modules/call-bind/index.js");
            var $indexOf = callBind(GetIntrinsic('String.prototype.indexOf'));
            module.exports = function callBoundIntrinsic(name, allowMissing) {
                var intrinsic = GetIntrinsic(name, !!allowMissing);
                if (typeof intrinsic === 'function' && $indexOf(name, '.prototype.') > -1) {
                    return callBind(intrinsic);
                }
                return intrinsic;
            };
            /***/ 
        }),
        /***/ "./node_modules/call-bind/index.js": 
        /*!*****************************************!*\
          !*** ./node_modules/call-bind/index.js ***!
          \*****************************************/
        /***/ ((module, __unused_webpack_exports, __webpack_require__) => {
            "use strict";
            var bind = __webpack_require__(/*! function-bind */ "./node_modules/function-bind/index.js");
            var GetIntrinsic = __webpack_require__(/*! get-intrinsic */ "./node_modules/get-intrinsic/index.js");
            var setFunctionLength = __webpack_require__(/*! set-function-length */ "./node_modules/set-function-length/index.js");
            var $TypeError = GetIntrinsic('%TypeError%');
            var $apply = GetIntrinsic('%Function.prototype.apply%');
            var $call = GetIntrinsic('%Function.prototype.call%');
            var $reflectApply = GetIntrinsic('%Reflect.apply%', true) || bind.call($call, $apply);
            var $defineProperty = GetIntrinsic('%Object.defineProperty%', true);
            var $max = GetIntrinsic('%Math.max%');
            if ($defineProperty) {
                try {
                    $defineProperty({}, 'a', { value: 1 });
                }
                catch (e) {
                    // IE 8 has a broken defineProperty
                    $defineProperty = null;
                }
            }
            module.exports = function callBind(originalFunction) {
                if (typeof originalFunction !== 'function') {
                    throw new $TypeError('a function is required');
                }
                var func = $reflectApply(bind, $call, arguments);
                return setFunctionLength(func, 1 + $max(0, originalFunction.length - (arguments.length - 1)), true);
            };
            var applyBind = function applyBind() {
                return $reflectApply(bind, $apply, arguments);
            };
            if ($defineProperty) {
                $defineProperty(module.exports, 'apply', { value: applyBind });
            }
            else {
                module.exports.apply = applyBind;
            }
            /***/ 
        }),
        /***/ "./node_modules/charenc/charenc.js": 
        /*!*****************************************!*\
          !*** ./node_modules/charenc/charenc.js ***!
          \*****************************************/
        /***/ ((module) => {
            var charenc = {
                // UTF-8 encoding
                utf8: {
                    // Convert a string to a byte array
                    stringToBytes: function (str) {
                        return charenc.bin.stringToBytes(unescape(encodeURIComponent(str)));
                    },
                    // Convert a byte array to a string
                    bytesToString: function (bytes) {
                        return decodeURIComponent(escape(charenc.bin.bytesToString(bytes)));
                    }
                },
                // Binary encoding
                bin: {
                    // Convert a string to a byte array
                    stringToBytes: function (str) {
                        for (var bytes = [], i = 0; i < str.length; i++)
                            bytes.push(str.charCodeAt(i) & 0xFF);
                        return bytes;
                    },
                    // Convert a byte array to a string
                    bytesToString: function (bytes) {
                        for (var str = [], i = 0; i < bytes.length; i++)
                            str.push(String.fromCharCode(bytes[i]));
                        return str.join('');
                    }
                }
            };
            module.exports = charenc;
            /***/ 
        }),
        /***/ "./node_modules/crypt/crypt.js": 
        /*!*************************************!*\
          !*** ./node_modules/crypt/crypt.js ***!
          \*************************************/
        /***/ ((module) => {
            (function () {
                var base64map = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/', crypt = {
                    // Bit-wise rotation left
                    rotl: function (n, b) {
                        return (n << b) | (n >>> (32 - b));
                    },
                    // Bit-wise rotation right
                    rotr: function (n, b) {
                        return (n << (32 - b)) | (n >>> b);
                    },
                    // Swap big-endian to little-endian and vice versa
                    endian: function (n) {
                        // If number given, swap endian
                        if (n.constructor == Number) {
                            return crypt.rotl(n, 8) & 0x00FF00FF | crypt.rotl(n, 24) & 0xFF00FF00;
                        }
                        // Else, assume array and swap all items
                        for (var i = 0; i < n.length; i++)
                            n[i] = crypt.endian(n[i]);
                        return n;
                    },
                    // Generate an array of any length of random bytes
                    randomBytes: function (n) {
                        for (var bytes = []; n > 0; n--)
                            bytes.push(Math.floor(Math.random() * 256));
                        return bytes;
                    },
                    // Convert a byte array to big-endian 32-bit words
                    bytesToWords: function (bytes) {
                        for (var words = [], i = 0, b = 0; i < bytes.length; i++, b += 8)
                            words[b >>> 5] |= bytes[i] << (24 - b % 32);
                        return words;
                    },
                    // Convert big-endian 32-bit words to a byte array
                    wordsToBytes: function (words) {
                        for (var bytes = [], b = 0; b < words.length * 32; b += 8)
                            bytes.push((words[b >>> 5] >>> (24 - b % 32)) & 0xFF);
                        return bytes;
                    },
                    // Convert a byte array to a hex string
                    bytesToHex: function (bytes) {
                        for (var hex = [], i = 0; i < bytes.length; i++) {
                            hex.push((bytes[i] >>> 4).toString(16));
                            hex.push((bytes[i] & 0xF).toString(16));
                        }
                        return hex.join('');
                    },
                    // Convert a hex string to a byte array
                    hexToBytes: function (hex) {
                        for (var bytes = [], c = 0; c < hex.length; c += 2)
                            bytes.push(parseInt(hex.substr(c, 2), 16));
                        return bytes;
                    },
                    // Convert a byte array to a base-64 string
                    bytesToBase64: function (bytes) {
                        for (var base64 = [], i = 0; i < bytes.length; i += 3) {
                            var triplet = (bytes[i] << 16) | (bytes[i + 1] << 8) | bytes[i + 2];
                            for (var j = 0; j < 4; j++)
                                if (i * 8 + j * 6 <= bytes.length * 8)
                                    base64.push(base64map.charAt((triplet >>> 6 * (3 - j)) & 0x3F));
                                else
                                    base64.push('=');
                        }
                        return base64.join('');
                    },
                    // Convert a base-64 string to a byte array
                    base64ToBytes: function (base64) {
                        // Remove non-base-64 characters
                        base64 = base64.replace(/[^A-Z0-9+\/]/ig, '');
                        for (var bytes = [], i = 0, imod4 = 0; i < base64.length; imod4 = ++i % 4) {
                            if (imod4 == 0)
                                continue;
                            bytes.push(((base64map.indexOf(base64.charAt(i - 1))
                                & (Math.pow(2, -2 * imod4 + 8) - 1)) << (imod4 * 2))
                                | (base64map.indexOf(base64.charAt(i)) >>> (6 - imod4 * 2)));
                        }
                        return bytes;
                    }
                };
                module.exports = crypt;
            })();
            /***/ 
        }),
        /***/ "./node_modules/csv-parse/lib/ResizeableBuffer.js": 
        /*!********************************************************!*\
          !*** ./node_modules/csv-parse/lib/ResizeableBuffer.js ***!
          \********************************************************/
        /***/ ((module) => {
            class ResizeableBuffer {
                constructor(size = 100) {
                    this.size = size;
                    this.length = 0;
                    this.buf = Buffer.alloc(size);
                }
                prepend(val) {
                    if (Buffer.isBuffer(val)) {
                        const length = this.length + val.length;
                        if (length >= this.size) {
                            this.resize();
                            if (length >= this.size) {
                                throw Error('INVALID_BUFFER_STATE');
                            }
                        }
                        const buf = this.buf;
                        this.buf = Buffer.alloc(this.size);
                        val.copy(this.buf, 0);
                        buf.copy(this.buf, val.length);
                        this.length += val.length;
                    }
                    else {
                        const length = this.length++;
                        if (length === this.size) {
                            this.resize();
                        }
                        const buf = this.clone();
                        this.buf[0] = val;
                        buf.copy(this.buf, 1, 0, length);
                    }
                }
                append(val) {
                    const length = this.length++;
                    if (length === this.size) {
                        this.resize();
                    }
                    this.buf[length] = val;
                }
                clone() {
                    return Buffer.from(this.buf.slice(0, this.length));
                }
                resize() {
                    const length = this.length;
                    this.size = this.size * 2;
                    const buf = Buffer.alloc(this.size);
                    this.buf.copy(buf, 0, 0, length);
                    this.buf = buf;
                }
                toString(encoding) {
                    if (encoding) {
                        return this.buf.slice(0, this.length).toString(encoding);
                    }
                    else {
                        return Uint8Array.prototype.slice.call(this.buf.slice(0, this.length));
                    }
                }
                toJSON() {
                    return this.toString('utf8');
                }
                reset() {
                    this.length = 0;
                }
            }
            module.exports = ResizeableBuffer;
            /***/ 
        }),
        /***/ "./node_modules/csv-parse/lib/index.js": 
        /*!*********************************************!*\
          !*** ./node_modules/csv-parse/lib/index.js ***!
          \*********************************************/
        /***/ ((module, __unused_webpack_exports, __webpack_require__) => {
            /*
            CSV Parse
            
            Please look at the [project documentation](https://csv.js.org/parse/) for
            additional information.
            */
            const { Transform } = __webpack_require__(/*! stream */ "stream");
            const ResizeableBuffer = __webpack_require__(/*! ./ResizeableBuffer */ "./node_modules/csv-parse/lib/ResizeableBuffer.js");
            // white space characters
            // https://en.wikipedia.org/wiki/Whitespace_character
            // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions/Character_Classes#Types
            // \f\n\r\t\v\u00a0\u1680\u2000-\u200a\u2028\u2029\u202f\u205f\u3000\ufeff
            const tab = 9;
            const nl = 10; // \n, 0x0A in hexadecimal, 10 in decimal
            const np = 12;
            const cr = 13; // \r, 0x0D in hexadcimal, 13 in decimal
            const space = 32;
            const boms = {
                // Note, the following are equals:
                // Buffer.from("\ufeff")
                // Buffer.from([239, 187, 191])
                // Buffer.from('EFBBBF', 'hex')
                'utf8': Buffer.from([239, 187, 191]),
                // Note, the following are equals:
                // Buffer.from "\ufeff", 'utf16le
                // Buffer.from([255, 254])
                'utf16le': Buffer.from([255, 254])
            };
            class Parser extends Transform {
                constructor(opts = {}) {
                    super({ ...{ readableObjectMode: true }, ...opts, encoding: null });
                    this.__originalOptions = opts;
                    this.__normalizeOptions(opts);
                }
                __normalizeOptions(opts) {
                    const options = {};
                    // Merge with user options
                    for (let opt in opts) {
                        options[underscore(opt)] = opts[opt];
                    }
                    // Normalize option `encoding`
                    // Note: defined first because other options depends on it
                    // to convert chars/strings into buffers.
                    if (options.encoding === undefined || options.encoding === true) {
                        options.encoding = 'utf8';
                    }
                    else if (options.encoding === null || options.encoding === false) {
                        options.encoding = null;
                    }
                    else if (typeof options.encoding !== 'string' && options.encoding !== null) {
                        throw new CsvError('CSV_INVALID_OPTION_ENCODING', [
                            'Invalid option encoding:',
                            'encoding must be a string or null to return a buffer,',
                            `got ${JSON.stringify(options.encoding)}`
                        ], options);
                    }
                    // Normalize option `bom`
                    if (options.bom === undefined || options.bom === null || options.bom === false) {
                        options.bom = false;
                    }
                    else if (options.bom !== true) {
                        throw new CsvError('CSV_INVALID_OPTION_BOM', [
                            'Invalid option bom:', 'bom must be true,',
                            `got ${JSON.stringify(options.bom)}`
                        ], options);
                    }
                    // Normalize option `cast`
                    let fnCastField = null;
                    if (options.cast === undefined || options.cast === null || options.cast === false || options.cast === '') {
                        options.cast = undefined;
                    }
                    else if (typeof options.cast === 'function') {
                        fnCastField = options.cast;
                        options.cast = true;
                    }
                    else if (options.cast !== true) {
                        throw new CsvError('CSV_INVALID_OPTION_CAST', [
                            'Invalid option cast:', 'cast must be true or a function,',
                            `got ${JSON.stringify(options.cast)}`
                        ], options);
                    }
                    // Normalize option `cast_date`
                    if (options.cast_date === undefined || options.cast_date === null || options.cast_date === false || options.cast_date === '') {
                        options.cast_date = false;
                    }
                    else if (options.cast_date === true) {
                        options.cast_date = function (value) {
                            const date = Date.parse(value);
                            return !isNaN(date) ? new Date(date) : value;
                        };
                    }
                    else {
                        throw new CsvError('CSV_INVALID_OPTION_CAST_DATE', [
                            'Invalid option cast_date:', 'cast_date must be true or a function,',
                            `got ${JSON.stringify(options.cast_date)}`
                        ], options);
                    }
                    // Normalize option `columns`
                    let fnFirstLineToHeaders = null;
                    if (options.columns === true) {
                        // Fields in the first line are converted as-is to columns
                        fnFirstLineToHeaders = undefined;
                    }
                    else if (typeof options.columns === 'function') {
                        fnFirstLineToHeaders = options.columns;
                        options.columns = true;
                    }
                    else if (Array.isArray(options.columns)) {
                        options.columns = normalizeColumnsArray(options.columns);
                    }
                    else if (options.columns === undefined || options.columns === null || options.columns === false) {
                        options.columns = false;
                    }
                    else {
                        throw new CsvError('CSV_INVALID_OPTION_COLUMNS', [
                            'Invalid option columns:',
                            'expect an array, a function or true,',
                            `got ${JSON.stringify(options.columns)}`
                        ], options);
                    }
                    // Normalize option `columns_duplicates_to_array`
                    if (options.columns_duplicates_to_array === undefined || options.columns_duplicates_to_array === null || options.columns_duplicates_to_array === false) {
                        options.columns_duplicates_to_array = false;
                    }
                    else if (options.columns_duplicates_to_array !== true) {
                        throw new CsvError('CSV_INVALID_OPTION_COLUMNS_DUPLICATES_TO_ARRAY', [
                            'Invalid option columns_duplicates_to_array:',
                            'expect an boolean,',
                            `got ${JSON.stringify(options.columns_duplicates_to_array)}`
                        ], options);
                    }
                    else if (options.columns === false) {
                        throw new CsvError('CSV_INVALID_OPTION_COLUMNS_DUPLICATES_TO_ARRAY', [
                            'Invalid option columns_duplicates_to_array:',
                            'the `columns` mode must be activated.'
                        ], options);
                    }
                    // Normalize option `comment`
                    if (options.comment === undefined || options.comment === null || options.comment === false || options.comment === '') {
                        options.comment = null;
                    }
                    else {
                        if (typeof options.comment === 'string') {
                            options.comment = Buffer.from(options.comment, options.encoding);
                        }
                        if (!Buffer.isBuffer(options.comment)) {
                            throw new CsvError('CSV_INVALID_OPTION_COMMENT', [
                                'Invalid option comment:',
                                'comment must be a buffer or a string,',
                                `got ${JSON.stringify(options.comment)}`
                            ], options);
                        }
                    }
                    // Normalize option `delimiter`
                    const delimiter_json = JSON.stringify(options.delimiter);
                    if (!Array.isArray(options.delimiter))
                        options.delimiter = [options.delimiter];
                    if (options.delimiter.length === 0) {
                        throw new CsvError('CSV_INVALID_OPTION_DELIMITER', [
                            'Invalid option delimiter:',
                            'delimiter must be a non empty string or buffer or array of string|buffer,',
                            `got ${delimiter_json}`
                        ], options);
                    }
                    options.delimiter = options.delimiter.map(function (delimiter) {
                        if (delimiter === undefined || delimiter === null || delimiter === false) {
                            return Buffer.from(',', options.encoding);
                        }
                        if (typeof delimiter === 'string') {
                            delimiter = Buffer.from(delimiter, options.encoding);
                        }
                        if (!Buffer.isBuffer(delimiter) || delimiter.length === 0) {
                            throw new CsvError('CSV_INVALID_OPTION_DELIMITER', [
                                'Invalid option delimiter:',
                                'delimiter must be a non empty string or buffer or array of string|buffer,',
                                `got ${delimiter_json}`
                            ], options);
                        }
                        return delimiter;
                    });
                    // Normalize option `escape`
                    if (options.escape === undefined || options.escape === true) {
                        options.escape = Buffer.from('"', options.encoding);
                    }
                    else if (typeof options.escape === 'string') {
                        options.escape = Buffer.from(options.escape, options.encoding);
                    }
                    else if (options.escape === null || options.escape === false) {
                        options.escape = null;
                    }
                    if (options.escape !== null) {
                        if (!Buffer.isBuffer(options.escape)) {
                            throw new Error(`Invalid Option: escape must be a buffer, a string or a boolean, got ${JSON.stringify(options.escape)}`);
                        }
                    }
                    // Normalize option `from`
                    if (options.from === undefined || options.from === null) {
                        options.from = 1;
                    }
                    else {
                        if (typeof options.from === 'string' && /\d+/.test(options.from)) {
                            options.from = parseInt(options.from);
                        }
                        if (Number.isInteger(options.from)) {
                            if (options.from < 0) {
                                throw new Error(`Invalid Option: from must be a positive integer, got ${JSON.stringify(opts.from)}`);
                            }
                        }
                        else {
                            throw new Error(`Invalid Option: from must be an integer, got ${JSON.stringify(options.from)}`);
                        }
                    }
                    // Normalize option `from_line`
                    if (options.from_line === undefined || options.from_line === null) {
                        options.from_line = 1;
                    }
                    else {
                        if (typeof options.from_line === 'string' && /\d+/.test(options.from_line)) {
                            options.from_line = parseInt(options.from_line);
                        }
                        if (Number.isInteger(options.from_line)) {
                            if (options.from_line <= 0) {
                                throw new Error(`Invalid Option: from_line must be a positive integer greater than 0, got ${JSON.stringify(opts.from_line)}`);
                            }
                        }
                        else {
                            throw new Error(`Invalid Option: from_line must be an integer, got ${JSON.stringify(opts.from_line)}`);
                        }
                    }
                    // Normalize options `ignore_last_delimiters`
                    if (options.ignore_last_delimiters === undefined || options.ignore_last_delimiters === null) {
                        options.ignore_last_delimiters = false;
                    }
                    else if (typeof options.ignore_last_delimiters === 'number') {
                        options.ignore_last_delimiters = Math.floor(options.ignore_last_delimiters);
                        if (options.ignore_last_delimiters === 0) {
                            options.ignore_last_delimiters = false;
                        }
                    }
                    else if (typeof options.ignore_last_delimiters !== 'boolean') {
                        throw new CsvError('CSV_INVALID_OPTION_IGNORE_LAST_DELIMITERS', [
                            'Invalid option `ignore_last_delimiters`:',
                            'the value must be a boolean value or an integer,',
                            `got ${JSON.stringify(options.ignore_last_delimiters)}`
                        ], options);
                    }
                    if (options.ignore_last_delimiters === true && options.columns === false) {
                        throw new CsvError('CSV_IGNORE_LAST_DELIMITERS_REQUIRES_COLUMNS', [
                            'The option `ignore_last_delimiters`',
                            'requires the activation of the `columns` option'
                        ], options);
                    }
                    // Normalize option `info`
                    if (options.info === undefined || options.info === null || options.info === false) {
                        options.info = false;
                    }
                    else if (options.info !== true) {
                        throw new Error(`Invalid Option: info must be true, got ${JSON.stringify(options.info)}`);
                    }
                    // Normalize option `max_record_size`
                    if (options.max_record_size === undefined || options.max_record_size === null || options.max_record_size === false) {
                        options.max_record_size = 0;
                    }
                    else if (Number.isInteger(options.max_record_size) && options.max_record_size >= 0) {
                        // Great, nothing to do
                    }
                    else if (typeof options.max_record_size === 'string' && /\d+/.test(options.max_record_size)) {
                        options.max_record_size = parseInt(options.max_record_size);
                    }
                    else {
                        throw new Error(`Invalid Option: max_record_size must be a positive integer, got ${JSON.stringify(options.max_record_size)}`);
                    }
                    // Normalize option `objname`
                    if (options.objname === undefined || options.objname === null || options.objname === false) {
                        options.objname = undefined;
                    }
                    else if (Buffer.isBuffer(options.objname)) {
                        if (options.objname.length === 0) {
                            throw new Error(`Invalid Option: objname must be a non empty buffer`);
                        }
                        if (options.encoding === null) {
                            // Don't call `toString`, leave objname as a buffer
                        }
                        else {
                            options.objname = options.objname.toString(options.encoding);
                        }
                    }
                    else if (typeof options.objname === 'string') {
                        if (options.objname.length === 0) {
                            throw new Error(`Invalid Option: objname must be a non empty string`);
                        }
                        // Great, nothing to do
                    }
                    else {
                        throw new Error(`Invalid Option: objname must be a string or a buffer, got ${options.objname}`);
                    }
                    // Normalize option `on_record`
                    if (options.on_record === undefined || options.on_record === null) {
                        options.on_record = undefined;
                    }
                    else if (typeof options.on_record !== 'function') {
                        throw new CsvError('CSV_INVALID_OPTION_ON_RECORD', [
                            'Invalid option `on_record`:',
                            'expect a function,',
                            `got ${JSON.stringify(options.on_record)}`
                        ], options);
                    }
                    // Normalize option `quote`
                    if (options.quote === null || options.quote === false || options.quote === '') {
                        options.quote = null;
                    }
                    else {
                        if (options.quote === undefined || options.quote === true) {
                            options.quote = Buffer.from('"', options.encoding);
                        }
                        else if (typeof options.quote === 'string') {
                            options.quote = Buffer.from(options.quote, options.encoding);
                        }
                        if (!Buffer.isBuffer(options.quote)) {
                            throw new Error(`Invalid Option: quote must be a buffer or a string, got ${JSON.stringify(options.quote)}`);
                        }
                    }
                    // Normalize option `raw`
                    if (options.raw === undefined || options.raw === null || options.raw === false) {
                        options.raw = false;
                    }
                    else if (options.raw !== true) {
                        throw new Error(`Invalid Option: raw must be true, got ${JSON.stringify(options.raw)}`);
                    }
                    // Normalize option `record_delimiter`
                    if (!options.record_delimiter) {
                        options.record_delimiter = [];
                    }
                    else if (!Array.isArray(options.record_delimiter)) {
                        options.record_delimiter = [options.record_delimiter];
                    }
                    options.record_delimiter = options.record_delimiter.map(function (rd) {
                        if (typeof rd === 'string') {
                            rd = Buffer.from(rd, options.encoding);
                        }
                        return rd;
                    });
                    // Normalize option `relax`
                    if (typeof options.relax === 'boolean') {
                        // Great, nothing to do
                    }
                    else if (options.relax === undefined || options.relax === null) {
                        options.relax = false;
                    }
                    else {
                        throw new Error(`Invalid Option: relax must be a boolean, got ${JSON.stringify(options.relax)}`);
                    }
                    // Normalize option `relax_column_count`
                    if (typeof options.relax_column_count === 'boolean') {
                        // Great, nothing to do
                    }
                    else if (options.relax_column_count === undefined || options.relax_column_count === null) {
                        options.relax_column_count = false;
                    }
                    else {
                        throw new Error(`Invalid Option: relax_column_count must be a boolean, got ${JSON.stringify(options.relax_column_count)}`);
                    }
                    if (typeof options.relax_column_count_less === 'boolean') {
                        // Great, nothing to do
                    }
                    else if (options.relax_column_count_less === undefined || options.relax_column_count_less === null) {
                        options.relax_column_count_less = false;
                    }
                    else {
                        throw new Error(`Invalid Option: relax_column_count_less must be a boolean, got ${JSON.stringify(options.relax_column_count_less)}`);
                    }
                    if (typeof options.relax_column_count_more === 'boolean') {
                        // Great, nothing to do
                    }
                    else if (options.relax_column_count_more === undefined || options.relax_column_count_more === null) {
                        options.relax_column_count_more = false;
                    }
                    else {
                        throw new Error(`Invalid Option: relax_column_count_more must be a boolean, got ${JSON.stringify(options.relax_column_count_more)}`);
                    }
                    // Normalize option `skip_empty_lines`
                    if (typeof options.skip_empty_lines === 'boolean') {
                        // Great, nothing to do
                    }
                    else if (options.skip_empty_lines === undefined || options.skip_empty_lines === null) {
                        options.skip_empty_lines = false;
                    }
                    else {
                        throw new Error(`Invalid Option: skip_empty_lines must be a boolean, got ${JSON.stringify(options.skip_empty_lines)}`);
                    }
                    // Normalize option `skip_lines_with_empty_values`
                    if (typeof options.skip_lines_with_empty_values === 'boolean') {
                        // Great, nothing to do
                    }
                    else if (options.skip_lines_with_empty_values === undefined || options.skip_lines_with_empty_values === null) {
                        options.skip_lines_with_empty_values = false;
                    }
                    else {
                        throw new Error(`Invalid Option: skip_lines_with_empty_values must be a boolean, got ${JSON.stringify(options.skip_lines_with_empty_values)}`);
                    }
                    // Normalize option `skip_lines_with_error`
                    if (typeof options.skip_lines_with_error === 'boolean') {
                        // Great, nothing to do
                    }
                    else if (options.skip_lines_with_error === undefined || options.skip_lines_with_error === null) {
                        options.skip_lines_with_error = false;
                    }
                    else {
                        throw new Error(`Invalid Option: skip_lines_with_error must be a boolean, got ${JSON.stringify(options.skip_lines_with_error)}`);
                    }
                    // Normalize option `rtrim`
                    if (options.rtrim === undefined || options.rtrim === null || options.rtrim === false) {
                        options.rtrim = false;
                    }
                    else if (options.rtrim !== true) {
                        throw new Error(`Invalid Option: rtrim must be a boolean, got ${JSON.stringify(options.rtrim)}`);
                    }
                    // Normalize option `ltrim`
                    if (options.ltrim === undefined || options.ltrim === null || options.ltrim === false) {
                        options.ltrim = false;
                    }
                    else if (options.ltrim !== true) {
                        throw new Error(`Invalid Option: ltrim must be a boolean, got ${JSON.stringify(options.ltrim)}`);
                    }
                    // Normalize option `trim`
                    if (options.trim === undefined || options.trim === null || options.trim === false) {
                        options.trim = false;
                    }
                    else if (options.trim !== true) {
                        throw new Error(`Invalid Option: trim must be a boolean, got ${JSON.stringify(options.trim)}`);
                    }
                    // Normalize options `trim`, `ltrim` and `rtrim`
                    if (options.trim === true && opts.ltrim !== false) {
                        options.ltrim = true;
                    }
                    else if (options.ltrim !== true) {
                        options.ltrim = false;
                    }
                    if (options.trim === true && opts.rtrim !== false) {
                        options.rtrim = true;
                    }
                    else if (options.rtrim !== true) {
                        options.rtrim = false;
                    }
                    // Normalize option `to`
                    if (options.to === undefined || options.to === null) {
                        options.to = -1;
                    }
                    else {
                        if (typeof options.to === 'string' && /\d+/.test(options.to)) {
                            options.to = parseInt(options.to);
                        }
                        if (Number.isInteger(options.to)) {
                            if (options.to <= 0) {
                                throw new Error(`Invalid Option: to must be a positive integer greater than 0, got ${JSON.stringify(opts.to)}`);
                            }
                        }
                        else {
                            throw new Error(`Invalid Option: to must be an integer, got ${JSON.stringify(opts.to)}`);
                        }
                    }
                    // Normalize option `to_line`
                    if (options.to_line === undefined || options.to_line === null) {
                        options.to_line = -1;
                    }
                    else {
                        if (typeof options.to_line === 'string' && /\d+/.test(options.to_line)) {
                            options.to_line = parseInt(options.to_line);
                        }
                        if (Number.isInteger(options.to_line)) {
                            if (options.to_line <= 0) {
                                throw new Error(`Invalid Option: to_line must be a positive integer greater than 0, got ${JSON.stringify(opts.to_line)}`);
                            }
                        }
                        else {
                            throw new Error(`Invalid Option: to_line must be an integer, got ${JSON.stringify(opts.to_line)}`);
                        }
                    }
                    this.info = {
                        bytes: 0,
                        comment_lines: 0,
                        empty_lines: 0,
                        invalid_field_length: 0,
                        lines: 1,
                        records: 0
                    };
                    this.options = options;
                    this.state = {
                        bomSkipped: false,
                        bufBytesStart: 0,
                        castField: fnCastField,
                        commenting: false,
                        // Current error encountered by a record
                        error: undefined,
                        enabled: options.from_line === 1,
                        escaping: false,
                        // escapeIsQuote: options.escape === options.quote,
                        escapeIsQuote: Buffer.isBuffer(options.escape) && Buffer.isBuffer(options.quote) && Buffer.compare(options.escape, options.quote) === 0,
                        // columns can be `false`, `true`, `Array`
                        expectedRecordLength: Array.isArray(options.columns) ? options.columns.length : undefined,
                        field: new ResizeableBuffer(20),
                        firstLineToHeaders: fnFirstLineToHeaders,
                        needMoreDataSize: Math.max(
                        // Skip if the remaining buffer smaller than comment
                        options.comment !== null ? options.comment.length : 0, 
                        // Skip if the remaining buffer can be delimiter
                        ...options.delimiter.map((delimiter) => delimiter.length), 
                        // Skip if the remaining buffer can be escape sequence
                        options.quote !== null ? options.quote.length : 0),
                        previousBuf: undefined,
                        quoting: false,
                        stop: false,
                        rawBuffer: new ResizeableBuffer(100),
                        record: [],
                        recordHasError: false,
                        record_length: 0,
                        recordDelimiterMaxLength: options.record_delimiter.length === 0 ? 2 : Math.max(...options.record_delimiter.map((v) => v.length)),
                        trimChars: [Buffer.from(' ', options.encoding)[0], Buffer.from('\t', options.encoding)[0]],
                        wasQuoting: false,
                        wasRowDelimiter: false
                    };
                }
                // Implementation of `Transform._transform`
                _transform(buf, encoding, callback) {
                    if (this.state.stop === true) {
                        return;
                    }
                    const err = this.__parse(buf, false);
                    if (err !== undefined) {
                        this.state.stop = true;
                    }
                    callback(err);
                }
                // Implementation of `Transform._flush`
                _flush(callback) {
                    if (this.state.stop === true) {
                        return;
                    }
                    const err = this.__parse(undefined, true);
                    callback(err);
                }
                // Central parser implementation
                __parse(nextBuf, end) {
                    const { bom, comment, escape, from_line, ltrim, max_record_size, quote, raw, relax, rtrim, skip_empty_lines, to, to_line } = this.options;
                    let { record_delimiter } = this.options;
                    const { bomSkipped, previousBuf, rawBuffer, escapeIsQuote } = this.state;
                    let buf;
                    if (previousBuf === undefined) {
                        if (nextBuf === undefined) {
                            // Handle empty string
                            this.push(null);
                            return;
                        }
                        else {
                            buf = nextBuf;
                        }
                    }
                    else if (previousBuf !== undefined && nextBuf === undefined) {
                        buf = previousBuf;
                    }
                    else {
                        buf = Buffer.concat([previousBuf, nextBuf]);
                    }
                    // Handle UTF BOM
                    if (bomSkipped === false) {
                        if (bom === false) {
                            this.state.bomSkipped = true;
                        }
                        else if (buf.length < 3) {
                            // No enough data
                            if (end === false) {
                                // Wait for more data
                                this.state.previousBuf = buf;
                                return;
                            }
                        }
                        else {
                            for (let encoding in boms) {
                                if (boms[encoding].compare(buf, 0, boms[encoding].length) === 0) {
                                    // Skip BOM
                                    let bomLength = boms[encoding].length;
                                    this.state.bufBytesStart += bomLength;
                                    buf = buf.slice(bomLength);
                                    // Renormalize original options with the new encoding
                                    this.__normalizeOptions({ ...this.__originalOptions, encoding: encoding });
                                    break;
                                }
                            }
                            this.state.bomSkipped = true;
                        }
                    }
                    const bufLen = buf.length;
                    let pos;
                    for (pos = 0; pos < bufLen; pos++) {
                        // Ensure we get enough space to look ahead
                        // There should be a way to move this out of the loop
                        if (this.__needMoreData(pos, bufLen, end)) {
                            break;
                        }
                        if (this.state.wasRowDelimiter === true) {
                            this.info.lines++;
                            this.state.wasRowDelimiter = false;
                        }
                        if (to_line !== -1 && this.info.lines > to_line) {
                            this.state.stop = true;
                            this.push(null);
                            return;
                        }
                        // Auto discovery of record_delimiter, unix, mac and windows supported
                        if (this.state.quoting === false && record_delimiter.length === 0) {
                            const record_delimiterCount = this.__autoDiscoverRecordDelimiter(buf, pos);
                            if (record_delimiterCount) {
                                record_delimiter = this.options.record_delimiter;
                            }
                        }
                        const chr = buf[pos];
                        if (raw === true) {
                            rawBuffer.append(chr);
                        }
                        if ((chr === cr || chr === nl) && this.state.wasRowDelimiter === false) {
                            this.state.wasRowDelimiter = true;
                        }
                        // Previous char was a valid escape char
                        // treat the current char as a regular char
                        if (this.state.escaping === true) {
                            this.state.escaping = false;
                        }
                        else {
                            // Escape is only active inside quoted fields
                            // We are quoting, the char is an escape chr and there is a chr to escape
                            // if(escape !== null && this.state.quoting === true && chr === escape && pos + 1 < bufLen){
                            if (escape !== null && this.state.quoting === true && this.__isEscape(buf, pos, chr) && pos + escape.length < bufLen) {
                                if (escapeIsQuote) {
                                    if (this.__isQuote(buf, pos + escape.length)) {
                                        this.state.escaping = true;
                                        pos += escape.length - 1;
                                        continue;
                                    }
                                }
                                else {
                                    this.state.escaping = true;
                                    pos += escape.length - 1;
                                    continue;
                                }
                            }
                            // Not currently escaping and chr is a quote
                            // TODO: need to compare bytes instead of single char
                            if (this.state.commenting === false && this.__isQuote(buf, pos)) {
                                if (this.state.quoting === true) {
                                    const nextChr = buf[pos + quote.length];
                                    const isNextChrTrimable = rtrim && this.__isCharTrimable(nextChr);
                                    const isNextChrComment = comment !== null && this.__compareBytes(comment, buf, pos + quote.length, nextChr);
                                    const isNextChrDelimiter = this.__isDelimiter(buf, pos + quote.length, nextChr);
                                    const isNextChrRecordDelimiter = record_delimiter.length === 0 ? this.__autoDiscoverRecordDelimiter(buf, pos + quote.length) : this.__isRecordDelimiter(nextChr, buf, pos + quote.length);
                                    // Escape a quote
                                    // Treat next char as a regular character
                                    if (escape !== null && this.__isEscape(buf, pos, chr) && this.__isQuote(buf, pos + escape.length)) {
                                        pos += escape.length - 1;
                                    }
                                    else if (!nextChr || isNextChrDelimiter || isNextChrRecordDelimiter || isNextChrComment || isNextChrTrimable) {
                                        this.state.quoting = false;
                                        this.state.wasQuoting = true;
                                        pos += quote.length - 1;
                                        continue;
                                    }
                                    else if (relax === false) {
                                        const err = this.__error(new CsvError('CSV_INVALID_CLOSING_QUOTE', [
                                            'Invalid Closing Quote:',
                                            `got "${String.fromCharCode(nextChr)}"`,
                                            `at line ${this.info.lines}`,
                                            'instead of delimiter, record delimiter, trimable character',
                                            '(if activated) or comment',
                                        ], this.options, this.__infoField()));
                                        if (err !== undefined)
                                            return err;
                                    }
                                    else {
                                        this.state.quoting = false;
                                        this.state.wasQuoting = true;
                                        this.state.field.prepend(quote);
                                        pos += quote.length - 1;
                                    }
                                }
                                else {
                                    if (this.state.field.length !== 0) {
                                        // In relax mode, treat opening quote preceded by chrs as regular
                                        if (relax === false) {
                                            const err = this.__error(new CsvError('INVALID_OPENING_QUOTE', [
                                                'Invalid Opening Quote:',
                                                `a quote is found inside a field at line ${this.info.lines}`,
                                            ], this.options, this.__infoField(), {
                                                field: this.state.field,
                                            }));
                                            if (err !== undefined)
                                                return err;
                                        }
                                    }
                                    else {
                                        this.state.quoting = true;
                                        pos += quote.length - 1;
                                        continue;
                                    }
                                }
                            }
                            if (this.state.quoting === false) {
                                let recordDelimiterLength = this.__isRecordDelimiter(chr, buf, pos);
                                if (recordDelimiterLength !== 0) {
                                    // Do not emit comments which take a full line
                                    const skipCommentLine = this.state.commenting && (this.state.wasQuoting === false && this.state.record.length === 0 && this.state.field.length === 0);
                                    if (skipCommentLine) {
                                        this.info.comment_lines++;
                                        // Skip full comment line
                                    }
                                    else {
                                        // Activate records emition if above from_line
                                        if (this.state.enabled === false && this.info.lines + (this.state.wasRowDelimiter === true ? 1 : 0) >= from_line) {
                                            this.state.enabled = true;
                                            this.__resetField();
                                            this.__resetRecord();
                                            pos += recordDelimiterLength - 1;
                                            continue;
                                        }
                                        // Skip if line is empty and skip_empty_lines activated
                                        if (skip_empty_lines === true && this.state.wasQuoting === false && this.state.record.length === 0 && this.state.field.length === 0) {
                                            this.info.empty_lines++;
                                            pos += recordDelimiterLength - 1;
                                            continue;
                                        }
                                        this.info.bytes = this.state.bufBytesStart + pos;
                                        const errField = this.__onField();
                                        if (errField !== undefined)
                                            return errField;
                                        this.info.bytes = this.state.bufBytesStart + pos + recordDelimiterLength;
                                        const errRecord = this.__onRecord();
                                        if (errRecord !== undefined)
                                            return errRecord;
                                        if (to !== -1 && this.info.records >= to) {
                                            this.state.stop = true;
                                            this.push(null);
                                            return;
                                        }
                                    }
                                    this.state.commenting = false;
                                    pos += recordDelimiterLength - 1;
                                    continue;
                                }
                                if (this.state.commenting) {
                                    continue;
                                }
                                const commentCount = comment === null ? 0 : this.__compareBytes(comment, buf, pos, chr);
                                if (commentCount !== 0) {
                                    this.state.commenting = true;
                                    continue;
                                }
                                let delimiterLength = this.__isDelimiter(buf, pos, chr);
                                if (delimiterLength !== 0) {
                                    this.info.bytes = this.state.bufBytesStart + pos;
                                    const errField = this.__onField();
                                    if (errField !== undefined)
                                        return errField;
                                    pos += delimiterLength - 1;
                                    continue;
                                }
                            }
                        }
                        if (this.state.commenting === false) {
                            if (max_record_size !== 0 && this.state.record_length + this.state.field.length > max_record_size) {
                                const err = this.__error(new CsvError('CSV_MAX_RECORD_SIZE', [
                                    'Max Record Size:',
                                    'record exceed the maximum number of tolerated bytes',
                                    `of ${max_record_size}`,
                                    `at line ${this.info.lines}`,
                                ], this.options, this.__infoField()));
                                if (err !== undefined)
                                    return err;
                            }
                        }
                        const lappend = ltrim === false || this.state.quoting === true || this.state.field.length !== 0 || !this.__isCharTrimable(chr);
                        // rtrim in non quoting is handle in __onField
                        const rappend = rtrim === false || this.state.wasQuoting === false;
                        if (lappend === true && rappend === true) {
                            this.state.field.append(chr);
                        }
                        else if (rtrim === true && !this.__isCharTrimable(chr)) {
                            const err = this.__error(new CsvError('CSV_NON_TRIMABLE_CHAR_AFTER_CLOSING_QUOTE', [
                                'Invalid Closing Quote:',
                                'found non trimable byte after quote',
                                `at line ${this.info.lines}`,
                            ], this.options, this.__infoField()));
                            if (err !== undefined)
                                return err;
                        }
                    }
                    if (end === true) {
                        // Ensure we are not ending in a quoting state
                        if (this.state.quoting === true) {
                            const err = this.__error(new CsvError('CSV_QUOTE_NOT_CLOSED', [
                                'Quote Not Closed:',
                                `the parsing is finished with an opening quote at line ${this.info.lines}`,
                            ], this.options, this.__infoField()));
                            if (err !== undefined)
                                return err;
                        }
                        else {
                            // Skip last line if it has no characters
                            if (this.state.wasQuoting === true || this.state.record.length !== 0 || this.state.field.length !== 0) {
                                this.info.bytes = this.state.bufBytesStart + pos;
                                const errField = this.__onField();
                                if (errField !== undefined)
                                    return errField;
                                const errRecord = this.__onRecord();
                                if (errRecord !== undefined)
                                    return errRecord;
                            }
                            else if (this.state.wasRowDelimiter === true) {
                                this.info.empty_lines++;
                            }
                            else if (this.state.commenting === true) {
                                this.info.comment_lines++;
                            }
                        }
                    }
                    else {
                        this.state.bufBytesStart += pos;
                        this.state.previousBuf = buf.slice(pos);
                    }
                    if (this.state.wasRowDelimiter === true) {
                        this.info.lines++;
                        this.state.wasRowDelimiter = false;
                    }
                }
                __onRecord() {
                    const { columns, columns_duplicates_to_array, encoding, info, from, relax_column_count, relax_column_count_less, relax_column_count_more, raw, skip_lines_with_empty_values } = this.options;
                    const { enabled, record } = this.state;
                    if (enabled === false) {
                        return this.__resetRecord();
                    }
                    // Convert the first line into column names
                    const recordLength = record.length;
                    if (columns === true) {
                        if (skip_lines_with_empty_values === true && isRecordEmpty(record)) {
                            this.__resetRecord();
                            return;
                        }
                        return this.__firstLineToColumns(record);
                    }
                    if (columns === false && this.info.records === 0) {
                        this.state.expectedRecordLength = recordLength;
                    }
                    if (recordLength !== this.state.expectedRecordLength) {
                        const err = columns === false ?
                            // Todo: rename CSV_INCONSISTENT_RECORD_LENGTH to
                            // CSV_RECORD_INCONSISTENT_FIELDS_LENGTH
                            new CsvError('CSV_INCONSISTENT_RECORD_LENGTH', [
                                'Invalid Record Length:',
                                `expect ${this.state.expectedRecordLength},`,
                                `got ${recordLength} on line ${this.info.lines}`,
                            ], this.options, this.__infoField(), {
                                record: record,
                            })
                            :
                                // Todo: rename CSV_RECORD_DONT_MATCH_COLUMNS_LENGTH to
                                // CSV_RECORD_INCONSISTENT_COLUMNS
                                new CsvError('CSV_RECORD_DONT_MATCH_COLUMNS_LENGTH', [
                                    'Invalid Record Length:',
                                    `columns length is ${columns.length},`,
                                    `got ${recordLength} on line ${this.info.lines}`,
                                ], this.options, this.__infoField(), {
                                    record: record,
                                });
                        if (relax_column_count === true ||
                            (relax_column_count_less === true && recordLength < this.state.expectedRecordLength) ||
                            (relax_column_count_more === true && recordLength > this.state.expectedRecordLength)) {
                            this.info.invalid_field_length++;
                            this.state.error = err;
                            // Error is undefined with skip_lines_with_error
                        }
                        else {
                            const finalErr = this.__error(err);
                            if (finalErr)
                                return finalErr;
                        }
                    }
                    if (skip_lines_with_empty_values === true && isRecordEmpty(record)) {
                        this.__resetRecord();
                        return;
                    }
                    if (this.state.recordHasError === true) {
                        this.__resetRecord();
                        this.state.recordHasError = false;
                        return;
                    }
                    this.info.records++;
                    if (from === 1 || this.info.records >= from) {
                        // With columns, records are object
                        if (columns !== false) {
                            const obj = {};
                            // Transform record array to an object
                            for (let i = 0, l = record.length; i < l; i++) {
                                if (columns[i] === undefined || columns[i].disabled)
                                    continue;
                                // Turn duplicate columns into an array
                                if (columns_duplicates_to_array === true && obj[columns[i].name] !== undefined) {
                                    if (Array.isArray(obj[columns[i].name])) {
                                        obj[columns[i].name] = obj[columns[i].name].concat(record[i]);
                                    }
                                    else {
                                        obj[columns[i].name] = [obj[columns[i].name], record[i]];
                                    }
                                }
                                else {
                                    obj[columns[i].name] = record[i];
                                }
                            }
                            const { objname } = this.options;
                            // Without objname (default)
                            if (objname === undefined) {
                                if (raw === true || info === true) {
                                    const err = this.__push(Object.assign({ record: obj }, (raw === true ? { raw: this.state.rawBuffer.toString(encoding) } : {}), (info === true ? { info: this.__infoRecord() } : {})));
                                    if (err) {
                                        return err;
                                    }
                                }
                                else {
                                    const err = this.__push(obj);
                                    if (err) {
                                        return err;
                                    }
                                }
                                // With objname (default)
                            }
                            else {
                                if (raw === true || info === true) {
                                    const err = this.__push(Object.assign({ record: [obj[objname], obj] }, raw === true ? { raw: this.state.rawBuffer.toString(encoding) } : {}, info === true ? { info: this.__infoRecord() } : {}));
                                    if (err) {
                                        return err;
                                    }
                                }
                                else {
                                    const err = this.__push([obj[objname], obj]);
                                    if (err) {
                                        return err;
                                    }
                                }
                            }
                            // Without columns, records are array
                        }
                        else {
                            if (raw === true || info === true) {
                                const err = this.__push(Object.assign({ record: record }, raw === true ? { raw: this.state.rawBuffer.toString(encoding) } : {}, info === true ? { info: this.__infoRecord() } : {}));
                                if (err) {
                                    return err;
                                }
                            }
                            else {
                                const err = this.__push(record);
                                if (err) {
                                    return err;
                                }
                            }
                        }
                    }
                    this.__resetRecord();
                }
                __firstLineToColumns(record) {
                    const { firstLineToHeaders } = this.state;
                    try {
                        const headers = firstLineToHeaders === undefined ? record : firstLineToHeaders.call(null, record);
                        if (!Array.isArray(headers)) {
                            return this.__error(new CsvError('CSV_INVALID_COLUMN_MAPPING', [
                                'Invalid Column Mapping:',
                                'expect an array from column function,',
                                `got ${JSON.stringify(headers)}`
                            ], this.options, this.__infoField(), {
                                headers: headers,
                            }));
                        }
                        const normalizedHeaders = normalizeColumnsArray(headers);
                        this.state.expectedRecordLength = normalizedHeaders.length;
                        this.options.columns = normalizedHeaders;
                        this.__resetRecord();
                        return;
                    }
                    catch (err) {
                        return err;
                    }
                }
                __resetRecord() {
                    if (this.options.raw === true) {
                        this.state.rawBuffer.reset();
                    }
                    this.state.error = undefined;
                    this.state.record = [];
                    this.state.record_length = 0;
                }
                __onField() {
                    const { cast, encoding, rtrim, max_record_size } = this.options;
                    const { enabled, wasQuoting } = this.state;
                    // Short circuit for the from_line options
                    if (enabled === false) {
                        return this.__resetField();
                    }
                    let field = this.state.field.toString(encoding);
                    if (rtrim === true && wasQuoting === false) {
                        field = field.trimRight();
                    }
                    if (cast === true) {
                        const [err, f] = this.__cast(field);
                        if (err !== undefined)
                            return err;
                        field = f;
                    }
                    this.state.record.push(field);
                    // Increment record length if record size must not exceed a limit
                    if (max_record_size !== 0 && typeof field === 'string') {
                        this.state.record_length += field.length;
                    }
                    this.__resetField();
                }
                __resetField() {
                    this.state.field.reset();
                    this.state.wasQuoting = false;
                }
                __push(record) {
                    const { on_record } = this.options;
                    if (on_record !== undefined) {
                        const info = this.__infoRecord();
                        try {
                            record = on_record.call(null, record, info);
                        }
                        catch (err) {
                            return err;
                        }
                        if (record === undefined || record === null) {
                            return;
                        }
                    }
                    this.push(record);
                }
                // Return a tuple with the error and the casted value
                __cast(field) {
                    const { columns, relax_column_count } = this.options;
                    const isColumns = Array.isArray(columns);
                    // Dont loose time calling cast
                    // because the final record is an object
                    // and this field can't be associated to a key present in columns
                    if (isColumns === true && relax_column_count && this.options.columns.length <= this.state.record.length) {
                        return [undefined, undefined];
                    }
                    if (this.state.castField !== null) {
                        try {
                            const info = this.__infoField();
                            return [undefined, this.state.castField.call(null, field, info)];
                        }
                        catch (err) {
                            return [err];
                        }
                    }
                    if (this.__isFloat(field)) {
                        return [undefined, parseFloat(field)];
                    }
                    else if (this.options.cast_date !== false) {
                        const info = this.__infoField();
                        return [undefined, this.options.cast_date.call(null, field, info)];
                    }
                    return [undefined, field];
                }
                // Helper to test if a character is a space or a line delimiter
                __isCharTrimable(chr) {
                    return chr === space || chr === tab || chr === cr || chr === nl || chr === np;
                }
                // Keep it in case we implement the `cast_int` option
                // __isInt(value){
                //   // return Number.isInteger(parseInt(value))
                //   // return !isNaN( parseInt( obj ) );
                //   return /^(\-|\+)?[1-9][0-9]*$/.test(value)
                // }
                __isFloat(value) {
                    return (value - parseFloat(value) + 1) >= 0; // Borrowed from jquery
                }
                __compareBytes(sourceBuf, targetBuf, targetPos, firstByte) {
                    if (sourceBuf[0] !== firstByte)
                        return 0;
                    const sourceLength = sourceBuf.length;
                    for (let i = 1; i < sourceLength; i++) {
                        if (sourceBuf[i] !== targetBuf[targetPos + i])
                            return 0;
                    }
                    return sourceLength;
                }
                __needMoreData(i, bufLen, end) {
                    if (end)
                        return false;
                    const { quote } = this.options;
                    const { quoting, needMoreDataSize, recordDelimiterMaxLength } = this.state;
                    const numOfCharLeft = bufLen - i - 1;
                    const requiredLength = Math.max(needMoreDataSize, 
                    // Skip if the remaining buffer smaller than record delimiter
                    recordDelimiterMaxLength, 
                    // Skip if the remaining buffer can be record delimiter following the closing quote
                    // 1 is for quote.length
                    quoting ? (quote.length + recordDelimiterMaxLength) : 0);
                    return numOfCharLeft < requiredLength;
                }
                __isDelimiter(buf, pos, chr) {
                    const { delimiter, ignore_last_delimiters } = this.options;
                    if (ignore_last_delimiters === true && this.state.record.length === this.options.columns.length - 1) {
                        return 0;
                    }
                    else if (ignore_last_delimiters !== false && typeof ignore_last_delimiters === 'number' && this.state.record.length === ignore_last_delimiters - 1) {
                        return 0;
                    }
                    loop1: for (let i = 0; i < delimiter.length; i++) {
                        const del = delimiter[i];
                        if (del[0] === chr) {
                            for (let j = 1; j < del.length; j++) {
                                if (del[j] !== buf[pos + j])
                                    continue loop1;
                            }
                            return del.length;
                        }
                    }
                    return 0;
                }
                __isRecordDelimiter(chr, buf, pos) {
                    const { record_delimiter } = this.options;
                    const recordDelimiterLength = record_delimiter.length;
                    loop1: for (let i = 0; i < recordDelimiterLength; i++) {
                        const rd = record_delimiter[i];
                        const rdLength = rd.length;
                        if (rd[0] !== chr) {
                            continue;
                        }
                        for (let j = 1; j < rdLength; j++) {
                            if (rd[j] !== buf[pos + j]) {
                                continue loop1;
                            }
                        }
                        return rd.length;
                    }
                    return 0;
                }
                __isEscape(buf, pos, chr) {
                    const { escape } = this.options;
                    if (escape === null)
                        return false;
                    const l = escape.length;
                    if (escape[0] === chr) {
                        for (let i = 0; i < l; i++) {
                            if (escape[i] !== buf[pos + i]) {
                                return false;
                            }
                        }
                        return true;
                    }
                    return false;
                }
                __isQuote(buf, pos) {
                    const { quote } = this.options;
                    if (quote === null)
                        return false;
                    const l = quote.length;
                    for (let i = 0; i < l; i++) {
                        if (quote[i] !== buf[pos + i]) {
                            return false;
                        }
                    }
                    return true;
                }
                __autoDiscoverRecordDelimiter(buf, pos) {
                    const { encoding } = this.options;
                    const chr = buf[pos];
                    if (chr === cr) {
                        if (buf[pos + 1] === nl) {
                            this.options.record_delimiter.push(Buffer.from('\r\n', encoding));
                            this.state.recordDelimiterMaxLength = 2;
                            return 2;
                        }
                        else {
                            this.options.record_delimiter.push(Buffer.from('\r', encoding));
                            this.state.recordDelimiterMaxLength = 1;
                            return 1;
                        }
                    }
                    else if (chr === nl) {
                        this.options.record_delimiter.push(Buffer.from('\n', encoding));
                        this.state.recordDelimiterMaxLength = 1;
                        return 1;
                    }
                    return 0;
                }
                __error(msg) {
                    const { skip_lines_with_error } = this.options;
                    const err = typeof msg === 'string' ? new Error(msg) : msg;
                    if (skip_lines_with_error) {
                        this.state.recordHasError = true;
                        this.emit('skip', err);
                        return undefined;
                    }
                    else {
                        return err;
                    }
                }
                __infoDataSet() {
                    return {
                        ...this.info,
                        columns: this.options.columns
                    };
                }
                __infoRecord() {
                    const { columns } = this.options;
                    return {
                        ...this.__infoDataSet(),
                        error: this.state.error,
                        header: columns === true,
                        index: this.state.record.length,
                    };
                }
                __infoField() {
                    const { columns } = this.options;
                    const isColumns = Array.isArray(columns);
                    return {
                        ...this.__infoRecord(),
                        column: isColumns === true ?
                            (columns.length > this.state.record.length ?
                                columns[this.state.record.length].name :
                                null) :
                            this.state.record.length,
                        quoting: this.state.wasQuoting,
                    };
                }
            }
            const parse = function () {
                let data, options, callback;
                for (let i in arguments) {
                    const argument = arguments[i];
                    const type = typeof argument;
                    if (data === undefined && (typeof argument === 'string' || Buffer.isBuffer(argument))) {
                        data = argument;
                    }
                    else if (options === undefined && isObject(argument)) {
                        options = argument;
                    }
                    else if (callback === undefined && type === 'function') {
                        callback = argument;
                    }
                    else {
                        throw new CsvError('CSV_INVALID_ARGUMENT', [
                            'Invalid argument:',
                            `got ${JSON.stringify(argument)} at index ${i}`
                        ], options || {});
                    }
                }
                const parser = new Parser(options);
                if (callback) {
                    const records = options === undefined || options.objname === undefined ? [] : {};
                    parser.on('readable', function () {
                        let record;
                        while ((record = this.read()) !== null) {
                            if (options === undefined || options.objname === undefined) {
                                records.push(record);
                            }
                            else {
                                records[record[0]] = record[1];
                            }
                        }
                    });
                    parser.on('error', function (err) {
                        callback(err, undefined, parser.__infoDataSet());
                    });
                    parser.on('end', function () {
                        callback(undefined, records, parser.__infoDataSet());
                    });
                }
                if (data !== undefined) {
                    // Give a chance for events to be registered later
                    if (typeof setImmediate === 'function') {
                        setImmediate(function () {
                            parser.write(data);
                            parser.end();
                        });
                    }
                    else {
                        parser.write(data);
                        parser.end();
                    }
                }
                return parser;
            };
            class CsvError extends Error {
                constructor(code, message, options, ...contexts) {
                    if (Array.isArray(message))
                        message = message.join(' ');
                    super(message);
                    if (Error.captureStackTrace !== undefined) {
                        Error.captureStackTrace(this, CsvError);
                    }
                    this.code = code;
                    for (const context of contexts) {
                        for (const key in context) {
                            const value = context[key];
                            this[key] = Buffer.isBuffer(value) ? value.toString(options.encoding) : value == null ? value : JSON.parse(JSON.stringify(value));
                        }
                    }
                }
            }
            parse.Parser = Parser;
            parse.CsvError = CsvError;
            module.exports = parse;
            const underscore = function (str) {
                return str.replace(/([A-Z])/g, function (_, match) {
                    return '_' + match.toLowerCase();
                });
            };
            const isObject = function (obj) {
                return (typeof obj === 'object' && obj !== null && !Array.isArray(obj));
            };
            const isRecordEmpty = function (record) {
                return record.every((field) => field == null || field.toString && field.toString().trim() === '');
            };
            const normalizeColumnsArray = function (columns) {
                const normalizedColumns = [];
                for (let i = 0, l = columns.length; i < l; i++) {
                    const column = columns[i];
                    if (column === undefined || column === null || column === false) {
                        normalizedColumns[i] = { disabled: true };
                    }
                    else if (typeof column === 'string') {
                        normalizedColumns[i] = { name: column };
                    }
                    else if (isObject(column)) {
                        if (typeof column.name !== 'string') {
                            throw new CsvError('CSV_OPTION_COLUMNS_MISSING_NAME', [
                                'Option columns missing name:',
                                `property "name" is required at position ${i}`,
                                'when column is an object literal'
                            ]);
                        }
                        normalizedColumns[i] = column;
                    }
                    else {
                        throw new CsvError('CSV_INVALID_COLUMN_DEFINITION', [
                            'Invalid column definition:',
                            'expect a string or a literal object,',
                            `got ${JSON.stringify(column)} at position ${i}`
                        ]);
                    }
                }
                return normalizedColumns;
            };
            /***/ 
        }),
        /***/ "./node_modules/csv-parse/lib/sync.js": 
        /*!********************************************!*\
          !*** ./node_modules/csv-parse/lib/sync.js ***!
          \********************************************/
        /***/ ((module, __unused_webpack_exports, __webpack_require__) => {
            const parse = __webpack_require__(/*! . */ "./node_modules/csv-parse/lib/index.js");
            module.exports = function (data, options = {}) {
                if (typeof data === 'string') {
                    data = Buffer.from(data);
                }
                const records = options && options.objname ? {} : [];
                const parser = new parse.Parser(options);
                parser.push = function (record) {
                    if (record === null) {
                        return;
                    }
                    if (options.objname === undefined)
                        records.push(record);
                    else {
                        records[record[0]] = record[1];
                    }
                };
                const err1 = parser.__parse(data, false);
                if (err1 !== undefined)
                    throw err1;
                const err2 = parser.__parse(undefined, true);
                if (err2 !== undefined)
                    throw err2;
                return records;
            };
            /***/ 
        }),
        /***/ "./node_modules/csv-stringify/lib/index.js": 
        /*!*************************************************!*\
          !*** ./node_modules/csv-stringify/lib/index.js ***!
          \*************************************************/
        /***/ ((module, __unused_webpack_exports, __webpack_require__) => {
            /*
            CSV Stringify
            
            Please look at the [project documentation](https://csv.js.org/stringify/) for
            additional information.
            */
            const { Transform } = __webpack_require__(/*! stream */ "stream");
            const bom_utf8 = Buffer.from([239, 187, 191]);
            class Stringifier extends Transform {
                constructor(opts = {}) {
                    super({ ...{ writableObjectMode: true }, ...opts });
                    const options = {};
                    let err;
                    // Merge with user options
                    for (let opt in opts) {
                        options[underscore(opt)] = opts[opt];
                    }
                    if (err = this.normalize(options))
                        throw err;
                    switch (options.record_delimiter) {
                        case 'auto':
                            options.record_delimiter = null;
                            break;
                        case 'unix':
                            options.record_delimiter = "\n";
                            break;
                        case 'mac':
                            options.record_delimiter = "\r";
                            break;
                        case 'windows':
                            options.record_delimiter = "\r\n";
                            break;
                        case 'ascii':
                            options.record_delimiter = "\u001e";
                            break;
                        case 'unicode':
                            options.record_delimiter = "\u2028";
                            break;
                    }
                    // Expose options
                    this.options = options;
                    // Internal state
                    this.state = {
                        stop: false
                    };
                    // Information
                    this.info = {
                        records: 0
                    };
                }
                normalize(options) {
                    // Normalize option `bom`
                    if (options.bom === undefined || options.bom === null || options.bom === false) {
                        options.bom = false;
                    }
                    else if (options.bom !== true) {
                        return new CsvError('CSV_OPTION_BOOLEAN_INVALID_TYPE', [
                            'option `bom` is optional and must be a boolean value,',
                            `got ${JSON.stringify(options.bom)}`
                        ]);
                    }
                    // Normalize option `delimiter`
                    if (options.delimiter === undefined || options.delimiter === null) {
                        options.delimiter = ',';
                    }
                    else if (Buffer.isBuffer(options.delimiter)) {
                        options.delimiter = options.delimiter.toString();
                    }
                    else if (typeof options.delimiter !== 'string') {
                        return new CsvError('CSV_OPTION_DELIMITER_INVALID_TYPE', [
                            'option `delimiter` must be a buffer or a string,',
                            `got ${JSON.stringify(options.delimiter)}`
                        ]);
                    }
                    // Normalize option `quote`
                    if (options.quote === undefined || options.quote === null) {
                        options.quote = '"';
                    }
                    else if (options.quote === true) {
                        options.quote = '"';
                    }
                    else if (options.quote === false) {
                        options.quote = '';
                    }
                    else if (Buffer.isBuffer(options.quote)) {
                        options.quote = options.quote.toString();
                    }
                    else if (typeof options.quote !== 'string') {
                        return new CsvError('CSV_OPTION_QUOTE_INVALID_TYPE', [
                            'option `quote` must be a boolean, a buffer or a string,',
                            `got ${JSON.stringify(options.quote)}`
                        ]);
                    }
                    // Normalize option `quoted`
                    if (options.quoted === undefined || options.quoted === null) {
                        options.quoted = false;
                    }
                    else {
                        // todo
                    }
                    // Normalize option `quoted_empty`
                    if (options.quoted_empty === undefined || options.quoted_empty === null) {
                        options.quoted_empty = undefined;
                    }
                    else {
                        // todo
                    }
                    // Normalize option `quoted_match`
                    if (options.quoted_match === undefined || options.quoted_match === null || options.quoted_match === false) {
                        options.quoted_match = null;
                    }
                    else if (!Array.isArray(options.quoted_match)) {
                        options.quoted_match = [options.quoted_match];
                    }
                    if (options.quoted_match) {
                        for (let quoted_match of options.quoted_match) {
                            const isString = typeof quoted_match === 'string';
                            const isRegExp = quoted_match instanceof RegExp;
                            if (!isString && !isRegExp) {
                                return Error(`Invalid Option: quoted_match must be a string or a regex, got ${JSON.stringify(quoted_match)}`);
                            }
                        }
                    }
                    // Normalize option `quoted_string`
                    if (options.quoted_string === undefined || options.quoted_string === null) {
                        options.quoted_string = false;
                    }
                    else {
                        // todo
                    }
                    // Normalize option `eof`
                    if (options.eof === undefined || options.eof === null) {
                        options.eof = true;
                    }
                    else {
                        // todo
                    }
                    // Normalize option `escape`
                    if (options.escape === undefined || options.escape === null) {
                        options.escape = '"';
                    }
                    else if (Buffer.isBuffer(options.escape)) {
                        options.escape = options.escape.toString();
                    }
                    else if (typeof options.escape !== 'string') {
                        return Error(`Invalid Option: escape must be a buffer or a string, got ${JSON.stringify(options.escape)}`);
                    }
                    if (options.escape.length > 1) {
                        return Error(`Invalid Option: escape must be one character, got ${options.escape.length} characters`);
                    }
                    // Normalize option `header`
                    if (options.header === undefined || options.header === null) {
                        options.header = false;
                    }
                    else {
                        // todo
                    }
                    // Normalize option `columns`
                    options.columns = this.normalize_columns(options.columns);
                    // Normalize option `quoted`
                    if (options.quoted === undefined || options.quoted === null) {
                        options.quoted = false;
                    }
                    else {
                        // todo
                    }
                    // Normalize option `cast`
                    if (options.cast === undefined || options.cast === null) {
                        options.cast = {};
                    }
                    else {
                        // todo
                    }
                    // Normalize option cast.bigint
                    if (options.cast.bigint === undefined || options.cast.bigint === null) {
                        // Cast boolean to string by default
                        options.cast.bigint = value => '' + value;
                    }
                    // Normalize option cast.boolean
                    if (options.cast.boolean === undefined || options.cast.boolean === null) {
                        // Cast boolean to string by default
                        options.cast.boolean = value => value ? '1' : '';
                    }
                    // Normalize option cast.date
                    if (options.cast.date === undefined || options.cast.date === null) {
                        // Cast date to timestamp string by default
                        options.cast.date = value => '' + value.getTime();
                    }
                    // Normalize option cast.number
                    if (options.cast.number === undefined || options.cast.number === null) {
                        // Cast number to string using native casting by default
                        options.cast.number = value => '' + value;
                    }
                    // Normalize option cast.object
                    if (options.cast.object === undefined || options.cast.object === null) {
                        // Stringify object as JSON by default
                        options.cast.object = value => JSON.stringify(value);
                    }
                    // Normalize option cast.string
                    if (options.cast.string === undefined || options.cast.string === null) {
                        // Leave string untouched
                        options.cast.string = function (value) { return value; };
                    }
                    // Normalize option `record_delimiter`
                    if (options.record_delimiter === undefined || options.record_delimiter === null) {
                        options.record_delimiter = '\n';
                    }
                    else if (Buffer.isBuffer(options.record_delimiter)) {
                        options.record_delimiter = options.record_delimiter.toString();
                    }
                    else if (typeof options.record_delimiter !== 'string') {
                        return Error(`Invalid Option: record_delimiter must be a buffer or a string, got ${JSON.stringify(options.record_delimiter)}`);
                    }
                }
                _transform(chunk, encoding, callback) {
                    if (this.state.stop === true) {
                        return;
                    }
                    // Chunk validation
                    if (!Array.isArray(chunk) && typeof chunk !== 'object') {
                        this.state.stop = true;
                        return callback(Error(`Invalid Record: expect an array or an object, got ${JSON.stringify(chunk)}`));
                    }
                    // Detect columns from the first record
                    if (this.info.records === 0) {
                        if (Array.isArray(chunk)) {
                            if (this.options.header === true && !this.options.columns) {
                                this.state.stop = true;
                                return callback(Error('Undiscoverable Columns: header option requires column option or object records'));
                            }
                        }
                        else if (this.options.columns === undefined || this.options.columns === null) {
                            this.options.columns = this.normalize_columns(Object.keys(chunk));
                        }
                    }
                    // Emit the header
                    if (this.info.records === 0) {
                        this.bom();
                        this.headers();
                    }
                    // Emit and stringify the record if an object or an array
                    try {
                        this.emit('record', chunk, this.info.records);
                    }
                    catch (err) {
                        this.state.stop = true;
                        return this.emit('error', err);
                    }
                    // Convert the record into a string
                    let chunk_string;
                    if (this.options.eof) {
                        chunk_string = this.stringify(chunk);
                        if (chunk_string === undefined) {
                            return;
                        }
                        else {
                            chunk_string = chunk_string + this.options.record_delimiter;
                        }
                    }
                    else {
                        chunk_string = this.stringify(chunk);
                        if (chunk_string === undefined) {
                            return;
                        }
                        else {
                            if (this.options.header || this.info.records) {
                                chunk_string = this.options.record_delimiter + chunk_string;
                            }
                        }
                    }
                    // Emit the csv
                    this.info.records++;
                    this.push(chunk_string);
                    callback();
                }
                _flush(callback) {
                    if (this.info.records === 0) {
                        this.bom();
                        this.headers();
                    }
                    callback();
                }
                stringify(chunk, chunkIsHeader = false) {
                    if (typeof chunk !== 'object') {
                        return chunk;
                    }
                    const { columns, header } = this.options;
                    const record = [];
                    // Record is an array
                    if (Array.isArray(chunk)) {
                        // We are getting an array but the user has specified output columns. In
                        // this case, we respect the columns indexes
                        if (columns) {
                            chunk.splice(columns.length);
                        }
                        // Cast record elements
                        for (let i = 0; i < chunk.length; i++) {
                            const field = chunk[i];
                            const [err, value] = this.__cast(field, {
                                index: i, column: i, records: this.info.records, header: chunkIsHeader
                            });
                            if (err) {
                                this.emit('error', err);
                                return;
                            }
                            record[i] = [value, field];
                        }
                        // Record is a literal object
                    }
                    else {
                        if (columns) {
                            for (let i = 0; i < columns.length; i++) {
                                const field = get(chunk, columns[i].key);
                                const [err, value] = this.__cast(field, {
                                    index: i, column: columns[i].key, records: this.info.records, header: chunkIsHeader
                                });
                                if (err) {
                                    this.emit('error', err);
                                    return;
                                }
                                record[i] = [value, field];
                            }
                        }
                        else {
                            for (let column of chunk) {
                                const field = chunk[column];
                                const [err, value] = this.__cast(field, {
                                    index: i, column: columns[i].key, records: this.info.records, header: chunkIsHeader
                                });
                                if (err) {
                                    this.emit('error', err);
                                    return;
                                }
                                record.push([value, field]);
                            }
                        }
                    }
                    let csvrecord = '';
                    for (let i = 0; i < record.length; i++) {
                        let options, err;
                        let [value, field] = record[i];
                        if (typeof value === "string") {
                            options = this.options;
                        }
                        else if (isObject(value)) {
                            // let { value, ...options } = value
                            options = value;
                            value = options.value;
                            delete options.value;
                            if (typeof value !== "string" && value !== undefined && value !== null) {
                                this.emit("error", Error(`Invalid Casting Value: returned value must return a string, null or undefined, got ${JSON.stringify(value)}`));
                                return;
                            }
                            options = { ...this.options, ...options };
                            if (err = this.normalize(options)) {
                                this.emit("error", err);
                                return;
                            }
                        }
                        else if (value === undefined || value === null) {
                            options = this.options;
                        }
                        else {
                            this.emit("error", Error(`Invalid Casting Value: returned value must return a string, an object, null or undefined, got ${JSON.stringify(value)}`));
                            return;
                        }
                        const { delimiter, escape, quote, quoted, quoted_empty, quoted_string, quoted_match, record_delimiter } = options;
                        if (value) {
                            if (typeof value !== 'string') {
                                this.emit("error", Error(`Formatter must return a string, null or undefined, got ${JSON.stringify(value)}`));
                                return null;
                            }
                            const containsdelimiter = delimiter.length && value.indexOf(delimiter) >= 0;
                            const containsQuote = (quote !== '') && value.indexOf(quote) >= 0;
                            const containsEscape = value.indexOf(escape) >= 0 && (escape !== quote);
                            const containsRecordDelimiter = value.indexOf(record_delimiter) >= 0;
                            const quotedString = quoted_string && typeof field === 'string';
                            let quotedMatch = quoted_match && quoted_match.filter(quoted_match => {
                                if (typeof quoted_match === 'string') {
                                    return value.indexOf(quoted_match) !== -1;
                                }
                                else {
                                    return quoted_match.test(value);
                                }
                            });
                            quotedMatch = quotedMatch && quotedMatch.length > 0;
                            const shouldQuote = containsQuote === true || containsdelimiter || containsRecordDelimiter || quoted || quotedString || quotedMatch;
                            if (shouldQuote === true && containsEscape === true) {
                                const regexp = escape === '\\'
                                    ? new RegExp(escape + escape, 'g')
                                    : new RegExp(escape, 'g');
                                value = value.replace(regexp, escape + escape);
                            }
                            if (containsQuote === true) {
                                const regexp = new RegExp(quote, 'g');
                                value = value.replace(regexp, escape + quote);
                            }
                            if (shouldQuote === true) {
                                value = quote + value + quote;
                            }
                            csvrecord += value;
                        }
                        else if (quoted_empty === true || (field === '' && quoted_string === true && quoted_empty !== false)) {
                            csvrecord += quote + quote;
                        }
                        if (i !== record.length - 1) {
                            csvrecord += delimiter;
                        }
                    }
                    return csvrecord;
                }
                bom() {
                    if (this.options.bom !== true) {
                        return;
                    }
                    this.push(bom_utf8);
                }
                headers() {
                    if (this.options.header === false) {
                        return;
                    }
                    if (this.options.columns === undefined) {
                        return;
                    }
                    let headers = this.options.columns.map(column => column.header);
                    if (this.options.eof) {
                        headers = this.stringify(headers, true) + this.options.record_delimiter;
                    }
                    else {
                        headers = this.stringify(headers);
                    }
                    this.push(headers);
                }
                __cast(value, context) {
                    const type = typeof value;
                    try {
                        if (type === 'string') { // Fine for 99% of the cases
                            return [undefined, this.options.cast.string(value, context)];
                        }
                        else if (type === 'bigint') {
                            return [undefined, this.options.cast.bigint(value, context)];
                        }
                        else if (type === 'number') {
                            return [undefined, this.options.cast.number(value, context)];
                        }
                        else if (type === 'boolean') {
                            return [undefined, this.options.cast.boolean(value, context)];
                        }
                        else if (value instanceof Date) {
                            return [undefined, this.options.cast.date(value, context)];
                        }
                        else if (type === 'object' && value !== null) {
                            return [undefined, this.options.cast.object(value, context)];
                        }
                        else {
                            return [undefined, value, value];
                        }
                    }
                    catch (err) {
                        return [err];
                    }
                }
                normalize_columns(columns) {
                    if (columns === undefined || columns === null) {
                        return undefined;
                    }
                    if (typeof columns !== 'object') {
                        throw Error('Invalid option "columns": expect an array or an object');
                    }
                    if (!Array.isArray(columns)) {
                        const newcolumns = [];
                        for (let k in columns) {
                            newcolumns.push({
                                key: k,
                                header: columns[k]
                            });
                        }
                        columns = newcolumns;
                    }
                    else {
                        const newcolumns = [];
                        for (let column of columns) {
                            if (typeof column === 'string') {
                                newcolumns.push({
                                    key: column,
                                    header: column
                                });
                            }
                            else if (typeof column === 'object' && column !== undefined && !Array.isArray(column)) {
                                if (!column.key) {
                                    throw Error('Invalid column definition: property "key" is required');
                                }
                                if (column.header === undefined) {
                                    column.header = column.key;
                                }
                                newcolumns.push(column);
                            }
                            else {
                                throw Error('Invalid column definition: expect a string or an object');
                            }
                        }
                        columns = newcolumns;
                    }
                    return columns;
                }
            }
            const stringify = function () {
                let data, options, callback;
                for (let i in arguments) {
                    const argument = arguments[i];
                    const type = typeof argument;
                    if (data === undefined && (Array.isArray(argument))) {
                        data = argument;
                    }
                    else if (options === undefined && isObject(argument)) {
                        options = argument;
                    }
                    else if (callback === undefined && type === 'function') {
                        callback = argument;
                    }
                    else {
                        throw new CsvError('CSV_INVALID_ARGUMENT', [
                            'Invalid argument:',
                            `got ${JSON.stringify(argument)} at index ${i}`
                        ]);
                    }
                }
                const stringifier = new Stringifier(options);
                if (callback) {
                    const chunks = [];
                    stringifier.on('readable', function () {
                        let chunk;
                        while ((chunk = this.read()) !== null) {
                            chunks.push(chunk);
                        }
                    });
                    stringifier.on('error', function (err) {
                        callback(err);
                    });
                    stringifier.on('end', function () {
                        callback(undefined, chunks.join(''));
                    });
                }
                if (data !== undefined) {
                    // Give a chance for events to be registered later
                    if (typeof setImmediate === 'function') {
                        setImmediate(function () {
                            for (let record of data) {
                                stringifier.write(record);
                            }
                            stringifier.end();
                        });
                    }
                    else {
                        for (let record of data) {
                            stringifier.write(record);
                        }
                        stringifier.end();
                    }
                }
                return stringifier;
            };
            class CsvError extends Error {
                constructor(code, message, ...contexts) {
                    if (Array.isArray(message))
                        message = message.join(' ');
                    super(message);
                    if (Error.captureStackTrace !== undefined) {
                        Error.captureStackTrace(this, CsvError);
                    }
                    this.code = code;
                    for (const context of contexts) {
                        for (const key in context) {
                            const value = context[key];
                            this[key] = Buffer.isBuffer(value) ? value.toString() : value == null ? value : JSON.parse(JSON.stringify(value));
                        }
                    }
                }
            }
            stringify.Stringifier = Stringifier;
            stringify.CsvError = CsvError;
            module.exports = stringify;
            const isObject = function (obj) {
                return typeof obj === 'object' && obj !== null && !Array.isArray(obj);
            };
            const underscore = function (str) {
                return str.replace(/([A-Z])/g, function (_, match) {
                    return '_' + match.toLowerCase();
                });
            };
            // Lodash implementation of `get`
            const charCodeOfDot = '.'.charCodeAt(0);
            const reEscapeChar = /\\(\\)?/g;
            const rePropName = RegExp(
            // Match anything that isn't a dot or bracket.
            '[^.[\\]]+' + '|' +
                // Or match property names within brackets.
                '\\[(?:' +
                // Match a non-string expression.
                '([^"\'][^[]*)' + '|' +
                // Or match strings (supports escaping characters).
                '(["\'])((?:(?!\\2)[^\\\\]|\\\\.)*?)\\2' +
                ')\\]' + '|' +
                // Or match "" as the space between consecutive dots or empty brackets.
                '(?=(?:\\.|\\[\\])(?:\\.|\\[\\]|$))', 'g');
            const reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/;
            const reIsPlainProp = /^\w*$/;
            const getTag = function (value) {
                if (!value)
                    value === undefined ? '[object Undefined]' : '[object Null]';
                return Object.prototype.toString.call(value);
            };
            const isKey = function (value, object) {
                if (Array.isArray(value)) {
                    return false;
                }
                const type = typeof value;
                if (type === 'number' || type === 'symbol' || type === 'boolean' || !value || isSymbol(value)) {
                    return true;
                }
                return reIsPlainProp.test(value) || !reIsDeepProp.test(value) ||
                    (object != null && value in Object(object));
            };
            const isSymbol = function (value) {
                const type = typeof value;
                return type === 'symbol' || (type === 'object' && value && getTag(value) === '[object Symbol]');
            };
            const stringToPath = function (string) {
                const result = [];
                if (string.charCodeAt(0) === charCodeOfDot) {
                    result.push('');
                }
                string.replace(rePropName, function (match, expression, quote, subString) {
                    let key = match;
                    if (quote) {
                        key = subString.replace(reEscapeChar, '$1');
                    }
                    else if (expression) {
                        key = expression.trim();
                    }
                    result.push(key);
                });
                return result;
            };
            const castPath = function (value, object) {
                if (Array.isArray(value)) {
                    return value;
                }
                else {
                    return isKey(value, object) ? [value] : stringToPath(value);
                }
            };
            const toKey = function (value) {
                if (typeof value === 'string' || isSymbol(value))
                    return value;
                const result = `${value}`;
                return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
            };
            const get = function (object, path) {
                path = castPath(path, object);
                let index = 0;
                const length = path.length;
                while (object != null && index < length) {
                    object = object[toKey(path[index++])];
                }
                return (index && index === length) ? object : undefined;
            };
            /***/ 
        }),
        /***/ "./node_modules/csv-stringify/lib/sync.js": 
        /*!************************************************!*\
          !*** ./node_modules/csv-stringify/lib/sync.js ***!
          \************************************************/
        /***/ ((module, __unused_webpack_exports, __webpack_require__) => {
            const stringify = __webpack_require__(/*! . */ "./node_modules/csv-stringify/lib/index.js");
            const { StringDecoder } = __webpack_require__(/*! string_decoder */ "string_decoder");
            module.exports = function (records, options = {}) {
                const data = [];
                if (Buffer.isBuffer(records)) {
                    const decoder = new StringDecoder();
                    records = decoder.write(records);
                }
                function onData(record) {
                    if (record) {
                        data.push(record.toString());
                    }
                }
                let stringifier = new stringify.Stringifier(options);
                stringifier.on('data', onData);
                for (let record of records) {
                    stringifier.write(record);
                }
                stringifier.end();
                stringifier.off('data', onData);
                return data.join('');
            };
            /***/ 
        }),
        /***/ "./node_modules/date-fns/esm/_lib/addLeadingZeros/index.js": 
        /*!*****************************************************************!*\
          !*** ./node_modules/date-fns/esm/_lib/addLeadingZeros/index.js ***!
          \*****************************************************************/
        /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony export */ __webpack_require__.d(__webpack_exports__, {
                /* harmony export */ "default": () => ( /* binding */addLeadingZeros)
                /* harmony export */ 
            });
            function addLeadingZeros(number, targetLength) {
                var sign = number < 0 ? '-' : '';
                var output = Math.abs(number).toString();
                while (output.length < targetLength) {
                    output = '0' + output;
                }
                return sign + output;
            }
            /***/ 
        }),
        /***/ "./node_modules/date-fns/esm/_lib/assign/index.js": 
        /*!********************************************************!*\
          !*** ./node_modules/date-fns/esm/_lib/assign/index.js ***!
          \********************************************************/
        /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony export */ __webpack_require__.d(__webpack_exports__, {
                /* harmony export */ "default": () => ( /* binding */assign)
                /* harmony export */ 
            });
            function assign(target, object) {
                if (target == null) {
                    throw new TypeError('assign requires that input parameter not be null or undefined');
                }
                for (var property in object) {
                    if (Object.prototype.hasOwnProperty.call(object, property)) {
                        ;
                        target[property] = object[property];
                    }
                }
                return target;
            }
            /***/ 
        }),
        /***/ "./node_modules/date-fns/esm/_lib/defaultLocale/index.js": 
        /*!***************************************************************!*\
          !*** ./node_modules/date-fns/esm/_lib/defaultLocale/index.js ***!
          \***************************************************************/
        /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony export */ __webpack_require__.d(__webpack_exports__, {
                /* harmony export */ "default": () => (__WEBPACK_DEFAULT_EXPORT__)
                /* harmony export */ 
            });
            /* harmony import */ var _locale_en_US_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../locale/en-US/index.js */ "./node_modules/date-fns/esm/locale/en-US/index.js");
            /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_locale_en_US_index_js__WEBPACK_IMPORTED_MODULE_0__["default"]);
            /***/ 
        }),
        /***/ "./node_modules/date-fns/esm/_lib/defaultOptions/index.js": 
        /*!****************************************************************!*\
          !*** ./node_modules/date-fns/esm/_lib/defaultOptions/index.js ***!
          \****************************************************************/
        /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony export */ __webpack_require__.d(__webpack_exports__, {
                /* harmony export */ getDefaultOptions: () => ( /* binding */getDefaultOptions),
                /* harmony export */ setDefaultOptions: () => ( /* binding */setDefaultOptions)
                /* harmony export */ 
            });
            var defaultOptions = {};
            function getDefaultOptions() {
                return defaultOptions;
            }
            function setDefaultOptions(newOptions) {
                defaultOptions = newOptions;
            }
            /***/ 
        }),
        /***/ "./node_modules/date-fns/esm/_lib/format/formatters/index.js": 
        /*!*******************************************************************!*\
          !*** ./node_modules/date-fns/esm/_lib/format/formatters/index.js ***!
          \*******************************************************************/
        /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony export */ __webpack_require__.d(__webpack_exports__, {
                /* harmony export */ "default": () => (__WEBPACK_DEFAULT_EXPORT__)
                /* harmony export */ 
            });
            /* harmony import */ var _lib_getUTCDayOfYear_index_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../../_lib/getUTCDayOfYear/index.js */ "./node_modules/date-fns/esm/_lib/getUTCDayOfYear/index.js");
            /* harmony import */ var _lib_getUTCISOWeek_index_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../../_lib/getUTCISOWeek/index.js */ "./node_modules/date-fns/esm/_lib/getUTCISOWeek/index.js");
            /* harmony import */ var _lib_getUTCISOWeekYear_index_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../_lib/getUTCISOWeekYear/index.js */ "./node_modules/date-fns/esm/_lib/getUTCISOWeekYear/index.js");
            /* harmony import */ var _lib_getUTCWeek_index_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../../_lib/getUTCWeek/index.js */ "./node_modules/date-fns/esm/_lib/getUTCWeek/index.js");
            /* harmony import */ var _lib_getUTCWeekYear_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../_lib/getUTCWeekYear/index.js */ "./node_modules/date-fns/esm/_lib/getUTCWeekYear/index.js");
            /* harmony import */ var _addLeadingZeros_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../addLeadingZeros/index.js */ "./node_modules/date-fns/esm/_lib/addLeadingZeros/index.js");
            /* harmony import */ var _lightFormatters_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../lightFormatters/index.js */ "./node_modules/date-fns/esm/_lib/format/lightFormatters/index.js");
            var dayPeriodEnum = {
                am: 'am',
                pm: 'pm',
                midnight: 'midnight',
                noon: 'noon',
                morning: 'morning',
                afternoon: 'afternoon',
                evening: 'evening',
                night: 'night'
            };
            /*
             * |     | Unit                           |     | Unit                           |
             * |-----|--------------------------------|-----|--------------------------------|
             * |  a  | AM, PM                         |  A* | Milliseconds in day            |
             * |  b  | AM, PM, noon, midnight         |  B  | Flexible day period            |
             * |  c  | Stand-alone local day of week  |  C* | Localized hour w/ day period   |
             * |  d  | Day of month                   |  D  | Day of year                    |
             * |  e  | Local day of week              |  E  | Day of week                    |
             * |  f  |                                |  F* | Day of week in month           |
             * |  g* | Modified Julian day            |  G  | Era                            |
             * |  h  | Hour [1-12]                    |  H  | Hour [0-23]                    |
             * |  i! | ISO day of week                |  I! | ISO week of year               |
             * |  j* | Localized hour w/ day period   |  J* | Localized hour w/o day period  |
             * |  k  | Hour [1-24]                    |  K  | Hour [0-11]                    |
             * |  l* | (deprecated)                   |  L  | Stand-alone month              |
             * |  m  | Minute                         |  M  | Month                          |
             * |  n  |                                |  N  |                                |
             * |  o! | Ordinal number modifier        |  O  | Timezone (GMT)                 |
             * |  p! | Long localized time            |  P! | Long localized date            |
             * |  q  | Stand-alone quarter            |  Q  | Quarter                        |
             * |  r* | Related Gregorian year         |  R! | ISO week-numbering year        |
             * |  s  | Second                         |  S  | Fraction of second             |
             * |  t! | Seconds timestamp              |  T! | Milliseconds timestamp         |
             * |  u  | Extended year                  |  U* | Cyclic year                    |
             * |  v* | Timezone (generic non-locat.)  |  V* | Timezone (location)            |
             * |  w  | Local week of year             |  W* | Week of month                  |
             * |  x  | Timezone (ISO-8601 w/o Z)      |  X  | Timezone (ISO-8601)            |
             * |  y  | Year (abs)                     |  Y  | Local week-numbering year      |
             * |  z  | Timezone (specific non-locat.) |  Z* | Timezone (aliases)             |
             *
             * Letters marked by * are not implemented but reserved by Unicode standard.
             *
             * Letters marked by ! are non-standard, but implemented by date-fns:
             * - `o` modifies the previous token to turn it into an ordinal (see `format` docs)
             * - `i` is ISO day of week. For `i` and `ii` is returns numeric ISO week days,
             *   i.e. 7 for Sunday, 1 for Monday, etc.
             * - `I` is ISO week of year, as opposed to `w` which is local week of year.
             * - `R` is ISO week-numbering year, as opposed to `Y` which is local week-numbering year.
             *   `R` is supposed to be used in conjunction with `I` and `i`
             *   for universal ISO week-numbering date, whereas
             *   `Y` is supposed to be used in conjunction with `w` and `e`
             *   for week-numbering date specific to the locale.
             * - `P` is long localized date format
             * - `p` is long localized time format
             */
            var formatters = {
                // Era
                G: function G(date, token, localize) {
                    var era = date.getUTCFullYear() > 0 ? 1 : 0;
                    switch (token) {
                        // AD, BC
                        case 'G':
                        case 'GG':
                        case 'GGG':
                            return localize.era(era, {
                                width: 'abbreviated'
                            });
                        // A, B
                        case 'GGGGG':
                            return localize.era(era, {
                                width: 'narrow'
                            });
                        // Anno Domini, Before Christ
                        case 'GGGG':
                        default:
                            return localize.era(era, {
                                width: 'wide'
                            });
                    }
                },
                // Year
                y: function y(date, token, localize) {
                    // Ordinal number
                    if (token === 'yo') {
                        var signedYear = date.getUTCFullYear();
                        // Returns 1 for 1 BC (which is year 0 in JavaScript)
                        var year = signedYear > 0 ? signedYear : 1 - signedYear;
                        return localize.ordinalNumber(year, {
                            unit: 'year'
                        });
                    }
                    return _lightFormatters_index_js__WEBPACK_IMPORTED_MODULE_0__["default"].y(date, token);
                },
                // Local week-numbering year
                Y: function Y(date, token, localize, options) {
                    var signedWeekYear = (0, _lib_getUTCWeekYear_index_js__WEBPACK_IMPORTED_MODULE_1__["default"])(date, options);
                    // Returns 1 for 1 BC (which is year 0 in JavaScript)
                    var weekYear = signedWeekYear > 0 ? signedWeekYear : 1 - signedWeekYear;
                    // Two digit year
                    if (token === 'YY') {
                        var twoDigitYear = weekYear % 100;
                        return (0, _addLeadingZeros_index_js__WEBPACK_IMPORTED_MODULE_2__["default"])(twoDigitYear, 2);
                    }
                    // Ordinal number
                    if (token === 'Yo') {
                        return localize.ordinalNumber(weekYear, {
                            unit: 'year'
                        });
                    }
                    // Padding
                    return (0, _addLeadingZeros_index_js__WEBPACK_IMPORTED_MODULE_2__["default"])(weekYear, token.length);
                },
                // ISO week-numbering year
                R: function R(date, token) {
                    var isoWeekYear = (0, _lib_getUTCISOWeekYear_index_js__WEBPACK_IMPORTED_MODULE_3__["default"])(date);
                    // Padding
                    return (0, _addLeadingZeros_index_js__WEBPACK_IMPORTED_MODULE_2__["default"])(isoWeekYear, token.length);
                },
                // Extended year. This is a single number designating the year of this calendar system.
                // The main difference between `y` and `u` localizers are B.C. years:
                // | Year | `y` | `u` |
                // |------|-----|-----|
                // | AC 1 |   1 |   1 |
                // | BC 1 |   1 |   0 |
                // | BC 2 |   2 |  -1 |
                // Also `yy` always returns the last two digits of a year,
                // while `uu` pads single digit years to 2 characters and returns other years unchanged.
                u: function u(date, token) {
                    var year = date.getUTCFullYear();
                    return (0, _addLeadingZeros_index_js__WEBPACK_IMPORTED_MODULE_2__["default"])(year, token.length);
                },
                // Quarter
                Q: function Q(date, token, localize) {
                    var quarter = Math.ceil((date.getUTCMonth() + 1) / 3);
                    switch (token) {
                        // 1, 2, 3, 4
                        case 'Q':
                            return String(quarter);
                        // 01, 02, 03, 04
                        case 'QQ':
                            return (0, _addLeadingZeros_index_js__WEBPACK_IMPORTED_MODULE_2__["default"])(quarter, 2);
                        // 1st, 2nd, 3rd, 4th
                        case 'Qo':
                            return localize.ordinalNumber(quarter, {
                                unit: 'quarter'
                            });
                        // Q1, Q2, Q3, Q4
                        case 'QQQ':
                            return localize.quarter(quarter, {
                                width: 'abbreviated',
                                context: 'formatting'
                            });
                        // 1, 2, 3, 4 (narrow quarter; could be not numerical)
                        case 'QQQQQ':
                            return localize.quarter(quarter, {
                                width: 'narrow',
                                context: 'formatting'
                            });
                        // 1st quarter, 2nd quarter, ...
                        case 'QQQQ':
                        default:
                            return localize.quarter(quarter, {
                                width: 'wide',
                                context: 'formatting'
                            });
                    }
                },
                // Stand-alone quarter
                q: function q(date, token, localize) {
                    var quarter = Math.ceil((date.getUTCMonth() + 1) / 3);
                    switch (token) {
                        // 1, 2, 3, 4
                        case 'q':
                            return String(quarter);
                        // 01, 02, 03, 04
                        case 'qq':
                            return (0, _addLeadingZeros_index_js__WEBPACK_IMPORTED_MODULE_2__["default"])(quarter, 2);
                        // 1st, 2nd, 3rd, 4th
                        case 'qo':
                            return localize.ordinalNumber(quarter, {
                                unit: 'quarter'
                            });
                        // Q1, Q2, Q3, Q4
                        case 'qqq':
                            return localize.quarter(quarter, {
                                width: 'abbreviated',
                                context: 'standalone'
                            });
                        // 1, 2, 3, 4 (narrow quarter; could be not numerical)
                        case 'qqqqq':
                            return localize.quarter(quarter, {
                                width: 'narrow',
                                context: 'standalone'
                            });
                        // 1st quarter, 2nd quarter, ...
                        case 'qqqq':
                        default:
                            return localize.quarter(quarter, {
                                width: 'wide',
                                context: 'standalone'
                            });
                    }
                },
                // Month
                M: function M(date, token, localize) {
                    var month = date.getUTCMonth();
                    switch (token) {
                        case 'M':
                        case 'MM':
                            return _lightFormatters_index_js__WEBPACK_IMPORTED_MODULE_0__["default"].M(date, token);
                        // 1st, 2nd, ..., 12th
                        case 'Mo':
                            return localize.ordinalNumber(month + 1, {
                                unit: 'month'
                            });
                        // Jan, Feb, ..., Dec
                        case 'MMM':
                            return localize.month(month, {
                                width: 'abbreviated',
                                context: 'formatting'
                            });
                        // J, F, ..., D
                        case 'MMMMM':
                            return localize.month(month, {
                                width: 'narrow',
                                context: 'formatting'
                            });
                        // January, February, ..., December
                        case 'MMMM':
                        default:
                            return localize.month(month, {
                                width: 'wide',
                                context: 'formatting'
                            });
                    }
                },
                // Stand-alone month
                L: function L(date, token, localize) {
                    var month = date.getUTCMonth();
                    switch (token) {
                        // 1, 2, ..., 12
                        case 'L':
                            return String(month + 1);
                        // 01, 02, ..., 12
                        case 'LL':
                            return (0, _addLeadingZeros_index_js__WEBPACK_IMPORTED_MODULE_2__["default"])(month + 1, 2);
                        // 1st, 2nd, ..., 12th
                        case 'Lo':
                            return localize.ordinalNumber(month + 1, {
                                unit: 'month'
                            });
                        // Jan, Feb, ..., Dec
                        case 'LLL':
                            return localize.month(month, {
                                width: 'abbreviated',
                                context: 'standalone'
                            });
                        // J, F, ..., D
                        case 'LLLLL':
                            return localize.month(month, {
                                width: 'narrow',
                                context: 'standalone'
                            });
                        // January, February, ..., December
                        case 'LLLL':
                        default:
                            return localize.month(month, {
                                width: 'wide',
                                context: 'standalone'
                            });
                    }
                },
                // Local week of year
                w: function w(date, token, localize, options) {
                    var week = (0, _lib_getUTCWeek_index_js__WEBPACK_IMPORTED_MODULE_4__["default"])(date, options);
                    if (token === 'wo') {
                        return localize.ordinalNumber(week, {
                            unit: 'week'
                        });
                    }
                    return (0, _addLeadingZeros_index_js__WEBPACK_IMPORTED_MODULE_2__["default"])(week, token.length);
                },
                // ISO week of year
                I: function I(date, token, localize) {
                    var isoWeek = (0, _lib_getUTCISOWeek_index_js__WEBPACK_IMPORTED_MODULE_5__["default"])(date);
                    if (token === 'Io') {
                        return localize.ordinalNumber(isoWeek, {
                            unit: 'week'
                        });
                    }
                    return (0, _addLeadingZeros_index_js__WEBPACK_IMPORTED_MODULE_2__["default"])(isoWeek, token.length);
                },
                // Day of the month
                d: function d(date, token, localize) {
                    if (token === 'do') {
                        return localize.ordinalNumber(date.getUTCDate(), {
                            unit: 'date'
                        });
                    }
                    return _lightFormatters_index_js__WEBPACK_IMPORTED_MODULE_0__["default"].d(date, token);
                },
                // Day of year
                D: function D(date, token, localize) {
                    var dayOfYear = (0, _lib_getUTCDayOfYear_index_js__WEBPACK_IMPORTED_MODULE_6__["default"])(date);
                    if (token === 'Do') {
                        return localize.ordinalNumber(dayOfYear, {
                            unit: 'dayOfYear'
                        });
                    }
                    return (0, _addLeadingZeros_index_js__WEBPACK_IMPORTED_MODULE_2__["default"])(dayOfYear, token.length);
                },
                // Day of week
                E: function E(date, token, localize) {
                    var dayOfWeek = date.getUTCDay();
                    switch (token) {
                        // Tue
                        case 'E':
                        case 'EE':
                        case 'EEE':
                            return localize.day(dayOfWeek, {
                                width: 'abbreviated',
                                context: 'formatting'
                            });
                        // T
                        case 'EEEEE':
                            return localize.day(dayOfWeek, {
                                width: 'narrow',
                                context: 'formatting'
                            });
                        // Tu
                        case 'EEEEEE':
                            return localize.day(dayOfWeek, {
                                width: 'short',
                                context: 'formatting'
                            });
                        // Tuesday
                        case 'EEEE':
                        default:
                            return localize.day(dayOfWeek, {
                                width: 'wide',
                                context: 'formatting'
                            });
                    }
                },
                // Local day of week
                e: function e(date, token, localize, options) {
                    var dayOfWeek = date.getUTCDay();
                    var localDayOfWeek = (dayOfWeek - options.weekStartsOn + 8) % 7 || 7;
                    switch (token) {
                        // Numerical value (Nth day of week with current locale or weekStartsOn)
                        case 'e':
                            return String(localDayOfWeek);
                        // Padded numerical value
                        case 'ee':
                            return (0, _addLeadingZeros_index_js__WEBPACK_IMPORTED_MODULE_2__["default"])(localDayOfWeek, 2);
                        // 1st, 2nd, ..., 7th
                        case 'eo':
                            return localize.ordinalNumber(localDayOfWeek, {
                                unit: 'day'
                            });
                        case 'eee':
                            return localize.day(dayOfWeek, {
                                width: 'abbreviated',
                                context: 'formatting'
                            });
                        // T
                        case 'eeeee':
                            return localize.day(dayOfWeek, {
                                width: 'narrow',
                                context: 'formatting'
                            });
                        // Tu
                        case 'eeeeee':
                            return localize.day(dayOfWeek, {
                                width: 'short',
                                context: 'formatting'
                            });
                        // Tuesday
                        case 'eeee':
                        default:
                            return localize.day(dayOfWeek, {
                                width: 'wide',
                                context: 'formatting'
                            });
                    }
                },
                // Stand-alone local day of week
                c: function c(date, token, localize, options) {
                    var dayOfWeek = date.getUTCDay();
                    var localDayOfWeek = (dayOfWeek - options.weekStartsOn + 8) % 7 || 7;
                    switch (token) {
                        // Numerical value (same as in `e`)
                        case 'c':
                            return String(localDayOfWeek);
                        // Padded numerical value
                        case 'cc':
                            return (0, _addLeadingZeros_index_js__WEBPACK_IMPORTED_MODULE_2__["default"])(localDayOfWeek, token.length);
                        // 1st, 2nd, ..., 7th
                        case 'co':
                            return localize.ordinalNumber(localDayOfWeek, {
                                unit: 'day'
                            });
                        case 'ccc':
                            return localize.day(dayOfWeek, {
                                width: 'abbreviated',
                                context: 'standalone'
                            });
                        // T
                        case 'ccccc':
                            return localize.day(dayOfWeek, {
                                width: 'narrow',
                                context: 'standalone'
                            });
                        // Tu
                        case 'cccccc':
                            return localize.day(dayOfWeek, {
                                width: 'short',
                                context: 'standalone'
                            });
                        // Tuesday
                        case 'cccc':
                        default:
                            return localize.day(dayOfWeek, {
                                width: 'wide',
                                context: 'standalone'
                            });
                    }
                },
                // ISO day of week
                i: function i(date, token, localize) {
                    var dayOfWeek = date.getUTCDay();
                    var isoDayOfWeek = dayOfWeek === 0 ? 7 : dayOfWeek;
                    switch (token) {
                        // 2
                        case 'i':
                            return String(isoDayOfWeek);
                        // 02
                        case 'ii':
                            return (0, _addLeadingZeros_index_js__WEBPACK_IMPORTED_MODULE_2__["default"])(isoDayOfWeek, token.length);
                        // 2nd
                        case 'io':
                            return localize.ordinalNumber(isoDayOfWeek, {
                                unit: 'day'
                            });
                        // Tue
                        case 'iii':
                            return localize.day(dayOfWeek, {
                                width: 'abbreviated',
                                context: 'formatting'
                            });
                        // T
                        case 'iiiii':
                            return localize.day(dayOfWeek, {
                                width: 'narrow',
                                context: 'formatting'
                            });
                        // Tu
                        case 'iiiiii':
                            return localize.day(dayOfWeek, {
                                width: 'short',
                                context: 'formatting'
                            });
                        // Tuesday
                        case 'iiii':
                        default:
                            return localize.day(dayOfWeek, {
                                width: 'wide',
                                context: 'formatting'
                            });
                    }
                },
                // AM or PM
                a: function a(date, token, localize) {
                    var hours = date.getUTCHours();
                    var dayPeriodEnumValue = hours / 12 >= 1 ? 'pm' : 'am';
                    switch (token) {
                        case 'a':
                        case 'aa':
                            return localize.dayPeriod(dayPeriodEnumValue, {
                                width: 'abbreviated',
                                context: 'formatting'
                            });
                        case 'aaa':
                            return localize.dayPeriod(dayPeriodEnumValue, {
                                width: 'abbreviated',
                                context: 'formatting'
                            }).toLowerCase();
                        case 'aaaaa':
                            return localize.dayPeriod(dayPeriodEnumValue, {
                                width: 'narrow',
                                context: 'formatting'
                            });
                        case 'aaaa':
                        default:
                            return localize.dayPeriod(dayPeriodEnumValue, {
                                width: 'wide',
                                context: 'formatting'
                            });
                    }
                },
                // AM, PM, midnight, noon
                b: function b(date, token, localize) {
                    var hours = date.getUTCHours();
                    var dayPeriodEnumValue;
                    if (hours === 12) {
                        dayPeriodEnumValue = dayPeriodEnum.noon;
                    }
                    else if (hours === 0) {
                        dayPeriodEnumValue = dayPeriodEnum.midnight;
                    }
                    else {
                        dayPeriodEnumValue = hours / 12 >= 1 ? 'pm' : 'am';
                    }
                    switch (token) {
                        case 'b':
                        case 'bb':
                            return localize.dayPeriod(dayPeriodEnumValue, {
                                width: 'abbreviated',
                                context: 'formatting'
                            });
                        case 'bbb':
                            return localize.dayPeriod(dayPeriodEnumValue, {
                                width: 'abbreviated',
                                context: 'formatting'
                            }).toLowerCase();
                        case 'bbbbb':
                            return localize.dayPeriod(dayPeriodEnumValue, {
                                width: 'narrow',
                                context: 'formatting'
                            });
                        case 'bbbb':
                        default:
                            return localize.dayPeriod(dayPeriodEnumValue, {
                                width: 'wide',
                                context: 'formatting'
                            });
                    }
                },
                // in the morning, in the afternoon, in the evening, at night
                B: function B(date, token, localize) {
                    var hours = date.getUTCHours();
                    var dayPeriodEnumValue;
                    if (hours >= 17) {
                        dayPeriodEnumValue = dayPeriodEnum.evening;
                    }
                    else if (hours >= 12) {
                        dayPeriodEnumValue = dayPeriodEnum.afternoon;
                    }
                    else if (hours >= 4) {
                        dayPeriodEnumValue = dayPeriodEnum.morning;
                    }
                    else {
                        dayPeriodEnumValue = dayPeriodEnum.night;
                    }
                    switch (token) {
                        case 'B':
                        case 'BB':
                        case 'BBB':
                            return localize.dayPeriod(dayPeriodEnumValue, {
                                width: 'abbreviated',
                                context: 'formatting'
                            });
                        case 'BBBBB':
                            return localize.dayPeriod(dayPeriodEnumValue, {
                                width: 'narrow',
                                context: 'formatting'
                            });
                        case 'BBBB':
                        default:
                            return localize.dayPeriod(dayPeriodEnumValue, {
                                width: 'wide',
                                context: 'formatting'
                            });
                    }
                },
                // Hour [1-12]
                h: function h(date, token, localize) {
                    if (token === 'ho') {
                        var hours = date.getUTCHours() % 12;
                        if (hours === 0)
                            hours = 12;
                        return localize.ordinalNumber(hours, {
                            unit: 'hour'
                        });
                    }
                    return _lightFormatters_index_js__WEBPACK_IMPORTED_MODULE_0__["default"].h(date, token);
                },
                // Hour [0-23]
                H: function H(date, token, localize) {
                    if (token === 'Ho') {
                        return localize.ordinalNumber(date.getUTCHours(), {
                            unit: 'hour'
                        });
                    }
                    return _lightFormatters_index_js__WEBPACK_IMPORTED_MODULE_0__["default"].H(date, token);
                },
                // Hour [0-11]
                K: function K(date, token, localize) {
                    var hours = date.getUTCHours() % 12;
                    if (token === 'Ko') {
                        return localize.ordinalNumber(hours, {
                            unit: 'hour'
                        });
                    }
                    return (0, _addLeadingZeros_index_js__WEBPACK_IMPORTED_MODULE_2__["default"])(hours, token.length);
                },
                // Hour [1-24]
                k: function k(date, token, localize) {
                    var hours = date.getUTCHours();
                    if (hours === 0)
                        hours = 24;
                    if (token === 'ko') {
                        return localize.ordinalNumber(hours, {
                            unit: 'hour'
                        });
                    }
                    return (0, _addLeadingZeros_index_js__WEBPACK_IMPORTED_MODULE_2__["default"])(hours, token.length);
                },
                // Minute
                m: function m(date, token, localize) {
                    if (token === 'mo') {
                        return localize.ordinalNumber(date.getUTCMinutes(), {
                            unit: 'minute'
                        });
                    }
                    return _lightFormatters_index_js__WEBPACK_IMPORTED_MODULE_0__["default"].m(date, token);
                },
                // Second
                s: function s(date, token, localize) {
                    if (token === 'so') {
                        return localize.ordinalNumber(date.getUTCSeconds(), {
                            unit: 'second'
                        });
                    }
                    return _lightFormatters_index_js__WEBPACK_IMPORTED_MODULE_0__["default"].s(date, token);
                },
                // Fraction of second
                S: function S(date, token) {
                    return _lightFormatters_index_js__WEBPACK_IMPORTED_MODULE_0__["default"].S(date, token);
                },
                // Timezone (ISO-8601. If offset is 0, output is always `'Z'`)
                X: function X(date, token, _localize, options) {
                    var originalDate = options._originalDate || date;
                    var timezoneOffset = originalDate.getTimezoneOffset();
                    if (timezoneOffset === 0) {
                        return 'Z';
                    }
                    switch (token) {
                        // Hours and optional minutes
                        case 'X':
                            return formatTimezoneWithOptionalMinutes(timezoneOffset);
                        // Hours, minutes and optional seconds without `:` delimiter
                        // Note: neither ISO-8601 nor JavaScript supports seconds in timezone offsets
                        // so this token always has the same output as `XX`
                        case 'XXXX':
                        case 'XX':
                            // Hours and minutes without `:` delimiter
                            return formatTimezone(timezoneOffset);
                        // Hours, minutes and optional seconds with `:` delimiter
                        // Note: neither ISO-8601 nor JavaScript supports seconds in timezone offsets
                        // so this token always has the same output as `XXX`
                        case 'XXXXX':
                        case 'XXX': // Hours and minutes with `:` delimiter
                        default:
                            return formatTimezone(timezoneOffset, ':');
                    }
                },
                // Timezone (ISO-8601. If offset is 0, output is `'+00:00'` or equivalent)
                x: function x(date, token, _localize, options) {
                    var originalDate = options._originalDate || date;
                    var timezoneOffset = originalDate.getTimezoneOffset();
                    switch (token) {
                        // Hours and optional minutes
                        case 'x':
                            return formatTimezoneWithOptionalMinutes(timezoneOffset);
                        // Hours, minutes and optional seconds without `:` delimiter
                        // Note: neither ISO-8601 nor JavaScript supports seconds in timezone offsets
                        // so this token always has the same output as `xx`
                        case 'xxxx':
                        case 'xx':
                            // Hours and minutes without `:` delimiter
                            return formatTimezone(timezoneOffset);
                        // Hours, minutes and optional seconds with `:` delimiter
                        // Note: neither ISO-8601 nor JavaScript supports seconds in timezone offsets
                        // so this token always has the same output as `xxx`
                        case 'xxxxx':
                        case 'xxx': // Hours and minutes with `:` delimiter
                        default:
                            return formatTimezone(timezoneOffset, ':');
                    }
                },
                // Timezone (GMT)
                O: function O(date, token, _localize, options) {
                    var originalDate = options._originalDate || date;
                    var timezoneOffset = originalDate.getTimezoneOffset();
                    switch (token) {
                        // Short
                        case 'O':
                        case 'OO':
                        case 'OOO':
                            return 'GMT' + formatTimezoneShort(timezoneOffset, ':');
                        // Long
                        case 'OOOO':
                        default:
                            return 'GMT' + formatTimezone(timezoneOffset, ':');
                    }
                },
                // Timezone (specific non-location)
                z: function z(date, token, _localize, options) {
                    var originalDate = options._originalDate || date;
                    var timezoneOffset = originalDate.getTimezoneOffset();
                    switch (token) {
                        // Short
                        case 'z':
                        case 'zz':
                        case 'zzz':
                            return 'GMT' + formatTimezoneShort(timezoneOffset, ':');
                        // Long
                        case 'zzzz':
                        default:
                            return 'GMT' + formatTimezone(timezoneOffset, ':');
                    }
                },
                // Seconds timestamp
                t: function t(date, token, _localize, options) {
                    var originalDate = options._originalDate || date;
                    var timestamp = Math.floor(originalDate.getTime() / 1000);
                    return (0, _addLeadingZeros_index_js__WEBPACK_IMPORTED_MODULE_2__["default"])(timestamp, token.length);
                },
                // Milliseconds timestamp
                T: function T(date, token, _localize, options) {
                    var originalDate = options._originalDate || date;
                    var timestamp = originalDate.getTime();
                    return (0, _addLeadingZeros_index_js__WEBPACK_IMPORTED_MODULE_2__["default"])(timestamp, token.length);
                }
            };
            function formatTimezoneShort(offset, dirtyDelimiter) {
                var sign = offset > 0 ? '-' : '+';
                var absOffset = Math.abs(offset);
                var hours = Math.floor(absOffset / 60);
                var minutes = absOffset % 60;
                if (minutes === 0) {
                    return sign + String(hours);
                }
                var delimiter = dirtyDelimiter || '';
                return sign + String(hours) + delimiter + (0, _addLeadingZeros_index_js__WEBPACK_IMPORTED_MODULE_2__["default"])(minutes, 2);
            }
            function formatTimezoneWithOptionalMinutes(offset, dirtyDelimiter) {
                if (offset % 60 === 0) {
                    var sign = offset > 0 ? '-' : '+';
                    return sign + (0, _addLeadingZeros_index_js__WEBPACK_IMPORTED_MODULE_2__["default"])(Math.abs(offset) / 60, 2);
                }
                return formatTimezone(offset, dirtyDelimiter);
            }
            function formatTimezone(offset, dirtyDelimiter) {
                var delimiter = dirtyDelimiter || '';
                var sign = offset > 0 ? '-' : '+';
                var absOffset = Math.abs(offset);
                var hours = (0, _addLeadingZeros_index_js__WEBPACK_IMPORTED_MODULE_2__["default"])(Math.floor(absOffset / 60), 2);
                var minutes = (0, _addLeadingZeros_index_js__WEBPACK_IMPORTED_MODULE_2__["default"])(absOffset % 60, 2);
                return sign + hours + delimiter + minutes;
            }
            /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (formatters);
            /***/ 
        }),
        /***/ "./node_modules/date-fns/esm/_lib/format/lightFormatters/index.js": 
        /*!************************************************************************!*\
          !*** ./node_modules/date-fns/esm/_lib/format/lightFormatters/index.js ***!
          \************************************************************************/
        /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony export */ __webpack_require__.d(__webpack_exports__, {
                /* harmony export */ "default": () => (__WEBPACK_DEFAULT_EXPORT__)
                /* harmony export */ 
            });
            /* harmony import */ var _addLeadingZeros_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../addLeadingZeros/index.js */ "./node_modules/date-fns/esm/_lib/addLeadingZeros/index.js");
            /*
             * |     | Unit                           |     | Unit                           |
             * |-----|--------------------------------|-----|--------------------------------|
             * |  a  | AM, PM                         |  A* |                                |
             * |  d  | Day of month                   |  D  |                                |
             * |  h  | Hour [1-12]                    |  H  | Hour [0-23]                    |
             * |  m  | Minute                         |  M  | Month                          |
             * |  s  | Second                         |  S  | Fraction of second             |
             * |  y  | Year (abs)                     |  Y  |                                |
             *
             * Letters marked by * are not implemented but reserved by Unicode standard.
             */
            var formatters = {
                // Year
                y: function y(date, token) {
                    // From http://www.unicode.org/reports/tr35/tr35-31/tr35-dates.html#Date_Format_tokens
                    // | Year     |     y | yy |   yyy |  yyyy | yyyyy |
                    // |----------|-------|----|-------|-------|-------|
                    // | AD 1     |     1 | 01 |   001 |  0001 | 00001 |
                    // | AD 12    |    12 | 12 |   012 |  0012 | 00012 |
                    // | AD 123   |   123 | 23 |   123 |  0123 | 00123 |
                    // | AD 1234  |  1234 | 34 |  1234 |  1234 | 01234 |
                    // | AD 12345 | 12345 | 45 | 12345 | 12345 | 12345 |
                    var signedYear = date.getUTCFullYear();
                    // Returns 1 for 1 BC (which is year 0 in JavaScript)
                    var year = signedYear > 0 ? signedYear : 1 - signedYear;
                    return (0, _addLeadingZeros_index_js__WEBPACK_IMPORTED_MODULE_0__["default"])(token === 'yy' ? year % 100 : year, token.length);
                },
                // Month
                M: function M(date, token) {
                    var month = date.getUTCMonth();
                    return token === 'M' ? String(month + 1) : (0, _addLeadingZeros_index_js__WEBPACK_IMPORTED_MODULE_0__["default"])(month + 1, 2);
                },
                // Day of the month
                d: function d(date, token) {
                    return (0, _addLeadingZeros_index_js__WEBPACK_IMPORTED_MODULE_0__["default"])(date.getUTCDate(), token.length);
                },
                // AM or PM
                a: function a(date, token) {
                    var dayPeriodEnumValue = date.getUTCHours() / 12 >= 1 ? 'pm' : 'am';
                    switch (token) {
                        case 'a':
                        case 'aa':
                            return dayPeriodEnumValue.toUpperCase();
                        case 'aaa':
                            return dayPeriodEnumValue;
                        case 'aaaaa':
                            return dayPeriodEnumValue[0];
                        case 'aaaa':
                        default:
                            return dayPeriodEnumValue === 'am' ? 'a.m.' : 'p.m.';
                    }
                },
                // Hour [1-12]
                h: function h(date, token) {
                    return (0, _addLeadingZeros_index_js__WEBPACK_IMPORTED_MODULE_0__["default"])(date.getUTCHours() % 12 || 12, token.length);
                },
                // Hour [0-23]
                H: function H(date, token) {
                    return (0, _addLeadingZeros_index_js__WEBPACK_IMPORTED_MODULE_0__["default"])(date.getUTCHours(), token.length);
                },
                // Minute
                m: function m(date, token) {
                    return (0, _addLeadingZeros_index_js__WEBPACK_IMPORTED_MODULE_0__["default"])(date.getUTCMinutes(), token.length);
                },
                // Second
                s: function s(date, token) {
                    return (0, _addLeadingZeros_index_js__WEBPACK_IMPORTED_MODULE_0__["default"])(date.getUTCSeconds(), token.length);
                },
                // Fraction of second
                S: function S(date, token) {
                    var numberOfDigits = token.length;
                    var milliseconds = date.getUTCMilliseconds();
                    var fractionalSeconds = Math.floor(milliseconds * Math.pow(10, numberOfDigits - 3));
                    return (0, _addLeadingZeros_index_js__WEBPACK_IMPORTED_MODULE_0__["default"])(fractionalSeconds, token.length);
                }
            };
            /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (formatters);
            /***/ 
        }),
        /***/ "./node_modules/date-fns/esm/_lib/format/longFormatters/index.js": 
        /*!***********************************************************************!*\
          !*** ./node_modules/date-fns/esm/_lib/format/longFormatters/index.js ***!
          \***********************************************************************/
        /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony export */ __webpack_require__.d(__webpack_exports__, {
                /* harmony export */ "default": () => (__WEBPACK_DEFAULT_EXPORT__)
                /* harmony export */ 
            });
            var dateLongFormatter = function dateLongFormatter(pattern, formatLong) {
                switch (pattern) {
                    case 'P':
                        return formatLong.date({
                            width: 'short'
                        });
                    case 'PP':
                        return formatLong.date({
                            width: 'medium'
                        });
                    case 'PPP':
                        return formatLong.date({
                            width: 'long'
                        });
                    case 'PPPP':
                    default:
                        return formatLong.date({
                            width: 'full'
                        });
                }
            };
            var timeLongFormatter = function timeLongFormatter(pattern, formatLong) {
                switch (pattern) {
                    case 'p':
                        return formatLong.time({
                            width: 'short'
                        });
                    case 'pp':
                        return formatLong.time({
                            width: 'medium'
                        });
                    case 'ppp':
                        return formatLong.time({
                            width: 'long'
                        });
                    case 'pppp':
                    default:
                        return formatLong.time({
                            width: 'full'
                        });
                }
            };
            var dateTimeLongFormatter = function dateTimeLongFormatter(pattern, formatLong) {
                var matchResult = pattern.match(/(P+)(p+)?/) || [];
                var datePattern = matchResult[1];
                var timePattern = matchResult[2];
                if (!timePattern) {
                    return dateLongFormatter(pattern, formatLong);
                }
                var dateTimeFormat;
                switch (datePattern) {
                    case 'P':
                        dateTimeFormat = formatLong.dateTime({
                            width: 'short'
                        });
                        break;
                    case 'PP':
                        dateTimeFormat = formatLong.dateTime({
                            width: 'medium'
                        });
                        break;
                    case 'PPP':
                        dateTimeFormat = formatLong.dateTime({
                            width: 'long'
                        });
                        break;
                    case 'PPPP':
                    default:
                        dateTimeFormat = formatLong.dateTime({
                            width: 'full'
                        });
                        break;
                }
                return dateTimeFormat.replace('{{date}}', dateLongFormatter(datePattern, formatLong)).replace('{{time}}', timeLongFormatter(timePattern, formatLong));
            };
            var longFormatters = {
                p: timeLongFormatter,
                P: dateTimeLongFormatter
            };
            /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (longFormatters);
            /***/ 
        }),
        /***/ "./node_modules/date-fns/esm/_lib/getTimezoneOffsetInMilliseconds/index.js": 
        /*!*********************************************************************************!*\
          !*** ./node_modules/date-fns/esm/_lib/getTimezoneOffsetInMilliseconds/index.js ***!
          \*********************************************************************************/
        /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony export */ __webpack_require__.d(__webpack_exports__, {
                /* harmony export */ "default": () => ( /* binding */getTimezoneOffsetInMilliseconds)
                /* harmony export */ 
            });
            /**
             * Google Chrome as of 67.0.3396.87 introduced timezones with offset that includes seconds.
             * They usually appear for dates that denote time before the timezones were introduced
             * (e.g. for 'Europe/Prague' timezone the offset is GMT+00:57:44 before 1 October 1891
             * and GMT+01:00:00 after that date)
             *
             * Date#getTimezoneOffset returns the offset in minutes and would return 57 for the example above,
             * which would lead to incorrect calculations.
             *
             * This function returns the timezone offset in milliseconds that takes seconds in account.
             */
            function getTimezoneOffsetInMilliseconds(date) {
                var utcDate = new Date(Date.UTC(date.getFullYear(), date.getMonth(), date.getDate(), date.getHours(), date.getMinutes(), date.getSeconds(), date.getMilliseconds()));
                utcDate.setUTCFullYear(date.getFullYear());
                return date.getTime() - utcDate.getTime();
            }
            /***/ 
        }),
        /***/ "./node_modules/date-fns/esm/_lib/getUTCDayOfYear/index.js": 
        /*!*****************************************************************!*\
          !*** ./node_modules/date-fns/esm/_lib/getUTCDayOfYear/index.js ***!
          \*****************************************************************/
        /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony export */ __webpack_require__.d(__webpack_exports__, {
                /* harmony export */ "default": () => ( /* binding */getUTCDayOfYear)
                /* harmony export */ 
            });
            /* harmony import */ var _toDate_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../toDate/index.js */ "./node_modules/date-fns/esm/toDate/index.js");
            /* harmony import */ var _requiredArgs_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../requiredArgs/index.js */ "./node_modules/date-fns/esm/_lib/requiredArgs/index.js");
            var MILLISECONDS_IN_DAY = 86400000;
            function getUTCDayOfYear(dirtyDate) {
                (0, _requiredArgs_index_js__WEBPACK_IMPORTED_MODULE_0__["default"])(1, arguments);
                var date = (0, _toDate_index_js__WEBPACK_IMPORTED_MODULE_1__["default"])(dirtyDate);
                var timestamp = date.getTime();
                date.setUTCMonth(0, 1);
                date.setUTCHours(0, 0, 0, 0);
                var startOfYearTimestamp = date.getTime();
                var difference = timestamp - startOfYearTimestamp;
                return Math.floor(difference / MILLISECONDS_IN_DAY) + 1;
            }
            /***/ 
        }),
        /***/ "./node_modules/date-fns/esm/_lib/getUTCISOWeek/index.js": 
        /*!***************************************************************!*\
          !*** ./node_modules/date-fns/esm/_lib/getUTCISOWeek/index.js ***!
          \***************************************************************/
        /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony export */ __webpack_require__.d(__webpack_exports__, {
                /* harmony export */ "default": () => ( /* binding */getUTCISOWeek)
                /* harmony export */ 
            });
            /* harmony import */ var _toDate_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../toDate/index.js */ "./node_modules/date-fns/esm/toDate/index.js");
            /* harmony import */ var _startOfUTCISOWeek_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../startOfUTCISOWeek/index.js */ "./node_modules/date-fns/esm/_lib/startOfUTCISOWeek/index.js");
            /* harmony import */ var _startOfUTCISOWeekYear_index_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../startOfUTCISOWeekYear/index.js */ "./node_modules/date-fns/esm/_lib/startOfUTCISOWeekYear/index.js");
            /* harmony import */ var _requiredArgs_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../requiredArgs/index.js */ "./node_modules/date-fns/esm/_lib/requiredArgs/index.js");
            var MILLISECONDS_IN_WEEK = 604800000;
            function getUTCISOWeek(dirtyDate) {
                (0, _requiredArgs_index_js__WEBPACK_IMPORTED_MODULE_0__["default"])(1, arguments);
                var date = (0, _toDate_index_js__WEBPACK_IMPORTED_MODULE_1__["default"])(dirtyDate);
                var diff = (0, _startOfUTCISOWeek_index_js__WEBPACK_IMPORTED_MODULE_2__["default"])(date).getTime() - (0, _startOfUTCISOWeekYear_index_js__WEBPACK_IMPORTED_MODULE_3__["default"])(date).getTime();
                // Round the number of days to the nearest integer
                // because the number of milliseconds in a week is not constant
                // (e.g. it's different in the week of the daylight saving time clock shift)
                return Math.round(diff / MILLISECONDS_IN_WEEK) + 1;
            }
            /***/ 
        }),
        /***/ "./node_modules/date-fns/esm/_lib/getUTCISOWeekYear/index.js": 
        /*!*******************************************************************!*\
          !*** ./node_modules/date-fns/esm/_lib/getUTCISOWeekYear/index.js ***!
          \*******************************************************************/
        /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony export */ __webpack_require__.d(__webpack_exports__, {
                /* harmony export */ "default": () => ( /* binding */getUTCISOWeekYear)
                /* harmony export */ 
            });
            /* harmony import */ var _toDate_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../toDate/index.js */ "./node_modules/date-fns/esm/toDate/index.js");
            /* harmony import */ var _requiredArgs_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../requiredArgs/index.js */ "./node_modules/date-fns/esm/_lib/requiredArgs/index.js");
            /* harmony import */ var _startOfUTCISOWeek_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../startOfUTCISOWeek/index.js */ "./node_modules/date-fns/esm/_lib/startOfUTCISOWeek/index.js");
            function getUTCISOWeekYear(dirtyDate) {
                (0, _requiredArgs_index_js__WEBPACK_IMPORTED_MODULE_0__["default"])(1, arguments);
                var date = (0, _toDate_index_js__WEBPACK_IMPORTED_MODULE_1__["default"])(dirtyDate);
                var year = date.getUTCFullYear();
                var fourthOfJanuaryOfNextYear = new Date(0);
                fourthOfJanuaryOfNextYear.setUTCFullYear(year + 1, 0, 4);
                fourthOfJanuaryOfNextYear.setUTCHours(0, 0, 0, 0);
                var startOfNextYear = (0, _startOfUTCISOWeek_index_js__WEBPACK_IMPORTED_MODULE_2__["default"])(fourthOfJanuaryOfNextYear);
                var fourthOfJanuaryOfThisYear = new Date(0);
                fourthOfJanuaryOfThisYear.setUTCFullYear(year, 0, 4);
                fourthOfJanuaryOfThisYear.setUTCHours(0, 0, 0, 0);
                var startOfThisYear = (0, _startOfUTCISOWeek_index_js__WEBPACK_IMPORTED_MODULE_2__["default"])(fourthOfJanuaryOfThisYear);
                if (date.getTime() >= startOfNextYear.getTime()) {
                    return year + 1;
                }
                else if (date.getTime() >= startOfThisYear.getTime()) {
                    return year;
                }
                else {
                    return year - 1;
                }
            }
            /***/ 
        }),
        /***/ "./node_modules/date-fns/esm/_lib/getUTCWeek/index.js": 
        /*!************************************************************!*\
          !*** ./node_modules/date-fns/esm/_lib/getUTCWeek/index.js ***!
          \************************************************************/
        /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony export */ __webpack_require__.d(__webpack_exports__, {
                /* harmony export */ "default": () => ( /* binding */getUTCWeek)
                /* harmony export */ 
            });
            /* harmony import */ var _toDate_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../toDate/index.js */ "./node_modules/date-fns/esm/toDate/index.js");
            /* harmony import */ var _startOfUTCWeek_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../startOfUTCWeek/index.js */ "./node_modules/date-fns/esm/_lib/startOfUTCWeek/index.js");
            /* harmony import */ var _startOfUTCWeekYear_index_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../startOfUTCWeekYear/index.js */ "./node_modules/date-fns/esm/_lib/startOfUTCWeekYear/index.js");
            /* harmony import */ var _requiredArgs_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../requiredArgs/index.js */ "./node_modules/date-fns/esm/_lib/requiredArgs/index.js");
            var MILLISECONDS_IN_WEEK = 604800000;
            function getUTCWeek(dirtyDate, options) {
                (0, _requiredArgs_index_js__WEBPACK_IMPORTED_MODULE_0__["default"])(1, arguments);
                var date = (0, _toDate_index_js__WEBPACK_IMPORTED_MODULE_1__["default"])(dirtyDate);
                var diff = (0, _startOfUTCWeek_index_js__WEBPACK_IMPORTED_MODULE_2__["default"])(date, options).getTime() - (0, _startOfUTCWeekYear_index_js__WEBPACK_IMPORTED_MODULE_3__["default"])(date, options).getTime();
                // Round the number of days to the nearest integer
                // because the number of milliseconds in a week is not constant
                // (e.g. it's different in the week of the daylight saving time clock shift)
                return Math.round(diff / MILLISECONDS_IN_WEEK) + 1;
            }
            /***/ 
        }),
        /***/ "./node_modules/date-fns/esm/_lib/getUTCWeekYear/index.js": 
        /*!****************************************************************!*\
          !*** ./node_modules/date-fns/esm/_lib/getUTCWeekYear/index.js ***!
          \****************************************************************/
        /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony export */ __webpack_require__.d(__webpack_exports__, {
                /* harmony export */ "default": () => ( /* binding */getUTCWeekYear)
                /* harmony export */ 
            });
            /* harmony import */ var _toDate_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../toDate/index.js */ "./node_modules/date-fns/esm/toDate/index.js");
            /* harmony import */ var _requiredArgs_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../requiredArgs/index.js */ "./node_modules/date-fns/esm/_lib/requiredArgs/index.js");
            /* harmony import */ var _startOfUTCWeek_index_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../startOfUTCWeek/index.js */ "./node_modules/date-fns/esm/_lib/startOfUTCWeek/index.js");
            /* harmony import */ var _toInteger_index_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../toInteger/index.js */ "./node_modules/date-fns/esm/_lib/toInteger/index.js");
            /* harmony import */ var _defaultOptions_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../defaultOptions/index.js */ "./node_modules/date-fns/esm/_lib/defaultOptions/index.js");
            function getUTCWeekYear(dirtyDate, options) {
                var _ref, _ref2, _ref3, _options$firstWeekCon, _options$locale, _options$locale$optio, _defaultOptions$local, _defaultOptions$local2;
                (0, _requiredArgs_index_js__WEBPACK_IMPORTED_MODULE_0__["default"])(1, arguments);
                var date = (0, _toDate_index_js__WEBPACK_IMPORTED_MODULE_1__["default"])(dirtyDate);
                var year = date.getUTCFullYear();
                var defaultOptions = (0, _defaultOptions_index_js__WEBPACK_IMPORTED_MODULE_2__.getDefaultOptions)();
                var firstWeekContainsDate = (0, _toInteger_index_js__WEBPACK_IMPORTED_MODULE_3__["default"])((_ref = (_ref2 = (_ref3 = (_options$firstWeekCon = options === null || options === void 0 ? void 0 : options.firstWeekContainsDate) !== null && _options$firstWeekCon !== void 0 ? _options$firstWeekCon : options === null || options === void 0 ? void 0 : (_options$locale = options.locale) === null || _options$locale === void 0 ? void 0 : (_options$locale$optio = _options$locale.options) === null || _options$locale$optio === void 0 ? void 0 : _options$locale$optio.firstWeekContainsDate) !== null && _ref3 !== void 0 ? _ref3 : defaultOptions.firstWeekContainsDate) !== null && _ref2 !== void 0 ? _ref2 : (_defaultOptions$local = defaultOptions.locale) === null || _defaultOptions$local === void 0 ? void 0 : (_defaultOptions$local2 = _defaultOptions$local.options) === null || _defaultOptions$local2 === void 0 ? void 0 : _defaultOptions$local2.firstWeekContainsDate) !== null && _ref !== void 0 ? _ref : 1);
                // Test if weekStartsOn is between 1 and 7 _and_ is not NaN
                if (!(firstWeekContainsDate >= 1 && firstWeekContainsDate <= 7)) {
                    throw new RangeError('firstWeekContainsDate must be between 1 and 7 inclusively');
                }
                var firstWeekOfNextYear = new Date(0);
                firstWeekOfNextYear.setUTCFullYear(year + 1, 0, firstWeekContainsDate);
                firstWeekOfNextYear.setUTCHours(0, 0, 0, 0);
                var startOfNextYear = (0, _startOfUTCWeek_index_js__WEBPACK_IMPORTED_MODULE_4__["default"])(firstWeekOfNextYear, options);
                var firstWeekOfThisYear = new Date(0);
                firstWeekOfThisYear.setUTCFullYear(year, 0, firstWeekContainsDate);
                firstWeekOfThisYear.setUTCHours(0, 0, 0, 0);
                var startOfThisYear = (0, _startOfUTCWeek_index_js__WEBPACK_IMPORTED_MODULE_4__["default"])(firstWeekOfThisYear, options);
                if (date.getTime() >= startOfNextYear.getTime()) {
                    return year + 1;
                }
                else if (date.getTime() >= startOfThisYear.getTime()) {
                    return year;
                }
                else {
                    return year - 1;
                }
            }
            /***/ 
        }),
        /***/ "./node_modules/date-fns/esm/_lib/protectedTokens/index.js": 
        /*!*****************************************************************!*\
          !*** ./node_modules/date-fns/esm/_lib/protectedTokens/index.js ***!
          \*****************************************************************/
        /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony export */ __webpack_require__.d(__webpack_exports__, {
                /* harmony export */ isProtectedDayOfYearToken: () => ( /* binding */isProtectedDayOfYearToken),
                /* harmony export */ isProtectedWeekYearToken: () => ( /* binding */isProtectedWeekYearToken),
                /* harmony export */ throwProtectedError: () => ( /* binding */throwProtectedError)
                /* harmony export */ 
            });
            var protectedDayOfYearTokens = ['D', 'DD'];
            var protectedWeekYearTokens = ['YY', 'YYYY'];
            function isProtectedDayOfYearToken(token) {
                return protectedDayOfYearTokens.indexOf(token) !== -1;
            }
            function isProtectedWeekYearToken(token) {
                return protectedWeekYearTokens.indexOf(token) !== -1;
            }
            function throwProtectedError(token, format, input) {
                if (token === 'YYYY') {
                    throw new RangeError("Use `yyyy` instead of `YYYY` (in `".concat(format, "`) for formatting years to the input `").concat(input, "`; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md"));
                }
                else if (token === 'YY') {
                    throw new RangeError("Use `yy` instead of `YY` (in `".concat(format, "`) for formatting years to the input `").concat(input, "`; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md"));
                }
                else if (token === 'D') {
                    throw new RangeError("Use `d` instead of `D` (in `".concat(format, "`) for formatting days of the month to the input `").concat(input, "`; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md"));
                }
                else if (token === 'DD') {
                    throw new RangeError("Use `dd` instead of `DD` (in `".concat(format, "`) for formatting days of the month to the input `").concat(input, "`; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md"));
                }
            }
            /***/ 
        }),
        /***/ "./node_modules/date-fns/esm/_lib/requiredArgs/index.js": 
        /*!**************************************************************!*\
          !*** ./node_modules/date-fns/esm/_lib/requiredArgs/index.js ***!
          \**************************************************************/
        /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony export */ __webpack_require__.d(__webpack_exports__, {
                /* harmony export */ "default": () => ( /* binding */requiredArgs)
                /* harmony export */ 
            });
            function requiredArgs(required, args) {
                if (args.length < required) {
                    throw new TypeError(required + ' argument' + (required > 1 ? 's' : '') + ' required, but only ' + args.length + ' present');
                }
            }
            /***/ 
        }),
        /***/ "./node_modules/date-fns/esm/_lib/setUTCDay/index.js": 
        /*!***********************************************************!*\
          !*** ./node_modules/date-fns/esm/_lib/setUTCDay/index.js ***!
          \***********************************************************/
        /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony export */ __webpack_require__.d(__webpack_exports__, {
                /* harmony export */ "default": () => ( /* binding */setUTCDay)
                /* harmony export */ 
            });
            /* harmony import */ var _toDate_index_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../toDate/index.js */ "./node_modules/date-fns/esm/toDate/index.js");
            /* harmony import */ var _requiredArgs_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../requiredArgs/index.js */ "./node_modules/date-fns/esm/_lib/requiredArgs/index.js");
            /* harmony import */ var _toInteger_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../toInteger/index.js */ "./node_modules/date-fns/esm/_lib/toInteger/index.js");
            /* harmony import */ var _defaultOptions_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../defaultOptions/index.js */ "./node_modules/date-fns/esm/_lib/defaultOptions/index.js");
            function setUTCDay(dirtyDate, dirtyDay, options) {
                var _ref, _ref2, _ref3, _options$weekStartsOn, _options$locale, _options$locale$optio, _defaultOptions$local, _defaultOptions$local2;
                (0, _requiredArgs_index_js__WEBPACK_IMPORTED_MODULE_0__["default"])(2, arguments);
                var defaultOptions = (0, _defaultOptions_index_js__WEBPACK_IMPORTED_MODULE_1__.getDefaultOptions)();
                var weekStartsOn = (0, _toInteger_index_js__WEBPACK_IMPORTED_MODULE_2__["default"])((_ref = (_ref2 = (_ref3 = (_options$weekStartsOn = options === null || options === void 0 ? void 0 : options.weekStartsOn) !== null && _options$weekStartsOn !== void 0 ? _options$weekStartsOn : options === null || options === void 0 ? void 0 : (_options$locale = options.locale) === null || _options$locale === void 0 ? void 0 : (_options$locale$optio = _options$locale.options) === null || _options$locale$optio === void 0 ? void 0 : _options$locale$optio.weekStartsOn) !== null && _ref3 !== void 0 ? _ref3 : defaultOptions.weekStartsOn) !== null && _ref2 !== void 0 ? _ref2 : (_defaultOptions$local = defaultOptions.locale) === null || _defaultOptions$local === void 0 ? void 0 : (_defaultOptions$local2 = _defaultOptions$local.options) === null || _defaultOptions$local2 === void 0 ? void 0 : _defaultOptions$local2.weekStartsOn) !== null && _ref !== void 0 ? _ref : 0);
                // Test if weekStartsOn is between 0 and 6 _and_ is not NaN
                if (!(weekStartsOn >= 0 && weekStartsOn <= 6)) {
                    throw new RangeError('weekStartsOn must be between 0 and 6 inclusively');
                }
                var date = (0, _toDate_index_js__WEBPACK_IMPORTED_MODULE_3__["default"])(dirtyDate);
                var day = (0, _toInteger_index_js__WEBPACK_IMPORTED_MODULE_2__["default"])(dirtyDay);
                var currentDay = date.getUTCDay();
                var remainder = day % 7;
                var dayIndex = (remainder + 7) % 7;
                var diff = (dayIndex < weekStartsOn ? 7 : 0) + day - currentDay;
                date.setUTCDate(date.getUTCDate() + diff);
                return date;
            }
            /***/ 
        }),
        /***/ "./node_modules/date-fns/esm/_lib/setUTCISODay/index.js": 
        /*!**************************************************************!*\
          !*** ./node_modules/date-fns/esm/_lib/setUTCISODay/index.js ***!
          \**************************************************************/
        /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony export */ __webpack_require__.d(__webpack_exports__, {
                /* harmony export */ "default": () => ( /* binding */setUTCISODay)
                /* harmony export */ 
            });
            /* harmony import */ var _toDate_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../toDate/index.js */ "./node_modules/date-fns/esm/toDate/index.js");
            /* harmony import */ var _requiredArgs_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../requiredArgs/index.js */ "./node_modules/date-fns/esm/_lib/requiredArgs/index.js");
            /* harmony import */ var _toInteger_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../toInteger/index.js */ "./node_modules/date-fns/esm/_lib/toInteger/index.js");
            function setUTCISODay(dirtyDate, dirtyDay) {
                (0, _requiredArgs_index_js__WEBPACK_IMPORTED_MODULE_0__["default"])(2, arguments);
                var day = (0, _toInteger_index_js__WEBPACK_IMPORTED_MODULE_1__["default"])(dirtyDay);
                if (day % 7 === 0) {
                    day = day - 7;
                }
                var weekStartsOn = 1;
                var date = (0, _toDate_index_js__WEBPACK_IMPORTED_MODULE_2__["default"])(dirtyDate);
                var currentDay = date.getUTCDay();
                var remainder = day % 7;
                var dayIndex = (remainder + 7) % 7;
                var diff = (dayIndex < weekStartsOn ? 7 : 0) + day - currentDay;
                date.setUTCDate(date.getUTCDate() + diff);
                return date;
            }
            /***/ 
        }),
        /***/ "./node_modules/date-fns/esm/_lib/setUTCISOWeek/index.js": 
        /*!***************************************************************!*\
          !*** ./node_modules/date-fns/esm/_lib/setUTCISOWeek/index.js ***!
          \***************************************************************/
        /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony export */ __webpack_require__.d(__webpack_exports__, {
                /* harmony export */ "default": () => ( /* binding */setUTCISOWeek)
                /* harmony export */ 
            });
            /* harmony import */ var _toInteger_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../toInteger/index.js */ "./node_modules/date-fns/esm/_lib/toInteger/index.js");
            /* harmony import */ var _toDate_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../toDate/index.js */ "./node_modules/date-fns/esm/toDate/index.js");
            /* harmony import */ var _getUTCISOWeek_index_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../getUTCISOWeek/index.js */ "./node_modules/date-fns/esm/_lib/getUTCISOWeek/index.js");
            /* harmony import */ var _requiredArgs_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../requiredArgs/index.js */ "./node_modules/date-fns/esm/_lib/requiredArgs/index.js");
            function setUTCISOWeek(dirtyDate, dirtyISOWeek) {
                (0, _requiredArgs_index_js__WEBPACK_IMPORTED_MODULE_0__["default"])(2, arguments);
                var date = (0, _toDate_index_js__WEBPACK_IMPORTED_MODULE_1__["default"])(dirtyDate);
                var isoWeek = (0, _toInteger_index_js__WEBPACK_IMPORTED_MODULE_2__["default"])(dirtyISOWeek);
                var diff = (0, _getUTCISOWeek_index_js__WEBPACK_IMPORTED_MODULE_3__["default"])(date) - isoWeek;
                date.setUTCDate(date.getUTCDate() - diff * 7);
                return date;
            }
            /***/ 
        }),
        /***/ "./node_modules/date-fns/esm/_lib/setUTCWeek/index.js": 
        /*!************************************************************!*\
          !*** ./node_modules/date-fns/esm/_lib/setUTCWeek/index.js ***!
          \************************************************************/
        /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony export */ __webpack_require__.d(__webpack_exports__, {
                /* harmony export */ "default": () => ( /* binding */setUTCWeek)
                /* harmony export */ 
            });
            /* harmony import */ var _toInteger_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../toInteger/index.js */ "./node_modules/date-fns/esm/_lib/toInteger/index.js");
            /* harmony import */ var _toDate_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../toDate/index.js */ "./node_modules/date-fns/esm/toDate/index.js");
            /* harmony import */ var _getUTCWeek_index_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../getUTCWeek/index.js */ "./node_modules/date-fns/esm/_lib/getUTCWeek/index.js");
            /* harmony import */ var _requiredArgs_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../requiredArgs/index.js */ "./node_modules/date-fns/esm/_lib/requiredArgs/index.js");
            function setUTCWeek(dirtyDate, dirtyWeek, options) {
                (0, _requiredArgs_index_js__WEBPACK_IMPORTED_MODULE_0__["default"])(2, arguments);
                var date = (0, _toDate_index_js__WEBPACK_IMPORTED_MODULE_1__["default"])(dirtyDate);
                var week = (0, _toInteger_index_js__WEBPACK_IMPORTED_MODULE_2__["default"])(dirtyWeek);
                var diff = (0, _getUTCWeek_index_js__WEBPACK_IMPORTED_MODULE_3__["default"])(date, options) - week;
                date.setUTCDate(date.getUTCDate() - diff * 7);
                return date;
            }
            /***/ 
        }),
        /***/ "./node_modules/date-fns/esm/_lib/startOfUTCISOWeek/index.js": 
        /*!*******************************************************************!*\
          !*** ./node_modules/date-fns/esm/_lib/startOfUTCISOWeek/index.js ***!
          \*******************************************************************/
        /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony export */ __webpack_require__.d(__webpack_exports__, {
                /* harmony export */ "default": () => ( /* binding */startOfUTCISOWeek)
                /* harmony export */ 
            });
            /* harmony import */ var _toDate_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../toDate/index.js */ "./node_modules/date-fns/esm/toDate/index.js");
            /* harmony import */ var _requiredArgs_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../requiredArgs/index.js */ "./node_modules/date-fns/esm/_lib/requiredArgs/index.js");
            function startOfUTCISOWeek(dirtyDate) {
                (0, _requiredArgs_index_js__WEBPACK_IMPORTED_MODULE_0__["default"])(1, arguments);
                var weekStartsOn = 1;
                var date = (0, _toDate_index_js__WEBPACK_IMPORTED_MODULE_1__["default"])(dirtyDate);
                var day = date.getUTCDay();
                var diff = (day < weekStartsOn ? 7 : 0) + day - weekStartsOn;
                date.setUTCDate(date.getUTCDate() - diff);
                date.setUTCHours(0, 0, 0, 0);
                return date;
            }
            /***/ 
        }),
        /***/ "./node_modules/date-fns/esm/_lib/startOfUTCISOWeekYear/index.js": 
        /*!***********************************************************************!*\
          !*** ./node_modules/date-fns/esm/_lib/startOfUTCISOWeekYear/index.js ***!
          \***********************************************************************/
        /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony export */ __webpack_require__.d(__webpack_exports__, {
                /* harmony export */ "default": () => ( /* binding */startOfUTCISOWeekYear)
                /* harmony export */ 
            });
            /* harmony import */ var _getUTCISOWeekYear_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../getUTCISOWeekYear/index.js */ "./node_modules/date-fns/esm/_lib/getUTCISOWeekYear/index.js");
            /* harmony import */ var _startOfUTCISOWeek_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../startOfUTCISOWeek/index.js */ "./node_modules/date-fns/esm/_lib/startOfUTCISOWeek/index.js");
            /* harmony import */ var _requiredArgs_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../requiredArgs/index.js */ "./node_modules/date-fns/esm/_lib/requiredArgs/index.js");
            function startOfUTCISOWeekYear(dirtyDate) {
                (0, _requiredArgs_index_js__WEBPACK_IMPORTED_MODULE_0__["default"])(1, arguments);
                var year = (0, _getUTCISOWeekYear_index_js__WEBPACK_IMPORTED_MODULE_1__["default"])(dirtyDate);
                var fourthOfJanuary = new Date(0);
                fourthOfJanuary.setUTCFullYear(year, 0, 4);
                fourthOfJanuary.setUTCHours(0, 0, 0, 0);
                var date = (0, _startOfUTCISOWeek_index_js__WEBPACK_IMPORTED_MODULE_2__["default"])(fourthOfJanuary);
                return date;
            }
            /***/ 
        }),
        /***/ "./node_modules/date-fns/esm/_lib/startOfUTCWeek/index.js": 
        /*!****************************************************************!*\
          !*** ./node_modules/date-fns/esm/_lib/startOfUTCWeek/index.js ***!
          \****************************************************************/
        /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony export */ __webpack_require__.d(__webpack_exports__, {
                /* harmony export */ "default": () => ( /* binding */startOfUTCWeek)
                /* harmony export */ 
            });
            /* harmony import */ var _toDate_index_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../toDate/index.js */ "./node_modules/date-fns/esm/toDate/index.js");
            /* harmony import */ var _requiredArgs_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../requiredArgs/index.js */ "./node_modules/date-fns/esm/_lib/requiredArgs/index.js");
            /* harmony import */ var _toInteger_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../toInteger/index.js */ "./node_modules/date-fns/esm/_lib/toInteger/index.js");
            /* harmony import */ var _defaultOptions_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../defaultOptions/index.js */ "./node_modules/date-fns/esm/_lib/defaultOptions/index.js");
            function startOfUTCWeek(dirtyDate, options) {
                var _ref, _ref2, _ref3, _options$weekStartsOn, _options$locale, _options$locale$optio, _defaultOptions$local, _defaultOptions$local2;
                (0, _requiredArgs_index_js__WEBPACK_IMPORTED_MODULE_0__["default"])(1, arguments);
                var defaultOptions = (0, _defaultOptions_index_js__WEBPACK_IMPORTED_MODULE_1__.getDefaultOptions)();
                var weekStartsOn = (0, _toInteger_index_js__WEBPACK_IMPORTED_MODULE_2__["default"])((_ref = (_ref2 = (_ref3 = (_options$weekStartsOn = options === null || options === void 0 ? void 0 : options.weekStartsOn) !== null && _options$weekStartsOn !== void 0 ? _options$weekStartsOn : options === null || options === void 0 ? void 0 : (_options$locale = options.locale) === null || _options$locale === void 0 ? void 0 : (_options$locale$optio = _options$locale.options) === null || _options$locale$optio === void 0 ? void 0 : _options$locale$optio.weekStartsOn) !== null && _ref3 !== void 0 ? _ref3 : defaultOptions.weekStartsOn) !== null && _ref2 !== void 0 ? _ref2 : (_defaultOptions$local = defaultOptions.locale) === null || _defaultOptions$local === void 0 ? void 0 : (_defaultOptions$local2 = _defaultOptions$local.options) === null || _defaultOptions$local2 === void 0 ? void 0 : _defaultOptions$local2.weekStartsOn) !== null && _ref !== void 0 ? _ref : 0);
                // Test if weekStartsOn is between 0 and 6 _and_ is not NaN
                if (!(weekStartsOn >= 0 && weekStartsOn <= 6)) {
                    throw new RangeError('weekStartsOn must be between 0 and 6 inclusively');
                }
                var date = (0, _toDate_index_js__WEBPACK_IMPORTED_MODULE_3__["default"])(dirtyDate);
                var day = date.getUTCDay();
                var diff = (day < weekStartsOn ? 7 : 0) + day - weekStartsOn;
                date.setUTCDate(date.getUTCDate() - diff);
                date.setUTCHours(0, 0, 0, 0);
                return date;
            }
            /***/ 
        }),
        /***/ "./node_modules/date-fns/esm/_lib/startOfUTCWeekYear/index.js": 
        /*!********************************************************************!*\
          !*** ./node_modules/date-fns/esm/_lib/startOfUTCWeekYear/index.js ***!
          \********************************************************************/
        /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony export */ __webpack_require__.d(__webpack_exports__, {
                /* harmony export */ "default": () => ( /* binding */startOfUTCWeekYear)
                /* harmony export */ 
            });
            /* harmony import */ var _getUTCWeekYear_index_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../getUTCWeekYear/index.js */ "./node_modules/date-fns/esm/_lib/getUTCWeekYear/index.js");
            /* harmony import */ var _requiredArgs_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../requiredArgs/index.js */ "./node_modules/date-fns/esm/_lib/requiredArgs/index.js");
            /* harmony import */ var _startOfUTCWeek_index_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../startOfUTCWeek/index.js */ "./node_modules/date-fns/esm/_lib/startOfUTCWeek/index.js");
            /* harmony import */ var _toInteger_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../toInteger/index.js */ "./node_modules/date-fns/esm/_lib/toInteger/index.js");
            /* harmony import */ var _defaultOptions_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../defaultOptions/index.js */ "./node_modules/date-fns/esm/_lib/defaultOptions/index.js");
            function startOfUTCWeekYear(dirtyDate, options) {
                var _ref, _ref2, _ref3, _options$firstWeekCon, _options$locale, _options$locale$optio, _defaultOptions$local, _defaultOptions$local2;
                (0, _requiredArgs_index_js__WEBPACK_IMPORTED_MODULE_0__["default"])(1, arguments);
                var defaultOptions = (0, _defaultOptions_index_js__WEBPACK_IMPORTED_MODULE_1__.getDefaultOptions)();
                var firstWeekContainsDate = (0, _toInteger_index_js__WEBPACK_IMPORTED_MODULE_2__["default"])((_ref = (_ref2 = (_ref3 = (_options$firstWeekCon = options === null || options === void 0 ? void 0 : options.firstWeekContainsDate) !== null && _options$firstWeekCon !== void 0 ? _options$firstWeekCon : options === null || options === void 0 ? void 0 : (_options$locale = options.locale) === null || _options$locale === void 0 ? void 0 : (_options$locale$optio = _options$locale.options) === null || _options$locale$optio === void 0 ? void 0 : _options$locale$optio.firstWeekContainsDate) !== null && _ref3 !== void 0 ? _ref3 : defaultOptions.firstWeekContainsDate) !== null && _ref2 !== void 0 ? _ref2 : (_defaultOptions$local = defaultOptions.locale) === null || _defaultOptions$local === void 0 ? void 0 : (_defaultOptions$local2 = _defaultOptions$local.options) === null || _defaultOptions$local2 === void 0 ? void 0 : _defaultOptions$local2.firstWeekContainsDate) !== null && _ref !== void 0 ? _ref : 1);
                var year = (0, _getUTCWeekYear_index_js__WEBPACK_IMPORTED_MODULE_3__["default"])(dirtyDate, options);
                var firstWeek = new Date(0);
                firstWeek.setUTCFullYear(year, 0, firstWeekContainsDate);
                firstWeek.setUTCHours(0, 0, 0, 0);
                var date = (0, _startOfUTCWeek_index_js__WEBPACK_IMPORTED_MODULE_4__["default"])(firstWeek, options);
                return date;
            }
            /***/ 
        }),
        /***/ "./node_modules/date-fns/esm/_lib/toInteger/index.js": 
        /*!***********************************************************!*\
          !*** ./node_modules/date-fns/esm/_lib/toInteger/index.js ***!
          \***********************************************************/
        /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony export */ __webpack_require__.d(__webpack_exports__, {
                /* harmony export */ "default": () => ( /* binding */toInteger)
                /* harmony export */ 
            });
            function toInteger(dirtyNumber) {
                if (dirtyNumber === null || dirtyNumber === true || dirtyNumber === false) {
                    return NaN;
                }
                var number = Number(dirtyNumber);
                if (isNaN(number)) {
                    return number;
                }
                return number < 0 ? Math.ceil(number) : Math.floor(number);
            }
            /***/ 
        }),
        /***/ "./node_modules/date-fns/esm/addDays/index.js": 
        /*!****************************************************!*\
          !*** ./node_modules/date-fns/esm/addDays/index.js ***!
          \****************************************************/
        /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony export */ __webpack_require__.d(__webpack_exports__, {
                /* harmony export */ "default": () => ( /* binding */addDays)
                /* harmony export */ 
            });
            /* harmony import */ var _lib_toInteger_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../_lib/toInteger/index.js */ "./node_modules/date-fns/esm/_lib/toInteger/index.js");
            /* harmony import */ var _toDate_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../toDate/index.js */ "./node_modules/date-fns/esm/toDate/index.js");
            /* harmony import */ var _lib_requiredArgs_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../_lib/requiredArgs/index.js */ "./node_modules/date-fns/esm/_lib/requiredArgs/index.js");
            /**
             * @name addDays
             * @category Day Helpers
             * @summary Add the specified number of days to the given date.
             *
             * @description
             * Add the specified number of days to the given date.
             *
             * @param {Date|Number} date - the date to be changed
             * @param {Number} amount - the amount of days to be added. Positive decimals will be rounded using `Math.floor`, decimals less than zero will be rounded using `Math.ceil`.
             * @returns {Date} - the new date with the days added
             * @throws {TypeError} - 2 arguments required
             *
             * @example
             * // Add 10 days to 1 September 2014:
             * const result = addDays(new Date(2014, 8, 1), 10)
             * //=> Thu Sep 11 2014 00:00:00
             */
            function addDays(dirtyDate, dirtyAmount) {
                (0, _lib_requiredArgs_index_js__WEBPACK_IMPORTED_MODULE_0__["default"])(2, arguments);
                var date = (0, _toDate_index_js__WEBPACK_IMPORTED_MODULE_1__["default"])(dirtyDate);
                var amount = (0, _lib_toInteger_index_js__WEBPACK_IMPORTED_MODULE_2__["default"])(dirtyAmount);
                if (isNaN(amount)) {
                    return new Date(NaN);
                }
                if (!amount) {
                    // If 0 days, no-op to avoid changing times in the hour before end of DST
                    return date;
                }
                date.setDate(date.getDate() + amount);
                return date;
            }
            /***/ 
        }),
        /***/ "./node_modules/date-fns/esm/addMilliseconds/index.js": 
        /*!************************************************************!*\
          !*** ./node_modules/date-fns/esm/addMilliseconds/index.js ***!
          \************************************************************/
        /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony export */ __webpack_require__.d(__webpack_exports__, {
                /* harmony export */ "default": () => ( /* binding */addMilliseconds)
                /* harmony export */ 
            });
            /* harmony import */ var _lib_toInteger_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../_lib/toInteger/index.js */ "./node_modules/date-fns/esm/_lib/toInteger/index.js");
            /* harmony import */ var _toDate_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../toDate/index.js */ "./node_modules/date-fns/esm/toDate/index.js");
            /* harmony import */ var _lib_requiredArgs_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../_lib/requiredArgs/index.js */ "./node_modules/date-fns/esm/_lib/requiredArgs/index.js");
            /**
             * @name addMilliseconds
             * @category Millisecond Helpers
             * @summary Add the specified number of milliseconds to the given date.
             *
             * @description
             * Add the specified number of milliseconds to the given date.
             *
             * @param {Date|Number} date - the date to be changed
             * @param {Number} amount - the amount of milliseconds to be added. Positive decimals will be rounded using `Math.floor`, decimals less than zero will be rounded using `Math.ceil`.
             * @returns {Date} the new date with the milliseconds added
             * @throws {TypeError} 2 arguments required
             *
             * @example
             * // Add 750 milliseconds to 10 July 2014 12:45:30.000:
             * const result = addMilliseconds(new Date(2014, 6, 10, 12, 45, 30, 0), 750)
             * //=> Thu Jul 10 2014 12:45:30.750
             */
            function addMilliseconds(dirtyDate, dirtyAmount) {
                (0, _lib_requiredArgs_index_js__WEBPACK_IMPORTED_MODULE_0__["default"])(2, arguments);
                var timestamp = (0, _toDate_index_js__WEBPACK_IMPORTED_MODULE_1__["default"])(dirtyDate).getTime();
                var amount = (0, _lib_toInteger_index_js__WEBPACK_IMPORTED_MODULE_2__["default"])(dirtyAmount);
                return new Date(timestamp + amount);
            }
            /***/ 
        }),
        /***/ "./node_modules/date-fns/esm/addMonths/index.js": 
        /*!******************************************************!*\
          !*** ./node_modules/date-fns/esm/addMonths/index.js ***!
          \******************************************************/
        /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony export */ __webpack_require__.d(__webpack_exports__, {
                /* harmony export */ "default": () => ( /* binding */addMonths)
                /* harmony export */ 
            });
            /* harmony import */ var _lib_toInteger_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../_lib/toInteger/index.js */ "./node_modules/date-fns/esm/_lib/toInteger/index.js");
            /* harmony import */ var _toDate_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../toDate/index.js */ "./node_modules/date-fns/esm/toDate/index.js");
            /* harmony import */ var _lib_requiredArgs_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../_lib/requiredArgs/index.js */ "./node_modules/date-fns/esm/_lib/requiredArgs/index.js");
            /**
             * @name addMonths
             * @category Month Helpers
             * @summary Add the specified number of months to the given date.
             *
             * @description
             * Add the specified number of months to the given date.
             *
             * @param {Date|Number} date - the date to be changed
             * @param {Number} amount - the amount of months to be added. Positive decimals will be rounded using `Math.floor`, decimals less than zero will be rounded using `Math.ceil`.
             * @returns {Date} the new date with the months added
             * @throws {TypeError} 2 arguments required
             *
             * @example
             * // Add 5 months to 1 September 2014:
             * const result = addMonths(new Date(2014, 8, 1), 5)
             * //=> Sun Feb 01 2015 00:00:00
             */
            function addMonths(dirtyDate, dirtyAmount) {
                (0, _lib_requiredArgs_index_js__WEBPACK_IMPORTED_MODULE_0__["default"])(2, arguments);
                var date = (0, _toDate_index_js__WEBPACK_IMPORTED_MODULE_1__["default"])(dirtyDate);
                var amount = (0, _lib_toInteger_index_js__WEBPACK_IMPORTED_MODULE_2__["default"])(dirtyAmount);
                if (isNaN(amount)) {
                    return new Date(NaN);
                }
                if (!amount) {
                    // If 0 months, no-op to avoid changing times in the hour before end of DST
                    return date;
                }
                var dayOfMonth = date.getDate();
                // The JS Date object supports date math by accepting out-of-bounds values for
                // month, day, etc. For example, new Date(2020, 0, 0) returns 31 Dec 2019 and
                // new Date(2020, 13, 1) returns 1 Feb 2021.  This is *almost* the behavior we
                // want except that dates will wrap around the end of a month, meaning that
                // new Date(2020, 13, 31) will return 3 Mar 2021 not 28 Feb 2021 as desired. So
                // we'll default to the end of the desired month by adding 1 to the desired
                // month and using a date of 0 to back up one day to the end of the desired
                // month.
                var endOfDesiredMonth = new Date(date.getTime());
                endOfDesiredMonth.setMonth(date.getMonth() + amount + 1, 0);
                var daysInMonth = endOfDesiredMonth.getDate();
                if (dayOfMonth >= daysInMonth) {
                    // If we're already at the end of the month, then this is the correct date
                    // and we're done.
                    return endOfDesiredMonth;
                }
                else {
                    // Otherwise, we now know that setting the original day-of-month value won't
                    // cause an overflow, so set the desired day-of-month. Note that we can't
                    // just set the date of `endOfDesiredMonth` because that object may have had
                    // its time changed in the unusual case where where a DST transition was on
                    // the last day of the month and its local time was in the hour skipped or
                    // repeated next to a DST transition.  So we use `date` instead which is
                    // guaranteed to still have the original time.
                    date.setFullYear(endOfDesiredMonth.getFullYear(), endOfDesiredMonth.getMonth(), dayOfMonth);
                    return date;
                }
            }
            /***/ 
        }),
        /***/ "./node_modules/date-fns/esm/addWeeks/index.js": 
        /*!*****************************************************!*\
          !*** ./node_modules/date-fns/esm/addWeeks/index.js ***!
          \*****************************************************/
        /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony export */ __webpack_require__.d(__webpack_exports__, {
                /* harmony export */ "default": () => ( /* binding */addWeeks)
                /* harmony export */ 
            });
            /* harmony import */ var _lib_toInteger_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../_lib/toInteger/index.js */ "./node_modules/date-fns/esm/_lib/toInteger/index.js");
            /* harmony import */ var _addDays_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../addDays/index.js */ "./node_modules/date-fns/esm/addDays/index.js");
            /* harmony import */ var _lib_requiredArgs_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../_lib/requiredArgs/index.js */ "./node_modules/date-fns/esm/_lib/requiredArgs/index.js");
            /**
             * @name addWeeks
             * @category Week Helpers
             * @summary Add the specified number of weeks to the given date.
             *
             * @description
             * Add the specified number of week to the given date.
             *
             * @param {Date|Number} date - the date to be changed
             * @param {Number} amount - the amount of weeks to be added. Positive decimals will be rounded using `Math.floor`, decimals less than zero will be rounded using `Math.ceil`.
             * @returns {Date} the new date with the weeks added
             * @throws {TypeError} 2 arguments required
             *
             * @example
             * // Add 4 weeks to 1 September 2014:
             * const result = addWeeks(new Date(2014, 8, 1), 4)
             * //=> Mon Sep 29 2014 00:00:00
             */
            function addWeeks(dirtyDate, dirtyAmount) {
                (0, _lib_requiredArgs_index_js__WEBPACK_IMPORTED_MODULE_0__["default"])(2, arguments);
                var amount = (0, _lib_toInteger_index_js__WEBPACK_IMPORTED_MODULE_1__["default"])(dirtyAmount);
                var days = amount * 7;
                return (0, _addDays_index_js__WEBPACK_IMPORTED_MODULE_2__["default"])(dirtyDate, days);
            }
            /***/ 
        }),
        /***/ "./node_modules/date-fns/esm/addYears/index.js": 
        /*!*****************************************************!*\
          !*** ./node_modules/date-fns/esm/addYears/index.js ***!
          \*****************************************************/
        /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony export */ __webpack_require__.d(__webpack_exports__, {
                /* harmony export */ "default": () => ( /* binding */addYears)
                /* harmony export */ 
            });
            /* harmony import */ var _lib_toInteger_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../_lib/toInteger/index.js */ "./node_modules/date-fns/esm/_lib/toInteger/index.js");
            /* harmony import */ var _addMonths_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../addMonths/index.js */ "./node_modules/date-fns/esm/addMonths/index.js");
            /* harmony import */ var _lib_requiredArgs_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../_lib/requiredArgs/index.js */ "./node_modules/date-fns/esm/_lib/requiredArgs/index.js");
            /**
             * @name addYears
             * @category Year Helpers
             * @summary Add the specified number of years to the given date.
             *
             * @description
             * Add the specified number of years to the given date.
             *
             * @param {Date|Number} date - the date to be changed
             * @param {Number} amount - the amount of years to be added. Positive decimals will be rounded using `Math.floor`, decimals less than zero will be rounded using `Math.ceil`.
             * @returns {Date} the new date with the years added
             * @throws {TypeError} 2 arguments required
             *
             * @example
             * // Add 5 years to 1 September 2014:
             * const result = addYears(new Date(2014, 8, 1), 5)
             * //=> Sun Sep 01 2019 00:00:00
             */
            function addYears(dirtyDate, dirtyAmount) {
                (0, _lib_requiredArgs_index_js__WEBPACK_IMPORTED_MODULE_0__["default"])(2, arguments);
                var amount = (0, _lib_toInteger_index_js__WEBPACK_IMPORTED_MODULE_1__["default"])(dirtyAmount);
                return (0, _addMonths_index_js__WEBPACK_IMPORTED_MODULE_2__["default"])(dirtyDate, amount * 12);
            }
            /***/ 
        }),
        /***/ "./node_modules/date-fns/esm/constants/index.js": 
        /*!******************************************************!*\
          !*** ./node_modules/date-fns/esm/constants/index.js ***!
          \******************************************************/
        /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony export */ __webpack_require__.d(__webpack_exports__, {
                /* harmony export */ daysInWeek: () => ( /* binding */daysInWeek),
                /* harmony export */ daysInYear: () => ( /* binding */daysInYear),
                /* harmony export */ maxTime: () => ( /* binding */maxTime),
                /* harmony export */ millisecondsInHour: () => ( /* binding */millisecondsInHour),
                /* harmony export */ millisecondsInMinute: () => ( /* binding */millisecondsInMinute),
                /* harmony export */ millisecondsInSecond: () => ( /* binding */millisecondsInSecond),
                /* harmony export */ minTime: () => ( /* binding */minTime),
                /* harmony export */ minutesInHour: () => ( /* binding */minutesInHour),
                /* harmony export */ monthsInQuarter: () => ( /* binding */monthsInQuarter),
                /* harmony export */ monthsInYear: () => ( /* binding */monthsInYear),
                /* harmony export */ quartersInYear: () => ( /* binding */quartersInYear),
                /* harmony export */ secondsInDay: () => ( /* binding */secondsInDay),
                /* harmony export */ secondsInHour: () => ( /* binding */secondsInHour),
                /* harmony export */ secondsInMinute: () => ( /* binding */secondsInMinute),
                /* harmony export */ secondsInMonth: () => ( /* binding */secondsInMonth),
                /* harmony export */ secondsInQuarter: () => ( /* binding */secondsInQuarter),
                /* harmony export */ secondsInWeek: () => ( /* binding */secondsInWeek),
                /* harmony export */ secondsInYear: () => ( /* binding */secondsInYear)
                /* harmony export */ 
            });
            /**
             * Days in 1 week.
             *
             * @name daysInWeek
             * @constant
             * @type {number}
             * @default
             */
            var daysInWeek = 7;
            /**
             * Days in 1 year
             * One years equals 365.2425 days according to the formula:
             *
             * > Leap year occures every 4 years, except for years that are divisable by 100 and not divisable by 400.
             * > 1 mean year = (365+1/4-1/100+1/400) days = 365.2425 days
             *
             * @name daysInYear
             * @constant
             * @type {number}
             * @default
             */
            var daysInYear = 365.2425;
            /**
             * Maximum allowed time.
             *
             * @name maxTime
             * @constant
             * @type {number}
             * @default
             */
            var maxTime = Math.pow(10, 8) * 24 * 60 * 60 * 1000;
            /**
             * Milliseconds in 1 minute
             *
             * @name millisecondsInMinute
             * @constant
             * @type {number}
             * @default
             */
            var millisecondsInMinute = 60000;
            /**
             * Milliseconds in 1 hour
             *
             * @name millisecondsInHour
             * @constant
             * @type {number}
             * @default
             */
            var millisecondsInHour = 3600000;
            /**
             * Milliseconds in 1 second
             *
             * @name millisecondsInSecond
             * @constant
             * @type {number}
             * @default
             */
            var millisecondsInSecond = 1000;
            /**
             * Minimum allowed time.
             *
             * @name minTime
             * @constant
             * @type {number}
             * @default
             */
            var minTime = -maxTime;
            /**
             * Minutes in 1 hour
             *
             * @name minutesInHour
             * @constant
             * @type {number}
             * @default
             */
            var minutesInHour = 60;
            /**
             * Months in 1 quarter
             *
             * @name monthsInQuarter
             * @constant
             * @type {number}
             * @default
             */
            var monthsInQuarter = 3;
            /**
             * Months in 1 year
             *
             * @name monthsInYear
             * @constant
             * @type {number}
             * @default
             */
            var monthsInYear = 12;
            /**
             * Quarters in 1 year
             *
             * @name quartersInYear
             * @constant
             * @type {number}
             * @default
             */
            var quartersInYear = 4;
            /**
             * Seconds in 1 hour
             *
             * @name secondsInHour
             * @constant
             * @type {number}
             * @default
             */
            var secondsInHour = 3600;
            /**
             * Seconds in 1 minute
             *
             * @name secondsInMinute
             * @constant
             * @type {number}
             * @default
             */
            var secondsInMinute = 60;
            /**
             * Seconds in 1 day
             *
             * @name secondsInDay
             * @constant
             * @type {number}
             * @default
             */
            var secondsInDay = secondsInHour * 24;
            /**
             * Seconds in 1 week
             *
             * @name secondsInWeek
             * @constant
             * @type {number}
             * @default
             */
            var secondsInWeek = secondsInDay * 7;
            /**
             * Seconds in 1 year
             *
             * @name secondsInYear
             * @constant
             * @type {number}
             * @default
             */
            var secondsInYear = secondsInDay * daysInYear;
            /**
             * Seconds in 1 month
             *
             * @name secondsInMonth
             * @constant
             * @type {number}
             * @default
             */
            var secondsInMonth = secondsInYear / 12;
            /**
             * Seconds in 1 quarter
             *
             * @name secondsInQuarter
             * @constant
             * @type {number}
             * @default
             */
            var secondsInQuarter = secondsInMonth * 3;
            /***/ 
        }),
        /***/ "./node_modules/date-fns/esm/differenceInCalendarDays/index.js": 
        /*!*********************************************************************!*\
          !*** ./node_modules/date-fns/esm/differenceInCalendarDays/index.js ***!
          \*********************************************************************/
        /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony export */ __webpack_require__.d(__webpack_exports__, {
                /* harmony export */ "default": () => ( /* binding */differenceInCalendarDays)
                /* harmony export */ 
            });
            /* harmony import */ var _lib_getTimezoneOffsetInMilliseconds_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../_lib/getTimezoneOffsetInMilliseconds/index.js */ "./node_modules/date-fns/esm/_lib/getTimezoneOffsetInMilliseconds/index.js");
            /* harmony import */ var _startOfDay_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../startOfDay/index.js */ "./node_modules/date-fns/esm/startOfDay/index.js");
            /* harmony import */ var _lib_requiredArgs_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../_lib/requiredArgs/index.js */ "./node_modules/date-fns/esm/_lib/requiredArgs/index.js");
            var MILLISECONDS_IN_DAY = 86400000;
            /**
             * @name differenceInCalendarDays
             * @category Day Helpers
             * @summary Get the number of calendar days between the given dates.
             *
             * @description
             * Get the number of calendar days between the given dates. This means that the times are removed
             * from the dates and then the difference in days is calculated.
             *
             * @param {Date|Number} dateLeft - the later date
             * @param {Date|Number} dateRight - the earlier date
             * @returns {Number} the number of calendar days
             * @throws {TypeError} 2 arguments required
             *
             * @example
             * // How many calendar days are between
             * // 2 July 2011 23:00:00 and 2 July 2012 00:00:00?
             * const result = differenceInCalendarDays(
             *   new Date(2012, 6, 2, 0, 0),
             *   new Date(2011, 6, 2, 23, 0)
             * )
             * //=> 366
             * // How many calendar days are between
             * // 2 July 2011 23:59:00 and 3 July 2011 00:01:00?
             * const result = differenceInCalendarDays(
             *   new Date(2011, 6, 3, 0, 1),
             *   new Date(2011, 6, 2, 23, 59)
             * )
             * //=> 1
             */
            function differenceInCalendarDays(dirtyDateLeft, dirtyDateRight) {
                (0, _lib_requiredArgs_index_js__WEBPACK_IMPORTED_MODULE_0__["default"])(2, arguments);
                var startOfDayLeft = (0, _startOfDay_index_js__WEBPACK_IMPORTED_MODULE_1__["default"])(dirtyDateLeft);
                var startOfDayRight = (0, _startOfDay_index_js__WEBPACK_IMPORTED_MODULE_1__["default"])(dirtyDateRight);
                var timestampLeft = startOfDayLeft.getTime() - (0, _lib_getTimezoneOffsetInMilliseconds_index_js__WEBPACK_IMPORTED_MODULE_2__["default"])(startOfDayLeft);
                var timestampRight = startOfDayRight.getTime() - (0, _lib_getTimezoneOffsetInMilliseconds_index_js__WEBPACK_IMPORTED_MODULE_2__["default"])(startOfDayRight);
                // Round the number of days to the nearest integer
                // because the number of milliseconds in a day is not constant
                // (e.g. it's different in the day of the daylight saving time clock shift)
                return Math.round((timestampLeft - timestampRight) / MILLISECONDS_IN_DAY);
            }
            /***/ 
        }),
        /***/ "./node_modules/date-fns/esm/differenceInCalendarMonths/index.js": 
        /*!***********************************************************************!*\
          !*** ./node_modules/date-fns/esm/differenceInCalendarMonths/index.js ***!
          \***********************************************************************/
        /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony export */ __webpack_require__.d(__webpack_exports__, {
                /* harmony export */ "default": () => ( /* binding */differenceInCalendarMonths)
                /* harmony export */ 
            });
            /* harmony import */ var _toDate_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../toDate/index.js */ "./node_modules/date-fns/esm/toDate/index.js");
            /* harmony import */ var _lib_requiredArgs_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../_lib/requiredArgs/index.js */ "./node_modules/date-fns/esm/_lib/requiredArgs/index.js");
            /**
             * @name differenceInCalendarMonths
             * @category Month Helpers
             * @summary Get the number of calendar months between the given dates.
             *
             * @description
             * Get the number of calendar months between the given dates.
             *
             * @param {Date|Number} dateLeft - the later date
             * @param {Date|Number} dateRight - the earlier date
             * @returns {Number} the number of calendar months
             * @throws {TypeError} 2 arguments required
             *
             * @example
             * // How many calendar months are between 31 January 2014 and 1 September 2014?
             * const result = differenceInCalendarMonths(
             *   new Date(2014, 8, 1),
             *   new Date(2014, 0, 31)
             * )
             * //=> 8
             */
            function differenceInCalendarMonths(dirtyDateLeft, dirtyDateRight) {
                (0, _lib_requiredArgs_index_js__WEBPACK_IMPORTED_MODULE_0__["default"])(2, arguments);
                var dateLeft = (0, _toDate_index_js__WEBPACK_IMPORTED_MODULE_1__["default"])(dirtyDateLeft);
                var dateRight = (0, _toDate_index_js__WEBPACK_IMPORTED_MODULE_1__["default"])(dirtyDateRight);
                var yearDiff = dateLeft.getFullYear() - dateRight.getFullYear();
                var monthDiff = dateLeft.getMonth() - dateRight.getMonth();
                return yearDiff * 12 + monthDiff;
            }
            /***/ 
        }),
        /***/ "./node_modules/date-fns/esm/differenceInDays/index.js": 
        /*!*************************************************************!*\
          !*** ./node_modules/date-fns/esm/differenceInDays/index.js ***!
          \*************************************************************/
        /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony export */ __webpack_require__.d(__webpack_exports__, {
                /* harmony export */ "default": () => ( /* binding */differenceInDays)
                /* harmony export */ 
            });
            /* harmony import */ var _toDate_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../toDate/index.js */ "./node_modules/date-fns/esm/toDate/index.js");
            /* harmony import */ var _differenceInCalendarDays_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../differenceInCalendarDays/index.js */ "./node_modules/date-fns/esm/differenceInCalendarDays/index.js");
            /* harmony import */ var _lib_requiredArgs_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../_lib/requiredArgs/index.js */ "./node_modules/date-fns/esm/_lib/requiredArgs/index.js");
            // Like `compareAsc` but uses local time not UTC, which is needed
            // for accurate equality comparisons of UTC timestamps that end up
            // having the same representation in local time, e.g. one hour before
            // DST ends vs. the instant that DST ends.
            function compareLocalAsc(dateLeft, dateRight) {
                var diff = dateLeft.getFullYear() - dateRight.getFullYear() || dateLeft.getMonth() - dateRight.getMonth() || dateLeft.getDate() - dateRight.getDate() || dateLeft.getHours() - dateRight.getHours() || dateLeft.getMinutes() - dateRight.getMinutes() || dateLeft.getSeconds() - dateRight.getSeconds() || dateLeft.getMilliseconds() - dateRight.getMilliseconds();
                if (diff < 0) {
                    return -1;
                }
                else if (diff > 0) {
                    return 1;
                    // Return 0 if diff is 0; return NaN if diff is NaN
                }
                else {
                    return diff;
                }
            }
            /**
             * @name differenceInDays
             * @category Day Helpers
             * @summary Get the number of full days between the given dates.
             *
             * @description
             * Get the number of full day periods between two dates. Fractional days are
             * truncated towards zero.
             *
             * One "full day" is the distance between a local time in one day to the same
             * local time on the next or previous day. A full day can sometimes be less than
             * or more than 24 hours if a daylight savings change happens between two dates.
             *
             * To ignore DST and only measure exact 24-hour periods, use this instead:
             * `Math.floor(differenceInHours(dateLeft, dateRight)/24)|0`.
             *
             *
             * @param {Date|Number} dateLeft - the later date
             * @param {Date|Number} dateRight - the earlier date
             * @returns {Number} the number of full days according to the local timezone
             * @throws {TypeError} 2 arguments required
             *
             * @example
             * // How many full days are between
             * // 2 July 2011 23:00:00 and 2 July 2012 00:00:00?
             * const result = differenceInDays(
             *   new Date(2012, 6, 2, 0, 0),
             *   new Date(2011, 6, 2, 23, 0)
             * )
             * //=> 365
             * // How many full days are between
             * // 2 July 2011 23:59:00 and 3 July 2011 00:01:00?
             * const result = differenceInDays(
             *   new Date(2011, 6, 3, 0, 1),
             *   new Date(2011, 6, 2, 23, 59)
             * )
             * //=> 0
             * // How many full days are between
             * // 1 March 2020 0:00 and 1 June 2020 0:00 ?
             * // Note: because local time is used, the
             * // result will always be 92 days, even in
             * // time zones where DST starts and the
             * // period has only 92*24-1 hours.
             * const result = differenceInDays(
             *   new Date(2020, 5, 1),
             *   new Date(2020, 2, 1)
             * )
            //=> 92
             */
            function differenceInDays(dirtyDateLeft, dirtyDateRight) {
                (0, _lib_requiredArgs_index_js__WEBPACK_IMPORTED_MODULE_0__["default"])(2, arguments);
                var dateLeft = (0, _toDate_index_js__WEBPACK_IMPORTED_MODULE_1__["default"])(dirtyDateLeft);
                var dateRight = (0, _toDate_index_js__WEBPACK_IMPORTED_MODULE_1__["default"])(dirtyDateRight);
                var sign = compareLocalAsc(dateLeft, dateRight);
                var difference = Math.abs((0, _differenceInCalendarDays_index_js__WEBPACK_IMPORTED_MODULE_2__["default"])(dateLeft, dateRight));
                dateLeft.setDate(dateLeft.getDate() - sign * difference);
                // Math.abs(diff in full days - diff in calendar days) === 1 if last calendar day is not full
                // If so, result must be decreased by 1 in absolute value
                var isLastDayNotFull = Number(compareLocalAsc(dateLeft, dateRight) === -sign);
                var result = sign * (difference - isLastDayNotFull);
                // Prevent negative zero
                return result === 0 ? 0 : result;
            }
            /***/ 
        }),
        /***/ "./node_modules/date-fns/esm/differenceInMilliseconds/index.js": 
        /*!*********************************************************************!*\
          !*** ./node_modules/date-fns/esm/differenceInMilliseconds/index.js ***!
          \*********************************************************************/
        /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony export */ __webpack_require__.d(__webpack_exports__, {
                /* harmony export */ "default": () => ( /* binding */differenceInMilliseconds)
                /* harmony export */ 
            });
            /* harmony import */ var _toDate_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../toDate/index.js */ "./node_modules/date-fns/esm/toDate/index.js");
            /* harmony import */ var _lib_requiredArgs_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../_lib/requiredArgs/index.js */ "./node_modules/date-fns/esm/_lib/requiredArgs/index.js");
            /**
             * @name differenceInMilliseconds
             * @category Millisecond Helpers
             * @summary Get the number of milliseconds between the given dates.
             *
             * @description
             * Get the number of milliseconds between the given dates.
             *
             * @param {Date|Number} dateLeft - the later date
             * @param {Date|Number} dateRight - the earlier date
             * @returns {Number} the number of milliseconds
             * @throws {TypeError} 2 arguments required
             *
             * @example
             * // How many milliseconds are between
             * // 2 July 2014 12:30:20.600 and 2 July 2014 12:30:21.700?
             * const result = differenceInMilliseconds(
             *   new Date(2014, 6, 2, 12, 30, 21, 700),
             *   new Date(2014, 6, 2, 12, 30, 20, 600)
             * )
             * //=> 1100
             */
            function differenceInMilliseconds(dateLeft, dateRight) {
                (0, _lib_requiredArgs_index_js__WEBPACK_IMPORTED_MODULE_0__["default"])(2, arguments);
                return (0, _toDate_index_js__WEBPACK_IMPORTED_MODULE_1__["default"])(dateLeft).getTime() - (0, _toDate_index_js__WEBPACK_IMPORTED_MODULE_1__["default"])(dateRight).getTime();
            }
            /***/ 
        }),
        /***/ "./node_modules/date-fns/esm/endOfMonth/index.js": 
        /*!*******************************************************!*\
          !*** ./node_modules/date-fns/esm/endOfMonth/index.js ***!
          \*******************************************************/
        /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony export */ __webpack_require__.d(__webpack_exports__, {
                /* harmony export */ "default": () => ( /* binding */endOfMonth)
                /* harmony export */ 
            });
            /* harmony import */ var _toDate_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../toDate/index.js */ "./node_modules/date-fns/esm/toDate/index.js");
            /* harmony import */ var _lib_requiredArgs_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../_lib/requiredArgs/index.js */ "./node_modules/date-fns/esm/_lib/requiredArgs/index.js");
            /**
             * @name endOfMonth
             * @category Month Helpers
             * @summary Return the end of a month for the given date.
             *
             * @description
             * Return the end of a month for the given date.
             * The result will be in the local timezone.
             *
             * @param {Date|Number} date - the original date
             * @returns {Date} the end of a month
             * @throws {TypeError} 1 argument required
             *
             * @example
             * // The end of a month for 2 September 2014 11:55:00:
             * const result = endOfMonth(new Date(2014, 8, 2, 11, 55, 0))
             * //=> Tue Sep 30 2014 23:59:59.999
             */
            function endOfMonth(dirtyDate) {
                (0, _lib_requiredArgs_index_js__WEBPACK_IMPORTED_MODULE_0__["default"])(1, arguments);
                var date = (0, _toDate_index_js__WEBPACK_IMPORTED_MODULE_1__["default"])(dirtyDate);
                var month = date.getMonth();
                date.setFullYear(date.getFullYear(), month + 1, 0);
                date.setHours(23, 59, 59, 999);
                return date;
            }
            /***/ 
        }),
        /***/ "./node_modules/date-fns/esm/endOfWeek/index.js": 
        /*!******************************************************!*\
          !*** ./node_modules/date-fns/esm/endOfWeek/index.js ***!
          \******************************************************/
        /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony export */ __webpack_require__.d(__webpack_exports__, {
                /* harmony export */ "default": () => ( /* binding */endOfWeek)
                /* harmony export */ 
            });
            /* harmony import */ var _lib_defaultOptions_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../_lib/defaultOptions/index.js */ "./node_modules/date-fns/esm/_lib/defaultOptions/index.js");
            /* harmony import */ var _toDate_index_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../toDate/index.js */ "./node_modules/date-fns/esm/toDate/index.js");
            /* harmony import */ var _lib_toInteger_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../_lib/toInteger/index.js */ "./node_modules/date-fns/esm/_lib/toInteger/index.js");
            /* harmony import */ var _lib_requiredArgs_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../_lib/requiredArgs/index.js */ "./node_modules/date-fns/esm/_lib/requiredArgs/index.js");
            /**
             * @name endOfWeek
             * @category Week Helpers
             * @summary Return the end of a week for the given date.
             *
             * @description
             * Return the end of a week for the given date.
             * The result will be in the local timezone.
             *
             * @param {Date|Number} date - the original date
             * @param {Object} [options] - an object with options.
             * @param {Locale} [options.locale=defaultLocale] - the locale object. See [Locale]{@link https://date-fns.org/docs/Locale}
             * @param {0|1|2|3|4|5|6} [options.weekStartsOn=0] - the index of the first day of the week (0 - Sunday)
             * @returns {Date} the end of a week
             * @throws {TypeError} 1 argument required
             * @throws {RangeError} `options.weekStartsOn` must be between 0 and 6
             *
             * @example
             * // The end of a week for 2 September 2014 11:55:00:
             * const result = endOfWeek(new Date(2014, 8, 2, 11, 55, 0))
             * //=> Sat Sep 06 2014 23:59:59.999
             *
             * @example
             * // If the week starts on Monday, the end of the week for 2 September 2014 11:55:00:
             * const result = endOfWeek(new Date(2014, 8, 2, 11, 55, 0), { weekStartsOn: 1 })
             * //=> Sun Sep 07 2014 23:59:59.999
             */
            function endOfWeek(dirtyDate, options) {
                var _ref, _ref2, _ref3, _options$weekStartsOn, _options$locale, _options$locale$optio, _defaultOptions$local, _defaultOptions$local2;
                (0, _lib_requiredArgs_index_js__WEBPACK_IMPORTED_MODULE_0__["default"])(1, arguments);
                var defaultOptions = (0, _lib_defaultOptions_index_js__WEBPACK_IMPORTED_MODULE_1__.getDefaultOptions)();
                var weekStartsOn = (0, _lib_toInteger_index_js__WEBPACK_IMPORTED_MODULE_2__["default"])((_ref = (_ref2 = (_ref3 = (_options$weekStartsOn = options === null || options === void 0 ? void 0 : options.weekStartsOn) !== null && _options$weekStartsOn !== void 0 ? _options$weekStartsOn : options === null || options === void 0 ? void 0 : (_options$locale = options.locale) === null || _options$locale === void 0 ? void 0 : (_options$locale$optio = _options$locale.options) === null || _options$locale$optio === void 0 ? void 0 : _options$locale$optio.weekStartsOn) !== null && _ref3 !== void 0 ? _ref3 : defaultOptions.weekStartsOn) !== null && _ref2 !== void 0 ? _ref2 : (_defaultOptions$local = defaultOptions.locale) === null || _defaultOptions$local === void 0 ? void 0 : (_defaultOptions$local2 = _defaultOptions$local.options) === null || _defaultOptions$local2 === void 0 ? void 0 : _defaultOptions$local2.weekStartsOn) !== null && _ref !== void 0 ? _ref : 0);
                // Test if weekStartsOn is between 0 and 6 _and_ is not NaN
                if (!(weekStartsOn >= 0 && weekStartsOn <= 6)) {
                    throw new RangeError('weekStartsOn must be between 0 and 6 inclusively');
                }
                var date = (0, _toDate_index_js__WEBPACK_IMPORTED_MODULE_3__["default"])(dirtyDate);
                var day = date.getDay();
                var diff = (day < weekStartsOn ? -7 : 0) + 6 - (day - weekStartsOn);
                date.setDate(date.getDate() + diff);
                date.setHours(23, 59, 59, 999);
                return date;
            }
            /***/ 
        }),
        /***/ "./node_modules/date-fns/esm/format/index.js": 
        /*!***************************************************!*\
          !*** ./node_modules/date-fns/esm/format/index.js ***!
          \***************************************************/
        /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony export */ __webpack_require__.d(__webpack_exports__, {
                /* harmony export */ "default": () => ( /* binding */format)
                /* harmony export */ 
            });
            /* harmony import */ var _isValid_index_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../isValid/index.js */ "./node_modules/date-fns/esm/isValid/index.js");
            /* harmony import */ var _subMilliseconds_index_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../subMilliseconds/index.js */ "./node_modules/date-fns/esm/subMilliseconds/index.js");
            /* harmony import */ var _toDate_index_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../toDate/index.js */ "./node_modules/date-fns/esm/toDate/index.js");
            /* harmony import */ var _lib_format_formatters_index_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../_lib/format/formatters/index.js */ "./node_modules/date-fns/esm/_lib/format/formatters/index.js");
            /* harmony import */ var _lib_format_longFormatters_index_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../_lib/format/longFormatters/index.js */ "./node_modules/date-fns/esm/_lib/format/longFormatters/index.js");
            /* harmony import */ var _lib_getTimezoneOffsetInMilliseconds_index_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../_lib/getTimezoneOffsetInMilliseconds/index.js */ "./node_modules/date-fns/esm/_lib/getTimezoneOffsetInMilliseconds/index.js");
            /* harmony import */ var _lib_protectedTokens_index_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../_lib/protectedTokens/index.js */ "./node_modules/date-fns/esm/_lib/protectedTokens/index.js");
            /* harmony import */ var _lib_toInteger_index_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../_lib/toInteger/index.js */ "./node_modules/date-fns/esm/_lib/toInteger/index.js");
            /* harmony import */ var _lib_requiredArgs_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../_lib/requiredArgs/index.js */ "./node_modules/date-fns/esm/_lib/requiredArgs/index.js");
            /* harmony import */ var _lib_defaultOptions_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../_lib/defaultOptions/index.js */ "./node_modules/date-fns/esm/_lib/defaultOptions/index.js");
            /* harmony import */ var _lib_defaultLocale_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../_lib/defaultLocale/index.js */ "./node_modules/date-fns/esm/_lib/defaultLocale/index.js");
            // This RegExp consists of three parts separated by `|`:
            // - [yYQqMLwIdDecihHKkms]o matches any available ordinal number token
            //   (one of the certain letters followed by `o`)
            // - (\w)\1* matches any sequences of the same letter
            // - '' matches two quote characters in a row
            // - '(''|[^'])+('|$) matches anything surrounded by two quote characters ('),
            //   except a single quote symbol, which ends the sequence.
            //   Two quote characters do not end the sequence.
            //   If there is no matching single quote
            //   then the sequence will continue until the end of the string.
            // - . matches any single character unmatched by previous parts of the RegExps
            var formattingTokensRegExp = /[yYQqMLwIdDecihHKkms]o|(\w)\1*|''|'(''|[^'])+('|$)|./g;
            // This RegExp catches symbols escaped by quotes, and also
            // sequences of symbols P, p, and the combinations like `PPPPPPPppppp`
            var longFormattingTokensRegExp = /P+p+|P+|p+|''|'(''|[^'])+('|$)|./g;
            var escapedStringRegExp = /^'([^]*?)'?$/;
            var doubleQuoteRegExp = /''/g;
            var unescapedLatinCharacterRegExp = /[a-zA-Z]/;
            /**
             * @name format
             * @category Common Helpers
             * @summary Format the date.
             *
             * @description
             * Return the formatted date string in the given format. The result may vary by locale.
             *
             * >  Please note that the `format` tokens differ from Moment.js and other libraries.
             * > See: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
             *
             * The characters wrapped between two single quotes characters (') are escaped.
             * Two single quotes in a row, whether inside or outside a quoted sequence, represent a 'real' single quote.
             * (see the last example)
             *
             * Format of the string is based on Unicode Technical Standard #35:
             * https://www.unicode.org/reports/tr35/tr35-dates.html#Date_Field_Symbol_Table
             * with a few additions (see note 7 below the table).
             *
             * Accepted patterns:
             * | Unit                            | Pattern | Result examples                   | Notes |
             * |---------------------------------|---------|-----------------------------------|-------|
             * | Era                             | G..GGG  | AD, BC                            |       |
             * |                                 | GGGG    | Anno Domini, Before Christ        | 2     |
             * |                                 | GGGGG   | A, B                              |       |
             * | Calendar year                   | y       | 44, 1, 1900, 2017                 | 5     |
             * |                                 | yo      | 44th, 1st, 0th, 17th              | 5,7   |
             * |                                 | yy      | 44, 01, 00, 17                    | 5     |
             * |                                 | yyy     | 044, 001, 1900, 2017              | 5     |
             * |                                 | yyyy    | 0044, 0001, 1900, 2017            | 5     |
             * |                                 | yyyyy   | ...                               | 3,5   |
             * | Local week-numbering year       | Y       | 44, 1, 1900, 2017                 | 5     |
             * |                                 | Yo      | 44th, 1st, 1900th, 2017th         | 5,7   |
             * |                                 | YY      | 44, 01, 00, 17                    | 5,8   |
             * |                                 | YYY     | 044, 001, 1900, 2017              | 5     |
             * |                                 | YYYY    | 0044, 0001, 1900, 2017            | 5,8   |
             * |                                 | YYYYY   | ...                               | 3,5   |
             * | ISO week-numbering year         | R       | -43, 0, 1, 1900, 2017             | 5,7   |
             * |                                 | RR      | -43, 00, 01, 1900, 2017           | 5,7   |
             * |                                 | RRR     | -043, 000, 001, 1900, 2017        | 5,7   |
             * |                                 | RRRR    | -0043, 0000, 0001, 1900, 2017     | 5,7   |
             * |                                 | RRRRR   | ...                               | 3,5,7 |
             * | Extended year                   | u       | -43, 0, 1, 1900, 2017             | 5     |
             * |                                 | uu      | -43, 01, 1900, 2017               | 5     |
             * |                                 | uuu     | -043, 001, 1900, 2017             | 5     |
             * |                                 | uuuu    | -0043, 0001, 1900, 2017           | 5     |
             * |                                 | uuuuu   | ...                               | 3,5   |
             * | Quarter (formatting)            | Q       | 1, 2, 3, 4                        |       |
             * |                                 | Qo      | 1st, 2nd, 3rd, 4th                | 7     |
             * |                                 | QQ      | 01, 02, 03, 04                    |       |
             * |                                 | QQQ     | Q1, Q2, Q3, Q4                    |       |
             * |                                 | QQQQ    | 1st quarter, 2nd quarter, ...     | 2     |
             * |                                 | QQQQQ   | 1, 2, 3, 4                        | 4     |
             * | Quarter (stand-alone)           | q       | 1, 2, 3, 4                        |       |
             * |                                 | qo      | 1st, 2nd, 3rd, 4th                | 7     |
             * |                                 | qq      | 01, 02, 03, 04                    |       |
             * |                                 | qqq     | Q1, Q2, Q3, Q4                    |       |
             * |                                 | qqqq    | 1st quarter, 2nd quarter, ...     | 2     |
             * |                                 | qqqqq   | 1, 2, 3, 4                        | 4     |
             * | Month (formatting)              | M       | 1, 2, ..., 12                     |       |
             * |                                 | Mo      | 1st, 2nd, ..., 12th               | 7     |
             * |                                 | MM      | 01, 02, ..., 12                   |       |
             * |                                 | MMM     | Jan, Feb, ..., Dec                |       |
             * |                                 | MMMM    | January, February, ..., December  | 2     |
             * |                                 | MMMMM   | J, F, ..., D                      |       |
             * | Month (stand-alone)             | L       | 1, 2, ..., 12                     |       |
             * |                                 | Lo      | 1st, 2nd, ..., 12th               | 7     |
             * |                                 | LL      | 01, 02, ..., 12                   |       |
             * |                                 | LLL     | Jan, Feb, ..., Dec                |       |
             * |                                 | LLLL    | January, February, ..., December  | 2     |
             * |                                 | LLLLL   | J, F, ..., D                      |       |
             * | Local week of year              | w       | 1, 2, ..., 53                     |       |
             * |                                 | wo      | 1st, 2nd, ..., 53th               | 7     |
             * |                                 | ww      | 01, 02, ..., 53                   |       |
             * | ISO week of year                | I       | 1, 2, ..., 53                     | 7     |
             * |                                 | Io      | 1st, 2nd, ..., 53th               | 7     |
             * |                                 | II      | 01, 02, ..., 53                   | 7     |
             * | Day of month                    | d       | 1, 2, ..., 31                     |       |
             * |                                 | do      | 1st, 2nd, ..., 31st               | 7     |
             * |                                 | dd      | 01, 02, ..., 31                   |       |
             * | Day of year                     | D       | 1, 2, ..., 365, 366               | 9     |
             * |                                 | Do      | 1st, 2nd, ..., 365th, 366th       | 7     |
             * |                                 | DD      | 01, 02, ..., 365, 366             | 9     |
             * |                                 | DDD     | 001, 002, ..., 365, 366           |       |
             * |                                 | DDDD    | ...                               | 3     |
             * | Day of week (formatting)        | E..EEE  | Mon, Tue, Wed, ..., Sun           |       |
             * |                                 | EEEE    | Monday, Tuesday, ..., Sunday      | 2     |
             * |                                 | EEEEE   | M, T, W, T, F, S, S               |       |
             * |                                 | EEEEEE  | Mo, Tu, We, Th, Fr, Sa, Su        |       |
             * | ISO day of week (formatting)    | i       | 1, 2, 3, ..., 7                   | 7     |
             * |                                 | io      | 1st, 2nd, ..., 7th                | 7     |
             * |                                 | ii      | 01, 02, ..., 07                   | 7     |
             * |                                 | iii     | Mon, Tue, Wed, ..., Sun           | 7     |
             * |                                 | iiii    | Monday, Tuesday, ..., Sunday      | 2,7   |
             * |                                 | iiiii   | M, T, W, T, F, S, S               | 7     |
             * |                                 | iiiiii  | Mo, Tu, We, Th, Fr, Sa, Su        | 7     |
             * | Local day of week (formatting)  | e       | 2, 3, 4, ..., 1                   |       |
             * |                                 | eo      | 2nd, 3rd, ..., 1st                | 7     |
             * |                                 | ee      | 02, 03, ..., 01                   |       |
             * |                                 | eee     | Mon, Tue, Wed, ..., Sun           |       |
             * |                                 | eeee    | Monday, Tuesday, ..., Sunday      | 2     |
             * |                                 | eeeee   | M, T, W, T, F, S, S               |       |
             * |                                 | eeeeee  | Mo, Tu, We, Th, Fr, Sa, Su        |       |
             * | Local day of week (stand-alone) | c       | 2, 3, 4, ..., 1                   |       |
             * |                                 | co      | 2nd, 3rd, ..., 1st                | 7     |
             * |                                 | cc      | 02, 03, ..., 01                   |       |
             * |                                 | ccc     | Mon, Tue, Wed, ..., Sun           |       |
             * |                                 | cccc    | Monday, Tuesday, ..., Sunday      | 2     |
             * |                                 | ccccc   | M, T, W, T, F, S, S               |       |
             * |                                 | cccccc  | Mo, Tu, We, Th, Fr, Sa, Su        |       |
             * | AM, PM                          | a..aa   | AM, PM                            |       |
             * |                                 | aaa     | am, pm                            |       |
             * |                                 | aaaa    | a.m., p.m.                        | 2     |
             * |                                 | aaaaa   | a, p                              |       |
             * | AM, PM, noon, midnight          | b..bb   | AM, PM, noon, midnight            |       |
             * |                                 | bbb     | am, pm, noon, midnight            |       |
             * |                                 | bbbb    | a.m., p.m., noon, midnight        | 2     |
             * |                                 | bbbbb   | a, p, n, mi                       |       |
             * | Flexible day period             | B..BBB  | at night, in the morning, ...     |       |
             * |                                 | BBBB    | at night, in the morning, ...     | 2     |
             * |                                 | BBBBB   | at night, in the morning, ...     |       |
             * | Hour [1-12]                     | h       | 1, 2, ..., 11, 12                 |       |
             * |                                 | ho      | 1st, 2nd, ..., 11th, 12th         | 7     |
             * |                                 | hh      | 01, 02, ..., 11, 12               |       |
             * | Hour [0-23]                     | H       | 0, 1, 2, ..., 23                  |       |
             * |                                 | Ho      | 0th, 1st, 2nd, ..., 23rd          | 7     |
             * |                                 | HH      | 00, 01, 02, ..., 23               |       |
             * | Hour [0-11]                     | K       | 1, 2, ..., 11, 0                  |       |
             * |                                 | Ko      | 1st, 2nd, ..., 11th, 0th          | 7     |
             * |                                 | KK      | 01, 02, ..., 11, 00               |       |
             * | Hour [1-24]                     | k       | 24, 1, 2, ..., 23                 |       |
             * |                                 | ko      | 24th, 1st, 2nd, ..., 23rd         | 7     |
             * |                                 | kk      | 24, 01, 02, ..., 23               |       |
             * | Minute                          | m       | 0, 1, ..., 59                     |       |
             * |                                 | mo      | 0th, 1st, ..., 59th               | 7     |
             * |                                 | mm      | 00, 01, ..., 59                   |       |
             * | Second                          | s       | 0, 1, ..., 59                     |       |
             * |                                 | so      | 0th, 1st, ..., 59th               | 7     |
             * |                                 | ss      | 00, 01, ..., 59                   |       |
             * | Fraction of second              | S       | 0, 1, ..., 9                      |       |
             * |                                 | SS      | 00, 01, ..., 99                   |       |
             * |                                 | SSS     | 000, 001, ..., 999                |       |
             * |                                 | SSSS    | ...                               | 3     |
             * | Timezone (ISO-8601 w/ Z)        | X       | -08, +0530, Z                     |       |
             * |                                 | XX      | -0800, +0530, Z                   |       |
             * |                                 | XXX     | -08:00, +05:30, Z                 |       |
             * |                                 | XXXX    | -0800, +0530, Z, +123456          | 2     |
             * |                                 | XXXXX   | -08:00, +05:30, Z, +12:34:56      |       |
             * | Timezone (ISO-8601 w/o Z)       | x       | -08, +0530, +00                   |       |
             * |                                 | xx      | -0800, +0530, +0000               |       |
             * |                                 | xxx     | -08:00, +05:30, +00:00            | 2     |
             * |                                 | xxxx    | -0800, +0530, +0000, +123456      |       |
             * |                                 | xxxxx   | -08:00, +05:30, +00:00, +12:34:56 |       |
             * | Timezone (GMT)                  | O...OOO | GMT-8, GMT+5:30, GMT+0            |       |
             * |                                 | OOOO    | GMT-08:00, GMT+05:30, GMT+00:00   | 2     |
             * | Timezone (specific non-locat.)  | z...zzz | GMT-8, GMT+5:30, GMT+0            | 6     |
             * |                                 | zzzz    | GMT-08:00, GMT+05:30, GMT+00:00   | 2,6   |
             * | Seconds timestamp               | t       | 512969520                         | 7     |
             * |                                 | tt      | ...                               | 3,7   |
             * | Milliseconds timestamp          | T       | 512969520900                      | 7     |
             * |                                 | TT      | ...                               | 3,7   |
             * | Long localized date             | P       | 04/29/1453                        | 7     |
             * |                                 | PP      | Apr 29, 1453                      | 7     |
             * |                                 | PPP     | April 29th, 1453                  | 7     |
             * |                                 | PPPP    | Friday, April 29th, 1453          | 2,7   |
             * | Long localized time             | p       | 12:00 AM                          | 7     |
             * |                                 | pp      | 12:00:00 AM                       | 7     |
             * |                                 | ppp     | 12:00:00 AM GMT+2                 | 7     |
             * |                                 | pppp    | 12:00:00 AM GMT+02:00             | 2,7   |
             * | Combination of date and time    | Pp      | 04/29/1453, 12:00 AM              | 7     |
             * |                                 | PPpp    | Apr 29, 1453, 12:00:00 AM         | 7     |
             * |                                 | PPPppp  | April 29th, 1453 at ...           | 7     |
             * |                                 | PPPPpppp| Friday, April 29th, 1453 at ...   | 2,7   |
             * Notes:
             * 1. "Formatting" units (e.g. formatting quarter) in the default en-US locale
             *    are the same as "stand-alone" units, but are different in some languages.
             *    "Formatting" units are declined according to the rules of the language
             *    in the context of a date. "Stand-alone" units are always nominative singular:
             *
             *    `format(new Date(2017, 10, 6), 'do LLLL', {locale: cs}) //=> '6. listopad'`
             *
             *    `format(new Date(2017, 10, 6), 'do MMMM', {locale: cs}) //=> '6. listopadu'`
             *
             * 2. Any sequence of the identical letters is a pattern, unless it is escaped by
             *    the single quote characters (see below).
             *    If the sequence is longer than listed in table (e.g. `EEEEEEEEEEE`)
             *    the output will be the same as default pattern for this unit, usually
             *    the longest one (in case of ISO weekdays, `EEEE`). Default patterns for units
             *    are marked with "2" in the last column of the table.
             *
             *    `format(new Date(2017, 10, 6), 'MMM') //=> 'Nov'`
             *
             *    `format(new Date(2017, 10, 6), 'MMMM') //=> 'November'`
             *
             *    `format(new Date(2017, 10, 6), 'MMMMM') //=> 'N'`
             *
             *    `format(new Date(2017, 10, 6), 'MMMMMM') //=> 'November'`
             *
             *    `format(new Date(2017, 10, 6), 'MMMMMMM') //=> 'November'`
             *
             * 3. Some patterns could be unlimited length (such as `yyyyyyyy`).
             *    The output will be padded with zeros to match the length of the pattern.
             *
             *    `format(new Date(2017, 10, 6), 'yyyyyyyy') //=> '00002017'`
             *
             * 4. `QQQQQ` and `qqqqq` could be not strictly numerical in some locales.
             *    These tokens represent the shortest form of the quarter.
             *
             * 5. The main difference between `y` and `u` patterns are B.C. years:
             *
             *    | Year | `y` | `u` |
             *    |------|-----|-----|
             *    | AC 1 |   1 |   1 |
             *    | BC 1 |   1 |   0 |
             *    | BC 2 |   2 |  -1 |
             *
             *    Also `yy` always returns the last two digits of a year,
             *    while `uu` pads single digit years to 2 characters and returns other years unchanged:
             *
             *    | Year | `yy` | `uu` |
             *    |------|------|------|
             *    | 1    |   01 |   01 |
             *    | 14   |   14 |   14 |
             *    | 376  |   76 |  376 |
             *    | 1453 |   53 | 1453 |
             *
             *    The same difference is true for local and ISO week-numbering years (`Y` and `R`),
             *    except local week-numbering years are dependent on `options.weekStartsOn`
             *    and `options.firstWeekContainsDate` (compare [getISOWeekYear]{@link https://date-fns.org/docs/getISOWeekYear}
             *    and [getWeekYear]{@link https://date-fns.org/docs/getWeekYear}).
             *
             * 6. Specific non-location timezones are currently unavailable in `date-fns`,
             *    so right now these tokens fall back to GMT timezones.
             *
             * 7. These patterns are not in the Unicode Technical Standard #35:
             *    - `i`: ISO day of week
             *    - `I`: ISO week of year
             *    - `R`: ISO week-numbering year
             *    - `t`: seconds timestamp
             *    - `T`: milliseconds timestamp
             *    - `o`: ordinal number modifier
             *    - `P`: long localized date
             *    - `p`: long localized time
             *
             * 8. `YY` and `YYYY` tokens represent week-numbering years but they are often confused with years.
             *    You should enable `options.useAdditionalWeekYearTokens` to use them. See: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
             *
             * 9. `D` and `DD` tokens represent days of the year but they are often confused with days of the month.
             *    You should enable `options.useAdditionalDayOfYearTokens` to use them. See: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
             *
             * @param {Date|Number} date - the original date
             * @param {String} format - the string of tokens
             * @param {Object} [options] - an object with options.
             * @param {Locale} [options.locale=defaultLocale] - the locale object. See [Locale]{@link https://date-fns.org/docs/Locale}
             * @param {0|1|2|3|4|5|6} [options.weekStartsOn=0] - the index of the first day of the week (0 - Sunday)
             * @param {Number} [options.firstWeekContainsDate=1] - the day of January, which is
             * @param {Boolean} [options.useAdditionalWeekYearTokens=false] - if true, allows usage of the week-numbering year tokens `YY` and `YYYY`;
             *   see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
             * @param {Boolean} [options.useAdditionalDayOfYearTokens=false] - if true, allows usage of the day of year tokens `D` and `DD`;
             *   see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
             * @returns {String} the formatted date string
             * @throws {TypeError} 2 arguments required
             * @throws {RangeError} `date` must not be Invalid Date
             * @throws {RangeError} `options.locale` must contain `localize` property
             * @throws {RangeError} `options.locale` must contain `formatLong` property
             * @throws {RangeError} `options.weekStartsOn` must be between 0 and 6
             * @throws {RangeError} `options.firstWeekContainsDate` must be between 1 and 7
             * @throws {RangeError} use `yyyy` instead of `YYYY` for formatting years using [format provided] to the input [input provided]; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
             * @throws {RangeError} use `yy` instead of `YY` for formatting years using [format provided] to the input [input provided]; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
             * @throws {RangeError} use `d` instead of `D` for formatting days of the month using [format provided] to the input [input provided]; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
             * @throws {RangeError} use `dd` instead of `DD` for formatting days of the month using [format provided] to the input [input provided]; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
             * @throws {RangeError} format string contains an unescaped latin alphabet character
             *
             * @example
             * // Represent 11 February 2014 in middle-endian format:
             * const result = format(new Date(2014, 1, 11), 'MM/dd/yyyy')
             * //=> '02/11/2014'
             *
             * @example
             * // Represent 2 July 2014 in Esperanto:
             * import { eoLocale } from 'date-fns/locale/eo'
             * const result = format(new Date(2014, 6, 2), "do 'de' MMMM yyyy", {
             *   locale: eoLocale
             * })
             * //=> '2-a de julio 2014'
             *
             * @example
             * // Escape string by single quote characters:
             * const result = format(new Date(2014, 6, 2, 15), "h 'o''clock'")
             * //=> "3 o'clock"
             */
            function format(dirtyDate, dirtyFormatStr, options) {
                var _ref, _options$locale, _ref2, _ref3, _ref4, _options$firstWeekCon, _options$locale2, _options$locale2$opti, _defaultOptions$local, _defaultOptions$local2, _ref5, _ref6, _ref7, _options$weekStartsOn, _options$locale3, _options$locale3$opti, _defaultOptions$local3, _defaultOptions$local4;
                (0, _lib_requiredArgs_index_js__WEBPACK_IMPORTED_MODULE_0__["default"])(2, arguments);
                var formatStr = String(dirtyFormatStr);
                var defaultOptions = (0, _lib_defaultOptions_index_js__WEBPACK_IMPORTED_MODULE_1__.getDefaultOptions)();
                var locale = (_ref = (_options$locale = options === null || options === void 0 ? void 0 : options.locale) !== null && _options$locale !== void 0 ? _options$locale : defaultOptions.locale) !== null && _ref !== void 0 ? _ref : _lib_defaultLocale_index_js__WEBPACK_IMPORTED_MODULE_2__["default"];
                var firstWeekContainsDate = (0, _lib_toInteger_index_js__WEBPACK_IMPORTED_MODULE_3__["default"])((_ref2 = (_ref3 = (_ref4 = (_options$firstWeekCon = options === null || options === void 0 ? void 0 : options.firstWeekContainsDate) !== null && _options$firstWeekCon !== void 0 ? _options$firstWeekCon : options === null || options === void 0 ? void 0 : (_options$locale2 = options.locale) === null || _options$locale2 === void 0 ? void 0 : (_options$locale2$opti = _options$locale2.options) === null || _options$locale2$opti === void 0 ? void 0 : _options$locale2$opti.firstWeekContainsDate) !== null && _ref4 !== void 0 ? _ref4 : defaultOptions.firstWeekContainsDate) !== null && _ref3 !== void 0 ? _ref3 : (_defaultOptions$local = defaultOptions.locale) === null || _defaultOptions$local === void 0 ? void 0 : (_defaultOptions$local2 = _defaultOptions$local.options) === null || _defaultOptions$local2 === void 0 ? void 0 : _defaultOptions$local2.firstWeekContainsDate) !== null && _ref2 !== void 0 ? _ref2 : 1);
                // Test if weekStartsOn is between 1 and 7 _and_ is not NaN
                if (!(firstWeekContainsDate >= 1 && firstWeekContainsDate <= 7)) {
                    throw new RangeError('firstWeekContainsDate must be between 1 and 7 inclusively');
                }
                var weekStartsOn = (0, _lib_toInteger_index_js__WEBPACK_IMPORTED_MODULE_3__["default"])((_ref5 = (_ref6 = (_ref7 = (_options$weekStartsOn = options === null || options === void 0 ? void 0 : options.weekStartsOn) !== null && _options$weekStartsOn !== void 0 ? _options$weekStartsOn : options === null || options === void 0 ? void 0 : (_options$locale3 = options.locale) === null || _options$locale3 === void 0 ? void 0 : (_options$locale3$opti = _options$locale3.options) === null || _options$locale3$opti === void 0 ? void 0 : _options$locale3$opti.weekStartsOn) !== null && _ref7 !== void 0 ? _ref7 : defaultOptions.weekStartsOn) !== null && _ref6 !== void 0 ? _ref6 : (_defaultOptions$local3 = defaultOptions.locale) === null || _defaultOptions$local3 === void 0 ? void 0 : (_defaultOptions$local4 = _defaultOptions$local3.options) === null || _defaultOptions$local4 === void 0 ? void 0 : _defaultOptions$local4.weekStartsOn) !== null && _ref5 !== void 0 ? _ref5 : 0);
                // Test if weekStartsOn is between 0 and 6 _and_ is not NaN
                if (!(weekStartsOn >= 0 && weekStartsOn <= 6)) {
                    throw new RangeError('weekStartsOn must be between 0 and 6 inclusively');
                }
                if (!locale.localize) {
                    throw new RangeError('locale must contain localize property');
                }
                if (!locale.formatLong) {
                    throw new RangeError('locale must contain formatLong property');
                }
                var originalDate = (0, _toDate_index_js__WEBPACK_IMPORTED_MODULE_4__["default"])(dirtyDate);
                if (!(0, _isValid_index_js__WEBPACK_IMPORTED_MODULE_5__["default"])(originalDate)) {
                    throw new RangeError('Invalid time value');
                }
                // Convert the date in system timezone to the same date in UTC+00:00 timezone.
                // This ensures that when UTC functions will be implemented, locales will be compatible with them.
                // See an issue about UTC functions: https://github.com/date-fns/date-fns/issues/376
                var timezoneOffset = (0, _lib_getTimezoneOffsetInMilliseconds_index_js__WEBPACK_IMPORTED_MODULE_6__["default"])(originalDate);
                var utcDate = (0, _subMilliseconds_index_js__WEBPACK_IMPORTED_MODULE_7__["default"])(originalDate, timezoneOffset);
                var formatterOptions = {
                    firstWeekContainsDate: firstWeekContainsDate,
                    weekStartsOn: weekStartsOn,
                    locale: locale,
                    _originalDate: originalDate
                };
                var result = formatStr.match(longFormattingTokensRegExp).map(function (substring) {
                    var firstCharacter = substring[0];
                    if (firstCharacter === 'p' || firstCharacter === 'P') {
                        var longFormatter = _lib_format_longFormatters_index_js__WEBPACK_IMPORTED_MODULE_8__["default"][firstCharacter];
                        return longFormatter(substring, locale.formatLong);
                    }
                    return substring;
                }).join('').match(formattingTokensRegExp).map(function (substring) {
                    // Replace two single quote characters with one single quote character
                    if (substring === "''") {
                        return "'";
                    }
                    var firstCharacter = substring[0];
                    if (firstCharacter === "'") {
                        return cleanEscapedString(substring);
                    }
                    var formatter = _lib_format_formatters_index_js__WEBPACK_IMPORTED_MODULE_9__["default"][firstCharacter];
                    if (formatter) {
                        if (!(options !== null && options !== void 0 && options.useAdditionalWeekYearTokens) && (0, _lib_protectedTokens_index_js__WEBPACK_IMPORTED_MODULE_10__.isProtectedWeekYearToken)(substring)) {
                            (0, _lib_protectedTokens_index_js__WEBPACK_IMPORTED_MODULE_10__.throwProtectedError)(substring, dirtyFormatStr, String(dirtyDate));
                        }
                        if (!(options !== null && options !== void 0 && options.useAdditionalDayOfYearTokens) && (0, _lib_protectedTokens_index_js__WEBPACK_IMPORTED_MODULE_10__.isProtectedDayOfYearToken)(substring)) {
                            (0, _lib_protectedTokens_index_js__WEBPACK_IMPORTED_MODULE_10__.throwProtectedError)(substring, dirtyFormatStr, String(dirtyDate));
                        }
                        return formatter(utcDate, substring, locale.localize, formatterOptions);
                    }
                    if (firstCharacter.match(unescapedLatinCharacterRegExp)) {
                        throw new RangeError('Format string contains an unescaped latin alphabet character `' + firstCharacter + '`');
                    }
                    return substring;
                }).join('');
                return result;
            }
            function cleanEscapedString(input) {
                var matched = input.match(escapedStringRegExp);
                if (!matched) {
                    return input;
                }
                return matched[1].replace(doubleQuoteRegExp, "'");
            }
            /***/ 
        }),
        /***/ "./node_modules/date-fns/esm/getDate/index.js": 
        /*!****************************************************!*\
          !*** ./node_modules/date-fns/esm/getDate/index.js ***!
          \****************************************************/
        /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony export */ __webpack_require__.d(__webpack_exports__, {
                /* harmony export */ "default": () => ( /* binding */getDate)
                /* harmony export */ 
            });
            /* harmony import */ var _toDate_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../toDate/index.js */ "./node_modules/date-fns/esm/toDate/index.js");
            /* harmony import */ var _lib_requiredArgs_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../_lib/requiredArgs/index.js */ "./node_modules/date-fns/esm/_lib/requiredArgs/index.js");
            /**
             * @name getDate
             * @category Day Helpers
             * @summary Get the day of the month of the given date.
             *
             * @description
             * Get the day of the month of the given date.
             *
             * @param {Date|Number} date - the given date
             * @returns {Number} the day of month
             * @throws {TypeError} 1 argument required
             *
             * @example
             * // Which day of the month is 29 February 2012?
             * const result = getDate(new Date(2012, 1, 29))
             * //=> 29
             */
            function getDate(dirtyDate) {
                (0, _lib_requiredArgs_index_js__WEBPACK_IMPORTED_MODULE_0__["default"])(1, arguments);
                var date = (0, _toDate_index_js__WEBPACK_IMPORTED_MODULE_1__["default"])(dirtyDate);
                var dayOfMonth = date.getDate();
                return dayOfMonth;
            }
            /***/ 
        }),
        /***/ "./node_modules/date-fns/esm/getDay/index.js": 
        /*!***************************************************!*\
          !*** ./node_modules/date-fns/esm/getDay/index.js ***!
          \***************************************************/
        /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony export */ __webpack_require__.d(__webpack_exports__, {
                /* harmony export */ "default": () => ( /* binding */getDay)
                /* harmony export */ 
            });
            /* harmony import */ var _toDate_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../toDate/index.js */ "./node_modules/date-fns/esm/toDate/index.js");
            /* harmony import */ var _lib_requiredArgs_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../_lib/requiredArgs/index.js */ "./node_modules/date-fns/esm/_lib/requiredArgs/index.js");
            /**
             * @name getDay
             * @category Weekday Helpers
             * @summary Get the day of the week of the given date.
             *
             * @description
             * Get the day of the week of the given date.
             *
             * @param {Date|Number} date - the given date
             * @returns {0|1|2|3|4|5|6} the day of week, 0 represents Sunday
             * @throws {TypeError} 1 argument required
             *
             * @example
             * // Which day of the week is 29 February 2012?
             * const result = getDay(new Date(2012, 1, 29))
             * //=> 3
             */
            function getDay(dirtyDate) {
                (0, _lib_requiredArgs_index_js__WEBPACK_IMPORTED_MODULE_0__["default"])(1, arguments);
                var date = (0, _toDate_index_js__WEBPACK_IMPORTED_MODULE_1__["default"])(dirtyDate);
                var day = date.getDay();
                return day;
            }
            /***/ 
        }),
        /***/ "./node_modules/date-fns/esm/isAfter/index.js": 
        /*!****************************************************!*\
          !*** ./node_modules/date-fns/esm/isAfter/index.js ***!
          \****************************************************/
        /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony export */ __webpack_require__.d(__webpack_exports__, {
                /* harmony export */ "default": () => ( /* binding */isAfter)
                /* harmony export */ 
            });
            /* harmony import */ var _toDate_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../toDate/index.js */ "./node_modules/date-fns/esm/toDate/index.js");
            /* harmony import */ var _lib_requiredArgs_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../_lib/requiredArgs/index.js */ "./node_modules/date-fns/esm/_lib/requiredArgs/index.js");
            /**
             * @name isAfter
             * @category Common Helpers
             * @summary Is the first date after the second one?
             *
             * @description
             * Is the first date after the second one?
             *
             * @param {Date|Number} date - the date that should be after the other one to return true
             * @param {Date|Number} dateToCompare - the date to compare with
             * @returns {Boolean} the first date is after the second date
             * @throws {TypeError} 2 arguments required
             *
             * @example
             * // Is 10 July 1989 after 11 February 1987?
             * const result = isAfter(new Date(1989, 6, 10), new Date(1987, 1, 11))
             * //=> true
             */
            function isAfter(dirtyDate, dirtyDateToCompare) {
                (0, _lib_requiredArgs_index_js__WEBPACK_IMPORTED_MODULE_0__["default"])(2, arguments);
                var date = (0, _toDate_index_js__WEBPACK_IMPORTED_MODULE_1__["default"])(dirtyDate);
                var dateToCompare = (0, _toDate_index_js__WEBPACK_IMPORTED_MODULE_1__["default"])(dirtyDateToCompare);
                return date.getTime() > dateToCompare.getTime();
            }
            /***/ 
        }),
        /***/ "./node_modules/date-fns/esm/isBefore/index.js": 
        /*!*****************************************************!*\
          !*** ./node_modules/date-fns/esm/isBefore/index.js ***!
          \*****************************************************/
        /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony export */ __webpack_require__.d(__webpack_exports__, {
                /* harmony export */ "default": () => ( /* binding */isBefore)
                /* harmony export */ 
            });
            /* harmony import */ var _toDate_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../toDate/index.js */ "./node_modules/date-fns/esm/toDate/index.js");
            /* harmony import */ var _lib_requiredArgs_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../_lib/requiredArgs/index.js */ "./node_modules/date-fns/esm/_lib/requiredArgs/index.js");
            /**
             * @name isBefore
             * @category Common Helpers
             * @summary Is the first date before the second one?
             *
             * @description
             * Is the first date before the second one?
             *
             * @param {Date|Number} date - the date that should be before the other one to return true
             * @param {Date|Number} dateToCompare - the date to compare with
             * @returns {Boolean} the first date is before the second date
             * @throws {TypeError} 2 arguments required
             *
             * @example
             * // Is 10 July 1989 before 11 February 1987?
             * const result = isBefore(new Date(1989, 6, 10), new Date(1987, 1, 11))
             * //=> false
             */
            function isBefore(dirtyDate, dirtyDateToCompare) {
                (0, _lib_requiredArgs_index_js__WEBPACK_IMPORTED_MODULE_0__["default"])(2, arguments);
                var date = (0, _toDate_index_js__WEBPACK_IMPORTED_MODULE_1__["default"])(dirtyDate);
                var dateToCompare = (0, _toDate_index_js__WEBPACK_IMPORTED_MODULE_1__["default"])(dirtyDateToCompare);
                return date.getTime() < dateToCompare.getTime();
            }
            /***/ 
        }),
        /***/ "./node_modules/date-fns/esm/isDate/index.js": 
        /*!***************************************************!*\
          !*** ./node_modules/date-fns/esm/isDate/index.js ***!
          \***************************************************/
        /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony export */ __webpack_require__.d(__webpack_exports__, {
                /* harmony export */ "default": () => ( /* binding */isDate)
                /* harmony export */ 
            });
            /* harmony import */ var _babel_runtime_helpers_esm_typeof__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/typeof */ "./node_modules/@babel/runtime/helpers/esm/typeof.js");
            /* harmony import */ var _lib_requiredArgs_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../_lib/requiredArgs/index.js */ "./node_modules/date-fns/esm/_lib/requiredArgs/index.js");
            /**
             * @name isDate
             * @category Common Helpers
             * @summary Is the given value a date?
             *
             * @description
             * Returns true if the given value is an instance of Date. The function works for dates transferred across iframes.
             *
             * @param {*} value - the value to check
             * @returns {boolean} true if the given value is a date
             * @throws {TypeError} 1 arguments required
             *
             * @example
             * // For a valid date:
             * const result = isDate(new Date())
             * //=> true
             *
             * @example
             * // For an invalid date:
             * const result = isDate(new Date(NaN))
             * //=> true
             *
             * @example
             * // For some value:
             * const result = isDate('2014-02-31')
             * //=> false
             *
             * @example
             * // For an object:
             * const result = isDate({})
             * //=> false
             */
            function isDate(value) {
                (0, _lib_requiredArgs_index_js__WEBPACK_IMPORTED_MODULE_1__["default"])(1, arguments);
                return value instanceof Date || (0, _babel_runtime_helpers_esm_typeof__WEBPACK_IMPORTED_MODULE_0__["default"])(value) === 'object' && Object.prototype.toString.call(value) === '[object Date]';
            }
            /***/ 
        }),
        /***/ "./node_modules/date-fns/esm/isValid/index.js": 
        /*!****************************************************!*\
          !*** ./node_modules/date-fns/esm/isValid/index.js ***!
          \****************************************************/
        /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony export */ __webpack_require__.d(__webpack_exports__, {
                /* harmony export */ "default": () => ( /* binding */isValid)
                /* harmony export */ 
            });
            /* harmony import */ var _isDate_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../isDate/index.js */ "./node_modules/date-fns/esm/isDate/index.js");
            /* harmony import */ var _toDate_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../toDate/index.js */ "./node_modules/date-fns/esm/toDate/index.js");
            /* harmony import */ var _lib_requiredArgs_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../_lib/requiredArgs/index.js */ "./node_modules/date-fns/esm/_lib/requiredArgs/index.js");
            /**
             * @name isValid
             * @category Common Helpers
             * @summary Is the given date valid?
             *
             * @description
             * Returns false if argument is Invalid Date and true otherwise.
             * Argument is converted to Date using `toDate`. See [toDate]{@link https://date-fns.org/docs/toDate}
             * Invalid Date is a Date, whose time value is NaN.
             *
             * Time value of Date: http://es5.github.io/#x15.9.1.1
             *
             * @param {*} date - the date to check
             * @returns {Boolean} the date is valid
             * @throws {TypeError} 1 argument required
             *
             * @example
             * // For the valid date:
             * const result = isValid(new Date(2014, 1, 31))
             * //=> true
             *
             * @example
             * // For the value, convertable into a date:
             * const result = isValid(1393804800000)
             * //=> true
             *
             * @example
             * // For the invalid date:
             * const result = isValid(new Date(''))
             * //=> false
             */
            function isValid(dirtyDate) {
                (0, _lib_requiredArgs_index_js__WEBPACK_IMPORTED_MODULE_0__["default"])(1, arguments);
                if (!(0, _isDate_index_js__WEBPACK_IMPORTED_MODULE_1__["default"])(dirtyDate) && typeof dirtyDate !== 'number') {
                    return false;
                }
                var date = (0, _toDate_index_js__WEBPACK_IMPORTED_MODULE_2__["default"])(dirtyDate);
                return !isNaN(Number(date));
            }
            /***/ 
        }),
        /***/ "./node_modules/date-fns/esm/isWeekend/index.js": 
        /*!******************************************************!*\
          !*** ./node_modules/date-fns/esm/isWeekend/index.js ***!
          \******************************************************/
        /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony export */ __webpack_require__.d(__webpack_exports__, {
                /* harmony export */ "default": () => ( /* binding */isWeekend)
                /* harmony export */ 
            });
            /* harmony import */ var _toDate_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../toDate/index.js */ "./node_modules/date-fns/esm/toDate/index.js");
            /* harmony import */ var _lib_requiredArgs_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../_lib/requiredArgs/index.js */ "./node_modules/date-fns/esm/_lib/requiredArgs/index.js");
            /**
             * @name isWeekend
             * @category Weekday Helpers
             * @summary Does the given date fall on a weekend?
             *
             * @description
             * Does the given date fall on a weekend?
             *
             * @param {Date|Number} date - the date to check
             * @returns {Boolean} the date falls on a weekend
             * @throws {TypeError} 1 argument required
             *
             * @example
             * // Does 5 October 2014 fall on a weekend?
             * const result = isWeekend(new Date(2014, 9, 5))
             * //=> true
             */
            function isWeekend(dirtyDate) {
                (0, _lib_requiredArgs_index_js__WEBPACK_IMPORTED_MODULE_0__["default"])(1, arguments);
                var date = (0, _toDate_index_js__WEBPACK_IMPORTED_MODULE_1__["default"])(dirtyDate);
                var day = date.getDay();
                return day === 0 || day === 6;
            }
            /***/ 
        }),
        /***/ "./node_modules/date-fns/esm/locale/_lib/buildFormatLongFn/index.js": 
        /*!**************************************************************************!*\
          !*** ./node_modules/date-fns/esm/locale/_lib/buildFormatLongFn/index.js ***!
          \**************************************************************************/
        /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony export */ __webpack_require__.d(__webpack_exports__, {
                /* harmony export */ "default": () => ( /* binding */buildFormatLongFn)
                /* harmony export */ 
            });
            function buildFormatLongFn(args) {
                return function () {
                    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
                    // TODO: Remove String()
                    var width = options.width ? String(options.width) : args.defaultWidth;
                    var format = args.formats[width] || args.formats[args.defaultWidth];
                    return format;
                };
            }
            /***/ 
        }),
        /***/ "./node_modules/date-fns/esm/locale/_lib/buildLocalizeFn/index.js": 
        /*!************************************************************************!*\
          !*** ./node_modules/date-fns/esm/locale/_lib/buildLocalizeFn/index.js ***!
          \************************************************************************/
        /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony export */ __webpack_require__.d(__webpack_exports__, {
                /* harmony export */ "default": () => ( /* binding */buildLocalizeFn)
                /* harmony export */ 
            });
            function buildLocalizeFn(args) {
                return function (dirtyIndex, options) {
                    var context = options !== null && options !== void 0 && options.context ? String(options.context) : 'standalone';
                    var valuesArray;
                    if (context === 'formatting' && args.formattingValues) {
                        var defaultWidth = args.defaultFormattingWidth || args.defaultWidth;
                        var width = options !== null && options !== void 0 && options.width ? String(options.width) : defaultWidth;
                        valuesArray = args.formattingValues[width] || args.formattingValues[defaultWidth];
                    }
                    else {
                        var _defaultWidth = args.defaultWidth;
                        var _width = options !== null && options !== void 0 && options.width ? String(options.width) : args.defaultWidth;
                        valuesArray = args.values[_width] || args.values[_defaultWidth];
                    }
                    var index = args.argumentCallback ? args.argumentCallback(dirtyIndex) : dirtyIndex;
                    // @ts-ignore: For some reason TypeScript just don't want to match it, no matter how hard we try. I challenge you to try to remove it!
                    return valuesArray[index];
                };
            }
            /***/ 
        }),
        /***/ "./node_modules/date-fns/esm/locale/_lib/buildMatchFn/index.js": 
        /*!*********************************************************************!*\
          !*** ./node_modules/date-fns/esm/locale/_lib/buildMatchFn/index.js ***!
          \*********************************************************************/
        /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony export */ __webpack_require__.d(__webpack_exports__, {
                /* harmony export */ "default": () => ( /* binding */buildMatchFn)
                /* harmony export */ 
            });
            function buildMatchFn(args) {
                return function (string) {
                    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
                    var width = options.width;
                    var matchPattern = width && args.matchPatterns[width] || args.matchPatterns[args.defaultMatchWidth];
                    var matchResult = string.match(matchPattern);
                    if (!matchResult) {
                        return null;
                    }
                    var matchedString = matchResult[0];
                    var parsePatterns = width && args.parsePatterns[width] || args.parsePatterns[args.defaultParseWidth];
                    var key = Array.isArray(parsePatterns) ? findIndex(parsePatterns, function (pattern) {
                        return pattern.test(matchedString);
                    }) : findKey(parsePatterns, function (pattern) {
                        return pattern.test(matchedString);
                    });
                    var value;
                    value = args.valueCallback ? args.valueCallback(key) : key;
                    value = options.valueCallback ? options.valueCallback(value) : value;
                    var rest = string.slice(matchedString.length);
                    return {
                        value: value,
                        rest: rest
                    };
                };
            }
            function findKey(object, predicate) {
                for (var key in object) {
                    if (object.hasOwnProperty(key) && predicate(object[key])) {
                        return key;
                    }
                }
                return undefined;
            }
            function findIndex(array, predicate) {
                for (var key = 0; key < array.length; key++) {
                    if (predicate(array[key])) {
                        return key;
                    }
                }
                return undefined;
            }
            /***/ 
        }),
        /***/ "./node_modules/date-fns/esm/locale/_lib/buildMatchPatternFn/index.js": 
        /*!****************************************************************************!*\
          !*** ./node_modules/date-fns/esm/locale/_lib/buildMatchPatternFn/index.js ***!
          \****************************************************************************/
        /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony export */ __webpack_require__.d(__webpack_exports__, {
                /* harmony export */ "default": () => ( /* binding */buildMatchPatternFn)
                /* harmony export */ 
            });
            function buildMatchPatternFn(args) {
                return function (string) {
                    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
                    var matchResult = string.match(args.matchPattern);
                    if (!matchResult)
                        return null;
                    var matchedString = matchResult[0];
                    var parseResult = string.match(args.parsePattern);
                    if (!parseResult)
                        return null;
                    var value = args.valueCallback ? args.valueCallback(parseResult[0]) : parseResult[0];
                    value = options.valueCallback ? options.valueCallback(value) : value;
                    var rest = string.slice(matchedString.length);
                    return {
                        value: value,
                        rest: rest
                    };
                };
            }
            /***/ 
        }),
        /***/ "./node_modules/date-fns/esm/locale/en-US/_lib/formatDistance/index.js": 
        /*!*****************************************************************************!*\
          !*** ./node_modules/date-fns/esm/locale/en-US/_lib/formatDistance/index.js ***!
          \*****************************************************************************/
        /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony export */ __webpack_require__.d(__webpack_exports__, {
                /* harmony export */ "default": () => (__WEBPACK_DEFAULT_EXPORT__)
                /* harmony export */ 
            });
            var formatDistanceLocale = {
                lessThanXSeconds: {
                    one: 'less than a second',
                    other: 'less than {{count}} seconds'
                },
                xSeconds: {
                    one: '1 second',
                    other: '{{count}} seconds'
                },
                halfAMinute: 'half a minute',
                lessThanXMinutes: {
                    one: 'less than a minute',
                    other: 'less than {{count}} minutes'
                },
                xMinutes: {
                    one: '1 minute',
                    other: '{{count}} minutes'
                },
                aboutXHours: {
                    one: 'about 1 hour',
                    other: 'about {{count}} hours'
                },
                xHours: {
                    one: '1 hour',
                    other: '{{count}} hours'
                },
                xDays: {
                    one: '1 day',
                    other: '{{count}} days'
                },
                aboutXWeeks: {
                    one: 'about 1 week',
                    other: 'about {{count}} weeks'
                },
                xWeeks: {
                    one: '1 week',
                    other: '{{count}} weeks'
                },
                aboutXMonths: {
                    one: 'about 1 month',
                    other: 'about {{count}} months'
                },
                xMonths: {
                    one: '1 month',
                    other: '{{count}} months'
                },
                aboutXYears: {
                    one: 'about 1 year',
                    other: 'about {{count}} years'
                },
                xYears: {
                    one: '1 year',
                    other: '{{count}} years'
                },
                overXYears: {
                    one: 'over 1 year',
                    other: 'over {{count}} years'
                },
                almostXYears: {
                    one: 'almost 1 year',
                    other: 'almost {{count}} years'
                }
            };
            var formatDistance = function formatDistance(token, count, options) {
                var result;
                var tokenValue = formatDistanceLocale[token];
                if (typeof tokenValue === 'string') {
                    result = tokenValue;
                }
                else if (count === 1) {
                    result = tokenValue.one;
                }
                else {
                    result = tokenValue.other.replace('{{count}}', count.toString());
                }
                if (options !== null && options !== void 0 && options.addSuffix) {
                    if (options.comparison && options.comparison > 0) {
                        return 'in ' + result;
                    }
                    else {
                        return result + ' ago';
                    }
                }
                return result;
            };
            /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (formatDistance);
            /***/ 
        }),
        /***/ "./node_modules/date-fns/esm/locale/en-US/_lib/formatLong/index.js": 
        /*!*************************************************************************!*\
          !*** ./node_modules/date-fns/esm/locale/en-US/_lib/formatLong/index.js ***!
          \*************************************************************************/
        /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony export */ __webpack_require__.d(__webpack_exports__, {
                /* harmony export */ "default": () => (__WEBPACK_DEFAULT_EXPORT__)
                /* harmony export */ 
            });
            /* harmony import */ var _lib_buildFormatLongFn_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../_lib/buildFormatLongFn/index.js */ "./node_modules/date-fns/esm/locale/_lib/buildFormatLongFn/index.js");
            var dateFormats = {
                full: 'EEEE, MMMM do, y',
                long: 'MMMM do, y',
                medium: 'MMM d, y',
                short: 'MM/dd/yyyy'
            };
            var timeFormats = {
                full: 'h:mm:ss a zzzz',
                long: 'h:mm:ss a z',
                medium: 'h:mm:ss a',
                short: 'h:mm a'
            };
            var dateTimeFormats = {
                full: "{{date}} 'at' {{time}}",
                long: "{{date}} 'at' {{time}}",
                medium: '{{date}}, {{time}}',
                short: '{{date}}, {{time}}'
            };
            var formatLong = {
                date: (0, _lib_buildFormatLongFn_index_js__WEBPACK_IMPORTED_MODULE_0__["default"])({
                    formats: dateFormats,
                    defaultWidth: 'full'
                }),
                time: (0, _lib_buildFormatLongFn_index_js__WEBPACK_IMPORTED_MODULE_0__["default"])({
                    formats: timeFormats,
                    defaultWidth: 'full'
                }),
                dateTime: (0, _lib_buildFormatLongFn_index_js__WEBPACK_IMPORTED_MODULE_0__["default"])({
                    formats: dateTimeFormats,
                    defaultWidth: 'full'
                })
            };
            /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (formatLong);
            /***/ 
        }),
        /***/ "./node_modules/date-fns/esm/locale/en-US/_lib/formatRelative/index.js": 
        /*!*****************************************************************************!*\
          !*** ./node_modules/date-fns/esm/locale/en-US/_lib/formatRelative/index.js ***!
          \*****************************************************************************/
        /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony export */ __webpack_require__.d(__webpack_exports__, {
                /* harmony export */ "default": () => (__WEBPACK_DEFAULT_EXPORT__)
                /* harmony export */ 
            });
            var formatRelativeLocale = {
                lastWeek: "'last' eeee 'at' p",
                yesterday: "'yesterday at' p",
                today: "'today at' p",
                tomorrow: "'tomorrow at' p",
                nextWeek: "eeee 'at' p",
                other: 'P'
            };
            var formatRelative = function formatRelative(token, _date, _baseDate, _options) {
                return formatRelativeLocale[token];
            };
            /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (formatRelative);
            /***/ 
        }),
        /***/ "./node_modules/date-fns/esm/locale/en-US/_lib/localize/index.js": 
        /*!***********************************************************************!*\
          !*** ./node_modules/date-fns/esm/locale/en-US/_lib/localize/index.js ***!
          \***********************************************************************/
        /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony export */ __webpack_require__.d(__webpack_exports__, {
                /* harmony export */ "default": () => (__WEBPACK_DEFAULT_EXPORT__)
                /* harmony export */ 
            });
            /* harmony import */ var _lib_buildLocalizeFn_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../_lib/buildLocalizeFn/index.js */ "./node_modules/date-fns/esm/locale/_lib/buildLocalizeFn/index.js");
            var eraValues = {
                narrow: ['B', 'A'],
                abbreviated: ['BC', 'AD'],
                wide: ['Before Christ', 'Anno Domini']
            };
            var quarterValues = {
                narrow: ['1', '2', '3', '4'],
                abbreviated: ['Q1', 'Q2', 'Q3', 'Q4'],
                wide: ['1st quarter', '2nd quarter', '3rd quarter', '4th quarter']
            };
            // Note: in English, the names of days of the week and months are capitalized.
            // If you are making a new locale based on this one, check if the same is true for the language you're working on.
            // Generally, formatted dates should look like they are in the middle of a sentence,
            // e.g. in Spanish language the weekdays and months should be in the lowercase.
            var monthValues = {
                narrow: ['J', 'F', 'M', 'A', 'M', 'J', 'J', 'A', 'S', 'O', 'N', 'D'],
                abbreviated: ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'],
                wide: ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December']
            };
            var dayValues = {
                narrow: ['S', 'M', 'T', 'W', 'T', 'F', 'S'],
                short: ['Su', 'Mo', 'Tu', 'We', 'Th', 'Fr', 'Sa'],
                abbreviated: ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'],
                wide: ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday']
            };
            var dayPeriodValues = {
                narrow: {
                    am: 'a',
                    pm: 'p',
                    midnight: 'mi',
                    noon: 'n',
                    morning: 'morning',
                    afternoon: 'afternoon',
                    evening: 'evening',
                    night: 'night'
                },
                abbreviated: {
                    am: 'AM',
                    pm: 'PM',
                    midnight: 'midnight',
                    noon: 'noon',
                    morning: 'morning',
                    afternoon: 'afternoon',
                    evening: 'evening',
                    night: 'night'
                },
                wide: {
                    am: 'a.m.',
                    pm: 'p.m.',
                    midnight: 'midnight',
                    noon: 'noon',
                    morning: 'morning',
                    afternoon: 'afternoon',
                    evening: 'evening',
                    night: 'night'
                }
            };
            var formattingDayPeriodValues = {
                narrow: {
                    am: 'a',
                    pm: 'p',
                    midnight: 'mi',
                    noon: 'n',
                    morning: 'in the morning',
                    afternoon: 'in the afternoon',
                    evening: 'in the evening',
                    night: 'at night'
                },
                abbreviated: {
                    am: 'AM',
                    pm: 'PM',
                    midnight: 'midnight',
                    noon: 'noon',
                    morning: 'in the morning',
                    afternoon: 'in the afternoon',
                    evening: 'in the evening',
                    night: 'at night'
                },
                wide: {
                    am: 'a.m.',
                    pm: 'p.m.',
                    midnight: 'midnight',
                    noon: 'noon',
                    morning: 'in the morning',
                    afternoon: 'in the afternoon',
                    evening: 'in the evening',
                    night: 'at night'
                }
            };
            var ordinalNumber = function ordinalNumber(dirtyNumber, _options) {
                var number = Number(dirtyNumber);
                // If ordinal numbers depend on context, for example,
                // if they are different for different grammatical genders,
                // use `options.unit`.
                //
                // `unit` can be 'year', 'quarter', 'month', 'week', 'date', 'dayOfYear',
                // 'day', 'hour', 'minute', 'second'.
                var rem100 = number % 100;
                if (rem100 > 20 || rem100 < 10) {
                    switch (rem100 % 10) {
                        case 1:
                            return number + 'st';
                        case 2:
                            return number + 'nd';
                        case 3:
                            return number + 'rd';
                    }
                }
                return number + 'th';
            };
            var localize = {
                ordinalNumber: ordinalNumber,
                era: (0, _lib_buildLocalizeFn_index_js__WEBPACK_IMPORTED_MODULE_0__["default"])({
                    values: eraValues,
                    defaultWidth: 'wide'
                }),
                quarter: (0, _lib_buildLocalizeFn_index_js__WEBPACK_IMPORTED_MODULE_0__["default"])({
                    values: quarterValues,
                    defaultWidth: 'wide',
                    argumentCallback: function argumentCallback(quarter) {
                        return quarter - 1;
                    }
                }),
                month: (0, _lib_buildLocalizeFn_index_js__WEBPACK_IMPORTED_MODULE_0__["default"])({
                    values: monthValues,
                    defaultWidth: 'wide'
                }),
                day: (0, _lib_buildLocalizeFn_index_js__WEBPACK_IMPORTED_MODULE_0__["default"])({
                    values: dayValues,
                    defaultWidth: 'wide'
                }),
                dayPeriod: (0, _lib_buildLocalizeFn_index_js__WEBPACK_IMPORTED_MODULE_0__["default"])({
                    values: dayPeriodValues,
                    defaultWidth: 'wide',
                    formattingValues: formattingDayPeriodValues,
                    defaultFormattingWidth: 'wide'
                })
            };
            /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (localize);
            /***/ 
        }),
        /***/ "./node_modules/date-fns/esm/locale/en-US/_lib/match/index.js": 
        /*!********************************************************************!*\
          !*** ./node_modules/date-fns/esm/locale/en-US/_lib/match/index.js ***!
          \********************************************************************/
        /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony export */ __webpack_require__.d(__webpack_exports__, {
                /* harmony export */ "default": () => (__WEBPACK_DEFAULT_EXPORT__)
                /* harmony export */ 
            });
            /* harmony import */ var _lib_buildMatchFn_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../_lib/buildMatchFn/index.js */ "./node_modules/date-fns/esm/locale/_lib/buildMatchFn/index.js");
            /* harmony import */ var _lib_buildMatchPatternFn_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../_lib/buildMatchPatternFn/index.js */ "./node_modules/date-fns/esm/locale/_lib/buildMatchPatternFn/index.js");
            var matchOrdinalNumberPattern = /^(\d+)(th|st|nd|rd)?/i;
            var parseOrdinalNumberPattern = /\d+/i;
            var matchEraPatterns = {
                narrow: /^(b|a)/i,
                abbreviated: /^(b\.?\s?c\.?|b\.?\s?c\.?\s?e\.?|a\.?\s?d\.?|c\.?\s?e\.?)/i,
                wide: /^(before christ|before common era|anno domini|common era)/i
            };
            var parseEraPatterns = {
                any: [/^b/i, /^(a|c)/i]
            };
            var matchQuarterPatterns = {
                narrow: /^[1234]/i,
                abbreviated: /^q[1234]/i,
                wide: /^[1234](th|st|nd|rd)? quarter/i
            };
            var parseQuarterPatterns = {
                any: [/1/i, /2/i, /3/i, /4/i]
            };
            var matchMonthPatterns = {
                narrow: /^[jfmasond]/i,
                abbreviated: /^(jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)/i,
                wide: /^(january|february|march|april|may|june|july|august|september|october|november|december)/i
            };
            var parseMonthPatterns = {
                narrow: [/^j/i, /^f/i, /^m/i, /^a/i, /^m/i, /^j/i, /^j/i, /^a/i, /^s/i, /^o/i, /^n/i, /^d/i],
                any: [/^ja/i, /^f/i, /^mar/i, /^ap/i, /^may/i, /^jun/i, /^jul/i, /^au/i, /^s/i, /^o/i, /^n/i, /^d/i]
            };
            var matchDayPatterns = {
                narrow: /^[smtwf]/i,
                short: /^(su|mo|tu|we|th|fr|sa)/i,
                abbreviated: /^(sun|mon|tue|wed|thu|fri|sat)/i,
                wide: /^(sunday|monday|tuesday|wednesday|thursday|friday|saturday)/i
            };
            var parseDayPatterns = {
                narrow: [/^s/i, /^m/i, /^t/i, /^w/i, /^t/i, /^f/i, /^s/i],
                any: [/^su/i, /^m/i, /^tu/i, /^w/i, /^th/i, /^f/i, /^sa/i]
            };
            var matchDayPeriodPatterns = {
                narrow: /^(a|p|mi|n|(in the|at) (morning|afternoon|evening|night))/i,
                any: /^([ap]\.?\s?m\.?|midnight|noon|(in the|at) (morning|afternoon|evening|night))/i
            };
            var parseDayPeriodPatterns = {
                any: {
                    am: /^a/i,
                    pm: /^p/i,
                    midnight: /^mi/i,
                    noon: /^no/i,
                    morning: /morning/i,
                    afternoon: /afternoon/i,
                    evening: /evening/i,
                    night: /night/i
                }
            };
            var match = {
                ordinalNumber: (0, _lib_buildMatchPatternFn_index_js__WEBPACK_IMPORTED_MODULE_0__["default"])({
                    matchPattern: matchOrdinalNumberPattern,
                    parsePattern: parseOrdinalNumberPattern,
                    valueCallback: function valueCallback(value) {
                        return parseInt(value, 10);
                    }
                }),
                era: (0, _lib_buildMatchFn_index_js__WEBPACK_IMPORTED_MODULE_1__["default"])({
                    matchPatterns: matchEraPatterns,
                    defaultMatchWidth: 'wide',
                    parsePatterns: parseEraPatterns,
                    defaultParseWidth: 'any'
                }),
                quarter: (0, _lib_buildMatchFn_index_js__WEBPACK_IMPORTED_MODULE_1__["default"])({
                    matchPatterns: matchQuarterPatterns,
                    defaultMatchWidth: 'wide',
                    parsePatterns: parseQuarterPatterns,
                    defaultParseWidth: 'any',
                    valueCallback: function valueCallback(index) {
                        return index + 1;
                    }
                }),
                month: (0, _lib_buildMatchFn_index_js__WEBPACK_IMPORTED_MODULE_1__["default"])({
                    matchPatterns: matchMonthPatterns,
                    defaultMatchWidth: 'wide',
                    parsePatterns: parseMonthPatterns,
                    defaultParseWidth: 'any'
                }),
                day: (0, _lib_buildMatchFn_index_js__WEBPACK_IMPORTED_MODULE_1__["default"])({
                    matchPatterns: matchDayPatterns,
                    defaultMatchWidth: 'wide',
                    parsePatterns: parseDayPatterns,
                    defaultParseWidth: 'any'
                }),
                dayPeriod: (0, _lib_buildMatchFn_index_js__WEBPACK_IMPORTED_MODULE_1__["default"])({
                    matchPatterns: matchDayPeriodPatterns,
                    defaultMatchWidth: 'any',
                    parsePatterns: parseDayPeriodPatterns,
                    defaultParseWidth: 'any'
                })
            };
            /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (match);
            /***/ 
        }),
        /***/ "./node_modules/date-fns/esm/locale/en-US/index.js": 
        /*!*********************************************************!*\
          !*** ./node_modules/date-fns/esm/locale/en-US/index.js ***!
          \*********************************************************/
        /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony export */ __webpack_require__.d(__webpack_exports__, {
                /* harmony export */ "default": () => (__WEBPACK_DEFAULT_EXPORT__)
                /* harmony export */ 
            });
            /* harmony import */ var _lib_formatDistance_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_lib/formatDistance/index.js */ "./node_modules/date-fns/esm/locale/en-US/_lib/formatDistance/index.js");
            /* harmony import */ var _lib_formatLong_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_lib/formatLong/index.js */ "./node_modules/date-fns/esm/locale/en-US/_lib/formatLong/index.js");
            /* harmony import */ var _lib_formatRelative_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./_lib/formatRelative/index.js */ "./node_modules/date-fns/esm/locale/en-US/_lib/formatRelative/index.js");
            /* harmony import */ var _lib_localize_index_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./_lib/localize/index.js */ "./node_modules/date-fns/esm/locale/en-US/_lib/localize/index.js");
            /* harmony import */ var _lib_match_index_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./_lib/match/index.js */ "./node_modules/date-fns/esm/locale/en-US/_lib/match/index.js");
            /**
             * @type {Locale}
             * @category Locales
             * @summary English locale (United States).
             * @language English
             * @iso-639-2 eng
             * @author Sasha Koss [@kossnocorp]{@link https://github.com/kossnocorp}
             * @author Lesha Koss [@leshakoss]{@link https://github.com/leshakoss}
             */
            var locale = {
                code: 'en-US',
                formatDistance: _lib_formatDistance_index_js__WEBPACK_IMPORTED_MODULE_0__["default"],
                formatLong: _lib_formatLong_index_js__WEBPACK_IMPORTED_MODULE_1__["default"],
                formatRelative: _lib_formatRelative_index_js__WEBPACK_IMPORTED_MODULE_2__["default"],
                localize: _lib_localize_index_js__WEBPACK_IMPORTED_MODULE_3__["default"],
                match: _lib_match_index_js__WEBPACK_IMPORTED_MODULE_4__["default"],
                options: {
                    weekStartsOn: 0 /* Sunday */,
                    firstWeekContainsDate: 1
                }
            };
            /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (locale);
            /***/ 
        }),
        /***/ "./node_modules/date-fns/esm/max/index.js": 
        /*!************************************************!*\
          !*** ./node_modules/date-fns/esm/max/index.js ***!
          \************************************************/
        /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony export */ __webpack_require__.d(__webpack_exports__, {
                /* harmony export */ "default": () => ( /* binding */max)
                /* harmony export */ 
            });
            /* harmony import */ var _babel_runtime_helpers_esm_typeof__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/typeof */ "./node_modules/@babel/runtime/helpers/esm/typeof.js");
            /* harmony import */ var _toDate_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../toDate/index.js */ "./node_modules/date-fns/esm/toDate/index.js");
            /* harmony import */ var _lib_requiredArgs_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../_lib/requiredArgs/index.js */ "./node_modules/date-fns/esm/_lib/requiredArgs/index.js");
            /**
             * @name max
             * @category Common Helpers
             * @summary Return the latest of the given dates.
             *
             * @description
             * Return the latest of the given dates.
             *
             * @param {Date[]|Number[]} datesArray - the dates to compare
             * @returns {Date} the latest of the dates
             * @throws {TypeError} 1 argument required
             *
             * @example
             * // Which of these dates is the latest?
             * const result = max([
             *   new Date(1989, 6, 10),
             *   new Date(1987, 1, 11),
             *   new Date(1995, 6, 2),
             *   new Date(1990, 0, 1)
             * ])
             * //=> Sun Jul 02 1995 00:00:00
             */
            function max(dirtyDatesArray) {
                (0, _lib_requiredArgs_index_js__WEBPACK_IMPORTED_MODULE_1__["default"])(1, arguments);
                var datesArray;
                // `dirtyDatesArray` is Array, Set or Map, or object with custom `forEach` method
                if (dirtyDatesArray && typeof dirtyDatesArray.forEach === 'function') {
                    datesArray = dirtyDatesArray;
                    // If `dirtyDatesArray` is Array-like Object, convert to Array.
                }
                else if ((0, _babel_runtime_helpers_esm_typeof__WEBPACK_IMPORTED_MODULE_0__["default"])(dirtyDatesArray) === 'object' && dirtyDatesArray !== null) {
                    datesArray = Array.prototype.slice.call(dirtyDatesArray);
                }
                else {
                    // `dirtyDatesArray` is non-iterable, return Invalid Date
                    return new Date(NaN);
                }
                var result;
                datesArray.forEach(function (dirtyDate) {
                    var currentDate = (0, _toDate_index_js__WEBPACK_IMPORTED_MODULE_2__["default"])(dirtyDate);
                    if (result === undefined || result < currentDate || isNaN(Number(currentDate))) {
                        result = currentDate;
                    }
                });
                return result || new Date(NaN);
            }
            /***/ 
        }),
        /***/ "./node_modules/date-fns/esm/nextDay/index.js": 
        /*!****************************************************!*\
          !*** ./node_modules/date-fns/esm/nextDay/index.js ***!
          \****************************************************/
        /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony export */ __webpack_require__.d(__webpack_exports__, {
                /* harmony export */ "default": () => ( /* binding */nextDay)
                /* harmony export */ 
            });
            /* harmony import */ var _addDays_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../addDays/index.js */ "./node_modules/date-fns/esm/addDays/index.js");
            /* harmony import */ var _getDay_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../getDay/index.js */ "./node_modules/date-fns/esm/getDay/index.js");
            /* harmony import */ var _lib_requiredArgs_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../_lib/requiredArgs/index.js */ "./node_modules/date-fns/esm/_lib/requiredArgs/index.js");
            /**
             * @name nextDay
             * @category Weekday Helpers
             * @summary When is the next day of the week?
             *
             * @description
             * When is the next day of the week? 0-6 the day of the week, 0 represents Sunday.
             *
             * @param {Date | number} date - the date to check
             * @param {Day} day - day of the week
             * @returns {Date} - the date is the next day of week
             * @throws {TypeError} - 2 arguments required
             *
             * @example
             * // When is the next Monday after Mar, 20, 2020?
             * const result = nextDay(new Date(2020, 2, 20), 1)
             * //=> Mon Mar 23 2020 00:00:00
             *
             * @example
             * // When is the next Tuesday after Mar, 21, 2020?
             * const result = nextDay(new Date(2020, 2, 21), 2)
             * //=> Tue Mar 24 2020 00:00:00
             */
            function nextDay(date, day) {
                (0, _lib_requiredArgs_index_js__WEBPACK_IMPORTED_MODULE_0__["default"])(2, arguments);
                var delta = day - (0, _getDay_index_js__WEBPACK_IMPORTED_MODULE_1__["default"])(date);
                if (delta <= 0)
                    delta += 7;
                return (0, _addDays_index_js__WEBPACK_IMPORTED_MODULE_2__["default"])(date, delta);
            }
            /***/ 
        }),
        /***/ "./node_modules/date-fns/esm/nextMonday/index.js": 
        /*!*******************************************************!*\
          !*** ./node_modules/date-fns/esm/nextMonday/index.js ***!
          \*******************************************************/
        /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony export */ __webpack_require__.d(__webpack_exports__, {
                /* harmony export */ "default": () => ( /* binding */nextMonday)
                /* harmony export */ 
            });
            /* harmony import */ var _nextDay_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../nextDay/index.js */ "./node_modules/date-fns/esm/nextDay/index.js");
            /* harmony import */ var _lib_requiredArgs_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../_lib/requiredArgs/index.js */ "./node_modules/date-fns/esm/_lib/requiredArgs/index.js");
            /**
             * @name nextMonday
             * @category Weekday Helpers
             * @summary When is the next Monday?
             *
             * @description
             * When is the next Monday?
             *
             * @param {Date | number} date - the date to start counting from
             * @returns {Date} the next Monday
             * @throws {TypeError} 1 argument required
             *
             * @example
             * // When is the next Monday after Mar, 22, 2020?
             * const result = nextMonday(new Date(2020, 2, 22))
             * //=> Mon Mar 23 2020 00:00:00
             */
            function nextMonday(date) {
                (0, _lib_requiredArgs_index_js__WEBPACK_IMPORTED_MODULE_0__["default"])(1, arguments);
                return (0, _nextDay_index_js__WEBPACK_IMPORTED_MODULE_1__["default"])(date, 1);
            }
            /***/ 
        }),
        /***/ "./node_modules/date-fns/esm/parse/_lib/Parser.js": 
        /*!********************************************************!*\
          !*** ./node_modules/date-fns/esm/parse/_lib/Parser.js ***!
          \********************************************************/
        /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony export */ __webpack_require__.d(__webpack_exports__, {
                /* harmony export */ Parser: () => ( /* binding */Parser)
                /* harmony export */ 
            });
            /* harmony import */ var _babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/classCallCheck */ "./node_modules/@babel/runtime/helpers/esm/classCallCheck.js");
            /* harmony import */ var _babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/esm/createClass */ "./node_modules/@babel/runtime/helpers/esm/createClass.js");
            /* harmony import */ var _babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/runtime/helpers/esm/defineProperty */ "./node_modules/@babel/runtime/helpers/esm/defineProperty.js");
            /* harmony import */ var _Setter_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Setter.js */ "./node_modules/date-fns/esm/parse/_lib/Setter.js");
            var Parser = /*#__PURE__*/ function () {
                function Parser() {
                    (0, _babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_0__["default"])(this, Parser);
                    (0, _babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_2__["default"])(this, "incompatibleTokens", void 0);
                    (0, _babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_2__["default"])(this, "priority", void 0);
                    (0, _babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_2__["default"])(this, "subPriority", void 0);
                }
                (0, _babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_1__["default"])(Parser, [{
                        key: "run",
                        value: function run(dateString, token, match, options) {
                            var result = this.parse(dateString, token, match, options);
                            if (!result) {
                                return null;
                            }
                            return {
                                setter: new _Setter_js__WEBPACK_IMPORTED_MODULE_3__.ValueSetter(result.value, this.validate, this.set, this.priority, this.subPriority),
                                rest: result.rest
                            };
                        }
                    }, {
                        key: "validate",
                        value: function validate(_utcDate, _value, _options) {
                            return true;
                        }
                    }]);
                return Parser;
            }();
            /***/ 
        }),
        /***/ "./node_modules/date-fns/esm/parse/_lib/Setter.js": 
        /*!********************************************************!*\
          !*** ./node_modules/date-fns/esm/parse/_lib/Setter.js ***!
          \********************************************************/
        /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony export */ __webpack_require__.d(__webpack_exports__, {
                /* harmony export */ DateToSystemTimezoneSetter: () => ( /* binding */DateToSystemTimezoneSetter),
                /* harmony export */ Setter: () => ( /* binding */Setter),
                /* harmony export */ ValueSetter: () => ( /* binding */ValueSetter)
                /* harmony export */ 
            });
            /* harmony import */ var _babel_runtime_helpers_esm_assertThisInitialized__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/assertThisInitialized */ "./node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js");
            /* harmony import */ var _babel_runtime_helpers_esm_inherits__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/esm/inherits */ "./node_modules/@babel/runtime/helpers/esm/inherits.js");
            /* harmony import */ var _babel_runtime_helpers_esm_createSuper__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/runtime/helpers/esm/createSuper */ "./node_modules/@babel/runtime/helpers/esm/createSuper.js");
            /* harmony import */ var _babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @babel/runtime/helpers/esm/classCallCheck */ "./node_modules/@babel/runtime/helpers/esm/classCallCheck.js");
            /* harmony import */ var _babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @babel/runtime/helpers/esm/createClass */ "./node_modules/@babel/runtime/helpers/esm/createClass.js");
            /* harmony import */ var _babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @babel/runtime/helpers/esm/defineProperty */ "./node_modules/@babel/runtime/helpers/esm/defineProperty.js");
            var TIMEZONE_UNIT_PRIORITY = 10;
            var Setter = /*#__PURE__*/ function () {
                function Setter() {
                    (0, _babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_3__["default"])(this, Setter);
                    (0, _babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_5__["default"])(this, "priority", void 0);
                    (0, _babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_5__["default"])(this, "subPriority", 0);
                }
                (0, _babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_4__["default"])(Setter, [{
                        key: "validate",
                        value: function validate(_utcDate, _options) {
                            return true;
                        }
                    }]);
                return Setter;
            }();
            var ValueSetter = /*#__PURE__*/ function (_Setter) {
                (0, _babel_runtime_helpers_esm_inherits__WEBPACK_IMPORTED_MODULE_1__["default"])(ValueSetter, _Setter);
                var _super = (0, _babel_runtime_helpers_esm_createSuper__WEBPACK_IMPORTED_MODULE_2__["default"])(ValueSetter);
                function ValueSetter(value, validateValue, setValue, priority, subPriority) {
                    var _this;
                    (0, _babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_3__["default"])(this, ValueSetter);
                    _this = _super.call(this);
                    _this.value = value;
                    _this.validateValue = validateValue;
                    _this.setValue = setValue;
                    _this.priority = priority;
                    if (subPriority) {
                        _this.subPriority = subPriority;
                    }
                    return _this;
                }
                (0, _babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_4__["default"])(ValueSetter, [{
                        key: "validate",
                        value: function validate(utcDate, options) {
                            return this.validateValue(utcDate, this.value, options);
                        }
                    }, {
                        key: "set",
                        value: function set(utcDate, flags, options) {
                            return this.setValue(utcDate, flags, this.value, options);
                        }
                    }]);
                return ValueSetter;
            }(Setter);
            var DateToSystemTimezoneSetter = /*#__PURE__*/ function (_Setter2) {
                (0, _babel_runtime_helpers_esm_inherits__WEBPACK_IMPORTED_MODULE_1__["default"])(DateToSystemTimezoneSetter, _Setter2);
                var _super2 = (0, _babel_runtime_helpers_esm_createSuper__WEBPACK_IMPORTED_MODULE_2__["default"])(DateToSystemTimezoneSetter);
                function DateToSystemTimezoneSetter() {
                    var _this2;
                    (0, _babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_3__["default"])(this, DateToSystemTimezoneSetter);
                    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                        args[_key] = arguments[_key];
                    }
                    _this2 = _super2.call.apply(_super2, [this].concat(args));
                    (0, _babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_5__["default"])((0, _babel_runtime_helpers_esm_assertThisInitialized__WEBPACK_IMPORTED_MODULE_0__["default"])(_this2), "priority", TIMEZONE_UNIT_PRIORITY);
                    (0, _babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_5__["default"])((0, _babel_runtime_helpers_esm_assertThisInitialized__WEBPACK_IMPORTED_MODULE_0__["default"])(_this2), "subPriority", -1);
                    return _this2;
                }
                (0, _babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_4__["default"])(DateToSystemTimezoneSetter, [{
                        key: "set",
                        value: function set(date, flags) {
                            if (flags.timestampIsSet) {
                                return date;
                            }
                            var convertedDate = new Date(0);
                            convertedDate.setFullYear(date.getUTCFullYear(), date.getUTCMonth(), date.getUTCDate());
                            convertedDate.setHours(date.getUTCHours(), date.getUTCMinutes(), date.getUTCSeconds(), date.getUTCMilliseconds());
                            return convertedDate;
                        }
                    }]);
                return DateToSystemTimezoneSetter;
            }(Setter);
            /***/ 
        }),
        /***/ "./node_modules/date-fns/esm/parse/_lib/constants.js": 
        /*!***********************************************************!*\
          !*** ./node_modules/date-fns/esm/parse/_lib/constants.js ***!
          \***********************************************************/
        /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony export */ __webpack_require__.d(__webpack_exports__, {
                /* harmony export */ numericPatterns: () => ( /* binding */numericPatterns),
                /* harmony export */ timezonePatterns: () => ( /* binding */timezonePatterns)
                /* harmony export */ 
            });
            var numericPatterns = {
                month: /^(1[0-2]|0?\d)/,
                // 0 to 12
                date: /^(3[0-1]|[0-2]?\d)/,
                // 0 to 31
                dayOfYear: /^(36[0-6]|3[0-5]\d|[0-2]?\d?\d)/,
                // 0 to 366
                week: /^(5[0-3]|[0-4]?\d)/,
                // 0 to 53
                hour23h: /^(2[0-3]|[0-1]?\d)/,
                // 0 to 23
                hour24h: /^(2[0-4]|[0-1]?\d)/,
                // 0 to 24
                hour11h: /^(1[0-1]|0?\d)/,
                // 0 to 11
                hour12h: /^(1[0-2]|0?\d)/,
                // 0 to 12
                minute: /^[0-5]?\d/,
                // 0 to 59
                second: /^[0-5]?\d/,
                // 0 to 59
                singleDigit: /^\d/,
                // 0 to 9
                twoDigits: /^\d{1,2}/,
                // 0 to 99
                threeDigits: /^\d{1,3}/,
                // 0 to 999
                fourDigits: /^\d{1,4}/,
                // 0 to 9999
                anyDigitsSigned: /^-?\d+/,
                singleDigitSigned: /^-?\d/,
                // 0 to 9, -0 to -9
                twoDigitsSigned: /^-?\d{1,2}/,
                // 0 to 99, -0 to -99
                threeDigitsSigned: /^-?\d{1,3}/,
                // 0 to 999, -0 to -999
                fourDigitsSigned: /^-?\d{1,4}/ // 0 to 9999, -0 to -9999
            };
            var timezonePatterns = {
                basicOptionalMinutes: /^([+-])(\d{2})(\d{2})?|Z/,
                basic: /^([+-])(\d{2})(\d{2})|Z/,
                basicOptionalSeconds: /^([+-])(\d{2})(\d{2})((\d{2}))?|Z/,
                extended: /^([+-])(\d{2}):(\d{2})|Z/,
                extendedOptionalSeconds: /^([+-])(\d{2}):(\d{2})(:(\d{2}))?|Z/
            };
            /***/ 
        }),
        /***/ "./node_modules/date-fns/esm/parse/_lib/parsers/AMPMMidnightParser.js": 
        /*!****************************************************************************!*\
          !*** ./node_modules/date-fns/esm/parse/_lib/parsers/AMPMMidnightParser.js ***!
          \****************************************************************************/
        /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony export */ __webpack_require__.d(__webpack_exports__, {
                /* harmony export */ AMPMMidnightParser: () => ( /* binding */AMPMMidnightParser)
                /* harmony export */ 
            });
            /* harmony import */ var _babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/classCallCheck */ "./node_modules/@babel/runtime/helpers/esm/classCallCheck.js");
            /* harmony import */ var _babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/esm/createClass */ "./node_modules/@babel/runtime/helpers/esm/createClass.js");
            /* harmony import */ var _babel_runtime_helpers_esm_assertThisInitialized__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/runtime/helpers/esm/assertThisInitialized */ "./node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js");
            /* harmony import */ var _babel_runtime_helpers_esm_inherits__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @babel/runtime/helpers/esm/inherits */ "./node_modules/@babel/runtime/helpers/esm/inherits.js");
            /* harmony import */ var _babel_runtime_helpers_esm_createSuper__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @babel/runtime/helpers/esm/createSuper */ "./node_modules/@babel/runtime/helpers/esm/createSuper.js");
            /* harmony import */ var _babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @babel/runtime/helpers/esm/defineProperty */ "./node_modules/@babel/runtime/helpers/esm/defineProperty.js");
            /* harmony import */ var _Parser_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../Parser.js */ "./node_modules/date-fns/esm/parse/_lib/Parser.js");
            /* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../utils.js */ "./node_modules/date-fns/esm/parse/_lib/utils.js");
            var AMPMMidnightParser = /*#__PURE__*/ function (_Parser) {
                (0, _babel_runtime_helpers_esm_inherits__WEBPACK_IMPORTED_MODULE_3__["default"])(AMPMMidnightParser, _Parser);
                var _super = (0, _babel_runtime_helpers_esm_createSuper__WEBPACK_IMPORTED_MODULE_4__["default"])(AMPMMidnightParser);
                function AMPMMidnightParser() {
                    var _this;
                    (0, _babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_0__["default"])(this, AMPMMidnightParser);
                    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                        args[_key] = arguments[_key];
                    }
                    _this = _super.call.apply(_super, [this].concat(args));
                    (0, _babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_5__["default"])((0, _babel_runtime_helpers_esm_assertThisInitialized__WEBPACK_IMPORTED_MODULE_2__["default"])(_this), "priority", 80);
                    (0, _babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_5__["default"])((0, _babel_runtime_helpers_esm_assertThisInitialized__WEBPACK_IMPORTED_MODULE_2__["default"])(_this), "incompatibleTokens", ['a', 'B', 'H', 'k', 't', 'T']);
                    return _this;
                }
                (0, _babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_1__["default"])(AMPMMidnightParser, [{
                        key: "parse",
                        value: function parse(dateString, token, match) {
                            switch (token) {
                                case 'b':
                                case 'bb':
                                case 'bbb':
                                    return match.dayPeriod(dateString, {
                                        width: 'abbreviated',
                                        context: 'formatting'
                                    }) || match.dayPeriod(dateString, {
                                        width: 'narrow',
                                        context: 'formatting'
                                    });
                                case 'bbbbb':
                                    return match.dayPeriod(dateString, {
                                        width: 'narrow',
                                        context: 'formatting'
                                    });
                                case 'bbbb':
                                default:
                                    return match.dayPeriod(dateString, {
                                        width: 'wide',
                                        context: 'formatting'
                                    }) || match.dayPeriod(dateString, {
                                        width: 'abbreviated',
                                        context: 'formatting'
                                    }) || match.dayPeriod(dateString, {
                                        width: 'narrow',
                                        context: 'formatting'
                                    });
                            }
                        }
                    }, {
                        key: "set",
                        value: function set(date, _flags, value) {
                            date.setUTCHours((0, _utils_js__WEBPACK_IMPORTED_MODULE_6__.dayPeriodEnumToHours)(value), 0, 0, 0);
                            return date;
                        }
                    }]);
                return AMPMMidnightParser;
            }(_Parser_js__WEBPACK_IMPORTED_MODULE_7__.Parser);
            /***/ 
        }),
        /***/ "./node_modules/date-fns/esm/parse/_lib/parsers/AMPMParser.js": 
        /*!********************************************************************!*\
          !*** ./node_modules/date-fns/esm/parse/_lib/parsers/AMPMParser.js ***!
          \********************************************************************/
        /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony export */ __webpack_require__.d(__webpack_exports__, {
                /* harmony export */ AMPMParser: () => ( /* binding */AMPMParser)
                /* harmony export */ 
            });
            /* harmony import */ var _babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/classCallCheck */ "./node_modules/@babel/runtime/helpers/esm/classCallCheck.js");
            /* harmony import */ var _babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/esm/createClass */ "./node_modules/@babel/runtime/helpers/esm/createClass.js");
            /* harmony import */ var _babel_runtime_helpers_esm_assertThisInitialized__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/runtime/helpers/esm/assertThisInitialized */ "./node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js");
            /* harmony import */ var _babel_runtime_helpers_esm_inherits__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @babel/runtime/helpers/esm/inherits */ "./node_modules/@babel/runtime/helpers/esm/inherits.js");
            /* harmony import */ var _babel_runtime_helpers_esm_createSuper__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @babel/runtime/helpers/esm/createSuper */ "./node_modules/@babel/runtime/helpers/esm/createSuper.js");
            /* harmony import */ var _babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @babel/runtime/helpers/esm/defineProperty */ "./node_modules/@babel/runtime/helpers/esm/defineProperty.js");
            /* harmony import */ var _Parser_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../Parser.js */ "./node_modules/date-fns/esm/parse/_lib/Parser.js");
            /* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../utils.js */ "./node_modules/date-fns/esm/parse/_lib/utils.js");
            var AMPMParser = /*#__PURE__*/ function (_Parser) {
                (0, _babel_runtime_helpers_esm_inherits__WEBPACK_IMPORTED_MODULE_3__["default"])(AMPMParser, _Parser);
                var _super = (0, _babel_runtime_helpers_esm_createSuper__WEBPACK_IMPORTED_MODULE_4__["default"])(AMPMParser);
                function AMPMParser() {
                    var _this;
                    (0, _babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_0__["default"])(this, AMPMParser);
                    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                        args[_key] = arguments[_key];
                    }
                    _this = _super.call.apply(_super, [this].concat(args));
                    (0, _babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_5__["default"])((0, _babel_runtime_helpers_esm_assertThisInitialized__WEBPACK_IMPORTED_MODULE_2__["default"])(_this), "priority", 80);
                    (0, _babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_5__["default"])((0, _babel_runtime_helpers_esm_assertThisInitialized__WEBPACK_IMPORTED_MODULE_2__["default"])(_this), "incompatibleTokens", ['b', 'B', 'H', 'k', 't', 'T']);
                    return _this;
                }
                (0, _babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_1__["default"])(AMPMParser, [{
                        key: "parse",
                        value: function parse(dateString, token, match) {
                            switch (token) {
                                case 'a':
                                case 'aa':
                                case 'aaa':
                                    return match.dayPeriod(dateString, {
                                        width: 'abbreviated',
                                        context: 'formatting'
                                    }) || match.dayPeriod(dateString, {
                                        width: 'narrow',
                                        context: 'formatting'
                                    });
                                case 'aaaaa':
                                    return match.dayPeriod(dateString, {
                                        width: 'narrow',
                                        context: 'formatting'
                                    });
                                case 'aaaa':
                                default:
                                    return match.dayPeriod(dateString, {
                                        width: 'wide',
                                        context: 'formatting'
                                    }) || match.dayPeriod(dateString, {
                                        width: 'abbreviated',
                                        context: 'formatting'
                                    }) || match.dayPeriod(dateString, {
                                        width: 'narrow',
                                        context: 'formatting'
                                    });
                            }
                        }
                    }, {
                        key: "set",
                        value: function set(date, _flags, value) {
                            date.setUTCHours((0, _utils_js__WEBPACK_IMPORTED_MODULE_6__.dayPeriodEnumToHours)(value), 0, 0, 0);
                            return date;
                        }
                    }]);
                return AMPMParser;
            }(_Parser_js__WEBPACK_IMPORTED_MODULE_7__.Parser);
            /***/ 
        }),
        /***/ "./node_modules/date-fns/esm/parse/_lib/parsers/DateParser.js": 
        /*!********************************************************************!*\
          !*** ./node_modules/date-fns/esm/parse/_lib/parsers/DateParser.js ***!
          \********************************************************************/
        /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony export */ __webpack_require__.d(__webpack_exports__, {
                /* harmony export */ DateParser: () => ( /* binding */DateParser)
                /* harmony export */ 
            });
            /* harmony import */ var _babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/classCallCheck */ "./node_modules/@babel/runtime/helpers/esm/classCallCheck.js");
            /* harmony import */ var _babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/esm/createClass */ "./node_modules/@babel/runtime/helpers/esm/createClass.js");
            /* harmony import */ var _babel_runtime_helpers_esm_assertThisInitialized__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/runtime/helpers/esm/assertThisInitialized */ "./node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js");
            /* harmony import */ var _babel_runtime_helpers_esm_inherits__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @babel/runtime/helpers/esm/inherits */ "./node_modules/@babel/runtime/helpers/esm/inherits.js");
            /* harmony import */ var _babel_runtime_helpers_esm_createSuper__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @babel/runtime/helpers/esm/createSuper */ "./node_modules/@babel/runtime/helpers/esm/createSuper.js");
            /* harmony import */ var _babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @babel/runtime/helpers/esm/defineProperty */ "./node_modules/@babel/runtime/helpers/esm/defineProperty.js");
            /* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../utils.js */ "./node_modules/date-fns/esm/parse/_lib/utils.js");
            /* harmony import */ var _Parser_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../Parser.js */ "./node_modules/date-fns/esm/parse/_lib/Parser.js");
            /* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../constants.js */ "./node_modules/date-fns/esm/parse/_lib/constants.js");
            var DAYS_IN_MONTH = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
            var DAYS_IN_MONTH_LEAP_YEAR = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
            // Day of the month
            var DateParser = /*#__PURE__*/ function (_Parser) {
                (0, _babel_runtime_helpers_esm_inherits__WEBPACK_IMPORTED_MODULE_3__["default"])(DateParser, _Parser);
                var _super = (0, _babel_runtime_helpers_esm_createSuper__WEBPACK_IMPORTED_MODULE_4__["default"])(DateParser);
                function DateParser() {
                    var _this;
                    (0, _babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_0__["default"])(this, DateParser);
                    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                        args[_key] = arguments[_key];
                    }
                    _this = _super.call.apply(_super, [this].concat(args));
                    (0, _babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_5__["default"])((0, _babel_runtime_helpers_esm_assertThisInitialized__WEBPACK_IMPORTED_MODULE_2__["default"])(_this), "priority", 90);
                    (0, _babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_5__["default"])((0, _babel_runtime_helpers_esm_assertThisInitialized__WEBPACK_IMPORTED_MODULE_2__["default"])(_this), "subPriority", 1);
                    (0, _babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_5__["default"])((0, _babel_runtime_helpers_esm_assertThisInitialized__WEBPACK_IMPORTED_MODULE_2__["default"])(_this), "incompatibleTokens", ['Y', 'R', 'q', 'Q', 'w', 'I', 'D', 'i', 'e', 'c', 't', 'T']);
                    return _this;
                }
                (0, _babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_1__["default"])(DateParser, [{
                        key: "parse",
                        value: function parse(dateString, token, match) {
                            switch (token) {
                                case 'd':
                                    return (0, _utils_js__WEBPACK_IMPORTED_MODULE_6__.parseNumericPattern)(_constants_js__WEBPACK_IMPORTED_MODULE_7__.numericPatterns.date, dateString);
                                case 'do':
                                    return match.ordinalNumber(dateString, {
                                        unit: 'date'
                                    });
                                default:
                                    return (0, _utils_js__WEBPACK_IMPORTED_MODULE_6__.parseNDigits)(token.length, dateString);
                            }
                        }
                    }, {
                        key: "validate",
                        value: function validate(date, value) {
                            var year = date.getUTCFullYear();
                            var isLeapYear = (0, _utils_js__WEBPACK_IMPORTED_MODULE_6__.isLeapYearIndex)(year);
                            var month = date.getUTCMonth();
                            if (isLeapYear) {
                                return value >= 1 && value <= DAYS_IN_MONTH_LEAP_YEAR[month];
                            }
                            else {
                                return value >= 1 && value <= DAYS_IN_MONTH[month];
                            }
                        }
                    }, {
                        key: "set",
                        value: function set(date, _flags, value) {
                            date.setUTCDate(value);
                            date.setUTCHours(0, 0, 0, 0);
                            return date;
                        }
                    }]);
                return DateParser;
            }(_Parser_js__WEBPACK_IMPORTED_MODULE_8__.Parser);
            /***/ 
        }),
        /***/ "./node_modules/date-fns/esm/parse/_lib/parsers/DayOfYearParser.js": 
        /*!*************************************************************************!*\
          !*** ./node_modules/date-fns/esm/parse/_lib/parsers/DayOfYearParser.js ***!
          \*************************************************************************/
        /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony export */ __webpack_require__.d(__webpack_exports__, {
                /* harmony export */ DayOfYearParser: () => ( /* binding */DayOfYearParser)
                /* harmony export */ 
            });
            /* harmony import */ var _babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/classCallCheck */ "./node_modules/@babel/runtime/helpers/esm/classCallCheck.js");
            /* harmony import */ var _babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/esm/createClass */ "./node_modules/@babel/runtime/helpers/esm/createClass.js");
            /* harmony import */ var _babel_runtime_helpers_esm_assertThisInitialized__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/runtime/helpers/esm/assertThisInitialized */ "./node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js");
            /* harmony import */ var _babel_runtime_helpers_esm_inherits__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @babel/runtime/helpers/esm/inherits */ "./node_modules/@babel/runtime/helpers/esm/inherits.js");
            /* harmony import */ var _babel_runtime_helpers_esm_createSuper__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @babel/runtime/helpers/esm/createSuper */ "./node_modules/@babel/runtime/helpers/esm/createSuper.js");
            /* harmony import */ var _babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @babel/runtime/helpers/esm/defineProperty */ "./node_modules/@babel/runtime/helpers/esm/defineProperty.js");
            /* harmony import */ var _Parser_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../Parser.js */ "./node_modules/date-fns/esm/parse/_lib/Parser.js");
            /* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../constants.js */ "./node_modules/date-fns/esm/parse/_lib/constants.js");
            /* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../utils.js */ "./node_modules/date-fns/esm/parse/_lib/utils.js");
            var DayOfYearParser = /*#__PURE__*/ function (_Parser) {
                (0, _babel_runtime_helpers_esm_inherits__WEBPACK_IMPORTED_MODULE_3__["default"])(DayOfYearParser, _Parser);
                var _super = (0, _babel_runtime_helpers_esm_createSuper__WEBPACK_IMPORTED_MODULE_4__["default"])(DayOfYearParser);
                function DayOfYearParser() {
                    var _this;
                    (0, _babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_0__["default"])(this, DayOfYearParser);
                    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                        args[_key] = arguments[_key];
                    }
                    _this = _super.call.apply(_super, [this].concat(args));
                    (0, _babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_5__["default"])((0, _babel_runtime_helpers_esm_assertThisInitialized__WEBPACK_IMPORTED_MODULE_2__["default"])(_this), "priority", 90);
                    (0, _babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_5__["default"])((0, _babel_runtime_helpers_esm_assertThisInitialized__WEBPACK_IMPORTED_MODULE_2__["default"])(_this), "subpriority", 1);
                    (0, _babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_5__["default"])((0, _babel_runtime_helpers_esm_assertThisInitialized__WEBPACK_IMPORTED_MODULE_2__["default"])(_this), "incompatibleTokens", ['Y', 'R', 'q', 'Q', 'M', 'L', 'w', 'I', 'd', 'E', 'i', 'e', 'c', 't', 'T']);
                    return _this;
                }
                (0, _babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_1__["default"])(DayOfYearParser, [{
                        key: "parse",
                        value: function parse(dateString, token, match) {
                            switch (token) {
                                case 'D':
                                case 'DD':
                                    return (0, _utils_js__WEBPACK_IMPORTED_MODULE_6__.parseNumericPattern)(_constants_js__WEBPACK_IMPORTED_MODULE_7__.numericPatterns.dayOfYear, dateString);
                                case 'Do':
                                    return match.ordinalNumber(dateString, {
                                        unit: 'date'
                                    });
                                default:
                                    return (0, _utils_js__WEBPACK_IMPORTED_MODULE_6__.parseNDigits)(token.length, dateString);
                            }
                        }
                    }, {
                        key: "validate",
                        value: function validate(date, value) {
                            var year = date.getUTCFullYear();
                            var isLeapYear = (0, _utils_js__WEBPACK_IMPORTED_MODULE_6__.isLeapYearIndex)(year);
                            if (isLeapYear) {
                                return value >= 1 && value <= 366;
                            }
                            else {
                                return value >= 1 && value <= 365;
                            }
                        }
                    }, {
                        key: "set",
                        value: function set(date, _flags, value) {
                            date.setUTCMonth(0, value);
                            date.setUTCHours(0, 0, 0, 0);
                            return date;
                        }
                    }]);
                return DayOfYearParser;
            }(_Parser_js__WEBPACK_IMPORTED_MODULE_8__.Parser);
            /***/ 
        }),
        /***/ "./node_modules/date-fns/esm/parse/_lib/parsers/DayParser.js": 
        /*!*******************************************************************!*\
          !*** ./node_modules/date-fns/esm/parse/_lib/parsers/DayParser.js ***!
          \*******************************************************************/
        /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony export */ __webpack_require__.d(__webpack_exports__, {
                /* harmony export */ DayParser: () => ( /* binding */DayParser)
                /* harmony export */ 
            });
            /* harmony import */ var _babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/classCallCheck */ "./node_modules/@babel/runtime/helpers/esm/classCallCheck.js");
            /* harmony import */ var _babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/esm/createClass */ "./node_modules/@babel/runtime/helpers/esm/createClass.js");
            /* harmony import */ var _babel_runtime_helpers_esm_assertThisInitialized__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/runtime/helpers/esm/assertThisInitialized */ "./node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js");
            /* harmony import */ var _babel_runtime_helpers_esm_inherits__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @babel/runtime/helpers/esm/inherits */ "./node_modules/@babel/runtime/helpers/esm/inherits.js");
            /* harmony import */ var _babel_runtime_helpers_esm_createSuper__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @babel/runtime/helpers/esm/createSuper */ "./node_modules/@babel/runtime/helpers/esm/createSuper.js");
            /* harmony import */ var _babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @babel/runtime/helpers/esm/defineProperty */ "./node_modules/@babel/runtime/helpers/esm/defineProperty.js");
            /* harmony import */ var _Parser_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../Parser.js */ "./node_modules/date-fns/esm/parse/_lib/Parser.js");
            /* harmony import */ var _lib_setUTCDay_index_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../../_lib/setUTCDay/index.js */ "./node_modules/date-fns/esm/_lib/setUTCDay/index.js");
            // Day of week
            var DayParser = /*#__PURE__*/ function (_Parser) {
                (0, _babel_runtime_helpers_esm_inherits__WEBPACK_IMPORTED_MODULE_3__["default"])(DayParser, _Parser);
                var _super = (0, _babel_runtime_helpers_esm_createSuper__WEBPACK_IMPORTED_MODULE_4__["default"])(DayParser);
                function DayParser() {
                    var _this;
                    (0, _babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_0__["default"])(this, DayParser);
                    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                        args[_key] = arguments[_key];
                    }
                    _this = _super.call.apply(_super, [this].concat(args));
                    (0, _babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_5__["default"])((0, _babel_runtime_helpers_esm_assertThisInitialized__WEBPACK_IMPORTED_MODULE_2__["default"])(_this), "priority", 90);
                    (0, _babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_5__["default"])((0, _babel_runtime_helpers_esm_assertThisInitialized__WEBPACK_IMPORTED_MODULE_2__["default"])(_this), "incompatibleTokens", ['D', 'i', 'e', 'c', 't', 'T']);
                    return _this;
                }
                (0, _babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_1__["default"])(DayParser, [{
                        key: "parse",
                        value: function parse(dateString, token, match) {
                            switch (token) {
                                // Tue
                                case 'E':
                                case 'EE':
                                case 'EEE':
                                    return match.day(dateString, {
                                        width: 'abbreviated',
                                        context: 'formatting'
                                    }) || match.day(dateString, {
                                        width: 'short',
                                        context: 'formatting'
                                    }) || match.day(dateString, {
                                        width: 'narrow',
                                        context: 'formatting'
                                    });
                                // T
                                case 'EEEEE':
                                    return match.day(dateString, {
                                        width: 'narrow',
                                        context: 'formatting'
                                    });
                                // Tu
                                case 'EEEEEE':
                                    return match.day(dateString, {
                                        width: 'short',
                                        context: 'formatting'
                                    }) || match.day(dateString, {
                                        width: 'narrow',
                                        context: 'formatting'
                                    });
                                // Tuesday
                                case 'EEEE':
                                default:
                                    return match.day(dateString, {
                                        width: 'wide',
                                        context: 'formatting'
                                    }) || match.day(dateString, {
                                        width: 'abbreviated',
                                        context: 'formatting'
                                    }) || match.day(dateString, {
                                        width: 'short',
                                        context: 'formatting'
                                    }) || match.day(dateString, {
                                        width: 'narrow',
                                        context: 'formatting'
                                    });
                            }
                        }
                    }, {
                        key: "validate",
                        value: function validate(_date, value) {
                            return value >= 0 && value <= 6;
                        }
                    }, {
                        key: "set",
                        value: function set(date, _flags, value, options) {
                            date = (0, _lib_setUTCDay_index_js__WEBPACK_IMPORTED_MODULE_6__["default"])(date, value, options);
                            date.setUTCHours(0, 0, 0, 0);
                            return date;
                        }
                    }]);
                return DayParser;
            }(_Parser_js__WEBPACK_IMPORTED_MODULE_7__.Parser);
            /***/ 
        }),
        /***/ "./node_modules/date-fns/esm/parse/_lib/parsers/DayPeriodParser.js": 
        /*!*************************************************************************!*\
          !*** ./node_modules/date-fns/esm/parse/_lib/parsers/DayPeriodParser.js ***!
          \*************************************************************************/
        /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony export */ __webpack_require__.d(__webpack_exports__, {
                /* harmony export */ DayPeriodParser: () => ( /* binding */DayPeriodParser)
                /* harmony export */ 
            });
            /* harmony import */ var _babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/classCallCheck */ "./node_modules/@babel/runtime/helpers/esm/classCallCheck.js");
            /* harmony import */ var _babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/esm/createClass */ "./node_modules/@babel/runtime/helpers/esm/createClass.js");
            /* harmony import */ var _babel_runtime_helpers_esm_assertThisInitialized__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/runtime/helpers/esm/assertThisInitialized */ "./node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js");
            /* harmony import */ var _babel_runtime_helpers_esm_inherits__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @babel/runtime/helpers/esm/inherits */ "./node_modules/@babel/runtime/helpers/esm/inherits.js");
            /* harmony import */ var _babel_runtime_helpers_esm_createSuper__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @babel/runtime/helpers/esm/createSuper */ "./node_modules/@babel/runtime/helpers/esm/createSuper.js");
            /* harmony import */ var _babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @babel/runtime/helpers/esm/defineProperty */ "./node_modules/@babel/runtime/helpers/esm/defineProperty.js");
            /* harmony import */ var _Parser_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../Parser.js */ "./node_modules/date-fns/esm/parse/_lib/Parser.js");
            /* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../utils.js */ "./node_modules/date-fns/esm/parse/_lib/utils.js");
            // in the morning, in the afternoon, in the evening, at night
            var DayPeriodParser = /*#__PURE__*/ function (_Parser) {
                (0, _babel_runtime_helpers_esm_inherits__WEBPACK_IMPORTED_MODULE_3__["default"])(DayPeriodParser, _Parser);
                var _super = (0, _babel_runtime_helpers_esm_createSuper__WEBPACK_IMPORTED_MODULE_4__["default"])(DayPeriodParser);
                function DayPeriodParser() {
                    var _this;
                    (0, _babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_0__["default"])(this, DayPeriodParser);
                    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                        args[_key] = arguments[_key];
                    }
                    _this = _super.call.apply(_super, [this].concat(args));
                    (0, _babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_5__["default"])((0, _babel_runtime_helpers_esm_assertThisInitialized__WEBPACK_IMPORTED_MODULE_2__["default"])(_this), "priority", 80);
                    (0, _babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_5__["default"])((0, _babel_runtime_helpers_esm_assertThisInitialized__WEBPACK_IMPORTED_MODULE_2__["default"])(_this), "incompatibleTokens", ['a', 'b', 't', 'T']);
                    return _this;
                }
                (0, _babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_1__["default"])(DayPeriodParser, [{
                        key: "parse",
                        value: function parse(dateString, token, match) {
                            switch (token) {
                                case 'B':
                                case 'BB':
                                case 'BBB':
                                    return match.dayPeriod(dateString, {
                                        width: 'abbreviated',
                                        context: 'formatting'
                                    }) || match.dayPeriod(dateString, {
                                        width: 'narrow',
                                        context: 'formatting'
                                    });
                                case 'BBBBB':
                                    return match.dayPeriod(dateString, {
                                        width: 'narrow',
                                        context: 'formatting'
                                    });
                                case 'BBBB':
                                default:
                                    return match.dayPeriod(dateString, {
                                        width: 'wide',
                                        context: 'formatting'
                                    }) || match.dayPeriod(dateString, {
                                        width: 'abbreviated',
                                        context: 'formatting'
                                    }) || match.dayPeriod(dateString, {
                                        width: 'narrow',
                                        context: 'formatting'
                                    });
                            }
                        }
                    }, {
                        key: "set",
                        value: function set(date, _flags, value) {
                            date.setUTCHours((0, _utils_js__WEBPACK_IMPORTED_MODULE_6__.dayPeriodEnumToHours)(value), 0, 0, 0);
                            return date;
                        }
                    }]);
                return DayPeriodParser;
            }(_Parser_js__WEBPACK_IMPORTED_MODULE_7__.Parser);
            /***/ 
        }),
        /***/ "./node_modules/date-fns/esm/parse/_lib/parsers/EraParser.js": 
        /*!*******************************************************************!*\
          !*** ./node_modules/date-fns/esm/parse/_lib/parsers/EraParser.js ***!
          \*******************************************************************/
        /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony export */ __webpack_require__.d(__webpack_exports__, {
                /* harmony export */ EraParser: () => ( /* binding */EraParser)
                /* harmony export */ 
            });
            /* harmony import */ var _babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/classCallCheck */ "./node_modules/@babel/runtime/helpers/esm/classCallCheck.js");
            /* harmony import */ var _babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/esm/createClass */ "./node_modules/@babel/runtime/helpers/esm/createClass.js");
            /* harmony import */ var _babel_runtime_helpers_esm_assertThisInitialized__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/runtime/helpers/esm/assertThisInitialized */ "./node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js");
            /* harmony import */ var _babel_runtime_helpers_esm_inherits__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @babel/runtime/helpers/esm/inherits */ "./node_modules/@babel/runtime/helpers/esm/inherits.js");
            /* harmony import */ var _babel_runtime_helpers_esm_createSuper__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @babel/runtime/helpers/esm/createSuper */ "./node_modules/@babel/runtime/helpers/esm/createSuper.js");
            /* harmony import */ var _babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @babel/runtime/helpers/esm/defineProperty */ "./node_modules/@babel/runtime/helpers/esm/defineProperty.js");
            /* harmony import */ var _Parser_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../Parser.js */ "./node_modules/date-fns/esm/parse/_lib/Parser.js");
            var EraParser = /*#__PURE__*/ function (_Parser) {
                (0, _babel_runtime_helpers_esm_inherits__WEBPACK_IMPORTED_MODULE_3__["default"])(EraParser, _Parser);
                var _super = (0, _babel_runtime_helpers_esm_createSuper__WEBPACK_IMPORTED_MODULE_4__["default"])(EraParser);
                function EraParser() {
                    var _this;
                    (0, _babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_0__["default"])(this, EraParser);
                    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                        args[_key] = arguments[_key];
                    }
                    _this = _super.call.apply(_super, [this].concat(args));
                    (0, _babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_5__["default"])((0, _babel_runtime_helpers_esm_assertThisInitialized__WEBPACK_IMPORTED_MODULE_2__["default"])(_this), "priority", 140);
                    (0, _babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_5__["default"])((0, _babel_runtime_helpers_esm_assertThisInitialized__WEBPACK_IMPORTED_MODULE_2__["default"])(_this), "incompatibleTokens", ['R', 'u', 't', 'T']);
                    return _this;
                }
                (0, _babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_1__["default"])(EraParser, [{
                        key: "parse",
                        value: function parse(dateString, token, match) {
                            switch (token) {
                                // AD, BC
                                case 'G':
                                case 'GG':
                                case 'GGG':
                                    return match.era(dateString, {
                                        width: 'abbreviated'
                                    }) || match.era(dateString, {
                                        width: 'narrow'
                                    });
                                // A, B
                                case 'GGGGG':
                                    return match.era(dateString, {
                                        width: 'narrow'
                                    });
                                // Anno Domini, Before Christ
                                case 'GGGG':
                                default:
                                    return match.era(dateString, {
                                        width: 'wide'
                                    }) || match.era(dateString, {
                                        width: 'abbreviated'
                                    }) || match.era(dateString, {
                                        width: 'narrow'
                                    });
                            }
                        }
                    }, {
                        key: "set",
                        value: function set(date, flags, value) {
                            flags.era = value;
                            date.setUTCFullYear(value, 0, 1);
                            date.setUTCHours(0, 0, 0, 0);
                            return date;
                        }
                    }]);
                return EraParser;
            }(_Parser_js__WEBPACK_IMPORTED_MODULE_6__.Parser);
            /***/ 
        }),
        /***/ "./node_modules/date-fns/esm/parse/_lib/parsers/ExtendedYearParser.js": 
        /*!****************************************************************************!*\
          !*** ./node_modules/date-fns/esm/parse/_lib/parsers/ExtendedYearParser.js ***!
          \****************************************************************************/
        /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony export */ __webpack_require__.d(__webpack_exports__, {
                /* harmony export */ ExtendedYearParser: () => ( /* binding */ExtendedYearParser)
                /* harmony export */ 
            });
            /* harmony import */ var _babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/classCallCheck */ "./node_modules/@babel/runtime/helpers/esm/classCallCheck.js");
            /* harmony import */ var _babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/esm/createClass */ "./node_modules/@babel/runtime/helpers/esm/createClass.js");
            /* harmony import */ var _babel_runtime_helpers_esm_assertThisInitialized__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/runtime/helpers/esm/assertThisInitialized */ "./node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js");
            /* harmony import */ var _babel_runtime_helpers_esm_inherits__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @babel/runtime/helpers/esm/inherits */ "./node_modules/@babel/runtime/helpers/esm/inherits.js");
            /* harmony import */ var _babel_runtime_helpers_esm_createSuper__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @babel/runtime/helpers/esm/createSuper */ "./node_modules/@babel/runtime/helpers/esm/createSuper.js");
            /* harmony import */ var _babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @babel/runtime/helpers/esm/defineProperty */ "./node_modules/@babel/runtime/helpers/esm/defineProperty.js");
            /* harmony import */ var _Parser_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../Parser.js */ "./node_modules/date-fns/esm/parse/_lib/Parser.js");
            /* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../utils.js */ "./node_modules/date-fns/esm/parse/_lib/utils.js");
            var ExtendedYearParser = /*#__PURE__*/ function (_Parser) {
                (0, _babel_runtime_helpers_esm_inherits__WEBPACK_IMPORTED_MODULE_3__["default"])(ExtendedYearParser, _Parser);
                var _super = (0, _babel_runtime_helpers_esm_createSuper__WEBPACK_IMPORTED_MODULE_4__["default"])(ExtendedYearParser);
                function ExtendedYearParser() {
                    var _this;
                    (0, _babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_0__["default"])(this, ExtendedYearParser);
                    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                        args[_key] = arguments[_key];
                    }
                    _this = _super.call.apply(_super, [this].concat(args));
                    (0, _babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_5__["default"])((0, _babel_runtime_helpers_esm_assertThisInitialized__WEBPACK_IMPORTED_MODULE_2__["default"])(_this), "priority", 130);
                    (0, _babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_5__["default"])((0, _babel_runtime_helpers_esm_assertThisInitialized__WEBPACK_IMPORTED_MODULE_2__["default"])(_this), "incompatibleTokens", ['G', 'y', 'Y', 'R', 'w', 'I', 'i', 'e', 'c', 't', 'T']);
                    return _this;
                }
                (0, _babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_1__["default"])(ExtendedYearParser, [{
                        key: "parse",
                        value: function parse(dateString, token) {
                            if (token === 'u') {
                                return (0, _utils_js__WEBPACK_IMPORTED_MODULE_6__.parseNDigitsSigned)(4, dateString);
                            }
                            return (0, _utils_js__WEBPACK_IMPORTED_MODULE_6__.parseNDigitsSigned)(token.length, dateString);
                        }
                    }, {
                        key: "set",
                        value: function set(date, _flags, value) {
                            date.setUTCFullYear(value, 0, 1);
                            date.setUTCHours(0, 0, 0, 0);
                            return date;
                        }
                    }]);
                return ExtendedYearParser;
            }(_Parser_js__WEBPACK_IMPORTED_MODULE_7__.Parser);
            /***/ 
        }),
        /***/ "./node_modules/date-fns/esm/parse/_lib/parsers/FractionOfSecondParser.js": 
        /*!********************************************************************************!*\
          !*** ./node_modules/date-fns/esm/parse/_lib/parsers/FractionOfSecondParser.js ***!
          \********************************************************************************/
        /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony export */ __webpack_require__.d(__webpack_exports__, {
                /* harmony export */ FractionOfSecondParser: () => ( /* binding */FractionOfSecondParser)
                /* harmony export */ 
            });
            /* harmony import */ var _babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/classCallCheck */ "./node_modules/@babel/runtime/helpers/esm/classCallCheck.js");
            /* harmony import */ var _babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/esm/createClass */ "./node_modules/@babel/runtime/helpers/esm/createClass.js");
            /* harmony import */ var _babel_runtime_helpers_esm_assertThisInitialized__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/runtime/helpers/esm/assertThisInitialized */ "./node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js");
            /* harmony import */ var _babel_runtime_helpers_esm_inherits__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @babel/runtime/helpers/esm/inherits */ "./node_modules/@babel/runtime/helpers/esm/inherits.js");
            /* harmony import */ var _babel_runtime_helpers_esm_createSuper__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @babel/runtime/helpers/esm/createSuper */ "./node_modules/@babel/runtime/helpers/esm/createSuper.js");
            /* harmony import */ var _babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @babel/runtime/helpers/esm/defineProperty */ "./node_modules/@babel/runtime/helpers/esm/defineProperty.js");
            /* harmony import */ var _Parser_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../Parser.js */ "./node_modules/date-fns/esm/parse/_lib/Parser.js");
            /* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../utils.js */ "./node_modules/date-fns/esm/parse/_lib/utils.js");
            var FractionOfSecondParser = /*#__PURE__*/ function (_Parser) {
                (0, _babel_runtime_helpers_esm_inherits__WEBPACK_IMPORTED_MODULE_3__["default"])(FractionOfSecondParser, _Parser);
                var _super = (0, _babel_runtime_helpers_esm_createSuper__WEBPACK_IMPORTED_MODULE_4__["default"])(FractionOfSecondParser);
                function FractionOfSecondParser() {
                    var _this;
                    (0, _babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_0__["default"])(this, FractionOfSecondParser);
                    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                        args[_key] = arguments[_key];
                    }
                    _this = _super.call.apply(_super, [this].concat(args));
                    (0, _babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_5__["default"])((0, _babel_runtime_helpers_esm_assertThisInitialized__WEBPACK_IMPORTED_MODULE_2__["default"])(_this), "priority", 30);
                    (0, _babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_5__["default"])((0, _babel_runtime_helpers_esm_assertThisInitialized__WEBPACK_IMPORTED_MODULE_2__["default"])(_this), "incompatibleTokens", ['t', 'T']);
                    return _this;
                }
                (0, _babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_1__["default"])(FractionOfSecondParser, [{
                        key: "parse",
                        value: function parse(dateString, token) {
                            var valueCallback = function valueCallback(value) {
                                return Math.floor(value * Math.pow(10, -token.length + 3));
                            };
                            return (0, _utils_js__WEBPACK_IMPORTED_MODULE_6__.mapValue)((0, _utils_js__WEBPACK_IMPORTED_MODULE_6__.parseNDigits)(token.length, dateString), valueCallback);
                        }
                    }, {
                        key: "set",
                        value: function set(date, _flags, value) {
                            date.setUTCMilliseconds(value);
                            return date;
                        }
                    }]);
                return FractionOfSecondParser;
            }(_Parser_js__WEBPACK_IMPORTED_MODULE_7__.Parser);
            /***/ 
        }),
        /***/ "./node_modules/date-fns/esm/parse/_lib/parsers/Hour0To11Parser.js": 
        /*!*************************************************************************!*\
          !*** ./node_modules/date-fns/esm/parse/_lib/parsers/Hour0To11Parser.js ***!
          \*************************************************************************/
        /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony export */ __webpack_require__.d(__webpack_exports__, {
                /* harmony export */ Hour0To11Parser: () => ( /* binding */Hour0To11Parser)
                /* harmony export */ 
            });
            /* harmony import */ var _babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/classCallCheck */ "./node_modules/@babel/runtime/helpers/esm/classCallCheck.js");
            /* harmony import */ var _babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/esm/createClass */ "./node_modules/@babel/runtime/helpers/esm/createClass.js");
            /* harmony import */ var _babel_runtime_helpers_esm_assertThisInitialized__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/runtime/helpers/esm/assertThisInitialized */ "./node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js");
            /* harmony import */ var _babel_runtime_helpers_esm_inherits__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @babel/runtime/helpers/esm/inherits */ "./node_modules/@babel/runtime/helpers/esm/inherits.js");
            /* harmony import */ var _babel_runtime_helpers_esm_createSuper__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @babel/runtime/helpers/esm/createSuper */ "./node_modules/@babel/runtime/helpers/esm/createSuper.js");
            /* harmony import */ var _babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @babel/runtime/helpers/esm/defineProperty */ "./node_modules/@babel/runtime/helpers/esm/defineProperty.js");
            /* harmony import */ var _Parser_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../Parser.js */ "./node_modules/date-fns/esm/parse/_lib/Parser.js");
            /* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../constants.js */ "./node_modules/date-fns/esm/parse/_lib/constants.js");
            /* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../utils.js */ "./node_modules/date-fns/esm/parse/_lib/utils.js");
            var Hour0To11Parser = /*#__PURE__*/ function (_Parser) {
                (0, _babel_runtime_helpers_esm_inherits__WEBPACK_IMPORTED_MODULE_3__["default"])(Hour0To11Parser, _Parser);
                var _super = (0, _babel_runtime_helpers_esm_createSuper__WEBPACK_IMPORTED_MODULE_4__["default"])(Hour0To11Parser);
                function Hour0To11Parser() {
                    var _this;
                    (0, _babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_0__["default"])(this, Hour0To11Parser);
                    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                        args[_key] = arguments[_key];
                    }
                    _this = _super.call.apply(_super, [this].concat(args));
                    (0, _babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_5__["default"])((0, _babel_runtime_helpers_esm_assertThisInitialized__WEBPACK_IMPORTED_MODULE_2__["default"])(_this), "priority", 70);
                    (0, _babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_5__["default"])((0, _babel_runtime_helpers_esm_assertThisInitialized__WEBPACK_IMPORTED_MODULE_2__["default"])(_this), "incompatibleTokens", ['h', 'H', 'k', 't', 'T']);
                    return _this;
                }
                (0, _babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_1__["default"])(Hour0To11Parser, [{
                        key: "parse",
                        value: function parse(dateString, token, match) {
                            switch (token) {
                                case 'K':
                                    return (0, _utils_js__WEBPACK_IMPORTED_MODULE_6__.parseNumericPattern)(_constants_js__WEBPACK_IMPORTED_MODULE_7__.numericPatterns.hour11h, dateString);
                                case 'Ko':
                                    return match.ordinalNumber(dateString, {
                                        unit: 'hour'
                                    });
                                default:
                                    return (0, _utils_js__WEBPACK_IMPORTED_MODULE_6__.parseNDigits)(token.length, dateString);
                            }
                        }
                    }, {
                        key: "validate",
                        value: function validate(_date, value) {
                            return value >= 0 && value <= 11;
                        }
                    }, {
                        key: "set",
                        value: function set(date, _flags, value) {
                            var isPM = date.getUTCHours() >= 12;
                            if (isPM && value < 12) {
                                date.setUTCHours(value + 12, 0, 0, 0);
                            }
                            else {
                                date.setUTCHours(value, 0, 0, 0);
                            }
                            return date;
                        }
                    }]);
                return Hour0To11Parser;
            }(_Parser_js__WEBPACK_IMPORTED_MODULE_8__.Parser);
            /***/ 
        }),
        /***/ "./node_modules/date-fns/esm/parse/_lib/parsers/Hour0to23Parser.js": 
        /*!*************************************************************************!*\
          !*** ./node_modules/date-fns/esm/parse/_lib/parsers/Hour0to23Parser.js ***!
          \*************************************************************************/
        /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony export */ __webpack_require__.d(__webpack_exports__, {
                /* harmony export */ Hour0to23Parser: () => ( /* binding */Hour0to23Parser)
                /* harmony export */ 
            });
            /* harmony import */ var _babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/classCallCheck */ "./node_modules/@babel/runtime/helpers/esm/classCallCheck.js");
            /* harmony import */ var _babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/esm/createClass */ "./node_modules/@babel/runtime/helpers/esm/createClass.js");
            /* harmony import */ var _babel_runtime_helpers_esm_assertThisInitialized__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/runtime/helpers/esm/assertThisInitialized */ "./node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js");
            /* harmony import */ var _babel_runtime_helpers_esm_inherits__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @babel/runtime/helpers/esm/inherits */ "./node_modules/@babel/runtime/helpers/esm/inherits.js");
            /* harmony import */ var _babel_runtime_helpers_esm_createSuper__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @babel/runtime/helpers/esm/createSuper */ "./node_modules/@babel/runtime/helpers/esm/createSuper.js");
            /* harmony import */ var _babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @babel/runtime/helpers/esm/defineProperty */ "./node_modules/@babel/runtime/helpers/esm/defineProperty.js");
            /* harmony import */ var _Parser_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../Parser.js */ "./node_modules/date-fns/esm/parse/_lib/Parser.js");
            /* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../constants.js */ "./node_modules/date-fns/esm/parse/_lib/constants.js");
            /* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../utils.js */ "./node_modules/date-fns/esm/parse/_lib/utils.js");
            var Hour0to23Parser = /*#__PURE__*/ function (_Parser) {
                (0, _babel_runtime_helpers_esm_inherits__WEBPACK_IMPORTED_MODULE_3__["default"])(Hour0to23Parser, _Parser);
                var _super = (0, _babel_runtime_helpers_esm_createSuper__WEBPACK_IMPORTED_MODULE_4__["default"])(Hour0to23Parser);
                function Hour0to23Parser() {
                    var _this;
                    (0, _babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_0__["default"])(this, Hour0to23Parser);
                    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                        args[_key] = arguments[_key];
                    }
                    _this = _super.call.apply(_super, [this].concat(args));
                    (0, _babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_5__["default"])((0, _babel_runtime_helpers_esm_assertThisInitialized__WEBPACK_IMPORTED_MODULE_2__["default"])(_this), "priority", 70);
                    (0, _babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_5__["default"])((0, _babel_runtime_helpers_esm_assertThisInitialized__WEBPACK_IMPORTED_MODULE_2__["default"])(_this), "incompatibleTokens", ['a', 'b', 'h', 'K', 'k', 't', 'T']);
                    return _this;
                }
                (0, _babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_1__["default"])(Hour0to23Parser, [{
                        key: "parse",
                        value: function parse(dateString, token, match) {
                            switch (token) {
                                case 'H':
                                    return (0, _utils_js__WEBPACK_IMPORTED_MODULE_6__.parseNumericPattern)(_constants_js__WEBPACK_IMPORTED_MODULE_7__.numericPatterns.hour23h, dateString);
                                case 'Ho':
                                    return match.ordinalNumber(dateString, {
                                        unit: 'hour'
                                    });
                                default:
                                    return (0, _utils_js__WEBPACK_IMPORTED_MODULE_6__.parseNDigits)(token.length, dateString);
                            }
                        }
                    }, {
                        key: "validate",
                        value: function validate(_date, value) {
                            return value >= 0 && value <= 23;
                        }
                    }, {
                        key: "set",
                        value: function set(date, _flags, value) {
                            date.setUTCHours(value, 0, 0, 0);
                            return date;
                        }
                    }]);
                return Hour0to23Parser;
            }(_Parser_js__WEBPACK_IMPORTED_MODULE_8__.Parser);
            /***/ 
        }),
        /***/ "./node_modules/date-fns/esm/parse/_lib/parsers/Hour1To24Parser.js": 
        /*!*************************************************************************!*\
          !*** ./node_modules/date-fns/esm/parse/_lib/parsers/Hour1To24Parser.js ***!
          \*************************************************************************/
        /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony export */ __webpack_require__.d(__webpack_exports__, {
                /* harmony export */ Hour1To24Parser: () => ( /* binding */Hour1To24Parser)
                /* harmony export */ 
            });
            /* harmony import */ var _babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/classCallCheck */ "./node_modules/@babel/runtime/helpers/esm/classCallCheck.js");
            /* harmony import */ var _babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/esm/createClass */ "./node_modules/@babel/runtime/helpers/esm/createClass.js");
            /* harmony import */ var _babel_runtime_helpers_esm_assertThisInitialized__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/runtime/helpers/esm/assertThisInitialized */ "./node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js");
            /* harmony import */ var _babel_runtime_helpers_esm_inherits__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @babel/runtime/helpers/esm/inherits */ "./node_modules/@babel/runtime/helpers/esm/inherits.js");
            /* harmony import */ var _babel_runtime_helpers_esm_createSuper__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @babel/runtime/helpers/esm/createSuper */ "./node_modules/@babel/runtime/helpers/esm/createSuper.js");
            /* harmony import */ var _babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @babel/runtime/helpers/esm/defineProperty */ "./node_modules/@babel/runtime/helpers/esm/defineProperty.js");
            /* harmony import */ var _Parser_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../Parser.js */ "./node_modules/date-fns/esm/parse/_lib/Parser.js");
            /* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../constants.js */ "./node_modules/date-fns/esm/parse/_lib/constants.js");
            /* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../utils.js */ "./node_modules/date-fns/esm/parse/_lib/utils.js");
            var Hour1To24Parser = /*#__PURE__*/ function (_Parser) {
                (0, _babel_runtime_helpers_esm_inherits__WEBPACK_IMPORTED_MODULE_3__["default"])(Hour1To24Parser, _Parser);
                var _super = (0, _babel_runtime_helpers_esm_createSuper__WEBPACK_IMPORTED_MODULE_4__["default"])(Hour1To24Parser);
                function Hour1To24Parser() {
                    var _this;
                    (0, _babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_0__["default"])(this, Hour1To24Parser);
                    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                        args[_key] = arguments[_key];
                    }
                    _this = _super.call.apply(_super, [this].concat(args));
                    (0, _babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_5__["default"])((0, _babel_runtime_helpers_esm_assertThisInitialized__WEBPACK_IMPORTED_MODULE_2__["default"])(_this), "priority", 70);
                    (0, _babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_5__["default"])((0, _babel_runtime_helpers_esm_assertThisInitialized__WEBPACK_IMPORTED_MODULE_2__["default"])(_this), "incompatibleTokens", ['a', 'b', 'h', 'H', 'K', 't', 'T']);
                    return _this;
                }
                (0, _babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_1__["default"])(Hour1To24Parser, [{
                        key: "parse",
                        value: function parse(dateString, token, match) {
                            switch (token) {
                                case 'k':
                                    return (0, _utils_js__WEBPACK_IMPORTED_MODULE_6__.parseNumericPattern)(_constants_js__WEBPACK_IMPORTED_MODULE_7__.numericPatterns.hour24h, dateString);
                                case 'ko':
                                    return match.ordinalNumber(dateString, {
                                        unit: 'hour'
                                    });
                                default:
                                    return (0, _utils_js__WEBPACK_IMPORTED_MODULE_6__.parseNDigits)(token.length, dateString);
                            }
                        }
                    }, {
                        key: "validate",
                        value: function validate(_date, value) {
                            return value >= 1 && value <= 24;
                        }
                    }, {
                        key: "set",
                        value: function set(date, _flags, value) {
                            var hours = value <= 24 ? value % 24 : value;
                            date.setUTCHours(hours, 0, 0, 0);
                            return date;
                        }
                    }]);
                return Hour1To24Parser;
            }(_Parser_js__WEBPACK_IMPORTED_MODULE_8__.Parser);
            /***/ 
        }),
        /***/ "./node_modules/date-fns/esm/parse/_lib/parsers/Hour1to12Parser.js": 
        /*!*************************************************************************!*\
          !*** ./node_modules/date-fns/esm/parse/_lib/parsers/Hour1to12Parser.js ***!
          \*************************************************************************/
        /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony export */ __webpack_require__.d(__webpack_exports__, {
                /* harmony export */ Hour1to12Parser: () => ( /* binding */Hour1to12Parser)
                /* harmony export */ 
            });
            /* harmony import */ var _babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/classCallCheck */ "./node_modules/@babel/runtime/helpers/esm/classCallCheck.js");
            /* harmony import */ var _babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/esm/createClass */ "./node_modules/@babel/runtime/helpers/esm/createClass.js");
            /* harmony import */ var _babel_runtime_helpers_esm_assertThisInitialized__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/runtime/helpers/esm/assertThisInitialized */ "./node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js");
            /* harmony import */ var _babel_runtime_helpers_esm_inherits__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @babel/runtime/helpers/esm/inherits */ "./node_modules/@babel/runtime/helpers/esm/inherits.js");
            /* harmony import */ var _babel_runtime_helpers_esm_createSuper__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @babel/runtime/helpers/esm/createSuper */ "./node_modules/@babel/runtime/helpers/esm/createSuper.js");
            /* harmony import */ var _babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @babel/runtime/helpers/esm/defineProperty */ "./node_modules/@babel/runtime/helpers/esm/defineProperty.js");
            /* harmony import */ var _Parser_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../Parser.js */ "./node_modules/date-fns/esm/parse/_lib/Parser.js");
            /* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../constants.js */ "./node_modules/date-fns/esm/parse/_lib/constants.js");
            /* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../utils.js */ "./node_modules/date-fns/esm/parse/_lib/utils.js");
            var Hour1to12Parser = /*#__PURE__*/ function (_Parser) {
                (0, _babel_runtime_helpers_esm_inherits__WEBPACK_IMPORTED_MODULE_3__["default"])(Hour1to12Parser, _Parser);
                var _super = (0, _babel_runtime_helpers_esm_createSuper__WEBPACK_IMPORTED_MODULE_4__["default"])(Hour1to12Parser);
                function Hour1to12Parser() {
                    var _this;
                    (0, _babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_0__["default"])(this, Hour1to12Parser);
                    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                        args[_key] = arguments[_key];
                    }
                    _this = _super.call.apply(_super, [this].concat(args));
                    (0, _babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_5__["default"])((0, _babel_runtime_helpers_esm_assertThisInitialized__WEBPACK_IMPORTED_MODULE_2__["default"])(_this), "priority", 70);
                    (0, _babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_5__["default"])((0, _babel_runtime_helpers_esm_assertThisInitialized__WEBPACK_IMPORTED_MODULE_2__["default"])(_this), "incompatibleTokens", ['H', 'K', 'k', 't', 'T']);
                    return _this;
                }
                (0, _babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_1__["default"])(Hour1to12Parser, [{
                        key: "parse",
                        value: function parse(dateString, token, match) {
                            switch (token) {
                                case 'h':
                                    return (0, _utils_js__WEBPACK_IMPORTED_MODULE_6__.parseNumericPattern)(_constants_js__WEBPACK_IMPORTED_MODULE_7__.numericPatterns.hour12h, dateString);
                                case 'ho':
                                    return match.ordinalNumber(dateString, {
                                        unit: 'hour'
                                    });
                                default:
                                    return (0, _utils_js__WEBPACK_IMPORTED_MODULE_6__.parseNDigits)(token.length, dateString);
                            }
                        }
                    }, {
                        key: "validate",
                        value: function validate(_date, value) {
                            return value >= 1 && value <= 12;
                        }
                    }, {
                        key: "set",
                        value: function set(date, _flags, value) {
                            var isPM = date.getUTCHours() >= 12;
                            if (isPM && value < 12) {
                                date.setUTCHours(value + 12, 0, 0, 0);
                            }
                            else if (!isPM && value === 12) {
                                date.setUTCHours(0, 0, 0, 0);
                            }
                            else {
                                date.setUTCHours(value, 0, 0, 0);
                            }
                            return date;
                        }
                    }]);
                return Hour1to12Parser;
            }(_Parser_js__WEBPACK_IMPORTED_MODULE_8__.Parser);
            /***/ 
        }),
        /***/ "./node_modules/date-fns/esm/parse/_lib/parsers/ISODayParser.js": 
        /*!**********************************************************************!*\
          !*** ./node_modules/date-fns/esm/parse/_lib/parsers/ISODayParser.js ***!
          \**********************************************************************/
        /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony export */ __webpack_require__.d(__webpack_exports__, {
                /* harmony export */ ISODayParser: () => ( /* binding */ISODayParser)
                /* harmony export */ 
            });
            /* harmony import */ var _babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/classCallCheck */ "./node_modules/@babel/runtime/helpers/esm/classCallCheck.js");
            /* harmony import */ var _babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/esm/createClass */ "./node_modules/@babel/runtime/helpers/esm/createClass.js");
            /* harmony import */ var _babel_runtime_helpers_esm_assertThisInitialized__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/runtime/helpers/esm/assertThisInitialized */ "./node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js");
            /* harmony import */ var _babel_runtime_helpers_esm_inherits__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @babel/runtime/helpers/esm/inherits */ "./node_modules/@babel/runtime/helpers/esm/inherits.js");
            /* harmony import */ var _babel_runtime_helpers_esm_createSuper__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @babel/runtime/helpers/esm/createSuper */ "./node_modules/@babel/runtime/helpers/esm/createSuper.js");
            /* harmony import */ var _babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @babel/runtime/helpers/esm/defineProperty */ "./node_modules/@babel/runtime/helpers/esm/defineProperty.js");
            /* harmony import */ var _Parser_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../Parser.js */ "./node_modules/date-fns/esm/parse/_lib/Parser.js");
            /* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../utils.js */ "./node_modules/date-fns/esm/parse/_lib/utils.js");
            /* harmony import */ var _lib_setUTCISODay_index_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../../_lib/setUTCISODay/index.js */ "./node_modules/date-fns/esm/_lib/setUTCISODay/index.js");
            // ISO day of week
            var ISODayParser = /*#__PURE__*/ function (_Parser) {
                (0, _babel_runtime_helpers_esm_inherits__WEBPACK_IMPORTED_MODULE_3__["default"])(ISODayParser, _Parser);
                var _super = (0, _babel_runtime_helpers_esm_createSuper__WEBPACK_IMPORTED_MODULE_4__["default"])(ISODayParser);
                function ISODayParser() {
                    var _this;
                    (0, _babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_0__["default"])(this, ISODayParser);
                    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                        args[_key] = arguments[_key];
                    }
                    _this = _super.call.apply(_super, [this].concat(args));
                    (0, _babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_5__["default"])((0, _babel_runtime_helpers_esm_assertThisInitialized__WEBPACK_IMPORTED_MODULE_2__["default"])(_this), "priority", 90);
                    (0, _babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_5__["default"])((0, _babel_runtime_helpers_esm_assertThisInitialized__WEBPACK_IMPORTED_MODULE_2__["default"])(_this), "incompatibleTokens", ['y', 'Y', 'u', 'q', 'Q', 'M', 'L', 'w', 'd', 'D', 'E', 'e', 'c', 't', 'T']);
                    return _this;
                }
                (0, _babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_1__["default"])(ISODayParser, [{
                        key: "parse",
                        value: function parse(dateString, token, match) {
                            var valueCallback = function valueCallback(value) {
                                if (value === 0) {
                                    return 7;
                                }
                                return value;
                            };
                            switch (token) {
                                // 2
                                case 'i':
                                case 'ii':
                                    // 02
                                    return (0, _utils_js__WEBPACK_IMPORTED_MODULE_6__.parseNDigits)(token.length, dateString);
                                // 2nd
                                case 'io':
                                    return match.ordinalNumber(dateString, {
                                        unit: 'day'
                                    });
                                // Tue
                                case 'iii':
                                    return (0, _utils_js__WEBPACK_IMPORTED_MODULE_6__.mapValue)(match.day(dateString, {
                                        width: 'abbreviated',
                                        context: 'formatting'
                                    }) || match.day(dateString, {
                                        width: 'short',
                                        context: 'formatting'
                                    }) || match.day(dateString, {
                                        width: 'narrow',
                                        context: 'formatting'
                                    }), valueCallback);
                                // T
                                case 'iiiii':
                                    return (0, _utils_js__WEBPACK_IMPORTED_MODULE_6__.mapValue)(match.day(dateString, {
                                        width: 'narrow',
                                        context: 'formatting'
                                    }), valueCallback);
                                // Tu
                                case 'iiiiii':
                                    return (0, _utils_js__WEBPACK_IMPORTED_MODULE_6__.mapValue)(match.day(dateString, {
                                        width: 'short',
                                        context: 'formatting'
                                    }) || match.day(dateString, {
                                        width: 'narrow',
                                        context: 'formatting'
                                    }), valueCallback);
                                // Tuesday
                                case 'iiii':
                                default:
                                    return (0, _utils_js__WEBPACK_IMPORTED_MODULE_6__.mapValue)(match.day(dateString, {
                                        width: 'wide',
                                        context: 'formatting'
                                    }) || match.day(dateString, {
                                        width: 'abbreviated',
                                        context: 'formatting'
                                    }) || match.day(dateString, {
                                        width: 'short',
                                        context: 'formatting'
                                    }) || match.day(dateString, {
                                        width: 'narrow',
                                        context: 'formatting'
                                    }), valueCallback);
                            }
                        }
                    }, {
                        key: "validate",
                        value: function validate(_date, value) {
                            return value >= 1 && value <= 7;
                        }
                    }, {
                        key: "set",
                        value: function set(date, _flags, value) {
                            date = (0, _lib_setUTCISODay_index_js__WEBPACK_IMPORTED_MODULE_7__["default"])(date, value);
                            date.setUTCHours(0, 0, 0, 0);
                            return date;
                        }
                    }]);
                return ISODayParser;
            }(_Parser_js__WEBPACK_IMPORTED_MODULE_8__.Parser);
            /***/ 
        }),
        /***/ "./node_modules/date-fns/esm/parse/_lib/parsers/ISOTimezoneParser.js": 
        /*!***************************************************************************!*\
          !*** ./node_modules/date-fns/esm/parse/_lib/parsers/ISOTimezoneParser.js ***!
          \***************************************************************************/
        /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony export */ __webpack_require__.d(__webpack_exports__, {
                /* harmony export */ ISOTimezoneParser: () => ( /* binding */ISOTimezoneParser)
                /* harmony export */ 
            });
            /* harmony import */ var _babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/classCallCheck */ "./node_modules/@babel/runtime/helpers/esm/classCallCheck.js");
            /* harmony import */ var _babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/esm/createClass */ "./node_modules/@babel/runtime/helpers/esm/createClass.js");
            /* harmony import */ var _babel_runtime_helpers_esm_assertThisInitialized__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/runtime/helpers/esm/assertThisInitialized */ "./node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js");
            /* harmony import */ var _babel_runtime_helpers_esm_inherits__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @babel/runtime/helpers/esm/inherits */ "./node_modules/@babel/runtime/helpers/esm/inherits.js");
            /* harmony import */ var _babel_runtime_helpers_esm_createSuper__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @babel/runtime/helpers/esm/createSuper */ "./node_modules/@babel/runtime/helpers/esm/createSuper.js");
            /* harmony import */ var _babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @babel/runtime/helpers/esm/defineProperty */ "./node_modules/@babel/runtime/helpers/esm/defineProperty.js");
            /* harmony import */ var _Parser_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../Parser.js */ "./node_modules/date-fns/esm/parse/_lib/Parser.js");
            /* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../constants.js */ "./node_modules/date-fns/esm/parse/_lib/constants.js");
            /* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../utils.js */ "./node_modules/date-fns/esm/parse/_lib/utils.js");
            // Timezone (ISO-8601)
            var ISOTimezoneParser = /*#__PURE__*/ function (_Parser) {
                (0, _babel_runtime_helpers_esm_inherits__WEBPACK_IMPORTED_MODULE_3__["default"])(ISOTimezoneParser, _Parser);
                var _super = (0, _babel_runtime_helpers_esm_createSuper__WEBPACK_IMPORTED_MODULE_4__["default"])(ISOTimezoneParser);
                function ISOTimezoneParser() {
                    var _this;
                    (0, _babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_0__["default"])(this, ISOTimezoneParser);
                    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                        args[_key] = arguments[_key];
                    }
                    _this = _super.call.apply(_super, [this].concat(args));
                    (0, _babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_5__["default"])((0, _babel_runtime_helpers_esm_assertThisInitialized__WEBPACK_IMPORTED_MODULE_2__["default"])(_this), "priority", 10);
                    (0, _babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_5__["default"])((0, _babel_runtime_helpers_esm_assertThisInitialized__WEBPACK_IMPORTED_MODULE_2__["default"])(_this), "incompatibleTokens", ['t', 'T', 'X']);
                    return _this;
                }
                (0, _babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_1__["default"])(ISOTimezoneParser, [{
                        key: "parse",
                        value: function parse(dateString, token) {
                            switch (token) {
                                case 'x':
                                    return (0, _utils_js__WEBPACK_IMPORTED_MODULE_6__.parseTimezonePattern)(_constants_js__WEBPACK_IMPORTED_MODULE_7__.timezonePatterns.basicOptionalMinutes, dateString);
                                case 'xx':
                                    return (0, _utils_js__WEBPACK_IMPORTED_MODULE_6__.parseTimezonePattern)(_constants_js__WEBPACK_IMPORTED_MODULE_7__.timezonePatterns.basic, dateString);
                                case 'xxxx':
                                    return (0, _utils_js__WEBPACK_IMPORTED_MODULE_6__.parseTimezonePattern)(_constants_js__WEBPACK_IMPORTED_MODULE_7__.timezonePatterns.basicOptionalSeconds, dateString);
                                case 'xxxxx':
                                    return (0, _utils_js__WEBPACK_IMPORTED_MODULE_6__.parseTimezonePattern)(_constants_js__WEBPACK_IMPORTED_MODULE_7__.timezonePatterns.extendedOptionalSeconds, dateString);
                                case 'xxx':
                                default:
                                    return (0, _utils_js__WEBPACK_IMPORTED_MODULE_6__.parseTimezonePattern)(_constants_js__WEBPACK_IMPORTED_MODULE_7__.timezonePatterns.extended, dateString);
                            }
                        }
                    }, {
                        key: "set",
                        value: function set(date, flags, value) {
                            if (flags.timestampIsSet) {
                                return date;
                            }
                            return new Date(date.getTime() - value);
                        }
                    }]);
                return ISOTimezoneParser;
            }(_Parser_js__WEBPACK_IMPORTED_MODULE_8__.Parser);
            /***/ 
        }),
        /***/ "./node_modules/date-fns/esm/parse/_lib/parsers/ISOTimezoneWithZParser.js": 
        /*!********************************************************************************!*\
          !*** ./node_modules/date-fns/esm/parse/_lib/parsers/ISOTimezoneWithZParser.js ***!
          \********************************************************************************/
        /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony export */ __webpack_require__.d(__webpack_exports__, {
                /* harmony export */ ISOTimezoneWithZParser: () => ( /* binding */ISOTimezoneWithZParser)
                /* harmony export */ 
            });
            /* harmony import */ var _babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/classCallCheck */ "./node_modules/@babel/runtime/helpers/esm/classCallCheck.js");
            /* harmony import */ var _babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/esm/createClass */ "./node_modules/@babel/runtime/helpers/esm/createClass.js");
            /* harmony import */ var _babel_runtime_helpers_esm_assertThisInitialized__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/runtime/helpers/esm/assertThisInitialized */ "./node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js");
            /* harmony import */ var _babel_runtime_helpers_esm_inherits__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @babel/runtime/helpers/esm/inherits */ "./node_modules/@babel/runtime/helpers/esm/inherits.js");
            /* harmony import */ var _babel_runtime_helpers_esm_createSuper__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @babel/runtime/helpers/esm/createSuper */ "./node_modules/@babel/runtime/helpers/esm/createSuper.js");
            /* harmony import */ var _babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @babel/runtime/helpers/esm/defineProperty */ "./node_modules/@babel/runtime/helpers/esm/defineProperty.js");
            /* harmony import */ var _Parser_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../Parser.js */ "./node_modules/date-fns/esm/parse/_lib/Parser.js");
            /* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../constants.js */ "./node_modules/date-fns/esm/parse/_lib/constants.js");
            /* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../utils.js */ "./node_modules/date-fns/esm/parse/_lib/utils.js");
            // Timezone (ISO-8601. +00:00 is `'Z'`)
            var ISOTimezoneWithZParser = /*#__PURE__*/ function (_Parser) {
                (0, _babel_runtime_helpers_esm_inherits__WEBPACK_IMPORTED_MODULE_3__["default"])(ISOTimezoneWithZParser, _Parser);
                var _super = (0, _babel_runtime_helpers_esm_createSuper__WEBPACK_IMPORTED_MODULE_4__["default"])(ISOTimezoneWithZParser);
                function ISOTimezoneWithZParser() {
                    var _this;
                    (0, _babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_0__["default"])(this, ISOTimezoneWithZParser);
                    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                        args[_key] = arguments[_key];
                    }
                    _this = _super.call.apply(_super, [this].concat(args));
                    (0, _babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_5__["default"])((0, _babel_runtime_helpers_esm_assertThisInitialized__WEBPACK_IMPORTED_MODULE_2__["default"])(_this), "priority", 10);
                    (0, _babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_5__["default"])((0, _babel_runtime_helpers_esm_assertThisInitialized__WEBPACK_IMPORTED_MODULE_2__["default"])(_this), "incompatibleTokens", ['t', 'T', 'x']);
                    return _this;
                }
                (0, _babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_1__["default"])(ISOTimezoneWithZParser, [{
                        key: "parse",
                        value: function parse(dateString, token) {
                            switch (token) {
                                case 'X':
                                    return (0, _utils_js__WEBPACK_IMPORTED_MODULE_6__.parseTimezonePattern)(_constants_js__WEBPACK_IMPORTED_MODULE_7__.timezonePatterns.basicOptionalMinutes, dateString);
                                case 'XX':
                                    return (0, _utils_js__WEBPACK_IMPORTED_MODULE_6__.parseTimezonePattern)(_constants_js__WEBPACK_IMPORTED_MODULE_7__.timezonePatterns.basic, dateString);
                                case 'XXXX':
                                    return (0, _utils_js__WEBPACK_IMPORTED_MODULE_6__.parseTimezonePattern)(_constants_js__WEBPACK_IMPORTED_MODULE_7__.timezonePatterns.basicOptionalSeconds, dateString);
                                case 'XXXXX':
                                    return (0, _utils_js__WEBPACK_IMPORTED_MODULE_6__.parseTimezonePattern)(_constants_js__WEBPACK_IMPORTED_MODULE_7__.timezonePatterns.extendedOptionalSeconds, dateString);
                                case 'XXX':
                                default:
                                    return (0, _utils_js__WEBPACK_IMPORTED_MODULE_6__.parseTimezonePattern)(_constants_js__WEBPACK_IMPORTED_MODULE_7__.timezonePatterns.extended, dateString);
                            }
                        }
                    }, {
                        key: "set",
                        value: function set(date, flags, value) {
                            if (flags.timestampIsSet) {
                                return date;
                            }
                            return new Date(date.getTime() - value);
                        }
                    }]);
                return ISOTimezoneWithZParser;
            }(_Parser_js__WEBPACK_IMPORTED_MODULE_8__.Parser);
            /***/ 
        }),
        /***/ "./node_modules/date-fns/esm/parse/_lib/parsers/ISOWeekParser.js": 
        /*!***********************************************************************!*\
          !*** ./node_modules/date-fns/esm/parse/_lib/parsers/ISOWeekParser.js ***!
          \***********************************************************************/
        /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony export */ __webpack_require__.d(__webpack_exports__, {
                /* harmony export */ ISOWeekParser: () => ( /* binding */ISOWeekParser)
                /* harmony export */ 
            });
            /* harmony import */ var _babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/classCallCheck */ "./node_modules/@babel/runtime/helpers/esm/classCallCheck.js");
            /* harmony import */ var _babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/esm/createClass */ "./node_modules/@babel/runtime/helpers/esm/createClass.js");
            /* harmony import */ var _babel_runtime_helpers_esm_assertThisInitialized__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/runtime/helpers/esm/assertThisInitialized */ "./node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js");
            /* harmony import */ var _babel_runtime_helpers_esm_inherits__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @babel/runtime/helpers/esm/inherits */ "./node_modules/@babel/runtime/helpers/esm/inherits.js");
            /* harmony import */ var _babel_runtime_helpers_esm_createSuper__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @babel/runtime/helpers/esm/createSuper */ "./node_modules/@babel/runtime/helpers/esm/createSuper.js");
            /* harmony import */ var _babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @babel/runtime/helpers/esm/defineProperty */ "./node_modules/@babel/runtime/helpers/esm/defineProperty.js");
            /* harmony import */ var _Parser_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../Parser.js */ "./node_modules/date-fns/esm/parse/_lib/Parser.js");
            /* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../constants.js */ "./node_modules/date-fns/esm/parse/_lib/constants.js");
            /* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../utils.js */ "./node_modules/date-fns/esm/parse/_lib/utils.js");
            /* harmony import */ var _lib_setUTCISOWeek_index_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../../../_lib/setUTCISOWeek/index.js */ "./node_modules/date-fns/esm/_lib/setUTCISOWeek/index.js");
            /* harmony import */ var _lib_startOfUTCISOWeek_index_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../../_lib/startOfUTCISOWeek/index.js */ "./node_modules/date-fns/esm/_lib/startOfUTCISOWeek/index.js");
            // ISO week of year
            var ISOWeekParser = /*#__PURE__*/ function (_Parser) {
                (0, _babel_runtime_helpers_esm_inherits__WEBPACK_IMPORTED_MODULE_3__["default"])(ISOWeekParser, _Parser);
                var _super = (0, _babel_runtime_helpers_esm_createSuper__WEBPACK_IMPORTED_MODULE_4__["default"])(ISOWeekParser);
                function ISOWeekParser() {
                    var _this;
                    (0, _babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_0__["default"])(this, ISOWeekParser);
                    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                        args[_key] = arguments[_key];
                    }
                    _this = _super.call.apply(_super, [this].concat(args));
                    (0, _babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_5__["default"])((0, _babel_runtime_helpers_esm_assertThisInitialized__WEBPACK_IMPORTED_MODULE_2__["default"])(_this), "priority", 100);
                    (0, _babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_5__["default"])((0, _babel_runtime_helpers_esm_assertThisInitialized__WEBPACK_IMPORTED_MODULE_2__["default"])(_this), "incompatibleTokens", ['y', 'Y', 'u', 'q', 'Q', 'M', 'L', 'w', 'd', 'D', 'e', 'c', 't', 'T']);
                    return _this;
                }
                (0, _babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_1__["default"])(ISOWeekParser, [{
                        key: "parse",
                        value: function parse(dateString, token, match) {
                            switch (token) {
                                case 'I':
                                    return (0, _utils_js__WEBPACK_IMPORTED_MODULE_6__.parseNumericPattern)(_constants_js__WEBPACK_IMPORTED_MODULE_7__.numericPatterns.week, dateString);
                                case 'Io':
                                    return match.ordinalNumber(dateString, {
                                        unit: 'week'
                                    });
                                default:
                                    return (0, _utils_js__WEBPACK_IMPORTED_MODULE_6__.parseNDigits)(token.length, dateString);
                            }
                        }
                    }, {
                        key: "validate",
                        value: function validate(_date, value) {
                            return value >= 1 && value <= 53;
                        }
                    }, {
                        key: "set",
                        value: function set(date, _flags, value) {
                            return (0, _lib_startOfUTCISOWeek_index_js__WEBPACK_IMPORTED_MODULE_8__["default"])((0, _lib_setUTCISOWeek_index_js__WEBPACK_IMPORTED_MODULE_9__["default"])(date, value));
                        }
                    }]);
                return ISOWeekParser;
            }(_Parser_js__WEBPACK_IMPORTED_MODULE_10__.Parser);
            /***/ 
        }),
        /***/ "./node_modules/date-fns/esm/parse/_lib/parsers/ISOWeekYearParser.js": 
        /*!***************************************************************************!*\
          !*** ./node_modules/date-fns/esm/parse/_lib/parsers/ISOWeekYearParser.js ***!
          \***************************************************************************/
        /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony export */ __webpack_require__.d(__webpack_exports__, {
                /* harmony export */ ISOWeekYearParser: () => ( /* binding */ISOWeekYearParser)
                /* harmony export */ 
            });
            /* harmony import */ var _babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/classCallCheck */ "./node_modules/@babel/runtime/helpers/esm/classCallCheck.js");
            /* harmony import */ var _babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/esm/createClass */ "./node_modules/@babel/runtime/helpers/esm/createClass.js");
            /* harmony import */ var _babel_runtime_helpers_esm_assertThisInitialized__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/runtime/helpers/esm/assertThisInitialized */ "./node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js");
            /* harmony import */ var _babel_runtime_helpers_esm_inherits__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @babel/runtime/helpers/esm/inherits */ "./node_modules/@babel/runtime/helpers/esm/inherits.js");
            /* harmony import */ var _babel_runtime_helpers_esm_createSuper__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @babel/runtime/helpers/esm/createSuper */ "./node_modules/@babel/runtime/helpers/esm/createSuper.js");
            /* harmony import */ var _babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @babel/runtime/helpers/esm/defineProperty */ "./node_modules/@babel/runtime/helpers/esm/defineProperty.js");
            /* harmony import */ var _Parser_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../Parser.js */ "./node_modules/date-fns/esm/parse/_lib/Parser.js");
            /* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../utils.js */ "./node_modules/date-fns/esm/parse/_lib/utils.js");
            /* harmony import */ var _lib_startOfUTCISOWeek_index_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../../_lib/startOfUTCISOWeek/index.js */ "./node_modules/date-fns/esm/_lib/startOfUTCISOWeek/index.js");
            // ISO week-numbering year
            var ISOWeekYearParser = /*#__PURE__*/ function (_Parser) {
                (0, _babel_runtime_helpers_esm_inherits__WEBPACK_IMPORTED_MODULE_3__["default"])(ISOWeekYearParser, _Parser);
                var _super = (0, _babel_runtime_helpers_esm_createSuper__WEBPACK_IMPORTED_MODULE_4__["default"])(ISOWeekYearParser);
                function ISOWeekYearParser() {
                    var _this;
                    (0, _babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_0__["default"])(this, ISOWeekYearParser);
                    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                        args[_key] = arguments[_key];
                    }
                    _this = _super.call.apply(_super, [this].concat(args));
                    (0, _babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_5__["default"])((0, _babel_runtime_helpers_esm_assertThisInitialized__WEBPACK_IMPORTED_MODULE_2__["default"])(_this), "priority", 130);
                    (0, _babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_5__["default"])((0, _babel_runtime_helpers_esm_assertThisInitialized__WEBPACK_IMPORTED_MODULE_2__["default"])(_this), "incompatibleTokens", ['G', 'y', 'Y', 'u', 'Q', 'q', 'M', 'L', 'w', 'd', 'D', 'e', 'c', 't', 'T']);
                    return _this;
                }
                (0, _babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_1__["default"])(ISOWeekYearParser, [{
                        key: "parse",
                        value: function parse(dateString, token) {
                            if (token === 'R') {
                                return (0, _utils_js__WEBPACK_IMPORTED_MODULE_6__.parseNDigitsSigned)(4, dateString);
                            }
                            return (0, _utils_js__WEBPACK_IMPORTED_MODULE_6__.parseNDigitsSigned)(token.length, dateString);
                        }
                    }, {
                        key: "set",
                        value: function set(_date, _flags, value) {
                            var firstWeekOfYear = new Date(0);
                            firstWeekOfYear.setUTCFullYear(value, 0, 4);
                            firstWeekOfYear.setUTCHours(0, 0, 0, 0);
                            return (0, _lib_startOfUTCISOWeek_index_js__WEBPACK_IMPORTED_MODULE_7__["default"])(firstWeekOfYear);
                        }
                    }]);
                return ISOWeekYearParser;
            }(_Parser_js__WEBPACK_IMPORTED_MODULE_8__.Parser);
            /***/ 
        }),
        /***/ "./node_modules/date-fns/esm/parse/_lib/parsers/LocalDayParser.js": 
        /*!************************************************************************!*\
          !*** ./node_modules/date-fns/esm/parse/_lib/parsers/LocalDayParser.js ***!
          \************************************************************************/
        /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony export */ __webpack_require__.d(__webpack_exports__, {
                /* harmony export */ LocalDayParser: () => ( /* binding */LocalDayParser)
                /* harmony export */ 
            });
            /* harmony import */ var _babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/classCallCheck */ "./node_modules/@babel/runtime/helpers/esm/classCallCheck.js");
            /* harmony import */ var _babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/esm/createClass */ "./node_modules/@babel/runtime/helpers/esm/createClass.js");
            /* harmony import */ var _babel_runtime_helpers_esm_assertThisInitialized__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/runtime/helpers/esm/assertThisInitialized */ "./node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js");
            /* harmony import */ var _babel_runtime_helpers_esm_inherits__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @babel/runtime/helpers/esm/inherits */ "./node_modules/@babel/runtime/helpers/esm/inherits.js");
            /* harmony import */ var _babel_runtime_helpers_esm_createSuper__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @babel/runtime/helpers/esm/createSuper */ "./node_modules/@babel/runtime/helpers/esm/createSuper.js");
            /* harmony import */ var _babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @babel/runtime/helpers/esm/defineProperty */ "./node_modules/@babel/runtime/helpers/esm/defineProperty.js");
            /* harmony import */ var _Parser_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../Parser.js */ "./node_modules/date-fns/esm/parse/_lib/Parser.js");
            /* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../utils.js */ "./node_modules/date-fns/esm/parse/_lib/utils.js");
            /* harmony import */ var _lib_setUTCDay_index_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../../_lib/setUTCDay/index.js */ "./node_modules/date-fns/esm/_lib/setUTCDay/index.js");
            // Local day of week
            var LocalDayParser = /*#__PURE__*/ function (_Parser) {
                (0, _babel_runtime_helpers_esm_inherits__WEBPACK_IMPORTED_MODULE_3__["default"])(LocalDayParser, _Parser);
                var _super = (0, _babel_runtime_helpers_esm_createSuper__WEBPACK_IMPORTED_MODULE_4__["default"])(LocalDayParser);
                function LocalDayParser() {
                    var _this;
                    (0, _babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_0__["default"])(this, LocalDayParser);
                    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                        args[_key] = arguments[_key];
                    }
                    _this = _super.call.apply(_super, [this].concat(args));
                    (0, _babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_5__["default"])((0, _babel_runtime_helpers_esm_assertThisInitialized__WEBPACK_IMPORTED_MODULE_2__["default"])(_this), "priority", 90);
                    (0, _babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_5__["default"])((0, _babel_runtime_helpers_esm_assertThisInitialized__WEBPACK_IMPORTED_MODULE_2__["default"])(_this), "incompatibleTokens", ['y', 'R', 'u', 'q', 'Q', 'M', 'L', 'I', 'd', 'D', 'E', 'i', 'c', 't', 'T']);
                    return _this;
                }
                (0, _babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_1__["default"])(LocalDayParser, [{
                        key: "parse",
                        value: function parse(dateString, token, match, options) {
                            var valueCallback = function valueCallback(value) {
                                var wholeWeekDays = Math.floor((value - 1) / 7) * 7;
                                return (value + options.weekStartsOn + 6) % 7 + wholeWeekDays;
                            };
                            switch (token) {
                                // 3
                                case 'e':
                                case 'ee':
                                    // 03
                                    return (0, _utils_js__WEBPACK_IMPORTED_MODULE_6__.mapValue)((0, _utils_js__WEBPACK_IMPORTED_MODULE_6__.parseNDigits)(token.length, dateString), valueCallback);
                                // 3rd
                                case 'eo':
                                    return (0, _utils_js__WEBPACK_IMPORTED_MODULE_6__.mapValue)(match.ordinalNumber(dateString, {
                                        unit: 'day'
                                    }), valueCallback);
                                // Tue
                                case 'eee':
                                    return match.day(dateString, {
                                        width: 'abbreviated',
                                        context: 'formatting'
                                    }) || match.day(dateString, {
                                        width: 'short',
                                        context: 'formatting'
                                    }) || match.day(dateString, {
                                        width: 'narrow',
                                        context: 'formatting'
                                    });
                                // T
                                case 'eeeee':
                                    return match.day(dateString, {
                                        width: 'narrow',
                                        context: 'formatting'
                                    });
                                // Tu
                                case 'eeeeee':
                                    return match.day(dateString, {
                                        width: 'short',
                                        context: 'formatting'
                                    }) || match.day(dateString, {
                                        width: 'narrow',
                                        context: 'formatting'
                                    });
                                // Tuesday
                                case 'eeee':
                                default:
                                    return match.day(dateString, {
                                        width: 'wide',
                                        context: 'formatting'
                                    }) || match.day(dateString, {
                                        width: 'abbreviated',
                                        context: 'formatting'
                                    }) || match.day(dateString, {
                                        width: 'short',
                                        context: 'formatting'
                                    }) || match.day(dateString, {
                                        width: 'narrow',
                                        context: 'formatting'
                                    });
                            }
                        }
                    }, {
                        key: "validate",
                        value: function validate(_date, value) {
                            return value >= 0 && value <= 6;
                        }
                    }, {
                        key: "set",
                        value: function set(date, _flags, value, options) {
                            date = (0, _lib_setUTCDay_index_js__WEBPACK_IMPORTED_MODULE_7__["default"])(date, value, options);
                            date.setUTCHours(0, 0, 0, 0);
                            return date;
                        }
                    }]);
                return LocalDayParser;
            }(_Parser_js__WEBPACK_IMPORTED_MODULE_8__.Parser);
            /***/ 
        }),
        /***/ "./node_modules/date-fns/esm/parse/_lib/parsers/LocalWeekParser.js": 
        /*!*************************************************************************!*\
          !*** ./node_modules/date-fns/esm/parse/_lib/parsers/LocalWeekParser.js ***!
          \*************************************************************************/
        /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony export */ __webpack_require__.d(__webpack_exports__, {
                /* harmony export */ LocalWeekParser: () => ( /* binding */LocalWeekParser)
                /* harmony export */ 
            });
            /* harmony import */ var _babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/classCallCheck */ "./node_modules/@babel/runtime/helpers/esm/classCallCheck.js");
            /* harmony import */ var _babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/esm/createClass */ "./node_modules/@babel/runtime/helpers/esm/createClass.js");
            /* harmony import */ var _babel_runtime_helpers_esm_assertThisInitialized__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/runtime/helpers/esm/assertThisInitialized */ "./node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js");
            /* harmony import */ var _babel_runtime_helpers_esm_inherits__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @babel/runtime/helpers/esm/inherits */ "./node_modules/@babel/runtime/helpers/esm/inherits.js");
            /* harmony import */ var _babel_runtime_helpers_esm_createSuper__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @babel/runtime/helpers/esm/createSuper */ "./node_modules/@babel/runtime/helpers/esm/createSuper.js");
            /* harmony import */ var _babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @babel/runtime/helpers/esm/defineProperty */ "./node_modules/@babel/runtime/helpers/esm/defineProperty.js");
            /* harmony import */ var _Parser_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../Parser.js */ "./node_modules/date-fns/esm/parse/_lib/Parser.js");
            /* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../constants.js */ "./node_modules/date-fns/esm/parse/_lib/constants.js");
            /* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../utils.js */ "./node_modules/date-fns/esm/parse/_lib/utils.js");
            /* harmony import */ var _lib_setUTCWeek_index_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../../../_lib/setUTCWeek/index.js */ "./node_modules/date-fns/esm/_lib/setUTCWeek/index.js");
            /* harmony import */ var _lib_startOfUTCWeek_index_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../../_lib/startOfUTCWeek/index.js */ "./node_modules/date-fns/esm/_lib/startOfUTCWeek/index.js");
            // Local week of year
            var LocalWeekParser = /*#__PURE__*/ function (_Parser) {
                (0, _babel_runtime_helpers_esm_inherits__WEBPACK_IMPORTED_MODULE_3__["default"])(LocalWeekParser, _Parser);
                var _super = (0, _babel_runtime_helpers_esm_createSuper__WEBPACK_IMPORTED_MODULE_4__["default"])(LocalWeekParser);
                function LocalWeekParser() {
                    var _this;
                    (0, _babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_0__["default"])(this, LocalWeekParser);
                    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                        args[_key] = arguments[_key];
                    }
                    _this = _super.call.apply(_super, [this].concat(args));
                    (0, _babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_5__["default"])((0, _babel_runtime_helpers_esm_assertThisInitialized__WEBPACK_IMPORTED_MODULE_2__["default"])(_this), "priority", 100);
                    (0, _babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_5__["default"])((0, _babel_runtime_helpers_esm_assertThisInitialized__WEBPACK_IMPORTED_MODULE_2__["default"])(_this), "incompatibleTokens", ['y', 'R', 'u', 'q', 'Q', 'M', 'L', 'I', 'd', 'D', 'i', 't', 'T']);
                    return _this;
                }
                (0, _babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_1__["default"])(LocalWeekParser, [{
                        key: "parse",
                        value: function parse(dateString, token, match) {
                            switch (token) {
                                case 'w':
                                    return (0, _utils_js__WEBPACK_IMPORTED_MODULE_6__.parseNumericPattern)(_constants_js__WEBPACK_IMPORTED_MODULE_7__.numericPatterns.week, dateString);
                                case 'wo':
                                    return match.ordinalNumber(dateString, {
                                        unit: 'week'
                                    });
                                default:
                                    return (0, _utils_js__WEBPACK_IMPORTED_MODULE_6__.parseNDigits)(token.length, dateString);
                            }
                        }
                    }, {
                        key: "validate",
                        value: function validate(_date, value) {
                            return value >= 1 && value <= 53;
                        }
                    }, {
                        key: "set",
                        value: function set(date, _flags, value, options) {
                            return (0, _lib_startOfUTCWeek_index_js__WEBPACK_IMPORTED_MODULE_8__["default"])((0, _lib_setUTCWeek_index_js__WEBPACK_IMPORTED_MODULE_9__["default"])(date, value, options), options);
                        }
                    }]);
                return LocalWeekParser;
            }(_Parser_js__WEBPACK_IMPORTED_MODULE_10__.Parser);
            /***/ 
        }),
        /***/ "./node_modules/date-fns/esm/parse/_lib/parsers/LocalWeekYearParser.js": 
        /*!*****************************************************************************!*\
          !*** ./node_modules/date-fns/esm/parse/_lib/parsers/LocalWeekYearParser.js ***!
          \*****************************************************************************/
        /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony export */ __webpack_require__.d(__webpack_exports__, {
                /* harmony export */ LocalWeekYearParser: () => ( /* binding */LocalWeekYearParser)
                /* harmony export */ 
            });
            /* harmony import */ var _babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/classCallCheck */ "./node_modules/@babel/runtime/helpers/esm/classCallCheck.js");
            /* harmony import */ var _babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/esm/createClass */ "./node_modules/@babel/runtime/helpers/esm/createClass.js");
            /* harmony import */ var _babel_runtime_helpers_esm_assertThisInitialized__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/runtime/helpers/esm/assertThisInitialized */ "./node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js");
            /* harmony import */ var _babel_runtime_helpers_esm_inherits__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @babel/runtime/helpers/esm/inherits */ "./node_modules/@babel/runtime/helpers/esm/inherits.js");
            /* harmony import */ var _babel_runtime_helpers_esm_createSuper__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @babel/runtime/helpers/esm/createSuper */ "./node_modules/@babel/runtime/helpers/esm/createSuper.js");
            /* harmony import */ var _babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @babel/runtime/helpers/esm/defineProperty */ "./node_modules/@babel/runtime/helpers/esm/defineProperty.js");
            /* harmony import */ var _Parser_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../Parser.js */ "./node_modules/date-fns/esm/parse/_lib/Parser.js");
            /* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../utils.js */ "./node_modules/date-fns/esm/parse/_lib/utils.js");
            /* harmony import */ var _lib_getUTCWeekYear_index_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../../_lib/getUTCWeekYear/index.js */ "./node_modules/date-fns/esm/_lib/getUTCWeekYear/index.js");
            /* harmony import */ var _lib_startOfUTCWeek_index_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../../_lib/startOfUTCWeek/index.js */ "./node_modules/date-fns/esm/_lib/startOfUTCWeek/index.js");
            // Local week-numbering year
            var LocalWeekYearParser = /*#__PURE__*/ function (_Parser) {
                (0, _babel_runtime_helpers_esm_inherits__WEBPACK_IMPORTED_MODULE_3__["default"])(LocalWeekYearParser, _Parser);
                var _super = (0, _babel_runtime_helpers_esm_createSuper__WEBPACK_IMPORTED_MODULE_4__["default"])(LocalWeekYearParser);
                function LocalWeekYearParser() {
                    var _this;
                    (0, _babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_0__["default"])(this, LocalWeekYearParser);
                    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                        args[_key] = arguments[_key];
                    }
                    _this = _super.call.apply(_super, [this].concat(args));
                    (0, _babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_5__["default"])((0, _babel_runtime_helpers_esm_assertThisInitialized__WEBPACK_IMPORTED_MODULE_2__["default"])(_this), "priority", 130);
                    (0, _babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_5__["default"])((0, _babel_runtime_helpers_esm_assertThisInitialized__WEBPACK_IMPORTED_MODULE_2__["default"])(_this), "incompatibleTokens", ['y', 'R', 'u', 'Q', 'q', 'M', 'L', 'I', 'd', 'D', 'i', 't', 'T']);
                    return _this;
                }
                (0, _babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_1__["default"])(LocalWeekYearParser, [{
                        key: "parse",
                        value: function parse(dateString, token, match) {
                            var valueCallback = function valueCallback(year) {
                                return {
                                    year: year,
                                    isTwoDigitYear: token === 'YY'
                                };
                            };
                            switch (token) {
                                case 'Y':
                                    return (0, _utils_js__WEBPACK_IMPORTED_MODULE_6__.mapValue)((0, _utils_js__WEBPACK_IMPORTED_MODULE_6__.parseNDigits)(4, dateString), valueCallback);
                                case 'Yo':
                                    return (0, _utils_js__WEBPACK_IMPORTED_MODULE_6__.mapValue)(match.ordinalNumber(dateString, {
                                        unit: 'year'
                                    }), valueCallback);
                                default:
                                    return (0, _utils_js__WEBPACK_IMPORTED_MODULE_6__.mapValue)((0, _utils_js__WEBPACK_IMPORTED_MODULE_6__.parseNDigits)(token.length, dateString), valueCallback);
                            }
                        }
                    }, {
                        key: "validate",
                        value: function validate(_date, value) {
                            return value.isTwoDigitYear || value.year > 0;
                        }
                    }, {
                        key: "set",
                        value: function set(date, flags, value, options) {
                            var currentYear = (0, _lib_getUTCWeekYear_index_js__WEBPACK_IMPORTED_MODULE_7__["default"])(date, options);
                            if (value.isTwoDigitYear) {
                                var normalizedTwoDigitYear = (0, _utils_js__WEBPACK_IMPORTED_MODULE_6__.normalizeTwoDigitYear)(value.year, currentYear);
                                date.setUTCFullYear(normalizedTwoDigitYear, 0, options.firstWeekContainsDate);
                                date.setUTCHours(0, 0, 0, 0);
                                return (0, _lib_startOfUTCWeek_index_js__WEBPACK_IMPORTED_MODULE_8__["default"])(date, options);
                            }
                            var year = !('era' in flags) || flags.era === 1 ? value.year : 1 - value.year;
                            date.setUTCFullYear(year, 0, options.firstWeekContainsDate);
                            date.setUTCHours(0, 0, 0, 0);
                            return (0, _lib_startOfUTCWeek_index_js__WEBPACK_IMPORTED_MODULE_8__["default"])(date, options);
                        }
                    }]);
                return LocalWeekYearParser;
            }(_Parser_js__WEBPACK_IMPORTED_MODULE_9__.Parser);
            /***/ 
        }),
        /***/ "./node_modules/date-fns/esm/parse/_lib/parsers/MinuteParser.js": 
        /*!**********************************************************************!*\
          !*** ./node_modules/date-fns/esm/parse/_lib/parsers/MinuteParser.js ***!
          \**********************************************************************/
        /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony export */ __webpack_require__.d(__webpack_exports__, {
                /* harmony export */ MinuteParser: () => ( /* binding */MinuteParser)
                /* harmony export */ 
            });
            /* harmony import */ var _babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/classCallCheck */ "./node_modules/@babel/runtime/helpers/esm/classCallCheck.js");
            /* harmony import */ var _babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/esm/createClass */ "./node_modules/@babel/runtime/helpers/esm/createClass.js");
            /* harmony import */ var _babel_runtime_helpers_esm_assertThisInitialized__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/runtime/helpers/esm/assertThisInitialized */ "./node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js");
            /* harmony import */ var _babel_runtime_helpers_esm_inherits__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @babel/runtime/helpers/esm/inherits */ "./node_modules/@babel/runtime/helpers/esm/inherits.js");
            /* harmony import */ var _babel_runtime_helpers_esm_createSuper__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @babel/runtime/helpers/esm/createSuper */ "./node_modules/@babel/runtime/helpers/esm/createSuper.js");
            /* harmony import */ var _babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @babel/runtime/helpers/esm/defineProperty */ "./node_modules/@babel/runtime/helpers/esm/defineProperty.js");
            /* harmony import */ var _Parser_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../Parser.js */ "./node_modules/date-fns/esm/parse/_lib/Parser.js");
            /* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../constants.js */ "./node_modules/date-fns/esm/parse/_lib/constants.js");
            /* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../utils.js */ "./node_modules/date-fns/esm/parse/_lib/utils.js");
            var MinuteParser = /*#__PURE__*/ function (_Parser) {
                (0, _babel_runtime_helpers_esm_inherits__WEBPACK_IMPORTED_MODULE_3__["default"])(MinuteParser, _Parser);
                var _super = (0, _babel_runtime_helpers_esm_createSuper__WEBPACK_IMPORTED_MODULE_4__["default"])(MinuteParser);
                function MinuteParser() {
                    var _this;
                    (0, _babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_0__["default"])(this, MinuteParser);
                    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                        args[_key] = arguments[_key];
                    }
                    _this = _super.call.apply(_super, [this].concat(args));
                    (0, _babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_5__["default"])((0, _babel_runtime_helpers_esm_assertThisInitialized__WEBPACK_IMPORTED_MODULE_2__["default"])(_this), "priority", 60);
                    (0, _babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_5__["default"])((0, _babel_runtime_helpers_esm_assertThisInitialized__WEBPACK_IMPORTED_MODULE_2__["default"])(_this), "incompatibleTokens", ['t', 'T']);
                    return _this;
                }
                (0, _babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_1__["default"])(MinuteParser, [{
                        key: "parse",
                        value: function parse(dateString, token, match) {
                            switch (token) {
                                case 'm':
                                    return (0, _utils_js__WEBPACK_IMPORTED_MODULE_6__.parseNumericPattern)(_constants_js__WEBPACK_IMPORTED_MODULE_7__.numericPatterns.minute, dateString);
                                case 'mo':
                                    return match.ordinalNumber(dateString, {
                                        unit: 'minute'
                                    });
                                default:
                                    return (0, _utils_js__WEBPACK_IMPORTED_MODULE_6__.parseNDigits)(token.length, dateString);
                            }
                        }
                    }, {
                        key: "validate",
                        value: function validate(_date, value) {
                            return value >= 0 && value <= 59;
                        }
                    }, {
                        key: "set",
                        value: function set(date, _flags, value) {
                            date.setUTCMinutes(value, 0, 0);
                            return date;
                        }
                    }]);
                return MinuteParser;
            }(_Parser_js__WEBPACK_IMPORTED_MODULE_8__.Parser);
            /***/ 
        }),
        /***/ "./node_modules/date-fns/esm/parse/_lib/parsers/MonthParser.js": 
        /*!*********************************************************************!*\
          !*** ./node_modules/date-fns/esm/parse/_lib/parsers/MonthParser.js ***!
          \*********************************************************************/
        /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony export */ __webpack_require__.d(__webpack_exports__, {
                /* harmony export */ MonthParser: () => ( /* binding */MonthParser)
                /* harmony export */ 
            });
            /* harmony import */ var _babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/classCallCheck */ "./node_modules/@babel/runtime/helpers/esm/classCallCheck.js");
            /* harmony import */ var _babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/esm/createClass */ "./node_modules/@babel/runtime/helpers/esm/createClass.js");
            /* harmony import */ var _babel_runtime_helpers_esm_assertThisInitialized__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/runtime/helpers/esm/assertThisInitialized */ "./node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js");
            /* harmony import */ var _babel_runtime_helpers_esm_inherits__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @babel/runtime/helpers/esm/inherits */ "./node_modules/@babel/runtime/helpers/esm/inherits.js");
            /* harmony import */ var _babel_runtime_helpers_esm_createSuper__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @babel/runtime/helpers/esm/createSuper */ "./node_modules/@babel/runtime/helpers/esm/createSuper.js");
            /* harmony import */ var _babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @babel/runtime/helpers/esm/defineProperty */ "./node_modules/@babel/runtime/helpers/esm/defineProperty.js");
            /* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../utils.js */ "./node_modules/date-fns/esm/parse/_lib/utils.js");
            /* harmony import */ var _Parser_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../Parser.js */ "./node_modules/date-fns/esm/parse/_lib/Parser.js");
            /* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../constants.js */ "./node_modules/date-fns/esm/parse/_lib/constants.js");
            var MonthParser = /*#__PURE__*/ function (_Parser) {
                (0, _babel_runtime_helpers_esm_inherits__WEBPACK_IMPORTED_MODULE_3__["default"])(MonthParser, _Parser);
                var _super = (0, _babel_runtime_helpers_esm_createSuper__WEBPACK_IMPORTED_MODULE_4__["default"])(MonthParser);
                function MonthParser() {
                    var _this;
                    (0, _babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_0__["default"])(this, MonthParser);
                    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                        args[_key] = arguments[_key];
                    }
                    _this = _super.call.apply(_super, [this].concat(args));
                    (0, _babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_5__["default"])((0, _babel_runtime_helpers_esm_assertThisInitialized__WEBPACK_IMPORTED_MODULE_2__["default"])(_this), "incompatibleTokens", ['Y', 'R', 'q', 'Q', 'L', 'w', 'I', 'D', 'i', 'e', 'c', 't', 'T']);
                    (0, _babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_5__["default"])((0, _babel_runtime_helpers_esm_assertThisInitialized__WEBPACK_IMPORTED_MODULE_2__["default"])(_this), "priority", 110);
                    return _this;
                }
                (0, _babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_1__["default"])(MonthParser, [{
                        key: "parse",
                        value: function parse(dateString, token, match) {
                            var valueCallback = function valueCallback(value) {
                                return value - 1;
                            };
                            switch (token) {
                                // 1, 2, ..., 12
                                case 'M':
                                    return (0, _utils_js__WEBPACK_IMPORTED_MODULE_6__.mapValue)((0, _utils_js__WEBPACK_IMPORTED_MODULE_6__.parseNumericPattern)(_constants_js__WEBPACK_IMPORTED_MODULE_7__.numericPatterns.month, dateString), valueCallback);
                                // 01, 02, ..., 12
                                case 'MM':
                                    return (0, _utils_js__WEBPACK_IMPORTED_MODULE_6__.mapValue)((0, _utils_js__WEBPACK_IMPORTED_MODULE_6__.parseNDigits)(2, dateString), valueCallback);
                                // 1st, 2nd, ..., 12th
                                case 'Mo':
                                    return (0, _utils_js__WEBPACK_IMPORTED_MODULE_6__.mapValue)(match.ordinalNumber(dateString, {
                                        unit: 'month'
                                    }), valueCallback);
                                // Jan, Feb, ..., Dec
                                case 'MMM':
                                    return match.month(dateString, {
                                        width: 'abbreviated',
                                        context: 'formatting'
                                    }) || match.month(dateString, {
                                        width: 'narrow',
                                        context: 'formatting'
                                    });
                                // J, F, ..., D
                                case 'MMMMM':
                                    return match.month(dateString, {
                                        width: 'narrow',
                                        context: 'formatting'
                                    });
                                // January, February, ..., December
                                case 'MMMM':
                                default:
                                    return match.month(dateString, {
                                        width: 'wide',
                                        context: 'formatting'
                                    }) || match.month(dateString, {
                                        width: 'abbreviated',
                                        context: 'formatting'
                                    }) || match.month(dateString, {
                                        width: 'narrow',
                                        context: 'formatting'
                                    });
                            }
                        }
                    }, {
                        key: "validate",
                        value: function validate(_date, value) {
                            return value >= 0 && value <= 11;
                        }
                    }, {
                        key: "set",
                        value: function set(date, _flags, value) {
                            date.setUTCMonth(value, 1);
                            date.setUTCHours(0, 0, 0, 0);
                            return date;
                        }
                    }]);
                return MonthParser;
            }(_Parser_js__WEBPACK_IMPORTED_MODULE_8__.Parser);
            /***/ 
        }),
        /***/ "./node_modules/date-fns/esm/parse/_lib/parsers/QuarterParser.js": 
        /*!***********************************************************************!*\
          !*** ./node_modules/date-fns/esm/parse/_lib/parsers/QuarterParser.js ***!
          \***********************************************************************/
        /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony export */ __webpack_require__.d(__webpack_exports__, {
                /* harmony export */ QuarterParser: () => ( /* binding */QuarterParser)
                /* harmony export */ 
            });
            /* harmony import */ var _babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/classCallCheck */ "./node_modules/@babel/runtime/helpers/esm/classCallCheck.js");
            /* harmony import */ var _babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/esm/createClass */ "./node_modules/@babel/runtime/helpers/esm/createClass.js");
            /* harmony import */ var _babel_runtime_helpers_esm_assertThisInitialized__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/runtime/helpers/esm/assertThisInitialized */ "./node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js");
            /* harmony import */ var _babel_runtime_helpers_esm_inherits__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @babel/runtime/helpers/esm/inherits */ "./node_modules/@babel/runtime/helpers/esm/inherits.js");
            /* harmony import */ var _babel_runtime_helpers_esm_createSuper__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @babel/runtime/helpers/esm/createSuper */ "./node_modules/@babel/runtime/helpers/esm/createSuper.js");
            /* harmony import */ var _babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @babel/runtime/helpers/esm/defineProperty */ "./node_modules/@babel/runtime/helpers/esm/defineProperty.js");
            /* harmony import */ var _Parser_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../Parser.js */ "./node_modules/date-fns/esm/parse/_lib/Parser.js");
            /* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../utils.js */ "./node_modules/date-fns/esm/parse/_lib/utils.js");
            var QuarterParser = /*#__PURE__*/ function (_Parser) {
                (0, _babel_runtime_helpers_esm_inherits__WEBPACK_IMPORTED_MODULE_3__["default"])(QuarterParser, _Parser);
                var _super = (0, _babel_runtime_helpers_esm_createSuper__WEBPACK_IMPORTED_MODULE_4__["default"])(QuarterParser);
                function QuarterParser() {
                    var _this;
                    (0, _babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_0__["default"])(this, QuarterParser);
                    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                        args[_key] = arguments[_key];
                    }
                    _this = _super.call.apply(_super, [this].concat(args));
                    (0, _babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_5__["default"])((0, _babel_runtime_helpers_esm_assertThisInitialized__WEBPACK_IMPORTED_MODULE_2__["default"])(_this), "priority", 120);
                    (0, _babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_5__["default"])((0, _babel_runtime_helpers_esm_assertThisInitialized__WEBPACK_IMPORTED_MODULE_2__["default"])(_this), "incompatibleTokens", ['Y', 'R', 'q', 'M', 'L', 'w', 'I', 'd', 'D', 'i', 'e', 'c', 't', 'T']);
                    return _this;
                }
                (0, _babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_1__["default"])(QuarterParser, [{
                        key: "parse",
                        value: function parse(dateString, token, match) {
                            switch (token) {
                                // 1, 2, 3, 4
                                case 'Q':
                                case 'QQ':
                                    // 01, 02, 03, 04
                                    return (0, _utils_js__WEBPACK_IMPORTED_MODULE_6__.parseNDigits)(token.length, dateString);
                                // 1st, 2nd, 3rd, 4th
                                case 'Qo':
                                    return match.ordinalNumber(dateString, {
                                        unit: 'quarter'
                                    });
                                // Q1, Q2, Q3, Q4
                                case 'QQQ':
                                    return match.quarter(dateString, {
                                        width: 'abbreviated',
                                        context: 'formatting'
                                    }) || match.quarter(dateString, {
                                        width: 'narrow',
                                        context: 'formatting'
                                    });
                                // 1, 2, 3, 4 (narrow quarter; could be not numerical)
                                case 'QQQQQ':
                                    return match.quarter(dateString, {
                                        width: 'narrow',
                                        context: 'formatting'
                                    });
                                // 1st quarter, 2nd quarter, ...
                                case 'QQQQ':
                                default:
                                    return match.quarter(dateString, {
                                        width: 'wide',
                                        context: 'formatting'
                                    }) || match.quarter(dateString, {
                                        width: 'abbreviated',
                                        context: 'formatting'
                                    }) || match.quarter(dateString, {
                                        width: 'narrow',
                                        context: 'formatting'
                                    });
                            }
                        }
                    }, {
                        key: "validate",
                        value: function validate(_date, value) {
                            return value >= 1 && value <= 4;
                        }
                    }, {
                        key: "set",
                        value: function set(date, _flags, value) {
                            date.setUTCMonth((value - 1) * 3, 1);
                            date.setUTCHours(0, 0, 0, 0);
                            return date;
                        }
                    }]);
                return QuarterParser;
            }(_Parser_js__WEBPACK_IMPORTED_MODULE_7__.Parser);
            /***/ 
        }),
        /***/ "./node_modules/date-fns/esm/parse/_lib/parsers/SecondParser.js": 
        /*!**********************************************************************!*\
          !*** ./node_modules/date-fns/esm/parse/_lib/parsers/SecondParser.js ***!
          \**********************************************************************/
        /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony export */ __webpack_require__.d(__webpack_exports__, {
                /* harmony export */ SecondParser: () => ( /* binding */SecondParser)
                /* harmony export */ 
            });
            /* harmony import */ var _babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/classCallCheck */ "./node_modules/@babel/runtime/helpers/esm/classCallCheck.js");
            /* harmony import */ var _babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/esm/createClass */ "./node_modules/@babel/runtime/helpers/esm/createClass.js");
            /* harmony import */ var _babel_runtime_helpers_esm_assertThisInitialized__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/runtime/helpers/esm/assertThisInitialized */ "./node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js");
            /* harmony import */ var _babel_runtime_helpers_esm_inherits__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @babel/runtime/helpers/esm/inherits */ "./node_modules/@babel/runtime/helpers/esm/inherits.js");
            /* harmony import */ var _babel_runtime_helpers_esm_createSuper__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @babel/runtime/helpers/esm/createSuper */ "./node_modules/@babel/runtime/helpers/esm/createSuper.js");
            /* harmony import */ var _babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @babel/runtime/helpers/esm/defineProperty */ "./node_modules/@babel/runtime/helpers/esm/defineProperty.js");
            /* harmony import */ var _Parser_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../Parser.js */ "./node_modules/date-fns/esm/parse/_lib/Parser.js");
            /* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../constants.js */ "./node_modules/date-fns/esm/parse/_lib/constants.js");
            /* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../utils.js */ "./node_modules/date-fns/esm/parse/_lib/utils.js");
            var SecondParser = /*#__PURE__*/ function (_Parser) {
                (0, _babel_runtime_helpers_esm_inherits__WEBPACK_IMPORTED_MODULE_3__["default"])(SecondParser, _Parser);
                var _super = (0, _babel_runtime_helpers_esm_createSuper__WEBPACK_IMPORTED_MODULE_4__["default"])(SecondParser);
                function SecondParser() {
                    var _this;
                    (0, _babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_0__["default"])(this, SecondParser);
                    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                        args[_key] = arguments[_key];
                    }
                    _this = _super.call.apply(_super, [this].concat(args));
                    (0, _babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_5__["default"])((0, _babel_runtime_helpers_esm_assertThisInitialized__WEBPACK_IMPORTED_MODULE_2__["default"])(_this), "priority", 50);
                    (0, _babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_5__["default"])((0, _babel_runtime_helpers_esm_assertThisInitialized__WEBPACK_IMPORTED_MODULE_2__["default"])(_this), "incompatibleTokens", ['t', 'T']);
                    return _this;
                }
                (0, _babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_1__["default"])(SecondParser, [{
                        key: "parse",
                        value: function parse(dateString, token, match) {
                            switch (token) {
                                case 's':
                                    return (0, _utils_js__WEBPACK_IMPORTED_MODULE_6__.parseNumericPattern)(_constants_js__WEBPACK_IMPORTED_MODULE_7__.numericPatterns.second, dateString);
                                case 'so':
                                    return match.ordinalNumber(dateString, {
                                        unit: 'second'
                                    });
                                default:
                                    return (0, _utils_js__WEBPACK_IMPORTED_MODULE_6__.parseNDigits)(token.length, dateString);
                            }
                        }
                    }, {
                        key: "validate",
                        value: function validate(_date, value) {
                            return value >= 0 && value <= 59;
                        }
                    }, {
                        key: "set",
                        value: function set(date, _flags, value) {
                            date.setUTCSeconds(value, 0);
                            return date;
                        }
                    }]);
                return SecondParser;
            }(_Parser_js__WEBPACK_IMPORTED_MODULE_8__.Parser);
            /***/ 
        }),
        /***/ "./node_modules/date-fns/esm/parse/_lib/parsers/StandAloneLocalDayParser.js": 
        /*!**********************************************************************************!*\
          !*** ./node_modules/date-fns/esm/parse/_lib/parsers/StandAloneLocalDayParser.js ***!
          \**********************************************************************************/
        /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony export */ __webpack_require__.d(__webpack_exports__, {
                /* harmony export */ StandAloneLocalDayParser: () => ( /* binding */StandAloneLocalDayParser)
                /* harmony export */ 
            });
            /* harmony import */ var _babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/classCallCheck */ "./node_modules/@babel/runtime/helpers/esm/classCallCheck.js");
            /* harmony import */ var _babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/esm/createClass */ "./node_modules/@babel/runtime/helpers/esm/createClass.js");
            /* harmony import */ var _babel_runtime_helpers_esm_assertThisInitialized__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/runtime/helpers/esm/assertThisInitialized */ "./node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js");
            /* harmony import */ var _babel_runtime_helpers_esm_inherits__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @babel/runtime/helpers/esm/inherits */ "./node_modules/@babel/runtime/helpers/esm/inherits.js");
            /* harmony import */ var _babel_runtime_helpers_esm_createSuper__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @babel/runtime/helpers/esm/createSuper */ "./node_modules/@babel/runtime/helpers/esm/createSuper.js");
            /* harmony import */ var _babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @babel/runtime/helpers/esm/defineProperty */ "./node_modules/@babel/runtime/helpers/esm/defineProperty.js");
            /* harmony import */ var _Parser_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../Parser.js */ "./node_modules/date-fns/esm/parse/_lib/Parser.js");
            /* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../utils.js */ "./node_modules/date-fns/esm/parse/_lib/utils.js");
            /* harmony import */ var _lib_setUTCDay_index_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../../_lib/setUTCDay/index.js */ "./node_modules/date-fns/esm/_lib/setUTCDay/index.js");
            // Stand-alone local day of week
            var StandAloneLocalDayParser = /*#__PURE__*/ function (_Parser) {
                (0, _babel_runtime_helpers_esm_inherits__WEBPACK_IMPORTED_MODULE_3__["default"])(StandAloneLocalDayParser, _Parser);
                var _super = (0, _babel_runtime_helpers_esm_createSuper__WEBPACK_IMPORTED_MODULE_4__["default"])(StandAloneLocalDayParser);
                function StandAloneLocalDayParser() {
                    var _this;
                    (0, _babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_0__["default"])(this, StandAloneLocalDayParser);
                    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                        args[_key] = arguments[_key];
                    }
                    _this = _super.call.apply(_super, [this].concat(args));
                    (0, _babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_5__["default"])((0, _babel_runtime_helpers_esm_assertThisInitialized__WEBPACK_IMPORTED_MODULE_2__["default"])(_this), "priority", 90);
                    (0, _babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_5__["default"])((0, _babel_runtime_helpers_esm_assertThisInitialized__WEBPACK_IMPORTED_MODULE_2__["default"])(_this), "incompatibleTokens", ['y', 'R', 'u', 'q', 'Q', 'M', 'L', 'I', 'd', 'D', 'E', 'i', 'e', 't', 'T']);
                    return _this;
                }
                (0, _babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_1__["default"])(StandAloneLocalDayParser, [{
                        key: "parse",
                        value: function parse(dateString, token, match, options) {
                            var valueCallback = function valueCallback(value) {
                                var wholeWeekDays = Math.floor((value - 1) / 7) * 7;
                                return (value + options.weekStartsOn + 6) % 7 + wholeWeekDays;
                            };
                            switch (token) {
                                // 3
                                case 'c':
                                case 'cc':
                                    // 03
                                    return (0, _utils_js__WEBPACK_IMPORTED_MODULE_6__.mapValue)((0, _utils_js__WEBPACK_IMPORTED_MODULE_6__.parseNDigits)(token.length, dateString), valueCallback);
                                // 3rd
                                case 'co':
                                    return (0, _utils_js__WEBPACK_IMPORTED_MODULE_6__.mapValue)(match.ordinalNumber(dateString, {
                                        unit: 'day'
                                    }), valueCallback);
                                // Tue
                                case 'ccc':
                                    return match.day(dateString, {
                                        width: 'abbreviated',
                                        context: 'standalone'
                                    }) || match.day(dateString, {
                                        width: 'short',
                                        context: 'standalone'
                                    }) || match.day(dateString, {
                                        width: 'narrow',
                                        context: 'standalone'
                                    });
                                // T
                                case 'ccccc':
                                    return match.day(dateString, {
                                        width: 'narrow',
                                        context: 'standalone'
                                    });
                                // Tu
                                case 'cccccc':
                                    return match.day(dateString, {
                                        width: 'short',
                                        context: 'standalone'
                                    }) || match.day(dateString, {
                                        width: 'narrow',
                                        context: 'standalone'
                                    });
                                // Tuesday
                                case 'cccc':
                                default:
                                    return match.day(dateString, {
                                        width: 'wide',
                                        context: 'standalone'
                                    }) || match.day(dateString, {
                                        width: 'abbreviated',
                                        context: 'standalone'
                                    }) || match.day(dateString, {
                                        width: 'short',
                                        context: 'standalone'
                                    }) || match.day(dateString, {
                                        width: 'narrow',
                                        context: 'standalone'
                                    });
                            }
                        }
                    }, {
                        key: "validate",
                        value: function validate(_date, value) {
                            return value >= 0 && value <= 6;
                        }
                    }, {
                        key: "set",
                        value: function set(date, _flags, value, options) {
                            date = (0, _lib_setUTCDay_index_js__WEBPACK_IMPORTED_MODULE_7__["default"])(date, value, options);
                            date.setUTCHours(0, 0, 0, 0);
                            return date;
                        }
                    }]);
                return StandAloneLocalDayParser;
            }(_Parser_js__WEBPACK_IMPORTED_MODULE_8__.Parser);
            /***/ 
        }),
        /***/ "./node_modules/date-fns/esm/parse/_lib/parsers/StandAloneMonthParser.js": 
        /*!*******************************************************************************!*\
          !*** ./node_modules/date-fns/esm/parse/_lib/parsers/StandAloneMonthParser.js ***!
          \*******************************************************************************/
        /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony export */ __webpack_require__.d(__webpack_exports__, {
                /* harmony export */ StandAloneMonthParser: () => ( /* binding */StandAloneMonthParser)
                /* harmony export */ 
            });
            /* harmony import */ var _babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/classCallCheck */ "./node_modules/@babel/runtime/helpers/esm/classCallCheck.js");
            /* harmony import */ var _babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/esm/createClass */ "./node_modules/@babel/runtime/helpers/esm/createClass.js");
            /* harmony import */ var _babel_runtime_helpers_esm_assertThisInitialized__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/runtime/helpers/esm/assertThisInitialized */ "./node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js");
            /* harmony import */ var _babel_runtime_helpers_esm_inherits__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @babel/runtime/helpers/esm/inherits */ "./node_modules/@babel/runtime/helpers/esm/inherits.js");
            /* harmony import */ var _babel_runtime_helpers_esm_createSuper__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @babel/runtime/helpers/esm/createSuper */ "./node_modules/@babel/runtime/helpers/esm/createSuper.js");
            /* harmony import */ var _babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @babel/runtime/helpers/esm/defineProperty */ "./node_modules/@babel/runtime/helpers/esm/defineProperty.js");
            /* harmony import */ var _Parser_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../Parser.js */ "./node_modules/date-fns/esm/parse/_lib/Parser.js");
            /* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../constants.js */ "./node_modules/date-fns/esm/parse/_lib/constants.js");
            /* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../utils.js */ "./node_modules/date-fns/esm/parse/_lib/utils.js");
            var StandAloneMonthParser = /*#__PURE__*/ function (_Parser) {
                (0, _babel_runtime_helpers_esm_inherits__WEBPACK_IMPORTED_MODULE_3__["default"])(StandAloneMonthParser, _Parser);
                var _super = (0, _babel_runtime_helpers_esm_createSuper__WEBPACK_IMPORTED_MODULE_4__["default"])(StandAloneMonthParser);
                function StandAloneMonthParser() {
                    var _this;
                    (0, _babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_0__["default"])(this, StandAloneMonthParser);
                    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                        args[_key] = arguments[_key];
                    }
                    _this = _super.call.apply(_super, [this].concat(args));
                    (0, _babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_5__["default"])((0, _babel_runtime_helpers_esm_assertThisInitialized__WEBPACK_IMPORTED_MODULE_2__["default"])(_this), "priority", 110);
                    (0, _babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_5__["default"])((0, _babel_runtime_helpers_esm_assertThisInitialized__WEBPACK_IMPORTED_MODULE_2__["default"])(_this), "incompatibleTokens", ['Y', 'R', 'q', 'Q', 'M', 'w', 'I', 'D', 'i', 'e', 'c', 't', 'T']);
                    return _this;
                }
                (0, _babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_1__["default"])(StandAloneMonthParser, [{
                        key: "parse",
                        value: function parse(dateString, token, match) {
                            var valueCallback = function valueCallback(value) {
                                return value - 1;
                            };
                            switch (token) {
                                // 1, 2, ..., 12
                                case 'L':
                                    return (0, _utils_js__WEBPACK_IMPORTED_MODULE_6__.mapValue)((0, _utils_js__WEBPACK_IMPORTED_MODULE_6__.parseNumericPattern)(_constants_js__WEBPACK_IMPORTED_MODULE_7__.numericPatterns.month, dateString), valueCallback);
                                // 01, 02, ..., 12
                                case 'LL':
                                    return (0, _utils_js__WEBPACK_IMPORTED_MODULE_6__.mapValue)((0, _utils_js__WEBPACK_IMPORTED_MODULE_6__.parseNDigits)(2, dateString), valueCallback);
                                // 1st, 2nd, ..., 12th
                                case 'Lo':
                                    return (0, _utils_js__WEBPACK_IMPORTED_MODULE_6__.mapValue)(match.ordinalNumber(dateString, {
                                        unit: 'month'
                                    }), valueCallback);
                                // Jan, Feb, ..., Dec
                                case 'LLL':
                                    return match.month(dateString, {
                                        width: 'abbreviated',
                                        context: 'standalone'
                                    }) || match.month(dateString, {
                                        width: 'narrow',
                                        context: 'standalone'
                                    });
                                // J, F, ..., D
                                case 'LLLLL':
                                    return match.month(dateString, {
                                        width: 'narrow',
                                        context: 'standalone'
                                    });
                                // January, February, ..., December
                                case 'LLLL':
                                default:
                                    return match.month(dateString, {
                                        width: 'wide',
                                        context: 'standalone'
                                    }) || match.month(dateString, {
                                        width: 'abbreviated',
                                        context: 'standalone'
                                    }) || match.month(dateString, {
                                        width: 'narrow',
                                        context: 'standalone'
                                    });
                            }
                        }
                    }, {
                        key: "validate",
                        value: function validate(_date, value) {
                            return value >= 0 && value <= 11;
                        }
                    }, {
                        key: "set",
                        value: function set(date, _flags, value) {
                            date.setUTCMonth(value, 1);
                            date.setUTCHours(0, 0, 0, 0);
                            return date;
                        }
                    }]);
                return StandAloneMonthParser;
            }(_Parser_js__WEBPACK_IMPORTED_MODULE_8__.Parser);
            /***/ 
        }),
        /***/ "./node_modules/date-fns/esm/parse/_lib/parsers/StandAloneQuarterParser.js": 
        /*!*********************************************************************************!*\
          !*** ./node_modules/date-fns/esm/parse/_lib/parsers/StandAloneQuarterParser.js ***!
          \*********************************************************************************/
        /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony export */ __webpack_require__.d(__webpack_exports__, {
                /* harmony export */ StandAloneQuarterParser: () => ( /* binding */StandAloneQuarterParser)
                /* harmony export */ 
            });
            /* harmony import */ var _babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/classCallCheck */ "./node_modules/@babel/runtime/helpers/esm/classCallCheck.js");
            /* harmony import */ var _babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/esm/createClass */ "./node_modules/@babel/runtime/helpers/esm/createClass.js");
            /* harmony import */ var _babel_runtime_helpers_esm_assertThisInitialized__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/runtime/helpers/esm/assertThisInitialized */ "./node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js");
            /* harmony import */ var _babel_runtime_helpers_esm_inherits__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @babel/runtime/helpers/esm/inherits */ "./node_modules/@babel/runtime/helpers/esm/inherits.js");
            /* harmony import */ var _babel_runtime_helpers_esm_createSuper__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @babel/runtime/helpers/esm/createSuper */ "./node_modules/@babel/runtime/helpers/esm/createSuper.js");
            /* harmony import */ var _babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @babel/runtime/helpers/esm/defineProperty */ "./node_modules/@babel/runtime/helpers/esm/defineProperty.js");
            /* harmony import */ var _Parser_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../Parser.js */ "./node_modules/date-fns/esm/parse/_lib/Parser.js");
            /* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../utils.js */ "./node_modules/date-fns/esm/parse/_lib/utils.js");
            var StandAloneQuarterParser = /*#__PURE__*/ function (_Parser) {
                (0, _babel_runtime_helpers_esm_inherits__WEBPACK_IMPORTED_MODULE_3__["default"])(StandAloneQuarterParser, _Parser);
                var _super = (0, _babel_runtime_helpers_esm_createSuper__WEBPACK_IMPORTED_MODULE_4__["default"])(StandAloneQuarterParser);
                function StandAloneQuarterParser() {
                    var _this;
                    (0, _babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_0__["default"])(this, StandAloneQuarterParser);
                    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                        args[_key] = arguments[_key];
                    }
                    _this = _super.call.apply(_super, [this].concat(args));
                    (0, _babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_5__["default"])((0, _babel_runtime_helpers_esm_assertThisInitialized__WEBPACK_IMPORTED_MODULE_2__["default"])(_this), "priority", 120);
                    (0, _babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_5__["default"])((0, _babel_runtime_helpers_esm_assertThisInitialized__WEBPACK_IMPORTED_MODULE_2__["default"])(_this), "incompatibleTokens", ['Y', 'R', 'Q', 'M', 'L', 'w', 'I', 'd', 'D', 'i', 'e', 'c', 't', 'T']);
                    return _this;
                }
                (0, _babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_1__["default"])(StandAloneQuarterParser, [{
                        key: "parse",
                        value: function parse(dateString, token, match) {
                            switch (token) {
                                // 1, 2, 3, 4
                                case 'q':
                                case 'qq':
                                    // 01, 02, 03, 04
                                    return (0, _utils_js__WEBPACK_IMPORTED_MODULE_6__.parseNDigits)(token.length, dateString);
                                // 1st, 2nd, 3rd, 4th
                                case 'qo':
                                    return match.ordinalNumber(dateString, {
                                        unit: 'quarter'
                                    });
                                // Q1, Q2, Q3, Q4
                                case 'qqq':
                                    return match.quarter(dateString, {
                                        width: 'abbreviated',
                                        context: 'standalone'
                                    }) || match.quarter(dateString, {
                                        width: 'narrow',
                                        context: 'standalone'
                                    });
                                // 1, 2, 3, 4 (narrow quarter; could be not numerical)
                                case 'qqqqq':
                                    return match.quarter(dateString, {
                                        width: 'narrow',
                                        context: 'standalone'
                                    });
                                // 1st quarter, 2nd quarter, ...
                                case 'qqqq':
                                default:
                                    return match.quarter(dateString, {
                                        width: 'wide',
                                        context: 'standalone'
                                    }) || match.quarter(dateString, {
                                        width: 'abbreviated',
                                        context: 'standalone'
                                    }) || match.quarter(dateString, {
                                        width: 'narrow',
                                        context: 'standalone'
                                    });
                            }
                        }
                    }, {
                        key: "validate",
                        value: function validate(_date, value) {
                            return value >= 1 && value <= 4;
                        }
                    }, {
                        key: "set",
                        value: function set(date, _flags, value) {
                            date.setUTCMonth((value - 1) * 3, 1);
                            date.setUTCHours(0, 0, 0, 0);
                            return date;
                        }
                    }]);
                return StandAloneQuarterParser;
            }(_Parser_js__WEBPACK_IMPORTED_MODULE_7__.Parser);
            /***/ 
        }),
        /***/ "./node_modules/date-fns/esm/parse/_lib/parsers/TimestampMillisecondsParser.js": 
        /*!*************************************************************************************!*\
          !*** ./node_modules/date-fns/esm/parse/_lib/parsers/TimestampMillisecondsParser.js ***!
          \*************************************************************************************/
        /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony export */ __webpack_require__.d(__webpack_exports__, {
                /* harmony export */ TimestampMillisecondsParser: () => ( /* binding */TimestampMillisecondsParser)
                /* harmony export */ 
            });
            /* harmony import */ var _babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/classCallCheck */ "./node_modules/@babel/runtime/helpers/esm/classCallCheck.js");
            /* harmony import */ var _babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/esm/createClass */ "./node_modules/@babel/runtime/helpers/esm/createClass.js");
            /* harmony import */ var _babel_runtime_helpers_esm_assertThisInitialized__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/runtime/helpers/esm/assertThisInitialized */ "./node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js");
            /* harmony import */ var _babel_runtime_helpers_esm_inherits__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @babel/runtime/helpers/esm/inherits */ "./node_modules/@babel/runtime/helpers/esm/inherits.js");
            /* harmony import */ var _babel_runtime_helpers_esm_createSuper__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @babel/runtime/helpers/esm/createSuper */ "./node_modules/@babel/runtime/helpers/esm/createSuper.js");
            /* harmony import */ var _babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @babel/runtime/helpers/esm/defineProperty */ "./node_modules/@babel/runtime/helpers/esm/defineProperty.js");
            /* harmony import */ var _Parser_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../Parser.js */ "./node_modules/date-fns/esm/parse/_lib/Parser.js");
            /* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../utils.js */ "./node_modules/date-fns/esm/parse/_lib/utils.js");
            var TimestampMillisecondsParser = /*#__PURE__*/ function (_Parser) {
                (0, _babel_runtime_helpers_esm_inherits__WEBPACK_IMPORTED_MODULE_3__["default"])(TimestampMillisecondsParser, _Parser);
                var _super = (0, _babel_runtime_helpers_esm_createSuper__WEBPACK_IMPORTED_MODULE_4__["default"])(TimestampMillisecondsParser);
                function TimestampMillisecondsParser() {
                    var _this;
                    (0, _babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_0__["default"])(this, TimestampMillisecondsParser);
                    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                        args[_key] = arguments[_key];
                    }
                    _this = _super.call.apply(_super, [this].concat(args));
                    (0, _babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_5__["default"])((0, _babel_runtime_helpers_esm_assertThisInitialized__WEBPACK_IMPORTED_MODULE_2__["default"])(_this), "priority", 20);
                    (0, _babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_5__["default"])((0, _babel_runtime_helpers_esm_assertThisInitialized__WEBPACK_IMPORTED_MODULE_2__["default"])(_this), "incompatibleTokens", '*');
                    return _this;
                }
                (0, _babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_1__["default"])(TimestampMillisecondsParser, [{
                        key: "parse",
                        value: function parse(dateString) {
                            return (0, _utils_js__WEBPACK_IMPORTED_MODULE_6__.parseAnyDigitsSigned)(dateString);
                        }
                    }, {
                        key: "set",
                        value: function set(_date, _flags, value) {
                            return [new Date(value), {
                                    timestampIsSet: true
                                }];
                        }
                    }]);
                return TimestampMillisecondsParser;
            }(_Parser_js__WEBPACK_IMPORTED_MODULE_7__.Parser);
            /***/ 
        }),
        /***/ "./node_modules/date-fns/esm/parse/_lib/parsers/TimestampSecondsParser.js": 
        /*!********************************************************************************!*\
          !*** ./node_modules/date-fns/esm/parse/_lib/parsers/TimestampSecondsParser.js ***!
          \********************************************************************************/
        /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony export */ __webpack_require__.d(__webpack_exports__, {
                /* harmony export */ TimestampSecondsParser: () => ( /* binding */TimestampSecondsParser)
                /* harmony export */ 
            });
            /* harmony import */ var _babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/classCallCheck */ "./node_modules/@babel/runtime/helpers/esm/classCallCheck.js");
            /* harmony import */ var _babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/esm/createClass */ "./node_modules/@babel/runtime/helpers/esm/createClass.js");
            /* harmony import */ var _babel_runtime_helpers_esm_assertThisInitialized__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/runtime/helpers/esm/assertThisInitialized */ "./node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js");
            /* harmony import */ var _babel_runtime_helpers_esm_inherits__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @babel/runtime/helpers/esm/inherits */ "./node_modules/@babel/runtime/helpers/esm/inherits.js");
            /* harmony import */ var _babel_runtime_helpers_esm_createSuper__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @babel/runtime/helpers/esm/createSuper */ "./node_modules/@babel/runtime/helpers/esm/createSuper.js");
            /* harmony import */ var _babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @babel/runtime/helpers/esm/defineProperty */ "./node_modules/@babel/runtime/helpers/esm/defineProperty.js");
            /* harmony import */ var _Parser_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../Parser.js */ "./node_modules/date-fns/esm/parse/_lib/Parser.js");
            /* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../utils.js */ "./node_modules/date-fns/esm/parse/_lib/utils.js");
            var TimestampSecondsParser = /*#__PURE__*/ function (_Parser) {
                (0, _babel_runtime_helpers_esm_inherits__WEBPACK_IMPORTED_MODULE_3__["default"])(TimestampSecondsParser, _Parser);
                var _super = (0, _babel_runtime_helpers_esm_createSuper__WEBPACK_IMPORTED_MODULE_4__["default"])(TimestampSecondsParser);
                function TimestampSecondsParser() {
                    var _this;
                    (0, _babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_0__["default"])(this, TimestampSecondsParser);
                    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                        args[_key] = arguments[_key];
                    }
                    _this = _super.call.apply(_super, [this].concat(args));
                    (0, _babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_5__["default"])((0, _babel_runtime_helpers_esm_assertThisInitialized__WEBPACK_IMPORTED_MODULE_2__["default"])(_this), "priority", 40);
                    (0, _babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_5__["default"])((0, _babel_runtime_helpers_esm_assertThisInitialized__WEBPACK_IMPORTED_MODULE_2__["default"])(_this), "incompatibleTokens", '*');
                    return _this;
                }
                (0, _babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_1__["default"])(TimestampSecondsParser, [{
                        key: "parse",
                        value: function parse(dateString) {
                            return (0, _utils_js__WEBPACK_IMPORTED_MODULE_6__.parseAnyDigitsSigned)(dateString);
                        }
                    }, {
                        key: "set",
                        value: function set(_date, _flags, value) {
                            return [new Date(value * 1000), {
                                    timestampIsSet: true
                                }];
                        }
                    }]);
                return TimestampSecondsParser;
            }(_Parser_js__WEBPACK_IMPORTED_MODULE_7__.Parser);
            /***/ 
        }),
        /***/ "./node_modules/date-fns/esm/parse/_lib/parsers/YearParser.js": 
        /*!********************************************************************!*\
          !*** ./node_modules/date-fns/esm/parse/_lib/parsers/YearParser.js ***!
          \********************************************************************/
        /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony export */ __webpack_require__.d(__webpack_exports__, {
                /* harmony export */ YearParser: () => ( /* binding */YearParser)
                /* harmony export */ 
            });
            /* harmony import */ var _babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/classCallCheck */ "./node_modules/@babel/runtime/helpers/esm/classCallCheck.js");
            /* harmony import */ var _babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/esm/createClass */ "./node_modules/@babel/runtime/helpers/esm/createClass.js");
            /* harmony import */ var _babel_runtime_helpers_esm_assertThisInitialized__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/runtime/helpers/esm/assertThisInitialized */ "./node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js");
            /* harmony import */ var _babel_runtime_helpers_esm_inherits__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @babel/runtime/helpers/esm/inherits */ "./node_modules/@babel/runtime/helpers/esm/inherits.js");
            /* harmony import */ var _babel_runtime_helpers_esm_createSuper__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @babel/runtime/helpers/esm/createSuper */ "./node_modules/@babel/runtime/helpers/esm/createSuper.js");
            /* harmony import */ var _babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @babel/runtime/helpers/esm/defineProperty */ "./node_modules/@babel/runtime/helpers/esm/defineProperty.js");
            /* harmony import */ var _Parser_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../Parser.js */ "./node_modules/date-fns/esm/parse/_lib/Parser.js");
            /* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../utils.js */ "./node_modules/date-fns/esm/parse/_lib/utils.js");
            // From http://www.unicode.org/reports/tr35/tr35-31/tr35-dates.html#Date_Format_Patterns
            // | Year     |     y | yy |   yyy |  yyyy | yyyyy |
            // |----------|-------|----|-------|-------|-------|
            // | AD 1     |     1 | 01 |   001 |  0001 | 00001 |
            // | AD 12    |    12 | 12 |   012 |  0012 | 00012 |
            // | AD 123   |   123 | 23 |   123 |  0123 | 00123 |
            // | AD 1234  |  1234 | 34 |  1234 |  1234 | 01234 |
            // | AD 12345 | 12345 | 45 | 12345 | 12345 | 12345 |
            var YearParser = /*#__PURE__*/ function (_Parser) {
                (0, _babel_runtime_helpers_esm_inherits__WEBPACK_IMPORTED_MODULE_3__["default"])(YearParser, _Parser);
                var _super = (0, _babel_runtime_helpers_esm_createSuper__WEBPACK_IMPORTED_MODULE_4__["default"])(YearParser);
                function YearParser() {
                    var _this;
                    (0, _babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_0__["default"])(this, YearParser);
                    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                        args[_key] = arguments[_key];
                    }
                    _this = _super.call.apply(_super, [this].concat(args));
                    (0, _babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_5__["default"])((0, _babel_runtime_helpers_esm_assertThisInitialized__WEBPACK_IMPORTED_MODULE_2__["default"])(_this), "priority", 130);
                    (0, _babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_5__["default"])((0, _babel_runtime_helpers_esm_assertThisInitialized__WEBPACK_IMPORTED_MODULE_2__["default"])(_this), "incompatibleTokens", ['Y', 'R', 'u', 'w', 'I', 'i', 'e', 'c', 't', 'T']);
                    return _this;
                }
                (0, _babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_1__["default"])(YearParser, [{
                        key: "parse",
                        value: function parse(dateString, token, match) {
                            var valueCallback = function valueCallback(year) {
                                return {
                                    year: year,
                                    isTwoDigitYear: token === 'yy'
                                };
                            };
                            switch (token) {
                                case 'y':
                                    return (0, _utils_js__WEBPACK_IMPORTED_MODULE_6__.mapValue)((0, _utils_js__WEBPACK_IMPORTED_MODULE_6__.parseNDigits)(4, dateString), valueCallback);
                                case 'yo':
                                    return (0, _utils_js__WEBPACK_IMPORTED_MODULE_6__.mapValue)(match.ordinalNumber(dateString, {
                                        unit: 'year'
                                    }), valueCallback);
                                default:
                                    return (0, _utils_js__WEBPACK_IMPORTED_MODULE_6__.mapValue)((0, _utils_js__WEBPACK_IMPORTED_MODULE_6__.parseNDigits)(token.length, dateString), valueCallback);
                            }
                        }
                    }, {
                        key: "validate",
                        value: function validate(_date, value) {
                            return value.isTwoDigitYear || value.year > 0;
                        }
                    }, {
                        key: "set",
                        value: function set(date, flags, value) {
                            var currentYear = date.getUTCFullYear();
                            if (value.isTwoDigitYear) {
                                var normalizedTwoDigitYear = (0, _utils_js__WEBPACK_IMPORTED_MODULE_6__.normalizeTwoDigitYear)(value.year, currentYear);
                                date.setUTCFullYear(normalizedTwoDigitYear, 0, 1);
                                date.setUTCHours(0, 0, 0, 0);
                                return date;
                            }
                            var year = !('era' in flags) || flags.era === 1 ? value.year : 1 - value.year;
                            date.setUTCFullYear(year, 0, 1);
                            date.setUTCHours(0, 0, 0, 0);
                            return date;
                        }
                    }]);
                return YearParser;
            }(_Parser_js__WEBPACK_IMPORTED_MODULE_7__.Parser);
            /***/ 
        }),
        /***/ "./node_modules/date-fns/esm/parse/_lib/parsers/index.js": 
        /*!***************************************************************!*\
          !*** ./node_modules/date-fns/esm/parse/_lib/parsers/index.js ***!
          \***************************************************************/
        /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony export */ __webpack_require__.d(__webpack_exports__, {
                /* harmony export */ parsers: () => ( /* binding */parsers)
                /* harmony export */ 
            });
            /* harmony import */ var _EraParser_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./EraParser.js */ "./node_modules/date-fns/esm/parse/_lib/parsers/EraParser.js");
            /* harmony import */ var _YearParser_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./YearParser.js */ "./node_modules/date-fns/esm/parse/_lib/parsers/YearParser.js");
            /* harmony import */ var _LocalWeekYearParser_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./LocalWeekYearParser.js */ "./node_modules/date-fns/esm/parse/_lib/parsers/LocalWeekYearParser.js");
            /* harmony import */ var _ISOWeekYearParser_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./ISOWeekYearParser.js */ "./node_modules/date-fns/esm/parse/_lib/parsers/ISOWeekYearParser.js");
            /* harmony import */ var _ExtendedYearParser_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./ExtendedYearParser.js */ "./node_modules/date-fns/esm/parse/_lib/parsers/ExtendedYearParser.js");
            /* harmony import */ var _QuarterParser_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./QuarterParser.js */ "./node_modules/date-fns/esm/parse/_lib/parsers/QuarterParser.js");
            /* harmony import */ var _StandAloneQuarterParser_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./StandAloneQuarterParser.js */ "./node_modules/date-fns/esm/parse/_lib/parsers/StandAloneQuarterParser.js");
            /* harmony import */ var _MonthParser_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./MonthParser.js */ "./node_modules/date-fns/esm/parse/_lib/parsers/MonthParser.js");
            /* harmony import */ var _StandAloneMonthParser_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./StandAloneMonthParser.js */ "./node_modules/date-fns/esm/parse/_lib/parsers/StandAloneMonthParser.js");
            /* harmony import */ var _LocalWeekParser_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./LocalWeekParser.js */ "./node_modules/date-fns/esm/parse/_lib/parsers/LocalWeekParser.js");
            /* harmony import */ var _ISOWeekParser_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./ISOWeekParser.js */ "./node_modules/date-fns/esm/parse/_lib/parsers/ISOWeekParser.js");
            /* harmony import */ var _DateParser_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./DateParser.js */ "./node_modules/date-fns/esm/parse/_lib/parsers/DateParser.js");
            /* harmony import */ var _DayOfYearParser_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./DayOfYearParser.js */ "./node_modules/date-fns/esm/parse/_lib/parsers/DayOfYearParser.js");
            /* harmony import */ var _DayParser_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./DayParser.js */ "./node_modules/date-fns/esm/parse/_lib/parsers/DayParser.js");
            /* harmony import */ var _LocalDayParser_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./LocalDayParser.js */ "./node_modules/date-fns/esm/parse/_lib/parsers/LocalDayParser.js");
            /* harmony import */ var _StandAloneLocalDayParser_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./StandAloneLocalDayParser.js */ "./node_modules/date-fns/esm/parse/_lib/parsers/StandAloneLocalDayParser.js");
            /* harmony import */ var _ISODayParser_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./ISODayParser.js */ "./node_modules/date-fns/esm/parse/_lib/parsers/ISODayParser.js");
            /* harmony import */ var _AMPMParser_js__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./AMPMParser.js */ "./node_modules/date-fns/esm/parse/_lib/parsers/AMPMParser.js");
            /* harmony import */ var _AMPMMidnightParser_js__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./AMPMMidnightParser.js */ "./node_modules/date-fns/esm/parse/_lib/parsers/AMPMMidnightParser.js");
            /* harmony import */ var _DayPeriodParser_js__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./DayPeriodParser.js */ "./node_modules/date-fns/esm/parse/_lib/parsers/DayPeriodParser.js");
            /* harmony import */ var _Hour1to12Parser_js__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./Hour1to12Parser.js */ "./node_modules/date-fns/esm/parse/_lib/parsers/Hour1to12Parser.js");
            /* harmony import */ var _Hour0to23Parser_js__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ./Hour0to23Parser.js */ "./node_modules/date-fns/esm/parse/_lib/parsers/Hour0to23Parser.js");
            /* harmony import */ var _Hour0To11Parser_js__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ./Hour0To11Parser.js */ "./node_modules/date-fns/esm/parse/_lib/parsers/Hour0To11Parser.js");
            /* harmony import */ var _Hour1To24Parser_js__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! ./Hour1To24Parser.js */ "./node_modules/date-fns/esm/parse/_lib/parsers/Hour1To24Parser.js");
            /* harmony import */ var _MinuteParser_js__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! ./MinuteParser.js */ "./node_modules/date-fns/esm/parse/_lib/parsers/MinuteParser.js");
            /* harmony import */ var _SecondParser_js__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! ./SecondParser.js */ "./node_modules/date-fns/esm/parse/_lib/parsers/SecondParser.js");
            /* harmony import */ var _FractionOfSecondParser_js__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(/*! ./FractionOfSecondParser.js */ "./node_modules/date-fns/esm/parse/_lib/parsers/FractionOfSecondParser.js");
            /* harmony import */ var _ISOTimezoneWithZParser_js__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__(/*! ./ISOTimezoneWithZParser.js */ "./node_modules/date-fns/esm/parse/_lib/parsers/ISOTimezoneWithZParser.js");
            /* harmony import */ var _ISOTimezoneParser_js__WEBPACK_IMPORTED_MODULE_28__ = __webpack_require__(/*! ./ISOTimezoneParser.js */ "./node_modules/date-fns/esm/parse/_lib/parsers/ISOTimezoneParser.js");
            /* harmony import */ var _TimestampSecondsParser_js__WEBPACK_IMPORTED_MODULE_29__ = __webpack_require__(/*! ./TimestampSecondsParser.js */ "./node_modules/date-fns/esm/parse/_lib/parsers/TimestampSecondsParser.js");
            /* harmony import */ var _TimestampMillisecondsParser_js__WEBPACK_IMPORTED_MODULE_30__ = __webpack_require__(/*! ./TimestampMillisecondsParser.js */ "./node_modules/date-fns/esm/parse/_lib/parsers/TimestampMillisecondsParser.js");
            /*
             * |     | Unit                           |     | Unit                           |
             * |-----|--------------------------------|-----|--------------------------------|
             * |  a  | AM, PM                         |  A* | Milliseconds in day            |
             * |  b  | AM, PM, noon, midnight         |  B  | Flexible day period            |
             * |  c  | Stand-alone local day of week  |  C* | Localized hour w/ day period   |
             * |  d  | Day of month                   |  D  | Day of year                    |
             * |  e  | Local day of week              |  E  | Day of week                    |
             * |  f  |                                |  F* | Day of week in month           |
             * |  g* | Modified Julian day            |  G  | Era                            |
             * |  h  | Hour [1-12]                    |  H  | Hour [0-23]                    |
             * |  i! | ISO day of week                |  I! | ISO week of year               |
             * |  j* | Localized hour w/ day period   |  J* | Localized hour w/o day period  |
             * |  k  | Hour [1-24]                    |  K  | Hour [0-11]                    |
             * |  l* | (deprecated)                   |  L  | Stand-alone month              |
             * |  m  | Minute                         |  M  | Month                          |
             * |  n  |                                |  N  |                                |
             * |  o! | Ordinal number modifier        |  O* | Timezone (GMT)                 |
             * |  p  |                                |  P  |                                |
             * |  q  | Stand-alone quarter            |  Q  | Quarter                        |
             * |  r* | Related Gregorian year         |  R! | ISO week-numbering year        |
             * |  s  | Second                         |  S  | Fraction of second             |
             * |  t! | Seconds timestamp              |  T! | Milliseconds timestamp         |
             * |  u  | Extended year                  |  U* | Cyclic year                    |
             * |  v* | Timezone (generic non-locat.)  |  V* | Timezone (location)            |
             * |  w  | Local week of year             |  W* | Week of month                  |
             * |  x  | Timezone (ISO-8601 w/o Z)      |  X  | Timezone (ISO-8601)            |
             * |  y  | Year (abs)                     |  Y  | Local week-numbering year      |
             * |  z* | Timezone (specific non-locat.) |  Z* | Timezone (aliases)             |
             *
             * Letters marked by * are not implemented but reserved by Unicode standard.
             *
             * Letters marked by ! are non-standard, but implemented by date-fns:
             * - `o` modifies the previous token to turn it into an ordinal (see `parse` docs)
             * - `i` is ISO day of week. For `i` and `ii` is returns numeric ISO week days,
             *   i.e. 7 for Sunday, 1 for Monday, etc.
             * - `I` is ISO week of year, as opposed to `w` which is local week of year.
             * - `R` is ISO week-numbering year, as opposed to `Y` which is local week-numbering year.
             *   `R` is supposed to be used in conjunction with `I` and `i`
             *   for universal ISO week-numbering date, whereas
             *   `Y` is supposed to be used in conjunction with `w` and `e`
             *   for week-numbering date specific to the locale.
             */
            var parsers = {
                G: new _EraParser_js__WEBPACK_IMPORTED_MODULE_0__.EraParser(),
                y: new _YearParser_js__WEBPACK_IMPORTED_MODULE_1__.YearParser(),
                Y: new _LocalWeekYearParser_js__WEBPACK_IMPORTED_MODULE_2__.LocalWeekYearParser(),
                R: new _ISOWeekYearParser_js__WEBPACK_IMPORTED_MODULE_3__.ISOWeekYearParser(),
                u: new _ExtendedYearParser_js__WEBPACK_IMPORTED_MODULE_4__.ExtendedYearParser(),
                Q: new _QuarterParser_js__WEBPACK_IMPORTED_MODULE_5__.QuarterParser(),
                q: new _StandAloneQuarterParser_js__WEBPACK_IMPORTED_MODULE_6__.StandAloneQuarterParser(),
                M: new _MonthParser_js__WEBPACK_IMPORTED_MODULE_7__.MonthParser(),
                L: new _StandAloneMonthParser_js__WEBPACK_IMPORTED_MODULE_8__.StandAloneMonthParser(),
                w: new _LocalWeekParser_js__WEBPACK_IMPORTED_MODULE_9__.LocalWeekParser(),
                I: new _ISOWeekParser_js__WEBPACK_IMPORTED_MODULE_10__.ISOWeekParser(),
                d: new _DateParser_js__WEBPACK_IMPORTED_MODULE_11__.DateParser(),
                D: new _DayOfYearParser_js__WEBPACK_IMPORTED_MODULE_12__.DayOfYearParser(),
                E: new _DayParser_js__WEBPACK_IMPORTED_MODULE_13__.DayParser(),
                e: new _LocalDayParser_js__WEBPACK_IMPORTED_MODULE_14__.LocalDayParser(),
                c: new _StandAloneLocalDayParser_js__WEBPACK_IMPORTED_MODULE_15__.StandAloneLocalDayParser(),
                i: new _ISODayParser_js__WEBPACK_IMPORTED_MODULE_16__.ISODayParser(),
                a: new _AMPMParser_js__WEBPACK_IMPORTED_MODULE_17__.AMPMParser(),
                b: new _AMPMMidnightParser_js__WEBPACK_IMPORTED_MODULE_18__.AMPMMidnightParser(),
                B: new _DayPeriodParser_js__WEBPACK_IMPORTED_MODULE_19__.DayPeriodParser(),
                h: new _Hour1to12Parser_js__WEBPACK_IMPORTED_MODULE_20__.Hour1to12Parser(),
                H: new _Hour0to23Parser_js__WEBPACK_IMPORTED_MODULE_21__.Hour0to23Parser(),
                K: new _Hour0To11Parser_js__WEBPACK_IMPORTED_MODULE_22__.Hour0To11Parser(),
                k: new _Hour1To24Parser_js__WEBPACK_IMPORTED_MODULE_23__.Hour1To24Parser(),
                m: new _MinuteParser_js__WEBPACK_IMPORTED_MODULE_24__.MinuteParser(),
                s: new _SecondParser_js__WEBPACK_IMPORTED_MODULE_25__.SecondParser(),
                S: new _FractionOfSecondParser_js__WEBPACK_IMPORTED_MODULE_26__.FractionOfSecondParser(),
                X: new _ISOTimezoneWithZParser_js__WEBPACK_IMPORTED_MODULE_27__.ISOTimezoneWithZParser(),
                x: new _ISOTimezoneParser_js__WEBPACK_IMPORTED_MODULE_28__.ISOTimezoneParser(),
                t: new _TimestampSecondsParser_js__WEBPACK_IMPORTED_MODULE_29__.TimestampSecondsParser(),
                T: new _TimestampMillisecondsParser_js__WEBPACK_IMPORTED_MODULE_30__.TimestampMillisecondsParser()
            };
            /***/ 
        }),
        /***/ "./node_modules/date-fns/esm/parse/_lib/utils.js": 
        /*!*******************************************************!*\
          !*** ./node_modules/date-fns/esm/parse/_lib/utils.js ***!
          \*******************************************************/
        /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony export */ __webpack_require__.d(__webpack_exports__, {
                /* harmony export */ dayPeriodEnumToHours: () => ( /* binding */dayPeriodEnumToHours),
                /* harmony export */ isLeapYearIndex: () => ( /* binding */isLeapYearIndex),
                /* harmony export */ mapValue: () => ( /* binding */mapValue),
                /* harmony export */ normalizeTwoDigitYear: () => ( /* binding */normalizeTwoDigitYear),
                /* harmony export */ parseAnyDigitsSigned: () => ( /* binding */parseAnyDigitsSigned),
                /* harmony export */ parseNDigits: () => ( /* binding */parseNDigits),
                /* harmony export */ parseNDigitsSigned: () => ( /* binding */parseNDigitsSigned),
                /* harmony export */ parseNumericPattern: () => ( /* binding */parseNumericPattern),
                /* harmony export */ parseTimezonePattern: () => ( /* binding */parseTimezonePattern)
                /* harmony export */ 
            });
            /* harmony import */ var _constants_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../constants/index.js */ "./node_modules/date-fns/esm/constants/index.js");
            /* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./constants.js */ "./node_modules/date-fns/esm/parse/_lib/constants.js");
            function mapValue(parseFnResult, mapFn) {
                if (!parseFnResult) {
                    return parseFnResult;
                }
                return {
                    value: mapFn(parseFnResult.value),
                    rest: parseFnResult.rest
                };
            }
            function parseNumericPattern(pattern, dateString) {
                var matchResult = dateString.match(pattern);
                if (!matchResult) {
                    return null;
                }
                return {
                    value: parseInt(matchResult[0], 10),
                    rest: dateString.slice(matchResult[0].length)
                };
            }
            function parseTimezonePattern(pattern, dateString) {
                var matchResult = dateString.match(pattern);
                if (!matchResult) {
                    return null;
                }
                // Input is 'Z'
                if (matchResult[0] === 'Z') {
                    return {
                        value: 0,
                        rest: dateString.slice(1)
                    };
                }
                var sign = matchResult[1] === '+' ? 1 : -1;
                var hours = matchResult[2] ? parseInt(matchResult[2], 10) : 0;
                var minutes = matchResult[3] ? parseInt(matchResult[3], 10) : 0;
                var seconds = matchResult[5] ? parseInt(matchResult[5], 10) : 0;
                return {
                    value: sign * (hours * _constants_index_js__WEBPACK_IMPORTED_MODULE_0__.millisecondsInHour + minutes * _constants_index_js__WEBPACK_IMPORTED_MODULE_0__.millisecondsInMinute + seconds * _constants_index_js__WEBPACK_IMPORTED_MODULE_0__.millisecondsInSecond),
                    rest: dateString.slice(matchResult[0].length)
                };
            }
            function parseAnyDigitsSigned(dateString) {
                return parseNumericPattern(_constants_js__WEBPACK_IMPORTED_MODULE_1__.numericPatterns.anyDigitsSigned, dateString);
            }
            function parseNDigits(n, dateString) {
                switch (n) {
                    case 1:
                        return parseNumericPattern(_constants_js__WEBPACK_IMPORTED_MODULE_1__.numericPatterns.singleDigit, dateString);
                    case 2:
                        return parseNumericPattern(_constants_js__WEBPACK_IMPORTED_MODULE_1__.numericPatterns.twoDigits, dateString);
                    case 3:
                        return parseNumericPattern(_constants_js__WEBPACK_IMPORTED_MODULE_1__.numericPatterns.threeDigits, dateString);
                    case 4:
                        return parseNumericPattern(_constants_js__WEBPACK_IMPORTED_MODULE_1__.numericPatterns.fourDigits, dateString);
                    default:
                        return parseNumericPattern(new RegExp('^\\d{1,' + n + '}'), dateString);
                }
            }
            function parseNDigitsSigned(n, dateString) {
                switch (n) {
                    case 1:
                        return parseNumericPattern(_constants_js__WEBPACK_IMPORTED_MODULE_1__.numericPatterns.singleDigitSigned, dateString);
                    case 2:
                        return parseNumericPattern(_constants_js__WEBPACK_IMPORTED_MODULE_1__.numericPatterns.twoDigitsSigned, dateString);
                    case 3:
                        return parseNumericPattern(_constants_js__WEBPACK_IMPORTED_MODULE_1__.numericPatterns.threeDigitsSigned, dateString);
                    case 4:
                        return parseNumericPattern(_constants_js__WEBPACK_IMPORTED_MODULE_1__.numericPatterns.fourDigitsSigned, dateString);
                    default:
                        return parseNumericPattern(new RegExp('^-?\\d{1,' + n + '}'), dateString);
                }
            }
            function dayPeriodEnumToHours(dayPeriod) {
                switch (dayPeriod) {
                    case 'morning':
                        return 4;
                    case 'evening':
                        return 17;
                    case 'pm':
                    case 'noon':
                    case 'afternoon':
                        return 12;
                    case 'am':
                    case 'midnight':
                    case 'night':
                    default:
                        return 0;
                }
            }
            function normalizeTwoDigitYear(twoDigitYear, currentYear) {
                var isCommonEra = currentYear > 0;
                // Absolute number of the current year:
                // 1 -> 1 AC
                // 0 -> 1 BC
                // -1 -> 2 BC
                var absCurrentYear = isCommonEra ? currentYear : 1 - currentYear;
                var result;
                if (absCurrentYear <= 50) {
                    result = twoDigitYear || 100;
                }
                else {
                    var rangeEnd = absCurrentYear + 50;
                    var rangeEndCentury = Math.floor(rangeEnd / 100) * 100;
                    var isPreviousCentury = twoDigitYear >= rangeEnd % 100;
                    result = twoDigitYear + rangeEndCentury - (isPreviousCentury ? 100 : 0);
                }
                return isCommonEra ? result : 1 - result;
            }
            function isLeapYearIndex(year) {
                return year % 400 === 0 || year % 4 === 0 && year % 100 !== 0;
            }
            /***/ 
        }),
        /***/ "./node_modules/date-fns/esm/parse/index.js": 
        /*!**************************************************!*\
          !*** ./node_modules/date-fns/esm/parse/index.js ***!
          \**************************************************/
        /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony export */ __webpack_require__.d(__webpack_exports__, {
                /* harmony export */ "default": () => ( /* binding */parse)
                /* harmony export */ 
            });
            /* harmony import */ var _babel_runtime_helpers_esm_typeof__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/typeof */ "./node_modules/@babel/runtime/helpers/esm/typeof.js");
            /* harmony import */ var _babel_runtime_helpers_esm_createForOfIteratorHelper__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/esm/createForOfIteratorHelper */ "./node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js");
            /* harmony import */ var _lib_defaultLocale_index_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../_lib/defaultLocale/index.js */ "./node_modules/date-fns/esm/_lib/defaultLocale/index.js");
            /* harmony import */ var _subMilliseconds_index_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../subMilliseconds/index.js */ "./node_modules/date-fns/esm/subMilliseconds/index.js");
            /* harmony import */ var _toDate_index_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../toDate/index.js */ "./node_modules/date-fns/esm/toDate/index.js");
            /* harmony import */ var _lib_assign_index_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../_lib/assign/index.js */ "./node_modules/date-fns/esm/_lib/assign/index.js");
            /* harmony import */ var _lib_format_longFormatters_index_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../_lib/format/longFormatters/index.js */ "./node_modules/date-fns/esm/_lib/format/longFormatters/index.js");
            /* harmony import */ var _lib_getTimezoneOffsetInMilliseconds_index_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../_lib/getTimezoneOffsetInMilliseconds/index.js */ "./node_modules/date-fns/esm/_lib/getTimezoneOffsetInMilliseconds/index.js");
            /* harmony import */ var _lib_protectedTokens_index_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../_lib/protectedTokens/index.js */ "./node_modules/date-fns/esm/_lib/protectedTokens/index.js");
            /* harmony import */ var _lib_toInteger_index_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../_lib/toInteger/index.js */ "./node_modules/date-fns/esm/_lib/toInteger/index.js");
            /* harmony import */ var _lib_requiredArgs_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../_lib/requiredArgs/index.js */ "./node_modules/date-fns/esm/_lib/requiredArgs/index.js");
            /* harmony import */ var _lib_Setter_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./_lib/Setter.js */ "./node_modules/date-fns/esm/parse/_lib/Setter.js");
            /* harmony import */ var _lib_parsers_index_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./_lib/parsers/index.js */ "./node_modules/date-fns/esm/parse/_lib/parsers/index.js");
            /* harmony import */ var _lib_defaultOptions_index_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../_lib/defaultOptions/index.js */ "./node_modules/date-fns/esm/_lib/defaultOptions/index.js");
            // This RegExp consists of three parts separated by `|`:
            // - [yYQqMLwIdDecihHKkms]o matches any available ordinal number token
            //   (one of the certain letters followed by `o`)
            // - (\w)\1* matches any sequences of the same letter
            // - '' matches two quote characters in a row
            // - '(''|[^'])+('|$) matches anything surrounded by two quote characters ('),
            //   except a single quote symbol, which ends the sequence.
            //   Two quote characters do not end the sequence.
            //   If there is no matching single quote
            //   then the sequence will continue until the end of the string.
            // - . matches any single character unmatched by previous parts of the RegExps
            var formattingTokensRegExp = /[yYQqMLwIdDecihHKkms]o|(\w)\1*|''|'(''|[^'])+('|$)|./g;
            // This RegExp catches symbols escaped by quotes, and also
            // sequences of symbols P, p, and the combinations like `PPPPPPPppppp`
            var longFormattingTokensRegExp = /P+p+|P+|p+|''|'(''|[^'])+('|$)|./g;
            var escapedStringRegExp = /^'([^]*?)'?$/;
            var doubleQuoteRegExp = /''/g;
            var notWhitespaceRegExp = /\S/;
            var unescapedLatinCharacterRegExp = /[a-zA-Z]/;
            /**
             * @name parse
             * @category Common Helpers
             * @summary Parse the date.
             *
             * @description
             * Return the date parsed from string using the given format string.
             *
             * >  Please note that the `format` tokens differ from Moment.js and other libraries.
             * > See: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
             *
             * The characters in the format string wrapped between two single quotes characters (') are escaped.
             * Two single quotes in a row, whether inside or outside a quoted sequence, represent a 'real' single quote.
             *
             * Format of the format string is based on Unicode Technical Standard #35:
             * https://www.unicode.org/reports/tr35/tr35-dates.html#Date_Field_Symbol_Table
             * with a few additions (see note 5 below the table).
             *
             * Not all tokens are compatible. Combinations that don't make sense or could lead to bugs are prohibited
             * and will throw `RangeError`. For example usage of 24-hour format token with AM/PM token will throw an exception:
             *
             * ```javascript
             * parse('23 AM', 'HH a', new Date())
             * //=> RangeError: The format string mustn't contain `HH` and `a` at the same time
             * ```
             *
             * See the compatibility table: https://docs.google.com/spreadsheets/d/e/2PACX-1vQOPU3xUhplll6dyoMmVUXHKl_8CRDs6_ueLmex3SoqwhuolkuN3O05l4rqx5h1dKX8eb46Ul-CCSrq/pubhtml?gid=0&single=true
             *
             * Accepted format string patterns:
             * | Unit                            |Prior| Pattern | Result examples                   | Notes |
             * |---------------------------------|-----|---------|-----------------------------------|-------|
             * | Era                             | 140 | G..GGG  | AD, BC                            |       |
             * |                                 |     | GGGG    | Anno Domini, Before Christ        | 2     |
             * |                                 |     | GGGGG   | A, B                              |       |
             * | Calendar year                   | 130 | y       | 44, 1, 1900, 2017, 9999           | 4     |
             * |                                 |     | yo      | 44th, 1st, 1900th, 9999999th      | 4,5   |
             * |                                 |     | yy      | 44, 01, 00, 17                    | 4     |
             * |                                 |     | yyy     | 044, 001, 123, 999                | 4     |
             * |                                 |     | yyyy    | 0044, 0001, 1900, 2017            | 4     |
             * |                                 |     | yyyyy   | ...                               | 2,4   |
             * | Local week-numbering year       | 130 | Y       | 44, 1, 1900, 2017, 9000           | 4     |
             * |                                 |     | Yo      | 44th, 1st, 1900th, 9999999th      | 4,5   |
             * |                                 |     | YY      | 44, 01, 00, 17                    | 4,6   |
             * |                                 |     | YYY     | 044, 001, 123, 999                | 4     |
             * |                                 |     | YYYY    | 0044, 0001, 1900, 2017            | 4,6   |
             * |                                 |     | YYYYY   | ...                               | 2,4   |
             * | ISO week-numbering year         | 130 | R       | -43, 1, 1900, 2017, 9999, -9999   | 4,5   |
             * |                                 |     | RR      | -43, 01, 00, 17                   | 4,5   |
             * |                                 |     | RRR     | -043, 001, 123, 999, -999         | 4,5   |
             * |                                 |     | RRRR    | -0043, 0001, 2017, 9999, -9999    | 4,5   |
             * |                                 |     | RRRRR   | ...                               | 2,4,5 |
             * | Extended year                   | 130 | u       | -43, 1, 1900, 2017, 9999, -999    | 4     |
             * |                                 |     | uu      | -43, 01, 99, -99                  | 4     |
             * |                                 |     | uuu     | -043, 001, 123, 999, -999         | 4     |
             * |                                 |     | uuuu    | -0043, 0001, 2017, 9999, -9999    | 4     |
             * |                                 |     | uuuuu   | ...                               | 2,4   |
             * | Quarter (formatting)            | 120 | Q       | 1, 2, 3, 4                        |       |
             * |                                 |     | Qo      | 1st, 2nd, 3rd, 4th                | 5     |
             * |                                 |     | QQ      | 01, 02, 03, 04                    |       |
             * |                                 |     | QQQ     | Q1, Q2, Q3, Q4                    |       |
             * |                                 |     | QQQQ    | 1st quarter, 2nd quarter, ...     | 2     |
             * |                                 |     | QQQQQ   | 1, 2, 3, 4                        | 4     |
             * | Quarter (stand-alone)           | 120 | q       | 1, 2, 3, 4                        |       |
             * |                                 |     | qo      | 1st, 2nd, 3rd, 4th                | 5     |
             * |                                 |     | qq      | 01, 02, 03, 04                    |       |
             * |                                 |     | qqq     | Q1, Q2, Q3, Q4                    |       |
             * |                                 |     | qqqq    | 1st quarter, 2nd quarter, ...     | 2     |
             * |                                 |     | qqqqq   | 1, 2, 3, 4                        | 3     |
             * | Month (formatting)              | 110 | M       | 1, 2, ..., 12                     |       |
             * |                                 |     | Mo      | 1st, 2nd, ..., 12th               | 5     |
             * |                                 |     | MM      | 01, 02, ..., 12                   |       |
             * |                                 |     | MMM     | Jan, Feb, ..., Dec                |       |
             * |                                 |     | MMMM    | January, February, ..., December  | 2     |
             * |                                 |     | MMMMM   | J, F, ..., D                      |       |
             * | Month (stand-alone)             | 110 | L       | 1, 2, ..., 12                     |       |
             * |                                 |     | Lo      | 1st, 2nd, ..., 12th               | 5     |
             * |                                 |     | LL      | 01, 02, ..., 12                   |       |
             * |                                 |     | LLL     | Jan, Feb, ..., Dec                |       |
             * |                                 |     | LLLL    | January, February, ..., December  | 2     |
             * |                                 |     | LLLLL   | J, F, ..., D                      |       |
             * | Local week of year              | 100 | w       | 1, 2, ..., 53                     |       |
             * |                                 |     | wo      | 1st, 2nd, ..., 53th               | 5     |
             * |                                 |     | ww      | 01, 02, ..., 53                   |       |
             * | ISO week of year                | 100 | I       | 1, 2, ..., 53                     | 5     |
             * |                                 |     | Io      | 1st, 2nd, ..., 53th               | 5     |
             * |                                 |     | II      | 01, 02, ..., 53                   | 5     |
             * | Day of month                    |  90 | d       | 1, 2, ..., 31                     |       |
             * |                                 |     | do      | 1st, 2nd, ..., 31st               | 5     |
             * |                                 |     | dd      | 01, 02, ..., 31                   |       |
             * | Day of year                     |  90 | D       | 1, 2, ..., 365, 366               | 7     |
             * |                                 |     | Do      | 1st, 2nd, ..., 365th, 366th       | 5     |
             * |                                 |     | DD      | 01, 02, ..., 365, 366             | 7     |
             * |                                 |     | DDD     | 001, 002, ..., 365, 366           |       |
             * |                                 |     | DDDD    | ...                               | 2     |
             * | Day of week (formatting)        |  90 | E..EEE  | Mon, Tue, Wed, ..., Sun           |       |
             * |                                 |     | EEEE    | Monday, Tuesday, ..., Sunday      | 2     |
             * |                                 |     | EEEEE   | M, T, W, T, F, S, S               |       |
             * |                                 |     | EEEEEE  | Mo, Tu, We, Th, Fr, Sa, Su        |       |
             * | ISO day of week (formatting)    |  90 | i       | 1, 2, 3, ..., 7                   | 5     |
             * |                                 |     | io      | 1st, 2nd, ..., 7th                | 5     |
             * |                                 |     | ii      | 01, 02, ..., 07                   | 5     |
             * |                                 |     | iii     | Mon, Tue, Wed, ..., Sun           | 5     |
             * |                                 |     | iiii    | Monday, Tuesday, ..., Sunday      | 2,5   |
             * |                                 |     | iiiii   | M, T, W, T, F, S, S               | 5     |
             * |                                 |     | iiiiii  | Mo, Tu, We, Th, Fr, Sa, Su        | 5     |
             * | Local day of week (formatting)  |  90 | e       | 2, 3, 4, ..., 1                   |       |
             * |                                 |     | eo      | 2nd, 3rd, ..., 1st                | 5     |
             * |                                 |     | ee      | 02, 03, ..., 01                   |       |
             * |                                 |     | eee     | Mon, Tue, Wed, ..., Sun           |       |
             * |                                 |     | eeee    | Monday, Tuesday, ..., Sunday      | 2     |
             * |                                 |     | eeeee   | M, T, W, T, F, S, S               |       |
             * |                                 |     | eeeeee  | Mo, Tu, We, Th, Fr, Sa, Su        |       |
             * | Local day of week (stand-alone) |  90 | c       | 2, 3, 4, ..., 1                   |       |
             * |                                 |     | co      | 2nd, 3rd, ..., 1st                | 5     |
             * |                                 |     | cc      | 02, 03, ..., 01                   |       |
             * |                                 |     | ccc     | Mon, Tue, Wed, ..., Sun           |       |
             * |                                 |     | cccc    | Monday, Tuesday, ..., Sunday      | 2     |
             * |                                 |     | ccccc   | M, T, W, T, F, S, S               |       |
             * |                                 |     | cccccc  | Mo, Tu, We, Th, Fr, Sa, Su        |       |
             * | AM, PM                          |  80 | a..aaa  | AM, PM                            |       |
             * |                                 |     | aaaa    | a.m., p.m.                        | 2     |
             * |                                 |     | aaaaa   | a, p                              |       |
             * | AM, PM, noon, midnight          |  80 | b..bbb  | AM, PM, noon, midnight            |       |
             * |                                 |     | bbbb    | a.m., p.m., noon, midnight        | 2     |
             * |                                 |     | bbbbb   | a, p, n, mi                       |       |
             * | Flexible day period             |  80 | B..BBB  | at night, in the morning, ...     |       |
             * |                                 |     | BBBB    | at night, in the morning, ...     | 2     |
             * |                                 |     | BBBBB   | at night, in the morning, ...     |       |
             * | Hour [1-12]                     |  70 | h       | 1, 2, ..., 11, 12                 |       |
             * |                                 |     | ho      | 1st, 2nd, ..., 11th, 12th         | 5     |
             * |                                 |     | hh      | 01, 02, ..., 11, 12               |       |
             * | Hour [0-23]                     |  70 | H       | 0, 1, 2, ..., 23                  |       |
             * |                                 |     | Ho      | 0th, 1st, 2nd, ..., 23rd          | 5     |
             * |                                 |     | HH      | 00, 01, 02, ..., 23               |       |
             * | Hour [0-11]                     |  70 | K       | 1, 2, ..., 11, 0                  |       |
             * |                                 |     | Ko      | 1st, 2nd, ..., 11th, 0th          | 5     |
             * |                                 |     | KK      | 01, 02, ..., 11, 00               |       |
             * | Hour [1-24]                     |  70 | k       | 24, 1, 2, ..., 23                 |       |
             * |                                 |     | ko      | 24th, 1st, 2nd, ..., 23rd         | 5     |
             * |                                 |     | kk      | 24, 01, 02, ..., 23               |       |
             * | Minute                          |  60 | m       | 0, 1, ..., 59                     |       |
             * |                                 |     | mo      | 0th, 1st, ..., 59th               | 5     |
             * |                                 |     | mm      | 00, 01, ..., 59                   |       |
             * | Second                          |  50 | s       | 0, 1, ..., 59                     |       |
             * |                                 |     | so      | 0th, 1st, ..., 59th               | 5     |
             * |                                 |     | ss      | 00, 01, ..., 59                   |       |
             * | Seconds timestamp               |  40 | t       | 512969520                         |       |
             * |                                 |     | tt      | ...                               | 2     |
             * | Fraction of second              |  30 | S       | 0, 1, ..., 9                      |       |
             * |                                 |     | SS      | 00, 01, ..., 99                   |       |
             * |                                 |     | SSS     | 000, 001, ..., 999                |       |
             * |                                 |     | SSSS    | ...                               | 2     |
             * | Milliseconds timestamp          |  20 | T       | 512969520900                      |       |
             * |                                 |     | TT      | ...                               | 2     |
             * | Timezone (ISO-8601 w/ Z)        |  10 | X       | -08, +0530, Z                     |       |
             * |                                 |     | XX      | -0800, +0530, Z                   |       |
             * |                                 |     | XXX     | -08:00, +05:30, Z                 |       |
             * |                                 |     | XXXX    | -0800, +0530, Z, +123456          | 2     |
             * |                                 |     | XXXXX   | -08:00, +05:30, Z, +12:34:56      |       |
             * | Timezone (ISO-8601 w/o Z)       |  10 | x       | -08, +0530, +00                   |       |
             * |                                 |     | xx      | -0800, +0530, +0000               |       |
             * |                                 |     | xxx     | -08:00, +05:30, +00:00            | 2     |
             * |                                 |     | xxxx    | -0800, +0530, +0000, +123456      |       |
             * |                                 |     | xxxxx   | -08:00, +05:30, +00:00, +12:34:56 |       |
             * | Long localized date             |  NA | P       | 05/29/1453                        | 5,8   |
             * |                                 |     | PP      | May 29, 1453                      |       |
             * |                                 |     | PPP     | May 29th, 1453                    |       |
             * |                                 |     | PPPP    | Sunday, May 29th, 1453            | 2,5,8 |
             * | Long localized time             |  NA | p       | 12:00 AM                          | 5,8   |
             * |                                 |     | pp      | 12:00:00 AM                       |       |
             * | Combination of date and time    |  NA | Pp      | 05/29/1453, 12:00 AM              |       |
             * |                                 |     | PPpp    | May 29, 1453, 12:00:00 AM         |       |
             * |                                 |     | PPPpp   | May 29th, 1453 at ...             |       |
             * |                                 |     | PPPPpp  | Sunday, May 29th, 1453 at ...     | 2,5,8 |
             * Notes:
             * 1. "Formatting" units (e.g. formatting quarter) in the default en-US locale
             *    are the same as "stand-alone" units, but are different in some languages.
             *    "Formatting" units are declined according to the rules of the language
             *    in the context of a date. "Stand-alone" units are always nominative singular.
             *    In `format` function, they will produce different result:
             *
             *    `format(new Date(2017, 10, 6), 'do LLLL', {locale: cs}) //=> '6. listopad'`
             *
             *    `format(new Date(2017, 10, 6), 'do MMMM', {locale: cs}) //=> '6. listopadu'`
             *
             *    `parse` will try to match both formatting and stand-alone units interchangably.
             *
             * 2. Any sequence of the identical letters is a pattern, unless it is escaped by
             *    the single quote characters (see below).
             *    If the sequence is longer than listed in table:
             *    - for numerical units (`yyyyyyyy`) `parse` will try to match a number
             *      as wide as the sequence
             *    - for text units (`MMMMMMMM`) `parse` will try to match the widest variation of the unit.
             *      These variations are marked with "2" in the last column of the table.
             *
             * 3. `QQQQQ` and `qqqqq` could be not strictly numerical in some locales.
             *    These tokens represent the shortest form of the quarter.
             *
             * 4. The main difference between `y` and `u` patterns are B.C. years:
             *
             *    | Year | `y` | `u` |
             *    |------|-----|-----|
             *    | AC 1 |   1 |   1 |
             *    | BC 1 |   1 |   0 |
             *    | BC 2 |   2 |  -1 |
             *
             *    Also `yy` will try to guess the century of two digit year by proximity with `referenceDate`:
             *
             *    `parse('50', 'yy', new Date(2018, 0, 1)) //=> Sat Jan 01 2050 00:00:00`
             *
             *    `parse('75', 'yy', new Date(2018, 0, 1)) //=> Wed Jan 01 1975 00:00:00`
             *
             *    while `uu` will just assign the year as is:
             *
             *    `parse('50', 'uu', new Date(2018, 0, 1)) //=> Sat Jan 01 0050 00:00:00`
             *
             *    `parse('75', 'uu', new Date(2018, 0, 1)) //=> Tue Jan 01 0075 00:00:00`
             *
             *    The same difference is true for local and ISO week-numbering years (`Y` and `R`),
             *    except local week-numbering years are dependent on `options.weekStartsOn`
             *    and `options.firstWeekContainsDate` (compare [setISOWeekYear]{@link https://date-fns.org/docs/setISOWeekYear}
             *    and [setWeekYear]{@link https://date-fns.org/docs/setWeekYear}).
             *
             * 5. These patterns are not in the Unicode Technical Standard #35:
             *    - `i`: ISO day of week
             *    - `I`: ISO week of year
             *    - `R`: ISO week-numbering year
             *    - `o`: ordinal number modifier
             *    - `P`: long localized date
             *    - `p`: long localized time
             *
             * 6. `YY` and `YYYY` tokens represent week-numbering years but they are often confused with years.
             *    You should enable `options.useAdditionalWeekYearTokens` to use them. See: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
             *
             * 7. `D` and `DD` tokens represent days of the year but they are ofthen confused with days of the month.
             *    You should enable `options.useAdditionalDayOfYearTokens` to use them. See: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
             *
             * 8. `P+` tokens do not have a defined priority since they are merely aliases to other tokens based
             *    on the given locale.
             *
             *    using `en-US` locale: `P` => `MM/dd/yyyy`
             *    using `en-US` locale: `p` => `hh:mm a`
             *    using `pt-BR` locale: `P` => `dd/MM/yyyy`
             *    using `pt-BR` locale: `p` => `HH:mm`
             *
             * Values will be assigned to the date in the descending order of its unit's priority.
             * Units of an equal priority overwrite each other in the order of appearance.
             *
             * If no values of higher priority are parsed (e.g. when parsing string 'January 1st' without a year),
             * the values will be taken from 3rd argument `referenceDate` which works as a context of parsing.
             *
             * `referenceDate` must be passed for correct work of the function.
             * If you're not sure which `referenceDate` to supply, create a new instance of Date:
             * `parse('02/11/2014', 'MM/dd/yyyy', new Date())`
             * In this case parsing will be done in the context of the current date.
             * If `referenceDate` is `Invalid Date` or a value not convertible to valid `Date`,
             * then `Invalid Date` will be returned.
             *
             * The result may vary by locale.
             *
             * If `formatString` matches with `dateString` but does not provides tokens, `referenceDate` will be returned.
             *
             * If parsing failed, `Invalid Date` will be returned.
             * Invalid Date is a Date, whose time value is NaN.
             * Time value of Date: http://es5.github.io/#x15.9.1.1
             *
             * @param {String} dateString - the string to parse
             * @param {String} formatString - the string of tokens
             * @param {Date|Number} referenceDate - defines values missing from the parsed dateString
             * @param {Object} [options] - an object with options.
             * @param {Locale} [options.locale=defaultLocale] - the locale object. See [Locale]{@link https://date-fns.org/docs/Locale}
             * @param {0|1|2|3|4|5|6} [options.weekStartsOn=0] - the index of the first day of the week (0 - Sunday)
             * @param {1|2|3|4|5|6|7} [options.firstWeekContainsDate=1] - the day of January, which is always in the first week of the year
             * @param {Boolean} [options.useAdditionalWeekYearTokens=false] - if true, allows usage of the week-numbering year tokens `YY` and `YYYY`;
             *   see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
             * @param {Boolean} [options.useAdditionalDayOfYearTokens=false] - if true, allows usage of the day of year tokens `D` and `DD`;
             *   see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
             * @returns {Date} the parsed date
             * @throws {TypeError} 3 arguments required
             * @throws {RangeError} `options.weekStartsOn` must be between 0 and 6
             * @throws {RangeError} `options.firstWeekContainsDate` must be between 1 and 7
             * @throws {RangeError} `options.locale` must contain `match` property
             * @throws {RangeError} use `yyyy` instead of `YYYY` for formatting years using [format provided] to the input [input provided]; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
             * @throws {RangeError} use `yy` instead of `YY` for formatting years using [format provided] to the input [input provided]; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
             * @throws {RangeError} use `d` instead of `D` for formatting days of the month using [format provided] to the input [input provided]; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
             * @throws {RangeError} use `dd` instead of `DD` for formatting days of the month using [format provided] to the input [input provided]; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
             * @throws {RangeError} format string contains an unescaped latin alphabet character
             *
             * @example
             * // Parse 11 February 2014 from middle-endian format:
             * var result = parse('02/11/2014', 'MM/dd/yyyy', new Date())
             * //=> Tue Feb 11 2014 00:00:00
             *
             * @example
             * // Parse 28th of February in Esperanto locale in the context of 2010 year:
             * import eo from 'date-fns/locale/eo'
             * var result = parse('28-a de februaro', "do 'de' MMMM", new Date(2010, 0, 1), {
             *   locale: eo
             * })
             * //=> Sun Feb 28 2010 00:00:00
             */
            function parse(dirtyDateString, dirtyFormatString, dirtyReferenceDate, options) {
                var _ref, _options$locale, _ref2, _ref3, _ref4, _options$firstWeekCon, _options$locale2, _options$locale2$opti, _defaultOptions$local, _defaultOptions$local2, _ref5, _ref6, _ref7, _options$weekStartsOn, _options$locale3, _options$locale3$opti, _defaultOptions$local3, _defaultOptions$local4;
                (0, _lib_requiredArgs_index_js__WEBPACK_IMPORTED_MODULE_2__["default"])(3, arguments);
                var dateString = String(dirtyDateString);
                var formatString = String(dirtyFormatString);
                var defaultOptions = (0, _lib_defaultOptions_index_js__WEBPACK_IMPORTED_MODULE_3__.getDefaultOptions)();
                var locale = (_ref = (_options$locale = options === null || options === void 0 ? void 0 : options.locale) !== null && _options$locale !== void 0 ? _options$locale : defaultOptions.locale) !== null && _ref !== void 0 ? _ref : _lib_defaultLocale_index_js__WEBPACK_IMPORTED_MODULE_4__["default"];
                if (!locale.match) {
                    throw new RangeError('locale must contain match property');
                }
                var firstWeekContainsDate = (0, _lib_toInteger_index_js__WEBPACK_IMPORTED_MODULE_5__["default"])((_ref2 = (_ref3 = (_ref4 = (_options$firstWeekCon = options === null || options === void 0 ? void 0 : options.firstWeekContainsDate) !== null && _options$firstWeekCon !== void 0 ? _options$firstWeekCon : options === null || options === void 0 ? void 0 : (_options$locale2 = options.locale) === null || _options$locale2 === void 0 ? void 0 : (_options$locale2$opti = _options$locale2.options) === null || _options$locale2$opti === void 0 ? void 0 : _options$locale2$opti.firstWeekContainsDate) !== null && _ref4 !== void 0 ? _ref4 : defaultOptions.firstWeekContainsDate) !== null && _ref3 !== void 0 ? _ref3 : (_defaultOptions$local = defaultOptions.locale) === null || _defaultOptions$local === void 0 ? void 0 : (_defaultOptions$local2 = _defaultOptions$local.options) === null || _defaultOptions$local2 === void 0 ? void 0 : _defaultOptions$local2.firstWeekContainsDate) !== null && _ref2 !== void 0 ? _ref2 : 1);
                // Test if weekStartsOn is between 1 and 7 _and_ is not NaN
                if (!(firstWeekContainsDate >= 1 && firstWeekContainsDate <= 7)) {
                    throw new RangeError('firstWeekContainsDate must be between 1 and 7 inclusively');
                }
                var weekStartsOn = (0, _lib_toInteger_index_js__WEBPACK_IMPORTED_MODULE_5__["default"])((_ref5 = (_ref6 = (_ref7 = (_options$weekStartsOn = options === null || options === void 0 ? void 0 : options.weekStartsOn) !== null && _options$weekStartsOn !== void 0 ? _options$weekStartsOn : options === null || options === void 0 ? void 0 : (_options$locale3 = options.locale) === null || _options$locale3 === void 0 ? void 0 : (_options$locale3$opti = _options$locale3.options) === null || _options$locale3$opti === void 0 ? void 0 : _options$locale3$opti.weekStartsOn) !== null && _ref7 !== void 0 ? _ref7 : defaultOptions.weekStartsOn) !== null && _ref6 !== void 0 ? _ref6 : (_defaultOptions$local3 = defaultOptions.locale) === null || _defaultOptions$local3 === void 0 ? void 0 : (_defaultOptions$local4 = _defaultOptions$local3.options) === null || _defaultOptions$local4 === void 0 ? void 0 : _defaultOptions$local4.weekStartsOn) !== null && _ref5 !== void 0 ? _ref5 : 0);
                // Test if weekStartsOn is between 0 and 6 _and_ is not NaN
                if (!(weekStartsOn >= 0 && weekStartsOn <= 6)) {
                    throw new RangeError('weekStartsOn must be between 0 and 6 inclusively');
                }
                if (formatString === '') {
                    if (dateString === '') {
                        return (0, _toDate_index_js__WEBPACK_IMPORTED_MODULE_6__["default"])(dirtyReferenceDate);
                    }
                    else {
                        return new Date(NaN);
                    }
                }
                var subFnOptions = {
                    firstWeekContainsDate: firstWeekContainsDate,
                    weekStartsOn: weekStartsOn,
                    locale: locale
                };
                // If timezone isn't specified, it will be set to the system timezone
                var setters = [new _lib_Setter_js__WEBPACK_IMPORTED_MODULE_7__.DateToSystemTimezoneSetter()];
                var tokens = formatString.match(longFormattingTokensRegExp).map(function (substring) {
                    var firstCharacter = substring[0];
                    if (firstCharacter in _lib_format_longFormatters_index_js__WEBPACK_IMPORTED_MODULE_8__["default"]) {
                        var longFormatter = _lib_format_longFormatters_index_js__WEBPACK_IMPORTED_MODULE_8__["default"][firstCharacter];
                        return longFormatter(substring, locale.formatLong);
                    }
                    return substring;
                }).join('').match(formattingTokensRegExp);
                var usedTokens = [];
                var _iterator = (0, _babel_runtime_helpers_esm_createForOfIteratorHelper__WEBPACK_IMPORTED_MODULE_1__["default"])(tokens), _step;
                try {
                    var _loop = function _loop() {
                        var token = _step.value;
                        if (!(options !== null && options !== void 0 && options.useAdditionalWeekYearTokens) && (0, _lib_protectedTokens_index_js__WEBPACK_IMPORTED_MODULE_9__.isProtectedWeekYearToken)(token)) {
                            (0, _lib_protectedTokens_index_js__WEBPACK_IMPORTED_MODULE_9__.throwProtectedError)(token, formatString, dirtyDateString);
                        }
                        if (!(options !== null && options !== void 0 && options.useAdditionalDayOfYearTokens) && (0, _lib_protectedTokens_index_js__WEBPACK_IMPORTED_MODULE_9__.isProtectedDayOfYearToken)(token)) {
                            (0, _lib_protectedTokens_index_js__WEBPACK_IMPORTED_MODULE_9__.throwProtectedError)(token, formatString, dirtyDateString);
                        }
                        var firstCharacter = token[0];
                        var parser = _lib_parsers_index_js__WEBPACK_IMPORTED_MODULE_10__.parsers[firstCharacter];
                        if (parser) {
                            var incompatibleTokens = parser.incompatibleTokens;
                            if (Array.isArray(incompatibleTokens)) {
                                var incompatibleToken = usedTokens.find(function (usedToken) {
                                    return incompatibleTokens.includes(usedToken.token) || usedToken.token === firstCharacter;
                                });
                                if (incompatibleToken) {
                                    throw new RangeError("The format string mustn't contain `".concat(incompatibleToken.fullToken, "` and `").concat(token, "` at the same time"));
                                }
                            }
                            else if (parser.incompatibleTokens === '*' && usedTokens.length > 0) {
                                throw new RangeError("The format string mustn't contain `".concat(token, "` and any other token at the same time"));
                            }
                            usedTokens.push({
                                token: firstCharacter,
                                fullToken: token
                            });
                            var parseResult = parser.run(dateString, token, locale.match, subFnOptions);
                            if (!parseResult) {
                                return {
                                    v: new Date(NaN)
                                };
                            }
                            setters.push(parseResult.setter);
                            dateString = parseResult.rest;
                        }
                        else {
                            if (firstCharacter.match(unescapedLatinCharacterRegExp)) {
                                throw new RangeError('Format string contains an unescaped latin alphabet character `' + firstCharacter + '`');
                            }
                            // Replace two single quote characters with one single quote character
                            if (token === "''") {
                                token = "'";
                            }
                            else if (firstCharacter === "'") {
                                token = cleanEscapedString(token);
                            }
                            // Cut token from string, or, if string doesn't match the token, return Invalid Date
                            if (dateString.indexOf(token) === 0) {
                                dateString = dateString.slice(token.length);
                            }
                            else {
                                return {
                                    v: new Date(NaN)
                                };
                            }
                        }
                    };
                    for (_iterator.s(); !(_step = _iterator.n()).done;) {
                        var _ret = _loop();
                        if ((0, _babel_runtime_helpers_esm_typeof__WEBPACK_IMPORTED_MODULE_0__["default"])(_ret) === "object")
                            return _ret.v;
                    }
                    // Check if the remaining input contains something other than whitespace
                }
                catch (err) {
                    _iterator.e(err);
                }
                finally {
                    _iterator.f();
                }
                if (dateString.length > 0 && notWhitespaceRegExp.test(dateString)) {
                    return new Date(NaN);
                }
                var uniquePrioritySetters = setters.map(function (setter) {
                    return setter.priority;
                }).sort(function (a, b) {
                    return b - a;
                }).filter(function (priority, index, array) {
                    return array.indexOf(priority) === index;
                }).map(function (priority) {
                    return setters.filter(function (setter) {
                        return setter.priority === priority;
                    }).sort(function (a, b) {
                        return b.subPriority - a.subPriority;
                    });
                }).map(function (setterArray) {
                    return setterArray[0];
                });
                var date = (0, _toDate_index_js__WEBPACK_IMPORTED_MODULE_6__["default"])(dirtyReferenceDate);
                if (isNaN(date.getTime())) {
                    return new Date(NaN);
                }
                // Convert the date in system timezone to the same date in UTC+00:00 timezone.
                var utcDate = (0, _subMilliseconds_index_js__WEBPACK_IMPORTED_MODULE_11__["default"])(date, (0, _lib_getTimezoneOffsetInMilliseconds_index_js__WEBPACK_IMPORTED_MODULE_12__["default"])(date));
                var flags = {};
                var _iterator2 = (0, _babel_runtime_helpers_esm_createForOfIteratorHelper__WEBPACK_IMPORTED_MODULE_1__["default"])(uniquePrioritySetters), _step2;
                try {
                    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
                        var setter = _step2.value;
                        if (!setter.validate(utcDate, subFnOptions)) {
                            return new Date(NaN);
                        }
                        var result = setter.set(utcDate, flags, subFnOptions);
                        // Result is tuple (date, flags)
                        if (Array.isArray(result)) {
                            utcDate = result[0];
                            (0, _lib_assign_index_js__WEBPACK_IMPORTED_MODULE_13__["default"])(flags, result[1]);
                            // Result is date
                        }
                        else {
                            utcDate = result;
                        }
                    }
                }
                catch (err) {
                    _iterator2.e(err);
                }
                finally {
                    _iterator2.f();
                }
                return utcDate;
            }
            function cleanEscapedString(input) {
                return input.match(escapedStringRegExp)[1].replace(doubleQuoteRegExp, "'");
            }
            /***/ 
        }),
        /***/ "./node_modules/date-fns/esm/parseISO/index.js": 
        /*!*****************************************************!*\
          !*** ./node_modules/date-fns/esm/parseISO/index.js ***!
          \*****************************************************/
        /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony export */ __webpack_require__.d(__webpack_exports__, {
                /* harmony export */ "default": () => ( /* binding */parseISO)
                /* harmony export */ 
            });
            /* harmony import */ var _constants_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../constants/index.js */ "./node_modules/date-fns/esm/constants/index.js");
            /* harmony import */ var _lib_requiredArgs_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../_lib/requiredArgs/index.js */ "./node_modules/date-fns/esm/_lib/requiredArgs/index.js");
            /* harmony import */ var _lib_toInteger_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../_lib/toInteger/index.js */ "./node_modules/date-fns/esm/_lib/toInteger/index.js");
            /**
             * @name parseISO
             * @category Common Helpers
             * @summary Parse ISO string
             *
             * @description
             * Parse the given string in ISO 8601 format and return an instance of Date.
             *
             * Function accepts complete ISO 8601 formats as well as partial implementations.
             * ISO 8601: http://en.wikipedia.org/wiki/ISO_8601
             *
             * If the argument isn't a string, the function cannot parse the string or
             * the values are invalid, it returns Invalid Date.
             *
             * @param {String} argument - the value to convert
             * @param {Object} [options] - an object with options.
             * @param {0|1|2} [options.additionalDigits=2] - the additional number of digits in the extended year format
             * @returns {Date} the parsed date in the local time zone
             * @throws {TypeError} 1 argument required
             * @throws {RangeError} `options.additionalDigits` must be 0, 1 or 2
             *
             * @example
             * // Convert string '2014-02-11T11:30:30' to date:
             * const result = parseISO('2014-02-11T11:30:30')
             * //=> Tue Feb 11 2014 11:30:30
             *
             * @example
             * // Convert string '+02014101' to date,
             * // if the additional number of digits in the extended year format is 1:
             * const result = parseISO('+02014101', { additionalDigits: 1 })
             * //=> Fri Apr 11 2014 00:00:00
             */
            function parseISO(argument, options) {
                var _options$additionalDi;
                (0, _lib_requiredArgs_index_js__WEBPACK_IMPORTED_MODULE_0__["default"])(1, arguments);
                var additionalDigits = (0, _lib_toInteger_index_js__WEBPACK_IMPORTED_MODULE_1__["default"])((_options$additionalDi = options === null || options === void 0 ? void 0 : options.additionalDigits) !== null && _options$additionalDi !== void 0 ? _options$additionalDi : 2);
                if (additionalDigits !== 2 && additionalDigits !== 1 && additionalDigits !== 0) {
                    throw new RangeError('additionalDigits must be 0, 1 or 2');
                }
                if (!(typeof argument === 'string' || Object.prototype.toString.call(argument) === '[object String]')) {
                    return new Date(NaN);
                }
                var dateStrings = splitDateString(argument);
                var date;
                if (dateStrings.date) {
                    var parseYearResult = parseYear(dateStrings.date, additionalDigits);
                    date = parseDate(parseYearResult.restDateString, parseYearResult.year);
                }
                if (!date || isNaN(date.getTime())) {
                    return new Date(NaN);
                }
                var timestamp = date.getTime();
                var time = 0;
                var offset;
                if (dateStrings.time) {
                    time = parseTime(dateStrings.time);
                    if (isNaN(time)) {
                        return new Date(NaN);
                    }
                }
                if (dateStrings.timezone) {
                    offset = parseTimezone(dateStrings.timezone);
                    if (isNaN(offset)) {
                        return new Date(NaN);
                    }
                }
                else {
                    var dirtyDate = new Date(timestamp + time);
                    // js parsed string assuming it's in UTC timezone
                    // but we need it to be parsed in our timezone
                    // so we use utc values to build date in our timezone.
                    // Year values from 0 to 99 map to the years 1900 to 1999
                    // so set year explicitly with setFullYear.
                    var result = new Date(0);
                    result.setFullYear(dirtyDate.getUTCFullYear(), dirtyDate.getUTCMonth(), dirtyDate.getUTCDate());
                    result.setHours(dirtyDate.getUTCHours(), dirtyDate.getUTCMinutes(), dirtyDate.getUTCSeconds(), dirtyDate.getUTCMilliseconds());
                    return result;
                }
                return new Date(timestamp + time + offset);
            }
            var patterns = {
                dateTimeDelimiter: /[T ]/,
                timeZoneDelimiter: /[Z ]/i,
                timezone: /([Z+-].*)$/
            };
            var dateRegex = /^-?(?:(\d{3})|(\d{2})(?:-?(\d{2}))?|W(\d{2})(?:-?(\d{1}))?|)$/;
            var timeRegex = /^(\d{2}(?:[.,]\d*)?)(?::?(\d{2}(?:[.,]\d*)?))?(?::?(\d{2}(?:[.,]\d*)?))?$/;
            var timezoneRegex = /^([+-])(\d{2})(?::?(\d{2}))?$/;
            function splitDateString(dateString) {
                var dateStrings = {};
                var array = dateString.split(patterns.dateTimeDelimiter);
                var timeString;
                // The regex match should only return at maximum two array elements.
                // [date], [time], or [date, time].
                if (array.length > 2) {
                    return dateStrings;
                }
                if (/:/.test(array[0])) {
                    timeString = array[0];
                }
                else {
                    dateStrings.date = array[0];
                    timeString = array[1];
                    if (patterns.timeZoneDelimiter.test(dateStrings.date)) {
                        dateStrings.date = dateString.split(patterns.timeZoneDelimiter)[0];
                        timeString = dateString.substr(dateStrings.date.length, dateString.length);
                    }
                }
                if (timeString) {
                    var token = patterns.timezone.exec(timeString);
                    if (token) {
                        dateStrings.time = timeString.replace(token[1], '');
                        dateStrings.timezone = token[1];
                    }
                    else {
                        dateStrings.time = timeString;
                    }
                }
                return dateStrings;
            }
            function parseYear(dateString, additionalDigits) {
                var regex = new RegExp('^(?:(\\d{4}|[+-]\\d{' + (4 + additionalDigits) + '})|(\\d{2}|[+-]\\d{' + (2 + additionalDigits) + '})$)');
                var captures = dateString.match(regex);
                // Invalid ISO-formatted year
                if (!captures)
                    return {
                        year: NaN,
                        restDateString: ''
                    };
                var year = captures[1] ? parseInt(captures[1]) : null;
                var century = captures[2] ? parseInt(captures[2]) : null;
                // either year or century is null, not both
                return {
                    year: century === null ? year : century * 100,
                    restDateString: dateString.slice((captures[1] || captures[2]).length)
                };
            }
            function parseDate(dateString, year) {
                // Invalid ISO-formatted year
                if (year === null)
                    return new Date(NaN);
                var captures = dateString.match(dateRegex);
                // Invalid ISO-formatted string
                if (!captures)
                    return new Date(NaN);
                var isWeekDate = !!captures[4];
                var dayOfYear = parseDateUnit(captures[1]);
                var month = parseDateUnit(captures[2]) - 1;
                var day = parseDateUnit(captures[3]);
                var week = parseDateUnit(captures[4]);
                var dayOfWeek = parseDateUnit(captures[5]) - 1;
                if (isWeekDate) {
                    if (!validateWeekDate(year, week, dayOfWeek)) {
                        return new Date(NaN);
                    }
                    return dayOfISOWeekYear(year, week, dayOfWeek);
                }
                else {
                    var date = new Date(0);
                    if (!validateDate(year, month, day) || !validateDayOfYearDate(year, dayOfYear)) {
                        return new Date(NaN);
                    }
                    date.setUTCFullYear(year, month, Math.max(dayOfYear, day));
                    return date;
                }
            }
            function parseDateUnit(value) {
                return value ? parseInt(value) : 1;
            }
            function parseTime(timeString) {
                var captures = timeString.match(timeRegex);
                if (!captures)
                    return NaN; // Invalid ISO-formatted time
                var hours = parseTimeUnit(captures[1]);
                var minutes = parseTimeUnit(captures[2]);
                var seconds = parseTimeUnit(captures[3]);
                if (!validateTime(hours, minutes, seconds)) {
                    return NaN;
                }
                return hours * _constants_index_js__WEBPACK_IMPORTED_MODULE_2__.millisecondsInHour + minutes * _constants_index_js__WEBPACK_IMPORTED_MODULE_2__.millisecondsInMinute + seconds * 1000;
            }
            function parseTimeUnit(value) {
                return value && parseFloat(value.replace(',', '.')) || 0;
            }
            function parseTimezone(timezoneString) {
                if (timezoneString === 'Z')
                    return 0;
                var captures = timezoneString.match(timezoneRegex);
                if (!captures)
                    return 0;
                var sign = captures[1] === '+' ? -1 : 1;
                var hours = parseInt(captures[2]);
                var minutes = captures[3] && parseInt(captures[3]) || 0;
                if (!validateTimezone(hours, minutes)) {
                    return NaN;
                }
                return sign * (hours * _constants_index_js__WEBPACK_IMPORTED_MODULE_2__.millisecondsInHour + minutes * _constants_index_js__WEBPACK_IMPORTED_MODULE_2__.millisecondsInMinute);
            }
            function dayOfISOWeekYear(isoWeekYear, week, day) {
                var date = new Date(0);
                date.setUTCFullYear(isoWeekYear, 0, 4);
                var fourthOfJanuaryDay = date.getUTCDay() || 7;
                var diff = (week - 1) * 7 + day + 1 - fourthOfJanuaryDay;
                date.setUTCDate(date.getUTCDate() + diff);
                return date;
            }
            // Validation functions
            // February is null to handle the leap year (using ||)
            var daysInMonths = [31, null, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
            function isLeapYearIndex(year) {
                return year % 400 === 0 || year % 4 === 0 && year % 100 !== 0;
            }
            function validateDate(year, month, date) {
                return month >= 0 && month <= 11 && date >= 1 && date <= (daysInMonths[month] || (isLeapYearIndex(year) ? 29 : 28));
            }
            function validateDayOfYearDate(year, dayOfYear) {
                return dayOfYear >= 1 && dayOfYear <= (isLeapYearIndex(year) ? 366 : 365);
            }
            function validateWeekDate(_year, week, day) {
                return week >= 1 && week <= 53 && day >= 0 && day <= 6;
            }
            function validateTime(hours, minutes, seconds) {
                if (hours === 24) {
                    return minutes === 0 && seconds === 0;
                }
                return seconds >= 0 && seconds < 60 && minutes >= 0 && minutes < 60 && hours >= 0 && hours < 25;
            }
            function validateTimezone(_hours, minutes) {
                return minutes >= 0 && minutes <= 59;
            }
            /***/ 
        }),
        /***/ "./node_modules/date-fns/esm/previousDay/index.js": 
        /*!********************************************************!*\
          !*** ./node_modules/date-fns/esm/previousDay/index.js ***!
          \********************************************************/
        /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony export */ __webpack_require__.d(__webpack_exports__, {
                /* harmony export */ "default": () => ( /* binding */previousDay)
                /* harmony export */ 
            });
            /* harmony import */ var _lib_requiredArgs_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../_lib/requiredArgs/index.js */ "./node_modules/date-fns/esm/_lib/requiredArgs/index.js");
            /* harmony import */ var _getDay_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../getDay/index.js */ "./node_modules/date-fns/esm/getDay/index.js");
            /* harmony import */ var _subDays_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../subDays/index.js */ "./node_modules/date-fns/esm/subDays/index.js");
            /**
             * @name previousDay
             * @category Weekday Helpers
             * @summary When is the previous day of the week?
             *
             * @description
             * When is the previous day of the week? 0-6 the day of the week, 0 represents Sunday.
             *
             * @param {Date | number} date - the date to check
             * @param {number} day - day of the week
             * @returns {Date} - the date is the previous day of week
             * @throws {TypeError} - 2 arguments required
             *
             * @example
             * // When is the previous Monday before Mar, 20, 2020?
             * const result = previousDay(new Date(2020, 2, 20), 1)
             * //=> Mon Mar 16 2020 00:00:00
             *
             * @example
             * // When is the previous Tuesday before Mar, 21, 2020?
             * const result = previousDay(new Date(2020, 2, 21), 2)
             * //=> Tue Mar 17 2020 00:00:00
             */
            function previousDay(date, day) {
                (0, _lib_requiredArgs_index_js__WEBPACK_IMPORTED_MODULE_0__["default"])(2, arguments);
                var delta = (0, _getDay_index_js__WEBPACK_IMPORTED_MODULE_1__["default"])(date) - day;
                if (delta <= 0)
                    delta += 7;
                return (0, _subDays_index_js__WEBPACK_IMPORTED_MODULE_2__["default"])(date, delta);
            }
            /***/ 
        }),
        /***/ "./node_modules/date-fns/esm/previousFriday/index.js": 
        /*!***********************************************************!*\
          !*** ./node_modules/date-fns/esm/previousFriday/index.js ***!
          \***********************************************************/
        /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony export */ __webpack_require__.d(__webpack_exports__, {
                /* harmony export */ "default": () => ( /* binding */previousFriday)
                /* harmony export */ 
            });
            /* harmony import */ var _lib_requiredArgs_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../_lib/requiredArgs/index.js */ "./node_modules/date-fns/esm/_lib/requiredArgs/index.js");
            /* harmony import */ var _previousDay_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../previousDay/index.js */ "./node_modules/date-fns/esm/previousDay/index.js");
            /**
             * @name previousFriday
             * @category Weekday Helpers
             * @summary When is the previous Friday?
             *
             * @description
             * When is the previous Friday?
             *
             * @param {Date | number} date - the date to start counting from
             * @returns {Date} the previous Friday
             * @throws {TypeError} 1 argument required
             *
             * @example
             * // When is the previous Friday before Jun, 19, 2021?
             * const result = previousFriday(new Date(2021, 5, 19))
             * //=> Fri June 18 2021 00:00:00
             */
            function previousFriday(date) {
                (0, _lib_requiredArgs_index_js__WEBPACK_IMPORTED_MODULE_0__["default"])(1, arguments);
                return (0, _previousDay_index_js__WEBPACK_IMPORTED_MODULE_1__["default"])(date, 5);
            }
            /***/ 
        }),
        /***/ "./node_modules/date-fns/esm/startOfDay/index.js": 
        /*!*******************************************************!*\
          !*** ./node_modules/date-fns/esm/startOfDay/index.js ***!
          \*******************************************************/
        /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony export */ __webpack_require__.d(__webpack_exports__, {
                /* harmony export */ "default": () => ( /* binding */startOfDay)
                /* harmony export */ 
            });
            /* harmony import */ var _toDate_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../toDate/index.js */ "./node_modules/date-fns/esm/toDate/index.js");
            /* harmony import */ var _lib_requiredArgs_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../_lib/requiredArgs/index.js */ "./node_modules/date-fns/esm/_lib/requiredArgs/index.js");
            /**
             * @name startOfDay
             * @category Day Helpers
             * @summary Return the start of a day for the given date.
             *
             * @description
             * Return the start of a day for the given date.
             * The result will be in the local timezone.
             *
             * @param {Date|Number} date - the original date
             * @returns {Date} the start of a day
             * @throws {TypeError} 1 argument required
             *
             * @example
             * // The start of a day for 2 September 2014 11:55:00:
             * const result = startOfDay(new Date(2014, 8, 2, 11, 55, 0))
             * //=> Tue Sep 02 2014 00:00:00
             */
            function startOfDay(dirtyDate) {
                (0, _lib_requiredArgs_index_js__WEBPACK_IMPORTED_MODULE_0__["default"])(1, arguments);
                var date = (0, _toDate_index_js__WEBPACK_IMPORTED_MODULE_1__["default"])(dirtyDate);
                date.setHours(0, 0, 0, 0);
                return date;
            }
            /***/ 
        }),
        /***/ "./node_modules/date-fns/esm/startOfMonth/index.js": 
        /*!*********************************************************!*\
          !*** ./node_modules/date-fns/esm/startOfMonth/index.js ***!
          \*********************************************************/
        /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony export */ __webpack_require__.d(__webpack_exports__, {
                /* harmony export */ "default": () => ( /* binding */startOfMonth)
                /* harmony export */ 
            });
            /* harmony import */ var _toDate_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../toDate/index.js */ "./node_modules/date-fns/esm/toDate/index.js");
            /* harmony import */ var _lib_requiredArgs_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../_lib/requiredArgs/index.js */ "./node_modules/date-fns/esm/_lib/requiredArgs/index.js");
            /**
             * @name startOfMonth
             * @category Month Helpers
             * @summary Return the start of a month for the given date.
             *
             * @description
             * Return the start of a month for the given date.
             * The result will be in the local timezone.
             *
             * @param {Date|Number} date - the original date
             * @returns {Date} the start of a month
             * @throws {TypeError} 1 argument required
             *
             * @example
             * // The start of a month for 2 September 2014 11:55:00:
             * const result = startOfMonth(new Date(2014, 8, 2, 11, 55, 0))
             * //=> Mon Sep 01 2014 00:00:00
             */
            function startOfMonth(dirtyDate) {
                (0, _lib_requiredArgs_index_js__WEBPACK_IMPORTED_MODULE_0__["default"])(1, arguments);
                var date = (0, _toDate_index_js__WEBPACK_IMPORTED_MODULE_1__["default"])(dirtyDate);
                date.setDate(1);
                date.setHours(0, 0, 0, 0);
                return date;
            }
            /***/ 
        }),
        /***/ "./node_modules/date-fns/esm/startOfWeek/index.js": 
        /*!********************************************************!*\
          !*** ./node_modules/date-fns/esm/startOfWeek/index.js ***!
          \********************************************************/
        /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony export */ __webpack_require__.d(__webpack_exports__, {
                /* harmony export */ "default": () => ( /* binding */startOfWeek)
                /* harmony export */ 
            });
            /* harmony import */ var _toDate_index_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../toDate/index.js */ "./node_modules/date-fns/esm/toDate/index.js");
            /* harmony import */ var _lib_toInteger_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../_lib/toInteger/index.js */ "./node_modules/date-fns/esm/_lib/toInteger/index.js");
            /* harmony import */ var _lib_requiredArgs_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../_lib/requiredArgs/index.js */ "./node_modules/date-fns/esm/_lib/requiredArgs/index.js");
            /* harmony import */ var _lib_defaultOptions_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../_lib/defaultOptions/index.js */ "./node_modules/date-fns/esm/_lib/defaultOptions/index.js");
            /**
             * @name startOfWeek
             * @category Week Helpers
             * @summary Return the start of a week for the given date.
             *
             * @description
             * Return the start of a week for the given date.
             * The result will be in the local timezone.
             *
             * @param {Date|Number} date - the original date
             * @param {Object} [options] - an object with options.
             * @param {Locale} [options.locale=defaultLocale] - the locale object. See [Locale]{@link https://date-fns.org/docs/Locale}
             * @param {0|1|2|3|4|5|6} [options.weekStartsOn=0] - the index of the first day of the week (0 - Sunday)
             * @returns {Date} the start of a week
             * @throws {TypeError} 1 argument required
             * @throws {RangeError} `options.weekStartsOn` must be between 0 and 6
             *
             * @example
             * // The start of a week for 2 September 2014 11:55:00:
             * const result = startOfWeek(new Date(2014, 8, 2, 11, 55, 0))
             * //=> Sun Aug 31 2014 00:00:00
             *
             * @example
             * // If the week starts on Monday, the start of the week for 2 September 2014 11:55:00:
             * const result = startOfWeek(new Date(2014, 8, 2, 11, 55, 0), { weekStartsOn: 1 })
             * //=> Mon Sep 01 2014 00:00:00
             */
            function startOfWeek(dirtyDate, options) {
                var _ref, _ref2, _ref3, _options$weekStartsOn, _options$locale, _options$locale$optio, _defaultOptions$local, _defaultOptions$local2;
                (0, _lib_requiredArgs_index_js__WEBPACK_IMPORTED_MODULE_0__["default"])(1, arguments);
                var defaultOptions = (0, _lib_defaultOptions_index_js__WEBPACK_IMPORTED_MODULE_1__.getDefaultOptions)();
                var weekStartsOn = (0, _lib_toInteger_index_js__WEBPACK_IMPORTED_MODULE_2__["default"])((_ref = (_ref2 = (_ref3 = (_options$weekStartsOn = options === null || options === void 0 ? void 0 : options.weekStartsOn) !== null && _options$weekStartsOn !== void 0 ? _options$weekStartsOn : options === null || options === void 0 ? void 0 : (_options$locale = options.locale) === null || _options$locale === void 0 ? void 0 : (_options$locale$optio = _options$locale.options) === null || _options$locale$optio === void 0 ? void 0 : _options$locale$optio.weekStartsOn) !== null && _ref3 !== void 0 ? _ref3 : defaultOptions.weekStartsOn) !== null && _ref2 !== void 0 ? _ref2 : (_defaultOptions$local = defaultOptions.locale) === null || _defaultOptions$local === void 0 ? void 0 : (_defaultOptions$local2 = _defaultOptions$local.options) === null || _defaultOptions$local2 === void 0 ? void 0 : _defaultOptions$local2.weekStartsOn) !== null && _ref !== void 0 ? _ref : 0);
                // Test if weekStartsOn is between 0 and 6 _and_ is not NaN
                if (!(weekStartsOn >= 0 && weekStartsOn <= 6)) {
                    throw new RangeError('weekStartsOn must be between 0 and 6 inclusively');
                }
                var date = (0, _toDate_index_js__WEBPACK_IMPORTED_MODULE_3__["default"])(dirtyDate);
                var day = date.getDay();
                var diff = (day < weekStartsOn ? 7 : 0) + day - weekStartsOn;
                date.setDate(date.getDate() - diff);
                date.setHours(0, 0, 0, 0);
                return date;
            }
            /***/ 
        }),
        /***/ "./node_modules/date-fns/esm/subDays/index.js": 
        /*!****************************************************!*\
          !*** ./node_modules/date-fns/esm/subDays/index.js ***!
          \****************************************************/
        /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony export */ __webpack_require__.d(__webpack_exports__, {
                /* harmony export */ "default": () => ( /* binding */subDays)
                /* harmony export */ 
            });
            /* harmony import */ var _addDays_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../addDays/index.js */ "./node_modules/date-fns/esm/addDays/index.js");
            /* harmony import */ var _lib_requiredArgs_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../_lib/requiredArgs/index.js */ "./node_modules/date-fns/esm/_lib/requiredArgs/index.js");
            /* harmony import */ var _lib_toInteger_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../_lib/toInteger/index.js */ "./node_modules/date-fns/esm/_lib/toInteger/index.js");
            /**
             * @name subDays
             * @category Day Helpers
             * @summary Subtract the specified number of days from the given date.
             *
             * @description
             * Subtract the specified number of days from the given date.
             *
             * @param {Date|Number} date - the date to be changed
             * @param {Number} amount - the amount of days to be subtracted. Positive decimals will be rounded using `Math.floor`, decimals less than zero will be rounded using `Math.ceil`.
             * @returns {Date} the new date with the days subtracted
             * @throws {TypeError} 2 arguments required
             *
             * @example
             * // Subtract 10 days from 1 September 2014:
             * const result = subDays(new Date(2014, 8, 1), 10)
             * //=> Fri Aug 22 2014 00:00:00
             */
            function subDays(dirtyDate, dirtyAmount) {
                (0, _lib_requiredArgs_index_js__WEBPACK_IMPORTED_MODULE_0__["default"])(2, arguments);
                var amount = (0, _lib_toInteger_index_js__WEBPACK_IMPORTED_MODULE_1__["default"])(dirtyAmount);
                return (0, _addDays_index_js__WEBPACK_IMPORTED_MODULE_2__["default"])(dirtyDate, -amount);
            }
            /***/ 
        }),
        /***/ "./node_modules/date-fns/esm/subMilliseconds/index.js": 
        /*!************************************************************!*\
          !*** ./node_modules/date-fns/esm/subMilliseconds/index.js ***!
          \************************************************************/
        /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony export */ __webpack_require__.d(__webpack_exports__, {
                /* harmony export */ "default": () => ( /* binding */subMilliseconds)
                /* harmony export */ 
            });
            /* harmony import */ var _addMilliseconds_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../addMilliseconds/index.js */ "./node_modules/date-fns/esm/addMilliseconds/index.js");
            /* harmony import */ var _lib_requiredArgs_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../_lib/requiredArgs/index.js */ "./node_modules/date-fns/esm/_lib/requiredArgs/index.js");
            /* harmony import */ var _lib_toInteger_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../_lib/toInteger/index.js */ "./node_modules/date-fns/esm/_lib/toInteger/index.js");
            /**
             * @name subMilliseconds
             * @category Millisecond Helpers
             * @summary Subtract the specified number of milliseconds from the given date.
             *
             * @description
             * Subtract the specified number of milliseconds from the given date.
             *
             * @param {Date|Number} date - the date to be changed
             * @param {Number} amount - the amount of milliseconds to be subtracted. Positive decimals will be rounded using `Math.floor`, decimals less than zero will be rounded using `Math.ceil`.
             * @returns {Date} the new date with the milliseconds subtracted
             * @throws {TypeError} 2 arguments required
             *
             * @example
             * // Subtract 750 milliseconds from 10 July 2014 12:45:30.000:
             * const result = subMilliseconds(new Date(2014, 6, 10, 12, 45, 30, 0), 750)
             * //=> Thu Jul 10 2014 12:45:29.250
             */
            function subMilliseconds(dirtyDate, dirtyAmount) {
                (0, _lib_requiredArgs_index_js__WEBPACK_IMPORTED_MODULE_0__["default"])(2, arguments);
                var amount = (0, _lib_toInteger_index_js__WEBPACK_IMPORTED_MODULE_1__["default"])(dirtyAmount);
                return (0, _addMilliseconds_index_js__WEBPACK_IMPORTED_MODULE_2__["default"])(dirtyDate, -amount);
            }
            /***/ 
        }),
        /***/ "./node_modules/date-fns/esm/subMonths/index.js": 
        /*!******************************************************!*\
          !*** ./node_modules/date-fns/esm/subMonths/index.js ***!
          \******************************************************/
        /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony export */ __webpack_require__.d(__webpack_exports__, {
                /* harmony export */ "default": () => ( /* binding */subMonths)
                /* harmony export */ 
            });
            /* harmony import */ var _lib_toInteger_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../_lib/toInteger/index.js */ "./node_modules/date-fns/esm/_lib/toInteger/index.js");
            /* harmony import */ var _addMonths_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../addMonths/index.js */ "./node_modules/date-fns/esm/addMonths/index.js");
            /* harmony import */ var _lib_requiredArgs_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../_lib/requiredArgs/index.js */ "./node_modules/date-fns/esm/_lib/requiredArgs/index.js");
            /**
             * @name subMonths
             * @category Month Helpers
             * @summary Subtract the specified number of months from the given date.
             *
             * @description
             * Subtract the specified number of months from the given date.
             *
             * @param {Date|Number} date - the date to be changed
             * @param {Number} amount - the amount of months to be subtracted. Positive decimals will be rounded using `Math.floor`, decimals less than zero will be rounded using `Math.ceil`.
             * @returns {Date} the new date with the months subtracted
             * @throws {TypeError} 2 arguments required
             *
             * @example
             * // Subtract 5 months from 1 February 2015:
             * const result = subMonths(new Date(2015, 1, 1), 5)
             * //=> Mon Sep 01 2014 00:00:00
             */
            function subMonths(dirtyDate, dirtyAmount) {
                (0, _lib_requiredArgs_index_js__WEBPACK_IMPORTED_MODULE_0__["default"])(2, arguments);
                var amount = (0, _lib_toInteger_index_js__WEBPACK_IMPORTED_MODULE_1__["default"])(dirtyAmount);
                return (0, _addMonths_index_js__WEBPACK_IMPORTED_MODULE_2__["default"])(dirtyDate, -amount);
            }
            /***/ 
        }),
        /***/ "./node_modules/date-fns/esm/subWeeks/index.js": 
        /*!*****************************************************!*\
          !*** ./node_modules/date-fns/esm/subWeeks/index.js ***!
          \*****************************************************/
        /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony export */ __webpack_require__.d(__webpack_exports__, {
                /* harmony export */ "default": () => ( /* binding */subWeeks)
                /* harmony export */ 
            });
            /* harmony import */ var _lib_toInteger_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../_lib/toInteger/index.js */ "./node_modules/date-fns/esm/_lib/toInteger/index.js");
            /* harmony import */ var _addWeeks_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../addWeeks/index.js */ "./node_modules/date-fns/esm/addWeeks/index.js");
            /* harmony import */ var _lib_requiredArgs_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../_lib/requiredArgs/index.js */ "./node_modules/date-fns/esm/_lib/requiredArgs/index.js");
            /**
             * @name subWeeks
             * @category Week Helpers
             * @summary Subtract the specified number of weeks from the given date.
             *
             * @description
             * Subtract the specified number of weeks from the given date.
             *
             * @param {Date|Number} date - the date to be changed
             * @param {Number} amount - the amount of weeks to be subtracted. Positive decimals will be rounded using `Math.floor`, decimals less than zero will be rounded using `Math.ceil`.
             * @returns {Date} the new date with the weeks subtracted
             * @throws {TypeError} 2 arguments required
             *
             * @example
             * // Subtract 4 weeks from 1 September 2014:
             * const result = subWeeks(new Date(2014, 8, 1), 4)
             * //=> Mon Aug 04 2014 00:00:00
             */
            function subWeeks(dirtyDate, dirtyAmount) {
                (0, _lib_requiredArgs_index_js__WEBPACK_IMPORTED_MODULE_0__["default"])(2, arguments);
                var amount = (0, _lib_toInteger_index_js__WEBPACK_IMPORTED_MODULE_1__["default"])(dirtyAmount);
                return (0, _addWeeks_index_js__WEBPACK_IMPORTED_MODULE_2__["default"])(dirtyDate, -amount);
            }
            /***/ 
        }),
        /***/ "./node_modules/date-fns/esm/subYears/index.js": 
        /*!*****************************************************!*\
          !*** ./node_modules/date-fns/esm/subYears/index.js ***!
          \*****************************************************/
        /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony export */ __webpack_require__.d(__webpack_exports__, {
                /* harmony export */ "default": () => ( /* binding */subYears)
                /* harmony export */ 
            });
            /* harmony import */ var _lib_toInteger_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../_lib/toInteger/index.js */ "./node_modules/date-fns/esm/_lib/toInteger/index.js");
            /* harmony import */ var _addYears_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../addYears/index.js */ "./node_modules/date-fns/esm/addYears/index.js");
            /* harmony import */ var _lib_requiredArgs_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../_lib/requiredArgs/index.js */ "./node_modules/date-fns/esm/_lib/requiredArgs/index.js");
            /**
             * @name subYears
             * @category Year Helpers
             * @summary Subtract the specified number of years from the given date.
             *
             * @description
             * Subtract the specified number of years from the given date.
             *
             * @param {Date|Number} date - the date to be changed
             * @param {Number} amount - the amount of years to be subtracted. Positive decimals will be rounded using `Math.floor`, decimals less than zero will be rounded using `Math.ceil`.
             * @returns {Date} the new date with the years subtracted
             * @throws {TypeError} 2 arguments required
             *
             * @example
             * // Subtract 5 years from 1 September 2014:
             * const result = subYears(new Date(2014, 8, 1), 5)
             * //=> Tue Sep 01 2009 00:00:00
             */
            function subYears(dirtyDate, dirtyAmount) {
                (0, _lib_requiredArgs_index_js__WEBPACK_IMPORTED_MODULE_0__["default"])(2, arguments);
                var amount = (0, _lib_toInteger_index_js__WEBPACK_IMPORTED_MODULE_1__["default"])(dirtyAmount);
                return (0, _addYears_index_js__WEBPACK_IMPORTED_MODULE_2__["default"])(dirtyDate, -amount);
            }
            /***/ 
        }),
        /***/ "./node_modules/date-fns/esm/toDate/index.js": 
        /*!***************************************************!*\
          !*** ./node_modules/date-fns/esm/toDate/index.js ***!
          \***************************************************/
        /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony export */ __webpack_require__.d(__webpack_exports__, {
                /* harmony export */ "default": () => ( /* binding */toDate)
                /* harmony export */ 
            });
            /* harmony import */ var _babel_runtime_helpers_esm_typeof__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/typeof */ "./node_modules/@babel/runtime/helpers/esm/typeof.js");
            /* harmony import */ var _lib_requiredArgs_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../_lib/requiredArgs/index.js */ "./node_modules/date-fns/esm/_lib/requiredArgs/index.js");
            /**
             * @name toDate
             * @category Common Helpers
             * @summary Convert the given argument to an instance of Date.
             *
             * @description
             * Convert the given argument to an instance of Date.
             *
             * If the argument is an instance of Date, the function returns its clone.
             *
             * If the argument is a number, it is treated as a timestamp.
             *
             * If the argument is none of the above, the function returns Invalid Date.
             *
             * **Note**: *all* Date arguments passed to any *date-fns* function is processed by `toDate`.
             *
             * @param {Date|Number} argument - the value to convert
             * @returns {Date} the parsed date in the local time zone
             * @throws {TypeError} 1 argument required
             *
             * @example
             * // Clone the date:
             * const result = toDate(new Date(2014, 1, 11, 11, 30, 30))
             * //=> Tue Feb 11 2014 11:30:30
             *
             * @example
             * // Convert the timestamp to date:
             * const result = toDate(1392098430000)
             * //=> Tue Feb 11 2014 11:30:30
             */
            function toDate(argument) {
                (0, _lib_requiredArgs_index_js__WEBPACK_IMPORTED_MODULE_1__["default"])(1, arguments);
                var argStr = Object.prototype.toString.call(argument);
                // Clone the date
                if (argument instanceof Date || (0, _babel_runtime_helpers_esm_typeof__WEBPACK_IMPORTED_MODULE_0__["default"])(argument) === 'object' && argStr === '[object Date]') {
                    // Prevent the date to lose the milliseconds when passed to new Date() in IE10
                    return new Date(argument.getTime());
                }
                else if (typeof argument === 'number' || argStr === '[object Number]') {
                    return new Date(argument);
                }
                else {
                    if ((typeof argument === 'string' || argStr === '[object String]') && typeof console !== 'undefined') {
                        // eslint-disable-next-line no-console
                        console.warn("Starting with v2.0.0-beta.1 date-fns doesn't accept strings as date arguments. Please use `parseISO` to parse strings. See: https://github.com/date-fns/date-fns/blob/master/docs/upgradeGuide.md#string-arguments");
                        // eslint-disable-next-line no-console
                        console.warn(new Error().stack);
                    }
                    return new Date(NaN);
                }
            }
            /***/ 
        }),
        /***/ "./node_modules/deep-equal/index.js": 
        /*!******************************************!*\
          !*** ./node_modules/deep-equal/index.js ***!
          \******************************************/
        /***/ ((module, __unused_webpack_exports, __webpack_require__) => {
            "use strict";
            var assign = __webpack_require__(/*! object.assign */ "./node_modules/object.assign/index.js");
            var callBound = __webpack_require__(/*! call-bind/callBound */ "./node_modules/call-bind/callBound.js");
            var flags = __webpack_require__(/*! regexp.prototype.flags */ "./node_modules/regexp.prototype.flags/index.js");
            var GetIntrinsic = __webpack_require__(/*! get-intrinsic */ "./node_modules/get-intrinsic/index.js");
            var getIterator = __webpack_require__(/*! es-get-iterator */ "./node_modules/es-get-iterator/node.js");
            var getSideChannel = __webpack_require__(/*! side-channel */ "./node_modules/side-channel/index.js");
            var is = __webpack_require__(/*! object-is */ "./node_modules/object-is/index.js");
            var isArguments = __webpack_require__(/*! is-arguments */ "./node_modules/is-arguments/index.js");
            var isArray = __webpack_require__(/*! isarray */ "./node_modules/isarray/index.js");
            var isArrayBuffer = __webpack_require__(/*! is-array-buffer */ "./node_modules/is-array-buffer/index.js");
            var isDate = __webpack_require__(/*! is-date-object */ "./node_modules/is-date-object/index.js");
            var isRegex = __webpack_require__(/*! is-regex */ "./node_modules/is-regex/index.js");
            var isSharedArrayBuffer = __webpack_require__(/*! is-shared-array-buffer */ "./node_modules/is-shared-array-buffer/index.js");
            var objectKeys = __webpack_require__(/*! object-keys */ "./node_modules/object-keys/index.js");
            var whichBoxedPrimitive = __webpack_require__(/*! which-boxed-primitive */ "./node_modules/which-boxed-primitive/index.js");
            var whichCollection = __webpack_require__(/*! which-collection */ "./node_modules/which-collection/index.js");
            var whichTypedArray = __webpack_require__(/*! which-typed-array */ "./node_modules/which-typed-array/index.js");
            var byteLength = __webpack_require__(/*! array-buffer-byte-length */ "./node_modules/array-buffer-byte-length/index.js");
            var sabByteLength = callBound('SharedArrayBuffer.prototype.byteLength', true);
            var $getTime = callBound('Date.prototype.getTime');
            var gPO = Object.getPrototypeOf;
            var $objToString = callBound('Object.prototype.toString');
            var $Set = GetIntrinsic('%Set%', true);
            var $mapHas = callBound('Map.prototype.has', true);
            var $mapGet = callBound('Map.prototype.get', true);
            var $mapSize = callBound('Map.prototype.size', true);
            var $setAdd = callBound('Set.prototype.add', true);
            var $setDelete = callBound('Set.prototype.delete', true);
            var $setHas = callBound('Set.prototype.has', true);
            var $setSize = callBound('Set.prototype.size', true);
            // taken from https://github.com/browserify/commonjs-assert/blob/bba838e9ba9e28edf3127ce6974624208502f6bc/internal/util/comparisons.js#L401-L414
            function setHasEqualElement(set, val1, opts, channel) {
                var i = getIterator(set);
                var result;
                while ((result = i.next()) && !result.done) {
                    if (internalDeepEqual(val1, result.value, opts, channel)) { // eslint-disable-line no-use-before-define
                        // Remove the matching element to make sure we do not check that again.
                        $setDelete(set, result.value);
                        return true;
                    }
                }
                return false;
            }
            // taken from https://github.com/browserify/commonjs-assert/blob/bba838e9ba9e28edf3127ce6974624208502f6bc/internal/util/comparisons.js#L416-L439
            function findLooseMatchingPrimitives(prim) {
                if (typeof prim === 'undefined') {
                    return null;
                }
                if (typeof prim === 'object') { // Only pass in null as object!
                    return void 0;
                }
                if (typeof prim === 'symbol') {
                    return false;
                }
                if (typeof prim === 'string' || typeof prim === 'number') {
                    // Loose equal entries exist only if the string is possible to convert to a regular number and not NaN.
                    return +prim === +prim; // eslint-disable-line no-implicit-coercion
                }
                return true;
            }
            // taken from https://github.com/browserify/commonjs-assert/blob/bba838e9ba9e28edf3127ce6974624208502f6bc/internal/util/comparisons.js#L449-L460
            function mapMightHaveLoosePrim(a, b, prim, item, opts, channel) {
                var altValue = findLooseMatchingPrimitives(prim);
                if (altValue != null) {
                    return altValue;
                }
                var curB = $mapGet(b, altValue);
                var looseOpts = assign({}, opts, { strict: false });
                if ((typeof curB === 'undefined' && !$mapHas(b, altValue))
                    // eslint-disable-next-line no-use-before-define
                    || !internalDeepEqual(item, curB, looseOpts, channel)) {
                    return false;
                }
                // eslint-disable-next-line no-use-before-define
                return !$mapHas(a, altValue) && internalDeepEqual(item, curB, looseOpts, channel);
            }
            // taken from https://github.com/browserify/commonjs-assert/blob/bba838e9ba9e28edf3127ce6974624208502f6bc/internal/util/comparisons.js#L441-L447
            function setMightHaveLoosePrim(a, b, prim) {
                var altValue = findLooseMatchingPrimitives(prim);
                if (altValue != null) {
                    return altValue;
                }
                return $setHas(b, altValue) && !$setHas(a, altValue);
            }
            // taken from https://github.com/browserify/commonjs-assert/blob/bba838e9ba9e28edf3127ce6974624208502f6bc/internal/util/comparisons.js#L518-L533
            function mapHasEqualEntry(set, map, key1, item1, opts, channel) {
                var i = getIterator(set);
                var result;
                var key2;
                while ((result = i.next()) && !result.done) {
                    key2 = result.value;
                    if (
                    // eslint-disable-next-line no-use-before-define
                    internalDeepEqual(key1, key2, opts, channel)
                        // eslint-disable-next-line no-use-before-define
                        && internalDeepEqual(item1, $mapGet(map, key2), opts, channel)) {
                        $setDelete(set, key2);
                        return true;
                    }
                }
                return false;
            }
            function internalDeepEqual(actual, expected, options, channel) {
                var opts = options || {};
                // 7.1. All identical values are equivalent, as determined by ===.
                if (opts.strict ? is(actual, expected) : actual === expected) {
                    return true;
                }
                var actualBoxed = whichBoxedPrimitive(actual);
                var expectedBoxed = whichBoxedPrimitive(expected);
                if (actualBoxed !== expectedBoxed) {
                    return false;
                }
                // 7.3. Other pairs that do not both pass typeof value == 'object', equivalence is determined by ==.
                if (!actual || !expected || (typeof actual !== 'object' && typeof expected !== 'object')) {
                    return opts.strict ? is(actual, expected) : actual == expected; // eslint-disable-line eqeqeq
                }
                /*
                 * 7.4. For all other Object pairs, including Array objects, equivalence is
                 * determined by having the same number of owned properties (as verified
                 * with Object.prototype.hasOwnProperty.call), the same set of keys
                 * (although not necessarily the same order), equivalent values for every
                 * corresponding key, and an identical 'prototype' property. Note: this
                 * accounts for both named and indexed properties on Arrays.
                 */
                // see https://github.com/nodejs/node/commit/d3aafd02efd3a403d646a3044adcf14e63a88d32 for memos/channel inspiration
                var hasActual = channel.has(actual);
                var hasExpected = channel.has(expected);
                var sentinel;
                if (hasActual && hasExpected) {
                    if (channel.get(actual) === channel.get(expected)) {
                        return true;
                    }
                }
                else {
                    sentinel = {};
                }
                if (!hasActual) {
                    channel.set(actual, sentinel);
                }
                if (!hasExpected) {
                    channel.set(expected, sentinel);
                }
                // eslint-disable-next-line no-use-before-define
                return objEquiv(actual, expected, opts, channel);
            }
            function isBuffer(x) {
                if (!x || typeof x !== 'object' || typeof x.length !== 'number') {
                    return false;
                }
                if (typeof x.copy !== 'function' || typeof x.slice !== 'function') {
                    return false;
                }
                if (x.length > 0 && typeof x[0] !== 'number') {
                    return false;
                }
                return !!(x.constructor && x.constructor.isBuffer && x.constructor.isBuffer(x));
            }
            function setEquiv(a, b, opts, channel) {
                if ($setSize(a) !== $setSize(b)) {
                    return false;
                }
                var iA = getIterator(a);
                var iB = getIterator(b);
                var resultA;
                var resultB;
                var set;
                while ((resultA = iA.next()) && !resultA.done) {
                    if (resultA.value && typeof resultA.value === 'object') {
                        if (!set) {
                            set = new $Set();
                        }
                        $setAdd(set, resultA.value);
                    }
                    else if (!$setHas(b, resultA.value)) {
                        if (opts.strict) {
                            return false;
                        }
                        if (!setMightHaveLoosePrim(a, b, resultA.value)) {
                            return false;
                        }
                        if (!set) {
                            set = new $Set();
                        }
                        $setAdd(set, resultA.value);
                    }
                }
                if (set) {
                    while ((resultB = iB.next()) && !resultB.done) {
                        // We have to check if a primitive value is already matching and only if it's not, go hunting for it.
                        if (resultB.value && typeof resultB.value === 'object') {
                            if (!setHasEqualElement(set, resultB.value, opts.strict, channel)) {
                                return false;
                            }
                        }
                        else if (!opts.strict
                            && !$setHas(a, resultB.value)
                            && !setHasEqualElement(set, resultB.value, opts.strict, channel)) {
                            return false;
                        }
                    }
                    return $setSize(set) === 0;
                }
                return true;
            }
            function mapEquiv(a, b, opts, channel) {
                if ($mapSize(a) !== $mapSize(b)) {
                    return false;
                }
                var iA = getIterator(a);
                var iB = getIterator(b);
                var resultA;
                var resultB;
                var set;
                var key;
                var item1;
                var item2;
                while ((resultA = iA.next()) && !resultA.done) {
                    key = resultA.value[0];
                    item1 = resultA.value[1];
                    if (key && typeof key === 'object') {
                        if (!set) {
                            set = new $Set();
                        }
                        $setAdd(set, key);
                    }
                    else {
                        item2 = $mapGet(b, key);
                        if ((typeof item2 === 'undefined' && !$mapHas(b, key)) || !internalDeepEqual(item1, item2, opts, channel)) {
                            if (opts.strict) {
                                return false;
                            }
                            if (!mapMightHaveLoosePrim(a, b, key, item1, opts, channel)) {
                                return false;
                            }
                            if (!set) {
                                set = new $Set();
                            }
                            $setAdd(set, key);
                        }
                    }
                }
                if (set) {
                    while ((resultB = iB.next()) && !resultB.done) {
                        key = resultB.value[0];
                        item2 = resultB.value[1];
                        if (key && typeof key === 'object') {
                            if (!mapHasEqualEntry(set, a, key, item2, opts, channel)) {
                                return false;
                            }
                        }
                        else if (!opts.strict
                            && (!a.has(key) || !internalDeepEqual($mapGet(a, key), item2, opts, channel))
                            && !mapHasEqualEntry(set, a, key, item2, assign({}, opts, { strict: false }), channel)) {
                            return false;
                        }
                    }
                    return $setSize(set) === 0;
                }
                return true;
            }
            function objEquiv(a, b, opts, channel) {
                /* eslint max-statements: [2, 100], max-lines-per-function: [2, 120], max-depth: [2, 5], max-lines: [2, 400] */
                var i, key;
                if (typeof a !== typeof b) {
                    return false;
                }
                if (a == null || b == null) {
                    return false;
                }
                if ($objToString(a) !== $objToString(b)) {
                    return false;
                }
                if (isArguments(a) !== isArguments(b)) {
                    return false;
                }
                var aIsArray = isArray(a);
                var bIsArray = isArray(b);
                if (aIsArray !== bIsArray) {
                    return false;
                }
                // TODO: replace when a cross-realm brand check is available
                var aIsError = a instanceof Error;
                var bIsError = b instanceof Error;
                if (aIsError !== bIsError) {
                    return false;
                }
                if (aIsError || bIsError) {
                    if (a.name !== b.name || a.message !== b.message) {
                        return false;
                    }
                }
                var aIsRegex = isRegex(a);
                var bIsRegex = isRegex(b);
                if (aIsRegex !== bIsRegex) {
                    return false;
                }
                if ((aIsRegex || bIsRegex) && (a.source !== b.source || flags(a) !== flags(b))) {
                    return false;
                }
                var aIsDate = isDate(a);
                var bIsDate = isDate(b);
                if (aIsDate !== bIsDate) {
                    return false;
                }
                if (aIsDate || bIsDate) { // && would work too, because both are true or both false here
                    if ($getTime(a) !== $getTime(b)) {
                        return false;
                    }
                }
                if (opts.strict && gPO && gPO(a) !== gPO(b)) {
                    return false;
                }
                var aWhich = whichTypedArray(a);
                var bWhich = whichTypedArray(b);
                if (aWhich !== bWhich) {
                    return false;
                }
                if (aWhich || bWhich) { // && would work too, because both are true or both false here
                    if (a.length !== b.length) {
                        return false;
                    }
                    for (i = 0; i < a.length; i++) {
                        if (a[i] !== b[i]) {
                            return false;
                        }
                    }
                    return true;
                }
                var aIsBuffer = isBuffer(a);
                var bIsBuffer = isBuffer(b);
                if (aIsBuffer !== bIsBuffer) {
                    return false;
                }
                if (aIsBuffer || bIsBuffer) { // && would work too, because both are true or both false here
                    if (a.length !== b.length) {
                        return false;
                    }
                    for (i = 0; i < a.length; i++) {
                        if (a[i] !== b[i]) {
                            return false;
                        }
                    }
                    return true;
                }
                var aIsArrayBuffer = isArrayBuffer(a);
                var bIsArrayBuffer = isArrayBuffer(b);
                if (aIsArrayBuffer !== bIsArrayBuffer) {
                    return false;
                }
                if (aIsArrayBuffer || bIsArrayBuffer) { // && would work too, because both are true or both false here
                    if (byteLength(a) !== byteLength(b)) {
                        return false;
                    }
                    return typeof Uint8Array === 'function' && internalDeepEqual(new Uint8Array(a), new Uint8Array(b), opts, channel);
                }
                var aIsSAB = isSharedArrayBuffer(a);
                var bIsSAB = isSharedArrayBuffer(b);
                if (aIsSAB !== bIsSAB) {
                    return false;
                }
                if (aIsSAB || bIsSAB) { // && would work too, because both are true or both false here
                    if (sabByteLength(a) !== sabByteLength(b)) {
                        return false;
                    }
                    return typeof Uint8Array === 'function' && internalDeepEqual(new Uint8Array(a), new Uint8Array(b), opts, channel);
                }
                if (typeof a !== typeof b) {
                    return false;
                }
                var ka = objectKeys(a);
                var kb = objectKeys(b);
                // having the same number of owned properties (keys incorporates hasOwnProperty)
                if (ka.length !== kb.length) {
                    return false;
                }
                // the same set of keys (although not necessarily the same order),
                ka.sort();
                kb.sort();
                // ~~~cheap key test
                for (i = ka.length - 1; i >= 0; i--) {
                    if (ka[i] != kb[i]) {
                        return false;
                    } // eslint-disable-line eqeqeq
                }
                // equivalent values for every corresponding key, and ~~~possibly expensive deep test
                for (i = ka.length - 1; i >= 0; i--) {
                    key = ka[i];
                    if (!internalDeepEqual(a[key], b[key], opts, channel)) {
                        return false;
                    }
                }
                var aCollection = whichCollection(a);
                var bCollection = whichCollection(b);
                if (aCollection !== bCollection) {
                    return false;
                }
                if (aCollection === 'Set' || bCollection === 'Set') { // aCollection === bCollection
                    return setEquiv(a, b, opts, channel);
                }
                if (aCollection === 'Map') { // aCollection === bCollection
                    return mapEquiv(a, b, opts, channel);
                }
                return true;
            }
            module.exports = function deepEqual(a, b, opts) {
                return internalDeepEqual(a, b, opts, getSideChannel());
            };
            /***/ 
        }),
        /***/ "./node_modules/define-data-property/index.js": 
        /*!****************************************************!*\
          !*** ./node_modules/define-data-property/index.js ***!
          \****************************************************/
        /***/ ((module, __unused_webpack_exports, __webpack_require__) => {
            "use strict";
            var hasPropertyDescriptors = __webpack_require__(/*! has-property-descriptors */ "./node_modules/has-property-descriptors/index.js")();
            var GetIntrinsic = __webpack_require__(/*! get-intrinsic */ "./node_modules/get-intrinsic/index.js");
            var $defineProperty = hasPropertyDescriptors && GetIntrinsic('%Object.defineProperty%', true);
            if ($defineProperty) {
                try {
                    $defineProperty({}, 'a', { value: 1 });
                }
                catch (e) {
                    // IE 8 has a broken defineProperty
                    $defineProperty = false;
                }
            }
            var $SyntaxError = GetIntrinsic('%SyntaxError%');
            var $TypeError = GetIntrinsic('%TypeError%');
            var gopd = __webpack_require__(/*! gopd */ "./node_modules/gopd/index.js");
            /** @type {(obj: Record<PropertyKey, unknown>, property: PropertyKey, value: unknown, nonEnumerable?: boolean | null, nonWritable?: boolean | null, nonConfigurable?: boolean | null, loose?: boolean) => void} */
            module.exports = function defineDataProperty(obj, property, value) {
                if (!obj || (typeof obj !== 'object' && typeof obj !== 'function')) {
                    throw new $TypeError('`obj` must be an object or a function`');
                }
                if (typeof property !== 'string' && typeof property !== 'symbol') {
                    throw new $TypeError('`property` must be a string or a symbol`');
                }
                if (arguments.length > 3 && typeof arguments[3] !== 'boolean' && arguments[3] !== null) {
                    throw new $TypeError('`nonEnumerable`, if provided, must be a boolean or null');
                }
                if (arguments.length > 4 && typeof arguments[4] !== 'boolean' && arguments[4] !== null) {
                    throw new $TypeError('`nonWritable`, if provided, must be a boolean or null');
                }
                if (arguments.length > 5 && typeof arguments[5] !== 'boolean' && arguments[5] !== null) {
                    throw new $TypeError('`nonConfigurable`, if provided, must be a boolean or null');
                }
                if (arguments.length > 6 && typeof arguments[6] !== 'boolean') {
                    throw new $TypeError('`loose`, if provided, must be a boolean');
                }
                var nonEnumerable = arguments.length > 3 ? arguments[3] : null;
                var nonWritable = arguments.length > 4 ? arguments[4] : null;
                var nonConfigurable = arguments.length > 5 ? arguments[5] : null;
                var loose = arguments.length > 6 ? arguments[6] : false;
                /* @type {false | TypedPropertyDescriptor<unknown>} */
                var desc = !!gopd && gopd(obj, property);
                if ($defineProperty) {
                    $defineProperty(obj, property, {
                        configurable: nonConfigurable === null && desc ? desc.configurable : !nonConfigurable,
                        enumerable: nonEnumerable === null && desc ? desc.enumerable : !nonEnumerable,
                        value: value,
                        writable: nonWritable === null && desc ? desc.writable : !nonWritable
                    });
                }
                else if (loose || (!nonEnumerable && !nonWritable && !nonConfigurable)) {
                    // must fall back to [[Set]], and was not explicitly asked to make non-enumerable, non-writable, or non-configurable
                    obj[property] = value; // eslint-disable-line no-param-reassign
                }
                else {
                    throw new $SyntaxError('This environment does not support defining a property as non-configurable, non-writable, or non-enumerable.');
                }
            };
            /***/ 
        }),
        /***/ "./node_modules/define-properties/index.js": 
        /*!*************************************************!*\
          !*** ./node_modules/define-properties/index.js ***!
          \*************************************************/
        /***/ ((module, __unused_webpack_exports, __webpack_require__) => {
            "use strict";
            var keys = __webpack_require__(/*! object-keys */ "./node_modules/object-keys/index.js");
            var hasSymbols = typeof Symbol === 'function' && typeof Symbol('foo') === 'symbol';
            var toStr = Object.prototype.toString;
            var concat = Array.prototype.concat;
            var origDefineProperty = Object.defineProperty;
            var isFunction = function (fn) {
                return typeof fn === 'function' && toStr.call(fn) === '[object Function]';
            };
            var hasPropertyDescriptors = __webpack_require__(/*! has-property-descriptors */ "./node_modules/has-property-descriptors/index.js")();
            var supportsDescriptors = origDefineProperty && hasPropertyDescriptors;
            var defineProperty = function (object, name, value, predicate) {
                if (name in object) {
                    if (predicate === true) {
                        if (object[name] === value) {
                            return;
                        }
                    }
                    else if (!isFunction(predicate) || !predicate()) {
                        return;
                    }
                }
                if (supportsDescriptors) {
                    origDefineProperty(object, name, {
                        configurable: true,
                        enumerable: false,
                        value: value,
                        writable: true
                    });
                }
                else {
                    object[name] = value; // eslint-disable-line no-param-reassign
                }
            };
            var defineProperties = function (object, map) {
                var predicates = arguments.length > 2 ? arguments[2] : {};
                var props = keys(map);
                if (hasSymbols) {
                    props = concat.call(props, Object.getOwnPropertySymbols(map));
                }
                for (var i = 0; i < props.length; i += 1) {
                    defineProperty(object, props[i], map[props[i]], predicates[props[i]]);
                }
            };
            defineProperties.supportsDescriptors = !!supportsDescriptors;
            module.exports = defineProperties;
            /***/ 
        }),
        /***/ "./node_modules/for-each/index.js": 
        /*!****************************************!*\
          !*** ./node_modules/for-each/index.js ***!
          \****************************************/
        /***/ ((module, __unused_webpack_exports, __webpack_require__) => {
            "use strict";
            var isCallable = __webpack_require__(/*! is-callable */ "./node_modules/is-callable/index.js");
            var toStr = Object.prototype.toString;
            var hasOwnProperty = Object.prototype.hasOwnProperty;
            var forEachArray = function forEachArray(array, iterator, receiver) {
                for (var i = 0, len = array.length; i < len; i++) {
                    if (hasOwnProperty.call(array, i)) {
                        if (receiver == null) {
                            iterator(array[i], i, array);
                        }
                        else {
                            iterator.call(receiver, array[i], i, array);
                        }
                    }
                }
            };
            var forEachString = function forEachString(string, iterator, receiver) {
                for (var i = 0, len = string.length; i < len; i++) {
                    // no such thing as a sparse string.
                    if (receiver == null) {
                        iterator(string.charAt(i), i, string);
                    }
                    else {
                        iterator.call(receiver, string.charAt(i), i, string);
                    }
                }
            };
            var forEachObject = function forEachObject(object, iterator, receiver) {
                for (var k in object) {
                    if (hasOwnProperty.call(object, k)) {
                        if (receiver == null) {
                            iterator(object[k], k, object);
                        }
                        else {
                            iterator.call(receiver, object[k], k, object);
                        }
                    }
                }
            };
            var forEach = function forEach(list, iterator, thisArg) {
                if (!isCallable(iterator)) {
                    throw new TypeError('iterator must be a function');
                }
                var receiver;
                if (arguments.length >= 3) {
                    receiver = thisArg;
                }
                if (toStr.call(list) === '[object Array]') {
                    forEachArray(list, iterator, receiver);
                }
                else if (typeof list === 'string') {
                    forEachString(list, iterator, receiver);
                }
                else {
                    forEachObject(list, iterator, receiver);
                }
            };
            module.exports = forEach;
            /***/ 
        }),
        /***/ "./node_modules/function-bind/implementation.js": 
        /*!******************************************************!*\
          !*** ./node_modules/function-bind/implementation.js ***!
          \******************************************************/
        /***/ ((module) => {
            "use strict";
            /* eslint no-invalid-this: 1 */
            var ERROR_MESSAGE = 'Function.prototype.bind called on incompatible ';
            var toStr = Object.prototype.toString;
            var max = Math.max;
            var funcType = '[object Function]';
            var concatty = function concatty(a, b) {
                var arr = [];
                for (var i = 0; i < a.length; i += 1) {
                    arr[i] = a[i];
                }
                for (var j = 0; j < b.length; j += 1) {
                    arr[j + a.length] = b[j];
                }
                return arr;
            };
            var slicy = function slicy(arrLike, offset) {
                var arr = [];
                for (var i = offset || 0, j = 0; i < arrLike.length; i += 1, j += 1) {
                    arr[j] = arrLike[i];
                }
                return arr;
            };
            var joiny = function (arr, joiner) {
                var str = '';
                for (var i = 0; i < arr.length; i += 1) {
                    str += arr[i];
                    if (i + 1 < arr.length) {
                        str += joiner;
                    }
                }
                return str;
            };
            module.exports = function bind(that) {
                var target = this;
                if (typeof target !== 'function' || toStr.apply(target) !== funcType) {
                    throw new TypeError(ERROR_MESSAGE + target);
                }
                var args = slicy(arguments, 1);
                var bound;
                var binder = function () {
                    if (this instanceof bound) {
                        var result = target.apply(this, concatty(args, arguments));
                        if (Object(result) === result) {
                            return result;
                        }
                        return this;
                    }
                    return target.apply(that, concatty(args, arguments));
                };
                var boundLength = max(0, target.length - args.length);
                var boundArgs = [];
                for (var i = 0; i < boundLength; i++) {
                    boundArgs[i] = '$' + i;
                }
                bound = Function('binder', 'return function (' + joiny(boundArgs, ',') + '){ return binder.apply(this,arguments); }')(binder);
                if (target.prototype) {
                    var Empty = function Empty() { };
                    Empty.prototype = target.prototype;
                    bound.prototype = new Empty();
                    Empty.prototype = null;
                }
                return bound;
            };
            /***/ 
        }),
        /***/ "./node_modules/function-bind/index.js": 
        /*!*********************************************!*\
          !*** ./node_modules/function-bind/index.js ***!
          \*********************************************/
        /***/ ((module, __unused_webpack_exports, __webpack_require__) => {
            "use strict";
            var implementation = __webpack_require__(/*! ./implementation */ "./node_modules/function-bind/implementation.js");
            module.exports = Function.prototype.bind || implementation;
            /***/ 
        }),
        /***/ "./node_modules/functions-have-names/index.js": 
        /*!****************************************************!*\
          !*** ./node_modules/functions-have-names/index.js ***!
          \****************************************************/
        /***/ ((module) => {
            "use strict";
            var functionsHaveNames = function functionsHaveNames() {
                return typeof function f() { }.name === 'string';
            };
            var gOPD = Object.getOwnPropertyDescriptor;
            if (gOPD) {
                try {
                    gOPD([], 'length');
                }
                catch (e) {
                    // IE 8 has a broken gOPD
                    gOPD = null;
                }
            }
            functionsHaveNames.functionsHaveConfigurableNames = function functionsHaveConfigurableNames() {
                if (!functionsHaveNames() || !gOPD) {
                    return false;
                }
                var desc = gOPD(function () { }, 'name');
                return !!desc && !!desc.configurable;
            };
            var $bind = Function.prototype.bind;
            functionsHaveNames.boundFunctionsHaveNames = function boundFunctionsHaveNames() {
                return functionsHaveNames() && typeof $bind === 'function' && function f() { }.bind().name !== '';
            };
            module.exports = functionsHaveNames;
            /***/ 
        }),
        /***/ "./node_modules/get-intrinsic/index.js": 
        /*!*********************************************!*\
          !*** ./node_modules/get-intrinsic/index.js ***!
          \*********************************************/
        /***/ ((module, __unused_webpack_exports, __webpack_require__) => {
            "use strict";
            var undefined;
            var $SyntaxError = SyntaxError;
            var $Function = Function;
            var $TypeError = TypeError;
            // eslint-disable-next-line consistent-return
            var getEvalledConstructor = function (expressionSyntax) {
                try {
                    return $Function('"use strict"; return (' + expressionSyntax + ').constructor;')();
                }
                catch (e) { }
            };
            var $gOPD = Object.getOwnPropertyDescriptor;
            if ($gOPD) {
                try {
                    $gOPD({}, '');
                }
                catch (e) {
                    $gOPD = null; // this is IE 8, which has a broken gOPD
                }
            }
            var throwTypeError = function () {
                throw new $TypeError();
            };
            var ThrowTypeError = $gOPD
                ? (function () {
                    try {
                        // eslint-disable-next-line no-unused-expressions, no-caller, no-restricted-properties
                        arguments.callee; // IE 8 does not throw here
                        return throwTypeError;
                    }
                    catch (calleeThrows) {
                        try {
                            // IE 8 throws on Object.getOwnPropertyDescriptor(arguments, '')
                            return $gOPD(arguments, 'callee').get;
                        }
                        catch (gOPDthrows) {
                            return throwTypeError;
                        }
                    }
                }())
                : throwTypeError;
            var hasSymbols = __webpack_require__(/*! has-symbols */ "./node_modules/has-symbols/index.js")();
            var hasProto = __webpack_require__(/*! has-proto */ "./node_modules/has-proto/index.js")();
            var getProto = Object.getPrototypeOf || (hasProto
                ? function (x) { return x.__proto__; } // eslint-disable-line no-proto
                : null);
            var needsEval = {};
            var TypedArray = typeof Uint8Array === 'undefined' || !getProto ? undefined : getProto(Uint8Array);
            var INTRINSICS = {
                '%AggregateError%': typeof AggregateError === 'undefined' ? undefined : AggregateError,
                '%Array%': Array,
                '%ArrayBuffer%': typeof ArrayBuffer === 'undefined' ? undefined : ArrayBuffer,
                '%ArrayIteratorPrototype%': hasSymbols && getProto ? getProto([][Symbol.iterator]()) : undefined,
                '%AsyncFromSyncIteratorPrototype%': undefined,
                '%AsyncFunction%': needsEval,
                '%AsyncGenerator%': needsEval,
                '%AsyncGeneratorFunction%': needsEval,
                '%AsyncIteratorPrototype%': needsEval,
                '%Atomics%': typeof Atomics === 'undefined' ? undefined : Atomics,
                '%BigInt%': typeof BigInt === 'undefined' ? undefined : BigInt,
                '%BigInt64Array%': typeof BigInt64Array === 'undefined' ? undefined : BigInt64Array,
                '%BigUint64Array%': typeof BigUint64Array === 'undefined' ? undefined : BigUint64Array,
                '%Boolean%': Boolean,
                '%DataView%': typeof DataView === 'undefined' ? undefined : DataView,
                '%Date%': Date,
                '%decodeURI%': decodeURI,
                '%decodeURIComponent%': decodeURIComponent,
                '%encodeURI%': encodeURI,
                '%encodeURIComponent%': encodeURIComponent,
                '%Error%': Error,
                '%eval%': eval,
                '%EvalError%': EvalError,
                '%Float32Array%': typeof Float32Array === 'undefined' ? undefined : Float32Array,
                '%Float64Array%': typeof Float64Array === 'undefined' ? undefined : Float64Array,
                '%FinalizationRegistry%': typeof FinalizationRegistry === 'undefined' ? undefined : FinalizationRegistry,
                '%Function%': $Function,
                '%GeneratorFunction%': needsEval,
                '%Int8Array%': typeof Int8Array === 'undefined' ? undefined : Int8Array,
                '%Int16Array%': typeof Int16Array === 'undefined' ? undefined : Int16Array,
                '%Int32Array%': typeof Int32Array === 'undefined' ? undefined : Int32Array,
                '%isFinite%': isFinite,
                '%isNaN%': isNaN,
                '%IteratorPrototype%': hasSymbols && getProto ? getProto(getProto([][Symbol.iterator]())) : undefined,
                '%JSON%': typeof JSON === 'object' ? JSON : undefined,
                '%Map%': typeof Map === 'undefined' ? undefined : Map,
                '%MapIteratorPrototype%': typeof Map === 'undefined' || !hasSymbols || !getProto ? undefined : getProto(new Map()[Symbol.iterator]()),
                '%Math%': Math,
                '%Number%': Number,
                '%Object%': Object,
                '%parseFloat%': parseFloat,
                '%parseInt%': parseInt,
                '%Promise%': typeof Promise === 'undefined' ? undefined : Promise,
                '%Proxy%': typeof Proxy === 'undefined' ? undefined : Proxy,
                '%RangeError%': RangeError,
                '%ReferenceError%': ReferenceError,
                '%Reflect%': typeof Reflect === 'undefined' ? undefined : Reflect,
                '%RegExp%': RegExp,
                '%Set%': typeof Set === 'undefined' ? undefined : Set,
                '%SetIteratorPrototype%': typeof Set === 'undefined' || !hasSymbols || !getProto ? undefined : getProto(new Set()[Symbol.iterator]()),
                '%SharedArrayBuffer%': typeof SharedArrayBuffer === 'undefined' ? undefined : SharedArrayBuffer,
                '%String%': String,
                '%StringIteratorPrototype%': hasSymbols && getProto ? getProto(''[Symbol.iterator]()) : undefined,
                '%Symbol%': hasSymbols ? Symbol : undefined,
                '%SyntaxError%': $SyntaxError,
                '%ThrowTypeError%': ThrowTypeError,
                '%TypedArray%': TypedArray,
                '%TypeError%': $TypeError,
                '%Uint8Array%': typeof Uint8Array === 'undefined' ? undefined : Uint8Array,
                '%Uint8ClampedArray%': typeof Uint8ClampedArray === 'undefined' ? undefined : Uint8ClampedArray,
                '%Uint16Array%': typeof Uint16Array === 'undefined' ? undefined : Uint16Array,
                '%Uint32Array%': typeof Uint32Array === 'undefined' ? undefined : Uint32Array,
                '%URIError%': URIError,
                '%WeakMap%': typeof WeakMap === 'undefined' ? undefined : WeakMap,
                '%WeakRef%': typeof WeakRef === 'undefined' ? undefined : WeakRef,
                '%WeakSet%': typeof WeakSet === 'undefined' ? undefined : WeakSet
            };
            if (getProto) {
                try {
                    null.error; // eslint-disable-line no-unused-expressions
                }
                catch (e) {
                    // https://github.com/tc39/proposal-shadowrealm/pull/384#issuecomment-1364264229
                    var errorProto = getProto(getProto(e));
                    INTRINSICS['%Error.prototype%'] = errorProto;
                }
            }
            var doEval = function doEval(name) {
                var value;
                if (name === '%AsyncFunction%') {
                    value = getEvalledConstructor('async function () {}');
                }
                else if (name === '%GeneratorFunction%') {
                    value = getEvalledConstructor('function* () {}');
                }
                else if (name === '%AsyncGeneratorFunction%') {
                    value = getEvalledConstructor('async function* () {}');
                }
                else if (name === '%AsyncGenerator%') {
                    var fn = doEval('%AsyncGeneratorFunction%');
                    if (fn) {
                        value = fn.prototype;
                    }
                }
                else if (name === '%AsyncIteratorPrototype%') {
                    var gen = doEval('%AsyncGenerator%');
                    if (gen && getProto) {
                        value = getProto(gen.prototype);
                    }
                }
                INTRINSICS[name] = value;
                return value;
            };
            var LEGACY_ALIASES = {
                '%ArrayBufferPrototype%': ['ArrayBuffer', 'prototype'],
                '%ArrayPrototype%': ['Array', 'prototype'],
                '%ArrayProto_entries%': ['Array', 'prototype', 'entries'],
                '%ArrayProto_forEach%': ['Array', 'prototype', 'forEach'],
                '%ArrayProto_keys%': ['Array', 'prototype', 'keys'],
                '%ArrayProto_values%': ['Array', 'prototype', 'values'],
                '%AsyncFunctionPrototype%': ['AsyncFunction', 'prototype'],
                '%AsyncGenerator%': ['AsyncGeneratorFunction', 'prototype'],
                '%AsyncGeneratorPrototype%': ['AsyncGeneratorFunction', 'prototype', 'prototype'],
                '%BooleanPrototype%': ['Boolean', 'prototype'],
                '%DataViewPrototype%': ['DataView', 'prototype'],
                '%DatePrototype%': ['Date', 'prototype'],
                '%ErrorPrototype%': ['Error', 'prototype'],
                '%EvalErrorPrototype%': ['EvalError', 'prototype'],
                '%Float32ArrayPrototype%': ['Float32Array', 'prototype'],
                '%Float64ArrayPrototype%': ['Float64Array', 'prototype'],
                '%FunctionPrototype%': ['Function', 'prototype'],
                '%Generator%': ['GeneratorFunction', 'prototype'],
                '%GeneratorPrototype%': ['GeneratorFunction', 'prototype', 'prototype'],
                '%Int8ArrayPrototype%': ['Int8Array', 'prototype'],
                '%Int16ArrayPrototype%': ['Int16Array', 'prototype'],
                '%Int32ArrayPrototype%': ['Int32Array', 'prototype'],
                '%JSONParse%': ['JSON', 'parse'],
                '%JSONStringify%': ['JSON', 'stringify'],
                '%MapPrototype%': ['Map', 'prototype'],
                '%NumberPrototype%': ['Number', 'prototype'],
                '%ObjectPrototype%': ['Object', 'prototype'],
                '%ObjProto_toString%': ['Object', 'prototype', 'toString'],
                '%ObjProto_valueOf%': ['Object', 'prototype', 'valueOf'],
                '%PromisePrototype%': ['Promise', 'prototype'],
                '%PromiseProto_then%': ['Promise', 'prototype', 'then'],
                '%Promise_all%': ['Promise', 'all'],
                '%Promise_reject%': ['Promise', 'reject'],
                '%Promise_resolve%': ['Promise', 'resolve'],
                '%RangeErrorPrototype%': ['RangeError', 'prototype'],
                '%ReferenceErrorPrototype%': ['ReferenceError', 'prototype'],
                '%RegExpPrototype%': ['RegExp', 'prototype'],
                '%SetPrototype%': ['Set', 'prototype'],
                '%SharedArrayBufferPrototype%': ['SharedArrayBuffer', 'prototype'],
                '%StringPrototype%': ['String', 'prototype'],
                '%SymbolPrototype%': ['Symbol', 'prototype'],
                '%SyntaxErrorPrototype%': ['SyntaxError', 'prototype'],
                '%TypedArrayPrototype%': ['TypedArray', 'prototype'],
                '%TypeErrorPrototype%': ['TypeError', 'prototype'],
                '%Uint8ArrayPrototype%': ['Uint8Array', 'prototype'],
                '%Uint8ClampedArrayPrototype%': ['Uint8ClampedArray', 'prototype'],
                '%Uint16ArrayPrototype%': ['Uint16Array', 'prototype'],
                '%Uint32ArrayPrototype%': ['Uint32Array', 'prototype'],
                '%URIErrorPrototype%': ['URIError', 'prototype'],
                '%WeakMapPrototype%': ['WeakMap', 'prototype'],
                '%WeakSetPrototype%': ['WeakSet', 'prototype']
            };
            var bind = __webpack_require__(/*! function-bind */ "./node_modules/function-bind/index.js");
            var hasOwn = __webpack_require__(/*! hasown */ "./node_modules/hasown/index.js");
            var $concat = bind.call(Function.call, Array.prototype.concat);
            var $spliceApply = bind.call(Function.apply, Array.prototype.splice);
            var $replace = bind.call(Function.call, String.prototype.replace);
            var $strSlice = bind.call(Function.call, String.prototype.slice);
            var $exec = bind.call(Function.call, RegExp.prototype.exec);
            /* adapted from https://github.com/lodash/lodash/blob/4.17.15/dist/lodash.js#L6735-L6744 */
            var rePropName = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
            var reEscapeChar = /\\(\\)?/g; /** Used to match backslashes in property paths. */
            var stringToPath = function stringToPath(string) {
                var first = $strSlice(string, 0, 1);
                var last = $strSlice(string, -1);
                if (first === '%' && last !== '%') {
                    throw new $SyntaxError('invalid intrinsic syntax, expected closing `%`');
                }
                else if (last === '%' && first !== '%') {
                    throw new $SyntaxError('invalid intrinsic syntax, expected opening `%`');
                }
                var result = [];
                $replace(string, rePropName, function (match, number, quote, subString) {
                    result[result.length] = quote ? $replace(subString, reEscapeChar, '$1') : number || match;
                });
                return result;
            };
            /* end adaptation */
            var getBaseIntrinsic = function getBaseIntrinsic(name, allowMissing) {
                var intrinsicName = name;
                var alias;
                if (hasOwn(LEGACY_ALIASES, intrinsicName)) {
                    alias = LEGACY_ALIASES[intrinsicName];
                    intrinsicName = '%' + alias[0] + '%';
                }
                if (hasOwn(INTRINSICS, intrinsicName)) {
                    var value = INTRINSICS[intrinsicName];
                    if (value === needsEval) {
                        value = doEval(intrinsicName);
                    }
                    if (typeof value === 'undefined' && !allowMissing) {
                        throw new $TypeError('intrinsic ' + name + ' exists, but is not available. Please file an issue!');
                    }
                    return {
                        alias: alias,
                        name: intrinsicName,
                        value: value
                    };
                }
                throw new $SyntaxError('intrinsic ' + name + ' does not exist!');
            };
            module.exports = function GetIntrinsic(name, allowMissing) {
                if (typeof name !== 'string' || name.length === 0) {
                    throw new $TypeError('intrinsic name must be a non-empty string');
                }
                if (arguments.length > 1 && typeof allowMissing !== 'boolean') {
                    throw new $TypeError('"allowMissing" argument must be a boolean');
                }
                if ($exec(/^%?[^%]*%?$/, name) === null) {
                    throw new $SyntaxError('`%` may not be present anywhere but at the beginning and end of the intrinsic name');
                }
                var parts = stringToPath(name);
                var intrinsicBaseName = parts.length > 0 ? parts[0] : '';
                var intrinsic = getBaseIntrinsic('%' + intrinsicBaseName + '%', allowMissing);
                var intrinsicRealName = intrinsic.name;
                var value = intrinsic.value;
                var skipFurtherCaching = false;
                var alias = intrinsic.alias;
                if (alias) {
                    intrinsicBaseName = alias[0];
                    $spliceApply(parts, $concat([0, 1], alias));
                }
                for (var i = 1, isOwn = true; i < parts.length; i += 1) {
                    var part = parts[i];
                    var first = $strSlice(part, 0, 1);
                    var last = $strSlice(part, -1);
                    if (((first === '"' || first === "'" || first === '`')
                        || (last === '"' || last === "'" || last === '`'))
                        && first !== last) {
                        throw new $SyntaxError('property names with quotes must have matching quotes');
                    }
                    if (part === 'constructor' || !isOwn) {
                        skipFurtherCaching = true;
                    }
                    intrinsicBaseName += '.' + part;
                    intrinsicRealName = '%' + intrinsicBaseName + '%';
                    if (hasOwn(INTRINSICS, intrinsicRealName)) {
                        value = INTRINSICS[intrinsicRealName];
                    }
                    else if (value != null) {
                        if (!(part in value)) {
                            if (!allowMissing) {
                                throw new $TypeError('base intrinsic for ' + name + ' exists, but the property is not available.');
                            }
                            return void undefined;
                        }
                        if ($gOPD && (i + 1) >= parts.length) {
                            var desc = $gOPD(value, part);
                            isOwn = !!desc;
                            // By convention, when a data property is converted to an accessor
                            // property to emulate a data property that does not suffer from
                            // the override mistake, that accessor's getter is marked with
                            // an `originalValue` property. Here, when we detect this, we
                            // uphold the illusion by pretending to see that original data
                            // property, i.e., returning the value rather than the getter
                            // itself.
                            if (isOwn && 'get' in desc && !('originalValue' in desc.get)) {
                                value = desc.get;
                            }
                            else {
                                value = value[part];
                            }
                        }
                        else {
                            isOwn = hasOwn(value, part);
                            value = value[part];
                        }
                        if (isOwn && !skipFurtherCaching) {
                            INTRINSICS[intrinsicRealName] = value;
                        }
                    }
                }
                return value;
            };
            /***/ 
        }),
        /***/ "./node_modules/gopd/index.js": 
        /*!************************************!*\
          !*** ./node_modules/gopd/index.js ***!
          \************************************/
        /***/ ((module, __unused_webpack_exports, __webpack_require__) => {
            "use strict";
            var GetIntrinsic = __webpack_require__(/*! get-intrinsic */ "./node_modules/get-intrinsic/index.js");
            var $gOPD = GetIntrinsic('%Object.getOwnPropertyDescriptor%', true);
            if ($gOPD) {
                try {
                    $gOPD([], 'length');
                }
                catch (e) {
                    // IE 8 has a broken gOPD
                    $gOPD = null;
                }
            }
            module.exports = $gOPD;
            /***/ 
        }),
        /***/ "./node_modules/has-bigints/index.js": 
        /*!*******************************************!*\
          !*** ./node_modules/has-bigints/index.js ***!
          \*******************************************/
        /***/ ((module) => {
            "use strict";
            var $BigInt = typeof BigInt !== 'undefined' && BigInt;
            module.exports = function hasNativeBigInts() {
                return typeof $BigInt === 'function'
                    && typeof BigInt === 'function'
                    && typeof $BigInt(42) === 'bigint' // eslint-disable-line no-magic-numbers
                    && typeof BigInt(42) === 'bigint'; // eslint-disable-line no-magic-numbers
            };
            /***/ 
        }),
        /***/ "./node_modules/has-property-descriptors/index.js": 
        /*!********************************************************!*\
          !*** ./node_modules/has-property-descriptors/index.js ***!
          \********************************************************/
        /***/ ((module, __unused_webpack_exports, __webpack_require__) => {
            "use strict";
            var GetIntrinsic = __webpack_require__(/*! get-intrinsic */ "./node_modules/get-intrinsic/index.js");
            var $defineProperty = GetIntrinsic('%Object.defineProperty%', true);
            var hasPropertyDescriptors = function hasPropertyDescriptors() {
                if ($defineProperty) {
                    try {
                        $defineProperty({}, 'a', { value: 1 });
                        return true;
                    }
                    catch (e) {
                        // IE 8 has a broken defineProperty
                        return false;
                    }
                }
                return false;
            };
            hasPropertyDescriptors.hasArrayLengthDefineBug = function hasArrayLengthDefineBug() {
                // node v0.6 has a bug where array lengths can be Set but not Defined
                if (!hasPropertyDescriptors()) {
                    return null;
                }
                try {
                    return $defineProperty([], 'length', { value: 1 }).length !== 1;
                }
                catch (e) {
                    // In Firefox 4-22, defining length on an array throws an exception.
                    return true;
                }
            };
            module.exports = hasPropertyDescriptors;
            /***/ 
        }),
        /***/ "./node_modules/has-proto/index.js": 
        /*!*****************************************!*\
          !*** ./node_modules/has-proto/index.js ***!
          \*****************************************/
        /***/ ((module) => {
            "use strict";
            var test = {
                foo: {}
            };
            var $Object = Object;
            module.exports = function hasProto() {
                return { __proto__: test }.foo === test.foo && !({ __proto__: null } instanceof $Object);
            };
            /***/ 
        }),
        /***/ "./node_modules/has-symbols/index.js": 
        /*!*******************************************!*\
          !*** ./node_modules/has-symbols/index.js ***!
          \*******************************************/
        /***/ ((module, __unused_webpack_exports, __webpack_require__) => {
            "use strict";
            var origSymbol = typeof Symbol !== 'undefined' && Symbol;
            var hasSymbolSham = __webpack_require__(/*! ./shams */ "./node_modules/has-symbols/shams.js");
            module.exports = function hasNativeSymbols() {
                if (typeof origSymbol !== 'function') {
                    return false;
                }
                if (typeof Symbol !== 'function') {
                    return false;
                }
                if (typeof origSymbol('foo') !== 'symbol') {
                    return false;
                }
                if (typeof Symbol('bar') !== 'symbol') {
                    return false;
                }
                return hasSymbolSham();
            };
            /***/ 
        }),
        /***/ "./node_modules/has-symbols/shams.js": 
        /*!*******************************************!*\
          !*** ./node_modules/has-symbols/shams.js ***!
          \*******************************************/
        /***/ ((module) => {
            "use strict";
            /* eslint complexity: [2, 18], max-statements: [2, 33] */
            module.exports = function hasSymbols() {
                if (typeof Symbol !== 'function' || typeof Object.getOwnPropertySymbols !== 'function') {
                    return false;
                }
                if (typeof Symbol.iterator === 'symbol') {
                    return true;
                }
                var obj = {};
                var sym = Symbol('test');
                var symObj = Object(sym);
                if (typeof sym === 'string') {
                    return false;
                }
                if (Object.prototype.toString.call(sym) !== '[object Symbol]') {
                    return false;
                }
                if (Object.prototype.toString.call(symObj) !== '[object Symbol]') {
                    return false;
                }
                // temp disabled per https://github.com/ljharb/object.assign/issues/17
                // if (sym instanceof Symbol) { return false; }
                // temp disabled per https://github.com/WebReflection/get-own-property-symbols/issues/4
                // if (!(symObj instanceof Symbol)) { return false; }
                // if (typeof Symbol.prototype.toString !== 'function') { return false; }
                // if (String(sym) !== Symbol.prototype.toString.call(sym)) { return false; }
                var symVal = 42;
                obj[sym] = symVal;
                for (sym in obj) {
                    return false;
                } // eslint-disable-line no-restricted-syntax, no-unreachable-loop
                if (typeof Object.keys === 'function' && Object.keys(obj).length !== 0) {
                    return false;
                }
                if (typeof Object.getOwnPropertyNames === 'function' && Object.getOwnPropertyNames(obj).length !== 0) {
                    return false;
                }
                var syms = Object.getOwnPropertySymbols(obj);
                if (syms.length !== 1 || syms[0] !== sym) {
                    return false;
                }
                if (!Object.prototype.propertyIsEnumerable.call(obj, sym)) {
                    return false;
                }
                if (typeof Object.getOwnPropertyDescriptor === 'function') {
                    var descriptor = Object.getOwnPropertyDescriptor(obj, sym);
                    if (descriptor.value !== symVal || descriptor.enumerable !== true) {
                        return false;
                    }
                }
                return true;
            };
            /***/ 
        }),
        /***/ "./node_modules/has-tostringtag/shams.js": 
        /*!***********************************************!*\
          !*** ./node_modules/has-tostringtag/shams.js ***!
          \***********************************************/
        /***/ ((module, __unused_webpack_exports, __webpack_require__) => {
            "use strict";
            var hasSymbols = __webpack_require__(/*! has-symbols/shams */ "./node_modules/has-symbols/shams.js");
            module.exports = function hasToStringTagShams() {
                return hasSymbols() && !!Symbol.toStringTag;
            };
            /***/ 
        }),
        /***/ "./node_modules/hasown/index.js": 
        /*!**************************************!*\
          !*** ./node_modules/hasown/index.js ***!
          \**************************************/
        /***/ ((module, __unused_webpack_exports, __webpack_require__) => {
            "use strict";
            var call = Function.prototype.call;
            var $hasOwn = Object.prototype.hasOwnProperty;
            var bind = __webpack_require__(/*! function-bind */ "./node_modules/function-bind/index.js");
            /** @type {(o: {}, p: PropertyKey) => p is keyof o} */
            module.exports = bind.call(call, $hasOwn);
            /***/ 
        }),
        /***/ "./node_modules/is-arguments/index.js": 
        /*!********************************************!*\
          !*** ./node_modules/is-arguments/index.js ***!
          \********************************************/
        /***/ ((module, __unused_webpack_exports, __webpack_require__) => {
            "use strict";
            var hasToStringTag = __webpack_require__(/*! has-tostringtag/shams */ "./node_modules/has-tostringtag/shams.js")();
            var callBound = __webpack_require__(/*! call-bind/callBound */ "./node_modules/call-bind/callBound.js");
            var $toString = callBound('Object.prototype.toString');
            var isStandardArguments = function isArguments(value) {
                if (hasToStringTag && value && typeof value === 'object' && Symbol.toStringTag in value) {
                    return false;
                }
                return $toString(value) === '[object Arguments]';
            };
            var isLegacyArguments = function isArguments(value) {
                if (isStandardArguments(value)) {
                    return true;
                }
                return value !== null &&
                    typeof value === 'object' &&
                    typeof value.length === 'number' &&
                    value.length >= 0 &&
                    $toString(value) !== '[object Array]' &&
                    $toString(value.callee) === '[object Function]';
            };
            var supportsStandardArguments = (function () {
                return isStandardArguments(arguments);
            }());
            isStandardArguments.isLegacyArguments = isLegacyArguments; // for tests
            module.exports = supportsStandardArguments ? isStandardArguments : isLegacyArguments;
            /***/ 
        }),
        /***/ "./node_modules/is-array-buffer/index.js": 
        /*!***********************************************!*\
          !*** ./node_modules/is-array-buffer/index.js ***!
          \***********************************************/
        /***/ ((module, __unused_webpack_exports, __webpack_require__) => {
            "use strict";
            var callBind = __webpack_require__(/*! call-bind */ "./node_modules/call-bind/index.js");
            var callBound = __webpack_require__(/*! call-bind/callBound */ "./node_modules/call-bind/callBound.js");
            var GetIntrinsic = __webpack_require__(/*! get-intrinsic */ "./node_modules/get-intrinsic/index.js");
            var isTypedArray = __webpack_require__(/*! is-typed-array */ "./node_modules/is-typed-array/index.js");
            var $ArrayBuffer = GetIntrinsic('ArrayBuffer', true);
            var $Float32Array = GetIntrinsic('Float32Array', true);
            var $byteLength = callBound('ArrayBuffer.prototype.byteLength', true);
            // in node 0.10, ArrayBuffers have no prototype methods, but have an own slot-checking `slice` method
            var abSlice = $ArrayBuffer && !$byteLength && new $ArrayBuffer().slice;
            var $abSlice = abSlice && callBind(abSlice);
            module.exports = $byteLength || $abSlice
                ? function isArrayBuffer(obj) {
                    if (!obj || typeof obj !== 'object') {
                        return false;
                    }
                    try {
                        if ($byteLength) {
                            $byteLength(obj);
                        }
                        else {
                            $abSlice(obj, 0);
                        }
                        return true;
                    }
                    catch (e) {
                        return false;
                    }
                }
                : $Float32Array
                    // in node 0.8, ArrayBuffers have no prototype or own methods
                    ? function IsArrayBuffer(obj) {
                        try {
                            return (new $Float32Array(obj)).buffer === obj && !isTypedArray(obj);
                        }
                        catch (e) {
                            return typeof obj === 'object' && e.name === 'RangeError';
                        }
                    }
                    : function isArrayBuffer(obj) {
                        return false;
                    };
            /***/ 
        }),
        /***/ "./node_modules/is-bigint/index.js": 
        /*!*****************************************!*\
          !*** ./node_modules/is-bigint/index.js ***!
          \*****************************************/
        /***/ ((module, __unused_webpack_exports, __webpack_require__) => {
            "use strict";
            var hasBigInts = __webpack_require__(/*! has-bigints */ "./node_modules/has-bigints/index.js")();
            if (hasBigInts) {
                var bigIntValueOf = BigInt.prototype.valueOf;
                var tryBigInt = function tryBigIntObject(value) {
                    try {
                        bigIntValueOf.call(value);
                        return true;
                    }
                    catch (e) {
                    }
                    return false;
                };
                module.exports = function isBigInt(value) {
                    if (value === null
                        || typeof value === 'undefined'
                        || typeof value === 'boolean'
                        || typeof value === 'string'
                        || typeof value === 'number'
                        || typeof value === 'symbol'
                        || typeof value === 'function') {
                        return false;
                    }
                    if (typeof value === 'bigint') {
                        return true;
                    }
                    return tryBigInt(value);
                };
            }
            else {
                module.exports = function isBigInt(value) {
                    return false && 0;
                };
            }
            /***/ 
        }),
        /***/ "./node_modules/is-boolean-object/index.js": 
        /*!*************************************************!*\
          !*** ./node_modules/is-boolean-object/index.js ***!
          \*************************************************/
        /***/ ((module, __unused_webpack_exports, __webpack_require__) => {
            "use strict";
            var callBound = __webpack_require__(/*! call-bind/callBound */ "./node_modules/call-bind/callBound.js");
            var $boolToStr = callBound('Boolean.prototype.toString');
            var $toString = callBound('Object.prototype.toString');
            var tryBooleanObject = function booleanBrandCheck(value) {
                try {
                    $boolToStr(value);
                    return true;
                }
                catch (e) {
                    return false;
                }
            };
            var boolClass = '[object Boolean]';
            var hasToStringTag = __webpack_require__(/*! has-tostringtag/shams */ "./node_modules/has-tostringtag/shams.js")();
            module.exports = function isBoolean(value) {
                if (typeof value === 'boolean') {
                    return true;
                }
                if (value === null || typeof value !== 'object') {
                    return false;
                }
                return hasToStringTag && Symbol.toStringTag in value ? tryBooleanObject(value) : $toString(value) === boolClass;
            };
            /***/ 
        }),
        /***/ "./node_modules/is-callable/index.js": 
        /*!*******************************************!*\
          !*** ./node_modules/is-callable/index.js ***!
          \*******************************************/
        /***/ ((module) => {
            "use strict";
            var fnToStr = Function.prototype.toString;
            var reflectApply = typeof Reflect === 'object' && Reflect !== null && Reflect.apply;
            var badArrayLike;
            var isCallableMarker;
            if (typeof reflectApply === 'function' && typeof Object.defineProperty === 'function') {
                try {
                    badArrayLike = Object.defineProperty({}, 'length', {
                        get: function () {
                            throw isCallableMarker;
                        }
                    });
                    isCallableMarker = {};
                    // eslint-disable-next-line no-throw-literal
                    reflectApply(function () { throw 42; }, null, badArrayLike);
                }
                catch (_) {
                    if (_ !== isCallableMarker) {
                        reflectApply = null;
                    }
                }
            }
            else {
                reflectApply = null;
            }
            var constructorRegex = /^\s*class\b/;
            var isES6ClassFn = function isES6ClassFunction(value) {
                try {
                    var fnStr = fnToStr.call(value);
                    return constructorRegex.test(fnStr);
                }
                catch (e) {
                    return false; // not a function
                }
            };
            var tryFunctionObject = function tryFunctionToStr(value) {
                try {
                    if (isES6ClassFn(value)) {
                        return false;
                    }
                    fnToStr.call(value);
                    return true;
                }
                catch (e) {
                    return false;
                }
            };
            var toStr = Object.prototype.toString;
            var objectClass = '[object Object]';
            var fnClass = '[object Function]';
            var genClass = '[object GeneratorFunction]';
            var ddaClass = '[object HTMLAllCollection]'; // IE 11
            var ddaClass2 = '[object HTML document.all class]';
            var ddaClass3 = '[object HTMLCollection]'; // IE 9-10
            var hasToStringTag = typeof Symbol === 'function' && !!Symbol.toStringTag; // better: use `has-tostringtag`
            var isIE68 = !(0 in [,]); // eslint-disable-line no-sparse-arrays, comma-spacing
            var isDDA = function isDocumentDotAll() { return false; };
            if (typeof document === 'object') {
                // Firefox 3 canonicalizes DDA to undefined when it's not accessed directly
                var all = document.all;
                if (toStr.call(all) === toStr.call(document.all)) {
                    isDDA = function isDocumentDotAll(value) {
                        /* globals document: false */
                        // in IE 6-8, typeof document.all is "object" and it's truthy
                        if ((isIE68 || !value) && (typeof value === 'undefined' || typeof value === 'object')) {
                            try {
                                var str = toStr.call(value);
                                return (str === ddaClass
                                    || str === ddaClass2
                                    || str === ddaClass3 // opera 12.16
                                    || str === objectClass // IE 6-8
                                ) && value('') == null; // eslint-disable-line eqeqeq
                            }
                            catch (e) { /**/ }
                        }
                        return false;
                    };
                }
            }
            module.exports = reflectApply
                ? function isCallable(value) {
                    if (isDDA(value)) {
                        return true;
                    }
                    if (!value) {
                        return false;
                    }
                    if (typeof value !== 'function' && typeof value !== 'object') {
                        return false;
                    }
                    try {
                        reflectApply(value, null, badArrayLike);
                    }
                    catch (e) {
                        if (e !== isCallableMarker) {
                            return false;
                        }
                    }
                    return !isES6ClassFn(value) && tryFunctionObject(value);
                }
                : function isCallable(value) {
                    if (isDDA(value)) {
                        return true;
                    }
                    if (!value) {
                        return false;
                    }
                    if (typeof value !== 'function' && typeof value !== 'object') {
                        return false;
                    }
                    if (hasToStringTag) {
                        return tryFunctionObject(value);
                    }
                    if (isES6ClassFn(value)) {
                        return false;
                    }
                    var strClass = toStr.call(value);
                    if (strClass !== fnClass && strClass !== genClass && !(/^\[object HTML/).test(strClass)) {
                        return false;
                    }
                    return tryFunctionObject(value);
                };
            /***/ 
        }),
        /***/ "./node_modules/is-date-object/index.js": 
        /*!**********************************************!*\
          !*** ./node_modules/is-date-object/index.js ***!
          \**********************************************/
        /***/ ((module, __unused_webpack_exports, __webpack_require__) => {
            "use strict";
            var getDay = Date.prototype.getDay;
            var tryDateObject = function tryDateGetDayCall(value) {
                try {
                    getDay.call(value);
                    return true;
                }
                catch (e) {
                    return false;
                }
            };
            var toStr = Object.prototype.toString;
            var dateClass = '[object Date]';
            var hasToStringTag = __webpack_require__(/*! has-tostringtag/shams */ "./node_modules/has-tostringtag/shams.js")();
            module.exports = function isDateObject(value) {
                if (typeof value !== 'object' || value === null) {
                    return false;
                }
                return hasToStringTag ? tryDateObject(value) : toStr.call(value) === dateClass;
            };
            /***/ 
        }),
        /***/ "./node_modules/is-map/index.js": 
        /*!**************************************!*\
          !*** ./node_modules/is-map/index.js ***!
          \**************************************/
        /***/ ((module) => {
            "use strict";
            var $Map = typeof Map === 'function' && Map.prototype ? Map : null;
            var $Set = typeof Set === 'function' && Set.prototype ? Set : null;
            var exported;
            if (!$Map) {
                // eslint-disable-next-line no-unused-vars
                exported = function isMap(x) {
                    // `Map` is not present in this environment.
                    return false;
                };
            }
            var $mapHas = $Map ? Map.prototype.has : null;
            var $setHas = $Set ? Set.prototype.has : null;
            if (!exported && !$mapHas) {
                // eslint-disable-next-line no-unused-vars
                exported = function isMap(x) {
                    // `Map` does not have a `has` method
                    return false;
                };
            }
            module.exports = exported || function isMap(x) {
                if (!x || typeof x !== 'object') {
                    return false;
                }
                try {
                    $mapHas.call(x);
                    if ($setHas) {
                        try {
                            $setHas.call(x);
                        }
                        catch (e) {
                            return true;
                        }
                    }
                    return x instanceof $Map; // core-js workaround, pre-v2.5.0
                }
                catch (e) { }
                return false;
            };
            /***/ 
        }),
        /***/ "./node_modules/is-number-object/index.js": 
        /*!************************************************!*\
          !*** ./node_modules/is-number-object/index.js ***!
          \************************************************/
        /***/ ((module, __unused_webpack_exports, __webpack_require__) => {
            "use strict";
            var numToStr = Number.prototype.toString;
            var tryNumberObject = function tryNumberObject(value) {
                try {
                    numToStr.call(value);
                    return true;
                }
                catch (e) {
                    return false;
                }
            };
            var toStr = Object.prototype.toString;
            var numClass = '[object Number]';
            var hasToStringTag = __webpack_require__(/*! has-tostringtag/shams */ "./node_modules/has-tostringtag/shams.js")();
            module.exports = function isNumberObject(value) {
                if (typeof value === 'number') {
                    return true;
                }
                if (typeof value !== 'object') {
                    return false;
                }
                return hasToStringTag ? tryNumberObject(value) : toStr.call(value) === numClass;
            };
            /***/ 
        }),
        /***/ "./node_modules/is-regex/index.js": 
        /*!****************************************!*\
          !*** ./node_modules/is-regex/index.js ***!
          \****************************************/
        /***/ ((module, __unused_webpack_exports, __webpack_require__) => {
            "use strict";
            var callBound = __webpack_require__(/*! call-bind/callBound */ "./node_modules/call-bind/callBound.js");
            var hasToStringTag = __webpack_require__(/*! has-tostringtag/shams */ "./node_modules/has-tostringtag/shams.js")();
            var has;
            var $exec;
            var isRegexMarker;
            var badStringifier;
            if (hasToStringTag) {
                has = callBound('Object.prototype.hasOwnProperty');
                $exec = callBound('RegExp.prototype.exec');
                isRegexMarker = {};
                var throwRegexMarker = function () {
                    throw isRegexMarker;
                };
                badStringifier = {
                    toString: throwRegexMarker,
                    valueOf: throwRegexMarker
                };
                if (typeof Symbol.toPrimitive === 'symbol') {
                    badStringifier[Symbol.toPrimitive] = throwRegexMarker;
                }
            }
            var $toString = callBound('Object.prototype.toString');
            var gOPD = Object.getOwnPropertyDescriptor;
            var regexClass = '[object RegExp]';
            module.exports = hasToStringTag
                // eslint-disable-next-line consistent-return
                ? function isRegex(value) {
                    if (!value || typeof value !== 'object') {
                        return false;
                    }
                    var descriptor = gOPD(value, 'lastIndex');
                    var hasLastIndexDataProperty = descriptor && has(descriptor, 'value');
                    if (!hasLastIndexDataProperty) {
                        return false;
                    }
                    try {
                        $exec(value, badStringifier);
                    }
                    catch (e) {
                        return e === isRegexMarker;
                    }
                }
                : function isRegex(value) {
                    // In older browsers, typeof regex incorrectly returns 'function'
                    if (!value || (typeof value !== 'object' && typeof value !== 'function')) {
                        return false;
                    }
                    return $toString(value) === regexClass;
                };
            /***/ 
        }),
        /***/ "./node_modules/is-set/index.js": 
        /*!**************************************!*\
          !*** ./node_modules/is-set/index.js ***!
          \**************************************/
        /***/ ((module) => {
            "use strict";
            var $Map = typeof Map === 'function' && Map.prototype ? Map : null;
            var $Set = typeof Set === 'function' && Set.prototype ? Set : null;
            var exported;
            if (!$Set) {
                // eslint-disable-next-line no-unused-vars
                exported = function isSet(x) {
                    // `Set` is not present in this environment.
                    return false;
                };
            }
            var $mapHas = $Map ? Map.prototype.has : null;
            var $setHas = $Set ? Set.prototype.has : null;
            if (!exported && !$setHas) {
                // eslint-disable-next-line no-unused-vars
                exported = function isSet(x) {
                    // `Set` does not have a `has` method
                    return false;
                };
            }
            module.exports = exported || function isSet(x) {
                if (!x || typeof x !== 'object') {
                    return false;
                }
                try {
                    $setHas.call(x);
                    if ($mapHas) {
                        try {
                            $mapHas.call(x);
                        }
                        catch (e) {
                            return true;
                        }
                    }
                    return x instanceof $Set; // core-js workaround, pre-v2.5.0
                }
                catch (e) { }
                return false;
            };
            /***/ 
        }),
        /***/ "./node_modules/is-shared-array-buffer/index.js": 
        /*!******************************************************!*\
          !*** ./node_modules/is-shared-array-buffer/index.js ***!
          \******************************************************/
        /***/ ((module, __unused_webpack_exports, __webpack_require__) => {
            "use strict";
            var callBound = __webpack_require__(/*! call-bind/callBound */ "./node_modules/call-bind/callBound.js");
            var $byteLength = callBound('SharedArrayBuffer.prototype.byteLength', true);
            module.exports = $byteLength
                ? function isSharedArrayBuffer(obj) {
                    if (!obj || typeof obj !== 'object') {
                        return false;
                    }
                    try {
                        $byteLength(obj);
                        return true;
                    }
                    catch (e) {
                        return false;
                    }
                }
                : function isSharedArrayBuffer(obj) {
                    return false;
                };
            /***/ 
        }),
        /***/ "./node_modules/is-string/index.js": 
        /*!*****************************************!*\
          !*** ./node_modules/is-string/index.js ***!
          \*****************************************/
        /***/ ((module, __unused_webpack_exports, __webpack_require__) => {
            "use strict";
            var strValue = String.prototype.valueOf;
            var tryStringObject = function tryStringObject(value) {
                try {
                    strValue.call(value);
                    return true;
                }
                catch (e) {
                    return false;
                }
            };
            var toStr = Object.prototype.toString;
            var strClass = '[object String]';
            var hasToStringTag = __webpack_require__(/*! has-tostringtag/shams */ "./node_modules/has-tostringtag/shams.js")();
            module.exports = function isString(value) {
                if (typeof value === 'string') {
                    return true;
                }
                if (typeof value !== 'object') {
                    return false;
                }
                return hasToStringTag ? tryStringObject(value) : toStr.call(value) === strClass;
            };
            /***/ 
        }),
        /***/ "./node_modules/is-symbol/index.js": 
        /*!*****************************************!*\
          !*** ./node_modules/is-symbol/index.js ***!
          \*****************************************/
        /***/ ((module, __unused_webpack_exports, __webpack_require__) => {
            "use strict";
            var toStr = Object.prototype.toString;
            var hasSymbols = __webpack_require__(/*! has-symbols */ "./node_modules/has-symbols/index.js")();
            if (hasSymbols) {
                var symToStr = Symbol.prototype.toString;
                var symStringRegex = /^Symbol\(.*\)$/;
                var isSymbolObject = function isRealSymbolObject(value) {
                    if (typeof value.valueOf() !== 'symbol') {
                        return false;
                    }
                    return symStringRegex.test(symToStr.call(value));
                };
                module.exports = function isSymbol(value) {
                    if (typeof value === 'symbol') {
                        return true;
                    }
                    if (toStr.call(value) !== '[object Symbol]') {
                        return false;
                    }
                    try {
                        return isSymbolObject(value);
                    }
                    catch (e) {
                        return false;
                    }
                };
            }
            else {
                module.exports = function isSymbol(value) {
                    // this environment does not support Symbols.
                    return false && 0;
                };
            }
            /***/ 
        }),
        /***/ "./node_modules/is-typed-array/index.js": 
        /*!**********************************************!*\
          !*** ./node_modules/is-typed-array/index.js ***!
          \**********************************************/
        /***/ ((module, __unused_webpack_exports, __webpack_require__) => {
            "use strict";
            var whichTypedArray = __webpack_require__(/*! which-typed-array */ "./node_modules/which-typed-array/index.js");
            module.exports = function isTypedArray(value) {
                return !!whichTypedArray(value);
            };
            /***/ 
        }),
        /***/ "./node_modules/is-weakmap/index.js": 
        /*!******************************************!*\
          !*** ./node_modules/is-weakmap/index.js ***!
          \******************************************/
        /***/ ((module) => {
            "use strict";
            var $WeakMap = typeof WeakMap === 'function' && WeakMap.prototype ? WeakMap : null;
            var $WeakSet = typeof WeakSet === 'function' && WeakSet.prototype ? WeakSet : null;
            var exported;
            if (!$WeakMap) {
                // eslint-disable-next-line no-unused-vars
                exported = function isWeakMap(x) {
                    // `WeakMap` is not present in this environment.
                    return false;
                };
            }
            var $mapHas = $WeakMap ? $WeakMap.prototype.has : null;
            var $setHas = $WeakSet ? $WeakSet.prototype.has : null;
            if (!exported && !$mapHas) {
                // eslint-disable-next-line no-unused-vars
                exported = function isWeakMap(x) {
                    // `WeakMap` does not have a `has` method
                    return false;
                };
            }
            module.exports = exported || function isWeakMap(x) {
                if (!x || typeof x !== 'object') {
                    return false;
                }
                try {
                    $mapHas.call(x, $mapHas);
                    if ($setHas) {
                        try {
                            $setHas.call(x, $setHas);
                        }
                        catch (e) {
                            return true;
                        }
                    }
                    return x instanceof $WeakMap; // core-js workaround, pre-v3
                }
                catch (e) { }
                return false;
            };
            /***/ 
        }),
        /***/ "./node_modules/is-weakset/index.js": 
        /*!******************************************!*\
          !*** ./node_modules/is-weakset/index.js ***!
          \******************************************/
        /***/ ((module, __unused_webpack_exports, __webpack_require__) => {
            "use strict";
            var GetIntrinsic = __webpack_require__(/*! get-intrinsic */ "./node_modules/get-intrinsic/index.js");
            var callBound = __webpack_require__(/*! call-bind/callBound */ "./node_modules/call-bind/callBound.js");
            var $WeakSet = GetIntrinsic('%WeakSet%', true);
            var $setHas = callBound('WeakSet.prototype.has', true);
            if ($setHas) {
                var $mapHas = callBound('WeakMap.prototype.has', true);
                module.exports = function isWeakSet(x) {
                    if (!x || typeof x !== 'object') {
                        return false;
                    }
                    try {
                        $setHas(x, $setHas);
                        if ($mapHas) {
                            try {
                                $mapHas(x, $mapHas);
                            }
                            catch (e) {
                                return true;
                            }
                        }
                        return x instanceof $WeakSet; // core-js workaround, pre-v3
                    }
                    catch (e) { }
                    return false;
                };
            }
            else {
                // eslint-disable-next-line no-unused-vars
                module.exports = function isWeakSet(x) {
                    // `WeakSet` does not exist, or does not have a `has` method
                    return false;
                };
            }
            /***/ 
        }),
        /***/ "./node_modules/isarray/index.js": 
        /*!***************************************!*\
          !*** ./node_modules/isarray/index.js ***!
          \***************************************/
        /***/ ((module) => {
            var toString = {}.toString;
            module.exports = Array.isArray || function (arr) {
                return toString.call(arr) == '[object Array]';
            };
            /***/ 
        }),
        /***/ "./node_modules/lru-cache/index.js": 
        /*!*****************************************!*\
          !*** ./node_modules/lru-cache/index.js ***!
          \*****************************************/
        /***/ ((module, __unused_webpack_exports, __webpack_require__) => {
            "use strict";
            // A linked list to keep track of recently-used-ness
            const Yallist = __webpack_require__(/*! yallist */ "./node_modules/lru-cache/node_modules/yallist/yallist.js");
            const MAX = Symbol('max');
            const LENGTH = Symbol('length');
            const LENGTH_CALCULATOR = Symbol('lengthCalculator');
            const ALLOW_STALE = Symbol('allowStale');
            const MAX_AGE = Symbol('maxAge');
            const DISPOSE = Symbol('dispose');
            const NO_DISPOSE_ON_SET = Symbol('noDisposeOnSet');
            const LRU_LIST = Symbol('lruList');
            const CACHE = Symbol('cache');
            const UPDATE_AGE_ON_GET = Symbol('updateAgeOnGet');
            const naiveLength = () => 1;
            // lruList is a yallist where the head is the youngest
            // item, and the tail is the oldest.  the list contains the Hit
            // objects as the entries.
            // Each Hit object has a reference to its Yallist.Node.  This
            // never changes.
            //
            // cache is a Map (or PseudoMap) that matches the keys to
            // the Yallist.Node object.
            class LRUCache {
                constructor(options) {
                    if (typeof options === 'number')
                        options = { max: options };
                    if (!options)
                        options = {};
                    if (options.max && (typeof options.max !== 'number' || options.max < 0))
                        throw new TypeError('max must be a non-negative number');
                    // Kind of weird to have a default max of Infinity, but oh well.
                    const max = this[MAX] = options.max || Infinity;
                    const lc = options.length || naiveLength;
                    this[LENGTH_CALCULATOR] = (typeof lc !== 'function') ? naiveLength : lc;
                    this[ALLOW_STALE] = options.stale || false;
                    if (options.maxAge && typeof options.maxAge !== 'number')
                        throw new TypeError('maxAge must be a number');
                    this[MAX_AGE] = options.maxAge || 0;
                    this[DISPOSE] = options.dispose;
                    this[NO_DISPOSE_ON_SET] = options.noDisposeOnSet || false;
                    this[UPDATE_AGE_ON_GET] = options.updateAgeOnGet || false;
                    this.reset();
                }
                // resize the cache when the max changes.
                set max(mL) {
                    if (typeof mL !== 'number' || mL < 0)
                        throw new TypeError('max must be a non-negative number');
                    this[MAX] = mL || Infinity;
                    trim(this);
                }
                get max() {
                    return this[MAX];
                }
                set allowStale(allowStale) {
                    this[ALLOW_STALE] = !!allowStale;
                }
                get allowStale() {
                    return this[ALLOW_STALE];
                }
                set maxAge(mA) {
                    if (typeof mA !== 'number')
                        throw new TypeError('maxAge must be a non-negative number');
                    this[MAX_AGE] = mA;
                    trim(this);
                }
                get maxAge() {
                    return this[MAX_AGE];
                }
                // resize the cache when the lengthCalculator changes.
                set lengthCalculator(lC) {
                    if (typeof lC !== 'function')
                        lC = naiveLength;
                    if (lC !== this[LENGTH_CALCULATOR]) {
                        this[LENGTH_CALCULATOR] = lC;
                        this[LENGTH] = 0;
                        this[LRU_LIST].forEach(hit => {
                            hit.length = this[LENGTH_CALCULATOR](hit.value, hit.key);
                            this[LENGTH] += hit.length;
                        });
                    }
                    trim(this);
                }
                get lengthCalculator() { return this[LENGTH_CALCULATOR]; }
                get length() { return this[LENGTH]; }
                get itemCount() { return this[LRU_LIST].length; }
                rforEach(fn, thisp) {
                    thisp = thisp || this;
                    for (let walker = this[LRU_LIST].tail; walker !== null;) {
                        const prev = walker.prev;
                        forEachStep(this, fn, walker, thisp);
                        walker = prev;
                    }
                }
                forEach(fn, thisp) {
                    thisp = thisp || this;
                    for (let walker = this[LRU_LIST].head; walker !== null;) {
                        const next = walker.next;
                        forEachStep(this, fn, walker, thisp);
                        walker = next;
                    }
                }
                keys() {
                    return this[LRU_LIST].toArray().map(k => k.key);
                }
                values() {
                    return this[LRU_LIST].toArray().map(k => k.value);
                }
                reset() {
                    if (this[DISPOSE] &&
                        this[LRU_LIST] &&
                        this[LRU_LIST].length) {
                        this[LRU_LIST].forEach(hit => this[DISPOSE](hit.key, hit.value));
                    }
                    this[CACHE] = new Map(); // hash of items by key
                    this[LRU_LIST] = new Yallist(); // list of items in order of use recency
                    this[LENGTH] = 0; // length of items in the list
                }
                dump() {
                    return this[LRU_LIST].map(hit => isStale(this, hit) ? false : {
                        k: hit.key,
                        v: hit.value,
                        e: hit.now + (hit.maxAge || 0)
                    }).toArray().filter(h => h);
                }
                dumpLru() {
                    return this[LRU_LIST];
                }
                set(key, value, maxAge) {
                    maxAge = maxAge || this[MAX_AGE];
                    if (maxAge && typeof maxAge !== 'number')
                        throw new TypeError('maxAge must be a number');
                    const now = maxAge ? Date.now() : 0;
                    const len = this[LENGTH_CALCULATOR](value, key);
                    if (this[CACHE].has(key)) {
                        if (len > this[MAX]) {
                            del(this, this[CACHE].get(key));
                            return false;
                        }
                        const node = this[CACHE].get(key);
                        const item = node.value;
                        // dispose of the old one before overwriting
                        // split out into 2 ifs for better coverage tracking
                        if (this[DISPOSE]) {
                            if (!this[NO_DISPOSE_ON_SET])
                                this[DISPOSE](key, item.value);
                        }
                        item.now = now;
                        item.maxAge = maxAge;
                        item.value = value;
                        this[LENGTH] += len - item.length;
                        item.length = len;
                        this.get(key);
                        trim(this);
                        return true;
                    }
                    const hit = new Entry(key, value, len, now, maxAge);
                    // oversized objects fall out of cache automatically.
                    if (hit.length > this[MAX]) {
                        if (this[DISPOSE])
                            this[DISPOSE](key, value);
                        return false;
                    }
                    this[LENGTH] += hit.length;
                    this[LRU_LIST].unshift(hit);
                    this[CACHE].set(key, this[LRU_LIST].head);
                    trim(this);
                    return true;
                }
                has(key) {
                    if (!this[CACHE].has(key))
                        return false;
                    const hit = this[CACHE].get(key).value;
                    return !isStale(this, hit);
                }
                get(key) {
                    return get(this, key, true);
                }
                peek(key) {
                    return get(this, key, false);
                }
                pop() {
                    const node = this[LRU_LIST].tail;
                    if (!node)
                        return null;
                    del(this, node);
                    return node.value;
                }
                del(key) {
                    del(this, this[CACHE].get(key));
                }
                load(arr) {
                    // reset the cache
                    this.reset();
                    const now = Date.now();
                    // A previous serialized cache has the most recent items first
                    for (let l = arr.length - 1; l >= 0; l--) {
                        const hit = arr[l];
                        const expiresAt = hit.e || 0;
                        if (expiresAt === 0)
                            // the item was created without expiration in a non aged cache
                            this.set(hit.k, hit.v);
                        else {
                            const maxAge = expiresAt - now;
                            // dont add already expired items
                            if (maxAge > 0) {
                                this.set(hit.k, hit.v, maxAge);
                            }
                        }
                    }
                }
                prune() {
                    this[CACHE].forEach((value, key) => get(this, key, false));
                }
            }
            const get = (self, key, doUse) => {
                const node = self[CACHE].get(key);
                if (node) {
                    const hit = node.value;
                    if (isStale(self, hit)) {
                        del(self, node);
                        if (!self[ALLOW_STALE])
                            return undefined;
                    }
                    else {
                        if (doUse) {
                            if (self[UPDATE_AGE_ON_GET])
                                node.value.now = Date.now();
                            self[LRU_LIST].unshiftNode(node);
                        }
                    }
                    return hit.value;
                }
            };
            const isStale = (self, hit) => {
                if (!hit || (!hit.maxAge && !self[MAX_AGE]))
                    return false;
                const diff = Date.now() - hit.now;
                return hit.maxAge ? diff > hit.maxAge
                    : self[MAX_AGE] && (diff > self[MAX_AGE]);
            };
            const trim = self => {
                if (self[LENGTH] > self[MAX]) {
                    for (let walker = self[LRU_LIST].tail; self[LENGTH] > self[MAX] && walker !== null;) {
                        // We know that we're about to delete this one, and also
                        // what the next least recently used key will be, so just
                        // go ahead and set it now.
                        const prev = walker.prev;
                        del(self, walker);
                        walker = prev;
                    }
                }
            };
            const del = (self, node) => {
                if (node) {
                    const hit = node.value;
                    if (self[DISPOSE])
                        self[DISPOSE](hit.key, hit.value);
                    self[LENGTH] -= hit.length;
                    self[CACHE].delete(hit.key);
                    self[LRU_LIST].removeNode(node);
                }
            };
            class Entry {
                constructor(key, value, length, now, maxAge) {
                    this.key = key;
                    this.value = value;
                    this.length = length;
                    this.now = now;
                    this.maxAge = maxAge || 0;
                }
            }
            const forEachStep = (self, fn, node, thisp) => {
                let hit = node.value;
                if (isStale(self, hit)) {
                    del(self, node);
                    if (!self[ALLOW_STALE])
                        hit = undefined;
                }
                if (hit)
                    fn.call(thisp, hit.value, hit.key, self);
            };
            module.exports = LRUCache;
            /***/ 
        }),
        /***/ "./node_modules/lru-cache/node_modules/yallist/iterator.js": 
        /*!*****************************************************************!*\
          !*** ./node_modules/lru-cache/node_modules/yallist/iterator.js ***!
          \*****************************************************************/
        /***/ ((module) => {
            "use strict";
            module.exports = function (Yallist) {
                Yallist.prototype[Symbol.iterator] = function* () {
                    for (let walker = this.head; walker; walker = walker.next) {
                        yield walker.value;
                    }
                };
            };
            /***/ 
        }),
        /***/ "./node_modules/lru-cache/node_modules/yallist/yallist.js": 
        /*!****************************************************************!*\
          !*** ./node_modules/lru-cache/node_modules/yallist/yallist.js ***!
          \****************************************************************/
        /***/ ((module, __unused_webpack_exports, __webpack_require__) => {
            "use strict";
            module.exports = Yallist;
            Yallist.Node = Node;
            Yallist.create = Yallist;
            function Yallist(list) {
                var self = this;
                if (!(self instanceof Yallist)) {
                    self = new Yallist();
                }
                self.tail = null;
                self.head = null;
                self.length = 0;
                if (list && typeof list.forEach === 'function') {
                    list.forEach(function (item) {
                        self.push(item);
                    });
                }
                else if (arguments.length > 0) {
                    for (var i = 0, l = arguments.length; i < l; i++) {
                        self.push(arguments[i]);
                    }
                }
                return self;
            }
            Yallist.prototype.removeNode = function (node) {
                if (node.list !== this) {
                    throw new Error('removing node which does not belong to this list');
                }
                var next = node.next;
                var prev = node.prev;
                if (next) {
                    next.prev = prev;
                }
                if (prev) {
                    prev.next = next;
                }
                if (node === this.head) {
                    this.head = next;
                }
                if (node === this.tail) {
                    this.tail = prev;
                }
                node.list.length--;
                node.next = null;
                node.prev = null;
                node.list = null;
                return next;
            };
            Yallist.prototype.unshiftNode = function (node) {
                if (node === this.head) {
                    return;
                }
                if (node.list) {
                    node.list.removeNode(node);
                }
                var head = this.head;
                node.list = this;
                node.next = head;
                if (head) {
                    head.prev = node;
                }
                this.head = node;
                if (!this.tail) {
                    this.tail = node;
                }
                this.length++;
            };
            Yallist.prototype.pushNode = function (node) {
                if (node === this.tail) {
                    return;
                }
                if (node.list) {
                    node.list.removeNode(node);
                }
                var tail = this.tail;
                node.list = this;
                node.prev = tail;
                if (tail) {
                    tail.next = node;
                }
                this.tail = node;
                if (!this.head) {
                    this.head = node;
                }
                this.length++;
            };
            Yallist.prototype.push = function () {
                for (var i = 0, l = arguments.length; i < l; i++) {
                    push(this, arguments[i]);
                }
                return this.length;
            };
            Yallist.prototype.unshift = function () {
                for (var i = 0, l = arguments.length; i < l; i++) {
                    unshift(this, arguments[i]);
                }
                return this.length;
            };
            Yallist.prototype.pop = function () {
                if (!this.tail) {
                    return undefined;
                }
                var res = this.tail.value;
                this.tail = this.tail.prev;
                if (this.tail) {
                    this.tail.next = null;
                }
                else {
                    this.head = null;
                }
                this.length--;
                return res;
            };
            Yallist.prototype.shift = function () {
                if (!this.head) {
                    return undefined;
                }
                var res = this.head.value;
                this.head = this.head.next;
                if (this.head) {
                    this.head.prev = null;
                }
                else {
                    this.tail = null;
                }
                this.length--;
                return res;
            };
            Yallist.prototype.forEach = function (fn, thisp) {
                thisp = thisp || this;
                for (var walker = this.head, i = 0; walker !== null; i++) {
                    fn.call(thisp, walker.value, i, this);
                    walker = walker.next;
                }
            };
            Yallist.prototype.forEachReverse = function (fn, thisp) {
                thisp = thisp || this;
                for (var walker = this.tail, i = this.length - 1; walker !== null; i--) {
                    fn.call(thisp, walker.value, i, this);
                    walker = walker.prev;
                }
            };
            Yallist.prototype.get = function (n) {
                for (var i = 0, walker = this.head; walker !== null && i < n; i++) {
                    // abort out of the list early if we hit a cycle
                    walker = walker.next;
                }
                if (i === n && walker !== null) {
                    return walker.value;
                }
            };
            Yallist.prototype.getReverse = function (n) {
                for (var i = 0, walker = this.tail; walker !== null && i < n; i++) {
                    // abort out of the list early if we hit a cycle
                    walker = walker.prev;
                }
                if (i === n && walker !== null) {
                    return walker.value;
                }
            };
            Yallist.prototype.map = function (fn, thisp) {
                thisp = thisp || this;
                var res = new Yallist();
                for (var walker = this.head; walker !== null;) {
                    res.push(fn.call(thisp, walker.value, this));
                    walker = walker.next;
                }
                return res;
            };
            Yallist.prototype.mapReverse = function (fn, thisp) {
                thisp = thisp || this;
                var res = new Yallist();
                for (var walker = this.tail; walker !== null;) {
                    res.push(fn.call(thisp, walker.value, this));
                    walker = walker.prev;
                }
                return res;
            };
            Yallist.prototype.reduce = function (fn, initial) {
                var acc;
                var walker = this.head;
                if (arguments.length > 1) {
                    acc = initial;
                }
                else if (this.head) {
                    walker = this.head.next;
                    acc = this.head.value;
                }
                else {
                    throw new TypeError('Reduce of empty list with no initial value');
                }
                for (var i = 0; walker !== null; i++) {
                    acc = fn(acc, walker.value, i);
                    walker = walker.next;
                }
                return acc;
            };
            Yallist.prototype.reduceReverse = function (fn, initial) {
                var acc;
                var walker = this.tail;
                if (arguments.length > 1) {
                    acc = initial;
                }
                else if (this.tail) {
                    walker = this.tail.prev;
                    acc = this.tail.value;
                }
                else {
                    throw new TypeError('Reduce of empty list with no initial value');
                }
                for (var i = this.length - 1; walker !== null; i--) {
                    acc = fn(acc, walker.value, i);
                    walker = walker.prev;
                }
                return acc;
            };
            Yallist.prototype.toArray = function () {
                var arr = new Array(this.length);
                for (var i = 0, walker = this.head; walker !== null; i++) {
                    arr[i] = walker.value;
                    walker = walker.next;
                }
                return arr;
            };
            Yallist.prototype.toArrayReverse = function () {
                var arr = new Array(this.length);
                for (var i = 0, walker = this.tail; walker !== null; i++) {
                    arr[i] = walker.value;
                    walker = walker.prev;
                }
                return arr;
            };
            Yallist.prototype.slice = function (from, to) {
                to = to || this.length;
                if (to < 0) {
                    to += this.length;
                }
                from = from || 0;
                if (from < 0) {
                    from += this.length;
                }
                var ret = new Yallist();
                if (to < from || to < 0) {
                    return ret;
                }
                if (from < 0) {
                    from = 0;
                }
                if (to > this.length) {
                    to = this.length;
                }
                for (var i = 0, walker = this.head; walker !== null && i < from; i++) {
                    walker = walker.next;
                }
                for (; walker !== null && i < to; i++, walker = walker.next) {
                    ret.push(walker.value);
                }
                return ret;
            };
            Yallist.prototype.sliceReverse = function (from, to) {
                to = to || this.length;
                if (to < 0) {
                    to += this.length;
                }
                from = from || 0;
                if (from < 0) {
                    from += this.length;
                }
                var ret = new Yallist();
                if (to < from || to < 0) {
                    return ret;
                }
                if (from < 0) {
                    from = 0;
                }
                if (to > this.length) {
                    to = this.length;
                }
                for (var i = this.length, walker = this.tail; walker !== null && i > to; i--) {
                    walker = walker.prev;
                }
                for (; walker !== null && i > from; i--, walker = walker.prev) {
                    ret.push(walker.value);
                }
                return ret;
            };
            Yallist.prototype.splice = function (start, deleteCount /*, ...nodes */) {
                if (start > this.length) {
                    start = this.length - 1;
                }
                if (start < 0) {
                    start = this.length + start;
                }
                for (var i = 0, walker = this.head; walker !== null && i < start; i++) {
                    walker = walker.next;
                }
                var ret = [];
                for (var i = 0; walker && i < deleteCount; i++) {
                    ret.push(walker.value);
                    walker = this.removeNode(walker);
                }
                if (walker === null) {
                    walker = this.tail;
                }
                if (walker !== this.head && walker !== this.tail) {
                    walker = walker.prev;
                }
                for (var i = 2; i < arguments.length; i++) {
                    walker = insert(this, walker, arguments[i]);
                }
                return ret;
            };
            Yallist.prototype.reverse = function () {
                var head = this.head;
                var tail = this.tail;
                for (var walker = head; walker !== null; walker = walker.prev) {
                    var p = walker.prev;
                    walker.prev = walker.next;
                    walker.next = p;
                }
                this.head = tail;
                this.tail = head;
                return this;
            };
            function insert(self, node, value) {
                var inserted = node === self.head ?
                    new Node(value, null, node, self) :
                    new Node(value, node, node.next, self);
                if (inserted.next === null) {
                    self.tail = inserted;
                }
                if (inserted.prev === null) {
                    self.head = inserted;
                }
                self.length++;
                return inserted;
            }
            function push(self, item) {
                self.tail = new Node(item, self.tail, null, self);
                if (!self.head) {
                    self.head = self.tail;
                }
                self.length++;
            }
            function unshift(self, item) {
                self.head = new Node(item, null, self.head, self);
                if (!self.tail) {
                    self.tail = self.head;
                }
                self.length++;
            }
            function Node(value, prev, next, list) {
                if (!(this instanceof Node)) {
                    return new Node(value, prev, next, list);
                }
                this.list = list;
                this.value = value;
                if (prev) {
                    prev.next = this;
                    this.prev = prev;
                }
                else {
                    this.prev = null;
                }
                if (next) {
                    next.prev = this;
                    this.next = next;
                }
                else {
                    this.next = null;
                }
            }
            try {
                // add if support for Symbol.iterator is present
                __webpack_require__(/*! ./iterator.js */ "./node_modules/lru-cache/node_modules/yallist/iterator.js")(Yallist);
            }
            catch (er) { }
            /***/ 
        }),
        /***/ "./node_modules/md5/md5.js": 
        /*!*********************************!*\
          !*** ./node_modules/md5/md5.js ***!
          \*********************************/
        /***/ ((module, __unused_webpack_exports, __webpack_require__) => {
            (function () {
                var crypt = __webpack_require__(/*! crypt */ "./node_modules/crypt/crypt.js"), utf8 = (__webpack_require__(/*! charenc */ "./node_modules/charenc/charenc.js").utf8), isBuffer = __webpack_require__(/*! is-buffer */ "./node_modules/md5/node_modules/is-buffer/index.js"), bin = (__webpack_require__(/*! charenc */ "./node_modules/charenc/charenc.js").bin), 
                // The core
                md5 = function (message, options) {
                    // Convert to byte array
                    if (message.constructor == String)
                        if (options && options.encoding === 'binary')
                            message = bin.stringToBytes(message);
                        else
                            message = utf8.stringToBytes(message);
                    else if (isBuffer(message))
                        message = Array.prototype.slice.call(message, 0);
                    else if (!Array.isArray(message) && message.constructor !== Uint8Array)
                        message = message.toString();
                    // else, assume byte array already
                    var m = crypt.bytesToWords(message), l = message.length * 8, a = 1732584193, b = -271733879, c = -1732584194, d = 271733878;
                    // Swap endian
                    for (var i = 0; i < m.length; i++) {
                        m[i] = ((m[i] << 8) | (m[i] >>> 24)) & 0x00FF00FF |
                            ((m[i] << 24) | (m[i] >>> 8)) & 0xFF00FF00;
                    }
                    // Padding
                    m[l >>> 5] |= 0x80 << (l % 32);
                    m[(((l + 64) >>> 9) << 4) + 14] = l;
                    // Method shortcuts
                    var FF = md5._ff, GG = md5._gg, HH = md5._hh, II = md5._ii;
                    for (var i = 0; i < m.length; i += 16) {
                        var aa = a, bb = b, cc = c, dd = d;
                        a = FF(a, b, c, d, m[i + 0], 7, -680876936);
                        d = FF(d, a, b, c, m[i + 1], 12, -389564586);
                        c = FF(c, d, a, b, m[i + 2], 17, 606105819);
                        b = FF(b, c, d, a, m[i + 3], 22, -1044525330);
                        a = FF(a, b, c, d, m[i + 4], 7, -176418897);
                        d = FF(d, a, b, c, m[i + 5], 12, 1200080426);
                        c = FF(c, d, a, b, m[i + 6], 17, -1473231341);
                        b = FF(b, c, d, a, m[i + 7], 22, -45705983);
                        a = FF(a, b, c, d, m[i + 8], 7, 1770035416);
                        d = FF(d, a, b, c, m[i + 9], 12, -1958414417);
                        c = FF(c, d, a, b, m[i + 10], 17, -42063);
                        b = FF(b, c, d, a, m[i + 11], 22, -1990404162);
                        a = FF(a, b, c, d, m[i + 12], 7, 1804603682);
                        d = FF(d, a, b, c, m[i + 13], 12, -40341101);
                        c = FF(c, d, a, b, m[i + 14], 17, -1502002290);
                        b = FF(b, c, d, a, m[i + 15], 22, 1236535329);
                        a = GG(a, b, c, d, m[i + 1], 5, -165796510);
                        d = GG(d, a, b, c, m[i + 6], 9, -1069501632);
                        c = GG(c, d, a, b, m[i + 11], 14, 643717713);
                        b = GG(b, c, d, a, m[i + 0], 20, -373897302);
                        a = GG(a, b, c, d, m[i + 5], 5, -701558691);
                        d = GG(d, a, b, c, m[i + 10], 9, 38016083);
                        c = GG(c, d, a, b, m[i + 15], 14, -660478335);
                        b = GG(b, c, d, a, m[i + 4], 20, -405537848);
                        a = GG(a, b, c, d, m[i + 9], 5, 568446438);
                        d = GG(d, a, b, c, m[i + 14], 9, -1019803690);
                        c = GG(c, d, a, b, m[i + 3], 14, -187363961);
                        b = GG(b, c, d, a, m[i + 8], 20, 1163531501);
                        a = GG(a, b, c, d, m[i + 13], 5, -1444681467);
                        d = GG(d, a, b, c, m[i + 2], 9, -51403784);
                        c = GG(c, d, a, b, m[i + 7], 14, 1735328473);
                        b = GG(b, c, d, a, m[i + 12], 20, -1926607734);
                        a = HH(a, b, c, d, m[i + 5], 4, -378558);
                        d = HH(d, a, b, c, m[i + 8], 11, -2022574463);
                        c = HH(c, d, a, b, m[i + 11], 16, 1839030562);
                        b = HH(b, c, d, a, m[i + 14], 23, -35309556);
                        a = HH(a, b, c, d, m[i + 1], 4, -1530992060);
                        d = HH(d, a, b, c, m[i + 4], 11, 1272893353);
                        c = HH(c, d, a, b, m[i + 7], 16, -155497632);
                        b = HH(b, c, d, a, m[i + 10], 23, -1094730640);
                        a = HH(a, b, c, d, m[i + 13], 4, 681279174);
                        d = HH(d, a, b, c, m[i + 0], 11, -358537222);
                        c = HH(c, d, a, b, m[i + 3], 16, -722521979);
                        b = HH(b, c, d, a, m[i + 6], 23, 76029189);
                        a = HH(a, b, c, d, m[i + 9], 4, -640364487);
                        d = HH(d, a, b, c, m[i + 12], 11, -421815835);
                        c = HH(c, d, a, b, m[i + 15], 16, 530742520);
                        b = HH(b, c, d, a, m[i + 2], 23, -995338651);
                        a = II(a, b, c, d, m[i + 0], 6, -198630844);
                        d = II(d, a, b, c, m[i + 7], 10, 1126891415);
                        c = II(c, d, a, b, m[i + 14], 15, -1416354905);
                        b = II(b, c, d, a, m[i + 5], 21, -57434055);
                        a = II(a, b, c, d, m[i + 12], 6, 1700485571);
                        d = II(d, a, b, c, m[i + 3], 10, -1894986606);
                        c = II(c, d, a, b, m[i + 10], 15, -1051523);
                        b = II(b, c, d, a, m[i + 1], 21, -2054922799);
                        a = II(a, b, c, d, m[i + 8], 6, 1873313359);
                        d = II(d, a, b, c, m[i + 15], 10, -30611744);
                        c = II(c, d, a, b, m[i + 6], 15, -1560198380);
                        b = II(b, c, d, a, m[i + 13], 21, 1309151649);
                        a = II(a, b, c, d, m[i + 4], 6, -145523070);
                        d = II(d, a, b, c, m[i + 11], 10, -1120210379);
                        c = II(c, d, a, b, m[i + 2], 15, 718787259);
                        b = II(b, c, d, a, m[i + 9], 21, -343485551);
                        a = (a + aa) >>> 0;
                        b = (b + bb) >>> 0;
                        c = (c + cc) >>> 0;
                        d = (d + dd) >>> 0;
                    }
                    return crypt.endian([a, b, c, d]);
                };
                // Auxiliary functions
                md5._ff = function (a, b, c, d, x, s, t) {
                    var n = a + (b & c | ~b & d) + (x >>> 0) + t;
                    return ((n << s) | (n >>> (32 - s))) + b;
                };
                md5._gg = function (a, b, c, d, x, s, t) {
                    var n = a + (b & d | c & ~d) + (x >>> 0) + t;
                    return ((n << s) | (n >>> (32 - s))) + b;
                };
                md5._hh = function (a, b, c, d, x, s, t) {
                    var n = a + (b ^ c ^ d) + (x >>> 0) + t;
                    return ((n << s) | (n >>> (32 - s))) + b;
                };
                md5._ii = function (a, b, c, d, x, s, t) {
                    var n = a + (c ^ (b | ~d)) + (x >>> 0) + t;
                    return ((n << s) | (n >>> (32 - s))) + b;
                };
                // Package private blocksize
                md5._blocksize = 16;
                md5._digestsize = 16;
                module.exports = function (message, options) {
                    if (message === undefined || message === null)
                        throw new Error('Illegal argument ' + message);
                    var digestbytes = crypt.wordsToBytes(md5(message, options));
                    return options && options.asBytes ? digestbytes :
                        options && options.asString ? bin.bytesToString(digestbytes) :
                            crypt.bytesToHex(digestbytes);
                };
            })();
            /***/ 
        }),
        /***/ "./node_modules/md5/node_modules/is-buffer/index.js": 
        /*!**********************************************************!*\
          !*** ./node_modules/md5/node_modules/is-buffer/index.js ***!
          \**********************************************************/
        /***/ ((module) => {
            /*!
             * Determine if an object is a Buffer
             *
             * @author   Feross Aboukhadijeh <https://feross.org>
             * @license  MIT
             */
            // The _isBuffer check is for Safari 5-7 support, because it's missing
            // Object.prototype.constructor. Remove this eventually
            module.exports = function (obj) {
                return obj != null && (isBuffer(obj) || isSlowBuffer(obj) || !!obj._isBuffer);
            };
            function isBuffer(obj) {
                return !!obj.constructor && typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj);
            }
            // For Node v0.10 support. Remove this eventually.
            function isSlowBuffer(obj) {
                return typeof obj.readFloatLE === 'function' && typeof obj.slice === 'function' && isBuffer(obj.slice(0, 0));
            }
            /***/ 
        }),
        /***/ "./node_modules/memoize-one/dist/memoize-one.esm.js": 
        /*!**********************************************************!*\
          !*** ./node_modules/memoize-one/dist/memoize-one.esm.js ***!
          \**********************************************************/
        /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony export */ __webpack_require__.d(__webpack_exports__, {
                /* harmony export */ "default": () => ( /* binding */memoizeOne)
                /* harmony export */ 
            });
            var safeIsNaN = Number.isNaN ||
                function ponyfill(value) {
                    return typeof value === 'number' && value !== value;
                };
            function isEqual(first, second) {
                if (first === second) {
                    return true;
                }
                if (safeIsNaN(first) && safeIsNaN(second)) {
                    return true;
                }
                return false;
            }
            function areInputsEqual(newInputs, lastInputs) {
                if (newInputs.length !== lastInputs.length) {
                    return false;
                }
                for (var i = 0; i < newInputs.length; i++) {
                    if (!isEqual(newInputs[i], lastInputs[i])) {
                        return false;
                    }
                }
                return true;
            }
            function memoizeOne(resultFn, isEqual) {
                if (isEqual === void 0) {
                    isEqual = areInputsEqual;
                }
                var cache = null;
                function memoized() {
                    var newArgs = [];
                    for (var _i = 0; _i < arguments.length; _i++) {
                        newArgs[_i] = arguments[_i];
                    }
                    if (cache && cache.lastThis === this && isEqual(newArgs, cache.lastArgs)) {
                        return cache.lastResult;
                    }
                    var lastResult = resultFn.apply(this, newArgs);
                    cache = {
                        lastResult: lastResult,
                        lastArgs: newArgs,
                        lastThis: this,
                    };
                    return lastResult;
                }
                memoized.clear = function clear() {
                    cache = null;
                };
                return memoized;
            }
            /***/ 
        }),
        /***/ "./node_modules/object-inspect/index.js": 
        /*!**********************************************!*\
          !*** ./node_modules/object-inspect/index.js ***!
          \**********************************************/
        /***/ ((module, __unused_webpack_exports, __webpack_require__) => {
            var hasMap = typeof Map === 'function' && Map.prototype;
            var mapSizeDescriptor = Object.getOwnPropertyDescriptor && hasMap ? Object.getOwnPropertyDescriptor(Map.prototype, 'size') : null;
            var mapSize = hasMap && mapSizeDescriptor && typeof mapSizeDescriptor.get === 'function' ? mapSizeDescriptor.get : null;
            var mapForEach = hasMap && Map.prototype.forEach;
            var hasSet = typeof Set === 'function' && Set.prototype;
            var setSizeDescriptor = Object.getOwnPropertyDescriptor && hasSet ? Object.getOwnPropertyDescriptor(Set.prototype, 'size') : null;
            var setSize = hasSet && setSizeDescriptor && typeof setSizeDescriptor.get === 'function' ? setSizeDescriptor.get : null;
            var setForEach = hasSet && Set.prototype.forEach;
            var hasWeakMap = typeof WeakMap === 'function' && WeakMap.prototype;
            var weakMapHas = hasWeakMap ? WeakMap.prototype.has : null;
            var hasWeakSet = typeof WeakSet === 'function' && WeakSet.prototype;
            var weakSetHas = hasWeakSet ? WeakSet.prototype.has : null;
            var hasWeakRef = typeof WeakRef === 'function' && WeakRef.prototype;
            var weakRefDeref = hasWeakRef ? WeakRef.prototype.deref : null;
            var booleanValueOf = Boolean.prototype.valueOf;
            var objectToString = Object.prototype.toString;
            var functionToString = Function.prototype.toString;
            var $match = String.prototype.match;
            var $slice = String.prototype.slice;
            var $replace = String.prototype.replace;
            var $toUpperCase = String.prototype.toUpperCase;
            var $toLowerCase = String.prototype.toLowerCase;
            var $test = RegExp.prototype.test;
            var $concat = Array.prototype.concat;
            var $join = Array.prototype.join;
            var $arrSlice = Array.prototype.slice;
            var $floor = Math.floor;
            var bigIntValueOf = typeof BigInt === 'function' ? BigInt.prototype.valueOf : null;
            var gOPS = Object.getOwnPropertySymbols;
            var symToString = typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol' ? Symbol.prototype.toString : null;
            var hasShammedSymbols = typeof Symbol === 'function' && typeof Symbol.iterator === 'object';
            // ie, `has-tostringtag/shams
            var toStringTag = typeof Symbol === 'function' && Symbol.toStringTag && (typeof Symbol.toStringTag === hasShammedSymbols ? 'object' : 'symbol')
                ? Symbol.toStringTag
                : null;
            var isEnumerable = Object.prototype.propertyIsEnumerable;
            var gPO = (typeof Reflect === 'function' ? Reflect.getPrototypeOf : Object.getPrototypeOf) || ([].__proto__ === Array.prototype // eslint-disable-line no-proto
                ? function (O) {
                    return O.__proto__; // eslint-disable-line no-proto
                }
                : null);
            function addNumericSeparator(num, str) {
                if (num === Infinity
                    || num === -Infinity
                    || num !== num
                    || (num && num > -1000 && num < 1000)
                    || $test.call(/e/, str)) {
                    return str;
                }
                var sepRegex = /[0-9](?=(?:[0-9]{3})+(?![0-9]))/g;
                if (typeof num === 'number') {
                    var int = num < 0 ? -$floor(-num) : $floor(num); // trunc(num)
                    if (int !== num) {
                        var intStr = String(int);
                        var dec = $slice.call(str, intStr.length + 1);
                        return $replace.call(intStr, sepRegex, '$&_') + '.' + $replace.call($replace.call(dec, /([0-9]{3})/g, '$&_'), /_$/, '');
                    }
                }
                return $replace.call(str, sepRegex, '$&_');
            }
            var utilInspect = __webpack_require__(/*! ./util.inspect */ "./node_modules/object-inspect/util.inspect.js");
            var inspectCustom = utilInspect.custom;
            var inspectSymbol = isSymbol(inspectCustom) ? inspectCustom : null;
            module.exports = function inspect_(obj, options, depth, seen) {
                var opts = options || {};
                if (has(opts, 'quoteStyle') && (opts.quoteStyle !== 'single' && opts.quoteStyle !== 'double')) {
                    throw new TypeError('option "quoteStyle" must be "single" or "double"');
                }
                if (has(opts, 'maxStringLength') && (typeof opts.maxStringLength === 'number'
                    ? opts.maxStringLength < 0 && opts.maxStringLength !== Infinity
                    : opts.maxStringLength !== null)) {
                    throw new TypeError('option "maxStringLength", if provided, must be a positive integer, Infinity, or `null`');
                }
                var customInspect = has(opts, 'customInspect') ? opts.customInspect : true;
                if (typeof customInspect !== 'boolean' && customInspect !== 'symbol') {
                    throw new TypeError('option "customInspect", if provided, must be `true`, `false`, or `\'symbol\'`');
                }
                if (has(opts, 'indent')
                    && opts.indent !== null
                    && opts.indent !== '\t'
                    && !(parseInt(opts.indent, 10) === opts.indent && opts.indent > 0)) {
                    throw new TypeError('option "indent" must be "\\t", an integer > 0, or `null`');
                }
                if (has(opts, 'numericSeparator') && typeof opts.numericSeparator !== 'boolean') {
                    throw new TypeError('option "numericSeparator", if provided, must be `true` or `false`');
                }
                var numericSeparator = opts.numericSeparator;
                if (typeof obj === 'undefined') {
                    return 'undefined';
                }
                if (obj === null) {
                    return 'null';
                }
                if (typeof obj === 'boolean') {
                    return obj ? 'true' : 'false';
                }
                if (typeof obj === 'string') {
                    return inspectString(obj, opts);
                }
                if (typeof obj === 'number') {
                    if (obj === 0) {
                        return Infinity / obj > 0 ? '0' : '-0';
                    }
                    var str = String(obj);
                    return numericSeparator ? addNumericSeparator(obj, str) : str;
                }
                if (typeof obj === 'bigint') {
                    var bigIntStr = String(obj) + 'n';
                    return numericSeparator ? addNumericSeparator(obj, bigIntStr) : bigIntStr;
                }
                var maxDepth = typeof opts.depth === 'undefined' ? 5 : opts.depth;
                if (typeof depth === 'undefined') {
                    depth = 0;
                }
                if (depth >= maxDepth && maxDepth > 0 && typeof obj === 'object') {
                    return isArray(obj) ? '[Array]' : '[Object]';
                }
                var indent = getIndent(opts, depth);
                if (typeof seen === 'undefined') {
                    seen = [];
                }
                else if (indexOf(seen, obj) >= 0) {
                    return '[Circular]';
                }
                function inspect(value, from, noIndent) {
                    if (from) {
                        seen = $arrSlice.call(seen);
                        seen.push(from);
                    }
                    if (noIndent) {
                        var newOpts = {
                            depth: opts.depth
                        };
                        if (has(opts, 'quoteStyle')) {
                            newOpts.quoteStyle = opts.quoteStyle;
                        }
                        return inspect_(value, newOpts, depth + 1, seen);
                    }
                    return inspect_(value, opts, depth + 1, seen);
                }
                if (typeof obj === 'function' && !isRegExp(obj)) { // in older engines, regexes are callable
                    var name = nameOf(obj);
                    var keys = arrObjKeys(obj, inspect);
                    return '[Function' + (name ? ': ' + name : ' (anonymous)') + ']' + (keys.length > 0 ? ' { ' + $join.call(keys, ', ') + ' }' : '');
                }
                if (isSymbol(obj)) {
                    var symString = hasShammedSymbols ? $replace.call(String(obj), /^(Symbol\(.*\))_[^)]*$/, '$1') : symToString.call(obj);
                    return typeof obj === 'object' && !hasShammedSymbols ? markBoxed(symString) : symString;
                }
                if (isElement(obj)) {
                    var s = '<' + $toLowerCase.call(String(obj.nodeName));
                    var attrs = obj.attributes || [];
                    for (var i = 0; i < attrs.length; i++) {
                        s += ' ' + attrs[i].name + '=' + wrapQuotes(quote(attrs[i].value), 'double', opts);
                    }
                    s += '>';
                    if (obj.childNodes && obj.childNodes.length) {
                        s += '...';
                    }
                    s += '</' + $toLowerCase.call(String(obj.nodeName)) + '>';
                    return s;
                }
                if (isArray(obj)) {
                    if (obj.length === 0) {
                        return '[]';
                    }
                    var xs = arrObjKeys(obj, inspect);
                    if (indent && !singleLineValues(xs)) {
                        return '[' + indentedJoin(xs, indent) + ']';
                    }
                    return '[ ' + $join.call(xs, ', ') + ' ]';
                }
                if (isError(obj)) {
                    var parts = arrObjKeys(obj, inspect);
                    if (!('cause' in Error.prototype) && 'cause' in obj && !isEnumerable.call(obj, 'cause')) {
                        return '{ [' + String(obj) + '] ' + $join.call($concat.call('[cause]: ' + inspect(obj.cause), parts), ', ') + ' }';
                    }
                    if (parts.length === 0) {
                        return '[' + String(obj) + ']';
                    }
                    return '{ [' + String(obj) + '] ' + $join.call(parts, ', ') + ' }';
                }
                if (typeof obj === 'object' && customInspect) {
                    if (inspectSymbol && typeof obj[inspectSymbol] === 'function' && utilInspect) {
                        return utilInspect(obj, { depth: maxDepth - depth });
                    }
                    else if (customInspect !== 'symbol' && typeof obj.inspect === 'function') {
                        return obj.inspect();
                    }
                }
                if (isMap(obj)) {
                    var mapParts = [];
                    if (mapForEach) {
                        mapForEach.call(obj, function (value, key) {
                            mapParts.push(inspect(key, obj, true) + ' => ' + inspect(value, obj));
                        });
                    }
                    return collectionOf('Map', mapSize.call(obj), mapParts, indent);
                }
                if (isSet(obj)) {
                    var setParts = [];
                    if (setForEach) {
                        setForEach.call(obj, function (value) {
                            setParts.push(inspect(value, obj));
                        });
                    }
                    return collectionOf('Set', setSize.call(obj), setParts, indent);
                }
                if (isWeakMap(obj)) {
                    return weakCollectionOf('WeakMap');
                }
                if (isWeakSet(obj)) {
                    return weakCollectionOf('WeakSet');
                }
                if (isWeakRef(obj)) {
                    return weakCollectionOf('WeakRef');
                }
                if (isNumber(obj)) {
                    return markBoxed(inspect(Number(obj)));
                }
                if (isBigInt(obj)) {
                    return markBoxed(inspect(bigIntValueOf.call(obj)));
                }
                if (isBoolean(obj)) {
                    return markBoxed(booleanValueOf.call(obj));
                }
                if (isString(obj)) {
                    return markBoxed(inspect(String(obj)));
                }
                if (!isDate(obj) && !isRegExp(obj)) {
                    var ys = arrObjKeys(obj, inspect);
                    var isPlainObject = gPO ? gPO(obj) === Object.prototype : obj instanceof Object || obj.constructor === Object;
                    var protoTag = obj instanceof Object ? '' : 'null prototype';
                    var stringTag = !isPlainObject && toStringTag && Object(obj) === obj && toStringTag in obj ? $slice.call(toStr(obj), 8, -1) : protoTag ? 'Object' : '';
                    var constructorTag = isPlainObject || typeof obj.constructor !== 'function' ? '' : obj.constructor.name ? obj.constructor.name + ' ' : '';
                    var tag = constructorTag + (stringTag || protoTag ? '[' + $join.call($concat.call([], stringTag || [], protoTag || []), ': ') + '] ' : '');
                    if (ys.length === 0) {
                        return tag + '{}';
                    }
                    if (indent) {
                        return tag + '{' + indentedJoin(ys, indent) + '}';
                    }
                    return tag + '{ ' + $join.call(ys, ', ') + ' }';
                }
                return String(obj);
            };
            function wrapQuotes(s, defaultStyle, opts) {
                var quoteChar = (opts.quoteStyle || defaultStyle) === 'double' ? '"' : "'";
                return quoteChar + s + quoteChar;
            }
            function quote(s) {
                return $replace.call(String(s), /"/g, '&quot;');
            }
            function isArray(obj) { return toStr(obj) === '[object Array]' && (!toStringTag || !(typeof obj === 'object' && toStringTag in obj)); }
            function isDate(obj) { return toStr(obj) === '[object Date]' && (!toStringTag || !(typeof obj === 'object' && toStringTag in obj)); }
            function isRegExp(obj) { return toStr(obj) === '[object RegExp]' && (!toStringTag || !(typeof obj === 'object' && toStringTag in obj)); }
            function isError(obj) { return toStr(obj) === '[object Error]' && (!toStringTag || !(typeof obj === 'object' && toStringTag in obj)); }
            function isString(obj) { return toStr(obj) === '[object String]' && (!toStringTag || !(typeof obj === 'object' && toStringTag in obj)); }
            function isNumber(obj) { return toStr(obj) === '[object Number]' && (!toStringTag || !(typeof obj === 'object' && toStringTag in obj)); }
            function isBoolean(obj) { return toStr(obj) === '[object Boolean]' && (!toStringTag || !(typeof obj === 'object' && toStringTag in obj)); }
            // Symbol and BigInt do have Symbol.toStringTag by spec, so that can't be used to eliminate false positives
            function isSymbol(obj) {
                if (hasShammedSymbols) {
                    return obj && typeof obj === 'object' && obj instanceof Symbol;
                }
                if (typeof obj === 'symbol') {
                    return true;
                }
                if (!obj || typeof obj !== 'object' || !symToString) {
                    return false;
                }
                try {
                    symToString.call(obj);
                    return true;
                }
                catch (e) { }
                return false;
            }
            function isBigInt(obj) {
                if (!obj || typeof obj !== 'object' || !bigIntValueOf) {
                    return false;
                }
                try {
                    bigIntValueOf.call(obj);
                    return true;
                }
                catch (e) { }
                return false;
            }
            var hasOwn = Object.prototype.hasOwnProperty || function (key) { return key in this; };
            function has(obj, key) {
                return hasOwn.call(obj, key);
            }
            function toStr(obj) {
                return objectToString.call(obj);
            }
            function nameOf(f) {
                if (f.name) {
                    return f.name;
                }
                var m = $match.call(functionToString.call(f), /^function\s*([\w$]+)/);
                if (m) {
                    return m[1];
                }
                return null;
            }
            function indexOf(xs, x) {
                if (xs.indexOf) {
                    return xs.indexOf(x);
                }
                for (var i = 0, l = xs.length; i < l; i++) {
                    if (xs[i] === x) {
                        return i;
                    }
                }
                return -1;
            }
            function isMap(x) {
                if (!mapSize || !x || typeof x !== 'object') {
                    return false;
                }
                try {
                    mapSize.call(x);
                    try {
                        setSize.call(x);
                    }
                    catch (s) {
                        return true;
                    }
                    return x instanceof Map; // core-js workaround, pre-v2.5.0
                }
                catch (e) { }
                return false;
            }
            function isWeakMap(x) {
                if (!weakMapHas || !x || typeof x !== 'object') {
                    return false;
                }
                try {
                    weakMapHas.call(x, weakMapHas);
                    try {
                        weakSetHas.call(x, weakSetHas);
                    }
                    catch (s) {
                        return true;
                    }
                    return x instanceof WeakMap; // core-js workaround, pre-v2.5.0
                }
                catch (e) { }
                return false;
            }
            function isWeakRef(x) {
                if (!weakRefDeref || !x || typeof x !== 'object') {
                    return false;
                }
                try {
                    weakRefDeref.call(x);
                    return true;
                }
                catch (e) { }
                return false;
            }
            function isSet(x) {
                if (!setSize || !x || typeof x !== 'object') {
                    return false;
                }
                try {
                    setSize.call(x);
                    try {
                        mapSize.call(x);
                    }
                    catch (m) {
                        return true;
                    }
                    return x instanceof Set; // core-js workaround, pre-v2.5.0
                }
                catch (e) { }
                return false;
            }
            function isWeakSet(x) {
                if (!weakSetHas || !x || typeof x !== 'object') {
                    return false;
                }
                try {
                    weakSetHas.call(x, weakSetHas);
                    try {
                        weakMapHas.call(x, weakMapHas);
                    }
                    catch (s) {
                        return true;
                    }
                    return x instanceof WeakSet; // core-js workaround, pre-v2.5.0
                }
                catch (e) { }
                return false;
            }
            function isElement(x) {
                if (!x || typeof x !== 'object') {
                    return false;
                }
                if (typeof HTMLElement !== 'undefined' && x instanceof HTMLElement) {
                    return true;
                }
                return typeof x.nodeName === 'string' && typeof x.getAttribute === 'function';
            }
            function inspectString(str, opts) {
                if (str.length > opts.maxStringLength) {
                    var remaining = str.length - opts.maxStringLength;
                    var trailer = '... ' + remaining + ' more character' + (remaining > 1 ? 's' : '');
                    return inspectString($slice.call(str, 0, opts.maxStringLength), opts) + trailer;
                }
                // eslint-disable-next-line no-control-regex
                var s = $replace.call($replace.call(str, /(['\\])/g, '\\$1'), /[\x00-\x1f]/g, lowbyte);
                return wrapQuotes(s, 'single', opts);
            }
            function lowbyte(c) {
                var n = c.charCodeAt(0);
                var x = {
                    8: 'b',
                    9: 't',
                    10: 'n',
                    12: 'f',
                    13: 'r'
                }[n];
                if (x) {
                    return '\\' + x;
                }
                return '\\x' + (n < 0x10 ? '0' : '') + $toUpperCase.call(n.toString(16));
            }
            function markBoxed(str) {
                return 'Object(' + str + ')';
            }
            function weakCollectionOf(type) {
                return type + ' { ? }';
            }
            function collectionOf(type, size, entries, indent) {
                var joinedEntries = indent ? indentedJoin(entries, indent) : $join.call(entries, ', ');
                return type + ' (' + size + ') {' + joinedEntries + '}';
            }
            function singleLineValues(xs) {
                for (var i = 0; i < xs.length; i++) {
                    if (indexOf(xs[i], '\n') >= 0) {
                        return false;
                    }
                }
                return true;
            }
            function getIndent(opts, depth) {
                var baseIndent;
                if (opts.indent === '\t') {
                    baseIndent = '\t';
                }
                else if (typeof opts.indent === 'number' && opts.indent > 0) {
                    baseIndent = $join.call(Array(opts.indent + 1), ' ');
                }
                else {
                    return null;
                }
                return {
                    base: baseIndent,
                    prev: $join.call(Array(depth + 1), baseIndent)
                };
            }
            function indentedJoin(xs, indent) {
                if (xs.length === 0) {
                    return '';
                }
                var lineJoiner = '\n' + indent.prev + indent.base;
                return lineJoiner + $join.call(xs, ',' + lineJoiner) + '\n' + indent.prev;
            }
            function arrObjKeys(obj, inspect) {
                var isArr = isArray(obj);
                var xs = [];
                if (isArr) {
                    xs.length = obj.length;
                    for (var i = 0; i < obj.length; i++) {
                        xs[i] = has(obj, i) ? inspect(obj[i], obj) : '';
                    }
                }
                var syms = typeof gOPS === 'function' ? gOPS(obj) : [];
                var symMap;
                if (hasShammedSymbols) {
                    symMap = {};
                    for (var k = 0; k < syms.length; k++) {
                        symMap['$' + syms[k]] = syms[k];
                    }
                }
                for (var key in obj) { // eslint-disable-line no-restricted-syntax
                    if (!has(obj, key)) {
                        continue;
                    } // eslint-disable-line no-restricted-syntax, no-continue
                    if (isArr && String(Number(key)) === key && key < obj.length) {
                        continue;
                    } // eslint-disable-line no-restricted-syntax, no-continue
                    if (hasShammedSymbols && symMap['$' + key] instanceof Symbol) {
                        // this is to prevent shammed Symbols, which are stored as strings, from being included in the string key section
                        continue; // eslint-disable-line no-restricted-syntax, no-continue
                    }
                    else if ($test.call(/[^\w$]/, key)) {
                        xs.push(inspect(key, obj) + ': ' + inspect(obj[key], obj));
                    }
                    else {
                        xs.push(key + ': ' + inspect(obj[key], obj));
                    }
                }
                if (typeof gOPS === 'function') {
                    for (var j = 0; j < syms.length; j++) {
                        if (isEnumerable.call(obj, syms[j])) {
                            xs.push('[' + inspect(syms[j]) + ']: ' + inspect(obj[syms[j]], obj));
                        }
                    }
                }
                return xs;
            }
            /***/ 
        }),
        /***/ "./node_modules/object-inspect/util.inspect.js": 
        /*!*****************************************************!*\
          !*** ./node_modules/object-inspect/util.inspect.js ***!
          \*****************************************************/
        /***/ ((module, __unused_webpack_exports, __webpack_require__) => {
            module.exports = __webpack_require__(/*! util */ "util").inspect;
            /***/ 
        }),
        /***/ "./node_modules/object-is/implementation.js": 
        /*!**************************************************!*\
          !*** ./node_modules/object-is/implementation.js ***!
          \**************************************************/
        /***/ ((module) => {
            "use strict";
            var numberIsNaN = function (value) {
                return value !== value;
            };
            module.exports = function is(a, b) {
                if (a === 0 && b === 0) {
                    return 1 / a === 1 / b;
                }
                if (a === b) {
                    return true;
                }
                if (numberIsNaN(a) && numberIsNaN(b)) {
                    return true;
                }
                return false;
            };
            /***/ 
        }),
        /***/ "./node_modules/object-is/index.js": 
        /*!*****************************************!*\
          !*** ./node_modules/object-is/index.js ***!
          \*****************************************/
        /***/ ((module, __unused_webpack_exports, __webpack_require__) => {
            "use strict";
            var define = __webpack_require__(/*! define-properties */ "./node_modules/define-properties/index.js");
            var callBind = __webpack_require__(/*! call-bind */ "./node_modules/call-bind/index.js");
            var implementation = __webpack_require__(/*! ./implementation */ "./node_modules/object-is/implementation.js");
            var getPolyfill = __webpack_require__(/*! ./polyfill */ "./node_modules/object-is/polyfill.js");
            var shim = __webpack_require__(/*! ./shim */ "./node_modules/object-is/shim.js");
            var polyfill = callBind(getPolyfill(), Object);
            define(polyfill, {
                getPolyfill: getPolyfill,
                implementation: implementation,
                shim: shim
            });
            module.exports = polyfill;
            /***/ 
        }),
        /***/ "./node_modules/object-is/polyfill.js": 
        /*!********************************************!*\
          !*** ./node_modules/object-is/polyfill.js ***!
          \********************************************/
        /***/ ((module, __unused_webpack_exports, __webpack_require__) => {
            "use strict";
            var implementation = __webpack_require__(/*! ./implementation */ "./node_modules/object-is/implementation.js");
            module.exports = function getPolyfill() {
                return typeof Object.is === 'function' ? Object.is : implementation;
            };
            /***/ 
        }),
        /***/ "./node_modules/object-is/shim.js": 
        /*!****************************************!*\
          !*** ./node_modules/object-is/shim.js ***!
          \****************************************/
        /***/ ((module, __unused_webpack_exports, __webpack_require__) => {
            "use strict";
            var getPolyfill = __webpack_require__(/*! ./polyfill */ "./node_modules/object-is/polyfill.js");
            var define = __webpack_require__(/*! define-properties */ "./node_modules/define-properties/index.js");
            module.exports = function shimObjectIs() {
                var polyfill = getPolyfill();
                define(Object, { is: polyfill }, {
                    is: function testObjectIs() {
                        return Object.is !== polyfill;
                    }
                });
                return polyfill;
            };
            /***/ 
        }),
        /***/ "./node_modules/object-keys/implementation.js": 
        /*!****************************************************!*\
          !*** ./node_modules/object-keys/implementation.js ***!
          \****************************************************/
        /***/ ((module, __unused_webpack_exports, __webpack_require__) => {
            "use strict";
            var keysShim;
            if (!Object.keys) {
                // modified from https://github.com/es-shims/es5-shim
                var has = Object.prototype.hasOwnProperty;
                var toStr = Object.prototype.toString;
                var isArgs = __webpack_require__(/*! ./isArguments */ "./node_modules/object-keys/isArguments.js"); // eslint-disable-line global-require
                var isEnumerable = Object.prototype.propertyIsEnumerable;
                var hasDontEnumBug = !isEnumerable.call({ toString: null }, 'toString');
                var hasProtoEnumBug = isEnumerable.call(function () { }, 'prototype');
                var dontEnums = [
                    'toString',
                    'toLocaleString',
                    'valueOf',
                    'hasOwnProperty',
                    'isPrototypeOf',
                    'propertyIsEnumerable',
                    'constructor'
                ];
                var equalsConstructorPrototype = function (o) {
                    var ctor = o.constructor;
                    return ctor && ctor.prototype === o;
                };
                var excludedKeys = {
                    $applicationCache: true,
                    $console: true,
                    $external: true,
                    $frame: true,
                    $frameElement: true,
                    $frames: true,
                    $innerHeight: true,
                    $innerWidth: true,
                    $onmozfullscreenchange: true,
                    $onmozfullscreenerror: true,
                    $outerHeight: true,
                    $outerWidth: true,
                    $pageXOffset: true,
                    $pageYOffset: true,
                    $parent: true,
                    $scrollLeft: true,
                    $scrollTop: true,
                    $scrollX: true,
                    $scrollY: true,
                    $self: true,
                    $webkitIndexedDB: true,
                    $webkitStorageInfo: true,
                    $window: true
                };
                var hasAutomationEqualityBug = (function () {
                    /* global window */
                    if (typeof window === 'undefined') {
                        return false;
                    }
                    for (var k in window) {
                        try {
                            if (!excludedKeys['$' + k] && has.call(window, k) && window[k] !== null && typeof window[k] === 'object') {
                                try {
                                    equalsConstructorPrototype(window[k]);
                                }
                                catch (e) {
                                    return true;
                                }
                            }
                        }
                        catch (e) {
                            return true;
                        }
                    }
                    return false;
                }());
                var equalsConstructorPrototypeIfNotBuggy = function (o) {
                    /* global window */
                    if (typeof window === 'undefined' || !hasAutomationEqualityBug) {
                        return equalsConstructorPrototype(o);
                    }
                    try {
                        return equalsConstructorPrototype(o);
                    }
                    catch (e) {
                        return false;
                    }
                };
                keysShim = function keys(object) {
                    var isObject = object !== null && typeof object === 'object';
                    var isFunction = toStr.call(object) === '[object Function]';
                    var isArguments = isArgs(object);
                    var isString = isObject && toStr.call(object) === '[object String]';
                    var theKeys = [];
                    if (!isObject && !isFunction && !isArguments) {
                        throw new TypeError('Object.keys called on a non-object');
                    }
                    var skipProto = hasProtoEnumBug && isFunction;
                    if (isString && object.length > 0 && !has.call(object, 0)) {
                        for (var i = 0; i < object.length; ++i) {
                            theKeys.push(String(i));
                        }
                    }
                    if (isArguments && object.length > 0) {
                        for (var j = 0; j < object.length; ++j) {
                            theKeys.push(String(j));
                        }
                    }
                    else {
                        for (var name in object) {
                            if (!(skipProto && name === 'prototype') && has.call(object, name)) {
                                theKeys.push(String(name));
                            }
                        }
                    }
                    if (hasDontEnumBug) {
                        var skipConstructor = equalsConstructorPrototypeIfNotBuggy(object);
                        for (var k = 0; k < dontEnums.length; ++k) {
                            if (!(skipConstructor && dontEnums[k] === 'constructor') && has.call(object, dontEnums[k])) {
                                theKeys.push(dontEnums[k]);
                            }
                        }
                    }
                    return theKeys;
                };
            }
            module.exports = keysShim;
            /***/ 
        }),
        /***/ "./node_modules/object-keys/index.js": 
        /*!*******************************************!*\
          !*** ./node_modules/object-keys/index.js ***!
          \*******************************************/
        /***/ ((module, __unused_webpack_exports, __webpack_require__) => {
            "use strict";
            var slice = Array.prototype.slice;
            var isArgs = __webpack_require__(/*! ./isArguments */ "./node_modules/object-keys/isArguments.js");
            var origKeys = Object.keys;
            var keysShim = origKeys ? function keys(o) { return origKeys(o); } : __webpack_require__(/*! ./implementation */ "./node_modules/object-keys/implementation.js");
            var originalKeys = Object.keys;
            keysShim.shim = function shimObjectKeys() {
                if (Object.keys) {
                    var keysWorksWithArguments = (function () {
                        // Safari 5.0 bug
                        var args = Object.keys(arguments);
                        return args && args.length === arguments.length;
                    }(1, 2));
                    if (!keysWorksWithArguments) {
                        Object.keys = function keys(object) {
                            if (isArgs(object)) {
                                return originalKeys(slice.call(object));
                            }
                            return originalKeys(object);
                        };
                    }
                }
                else {
                    Object.keys = keysShim;
                }
                return Object.keys || keysShim;
            };
            module.exports = keysShim;
            /***/ 
        }),
        /***/ "./node_modules/object-keys/isArguments.js": 
        /*!*************************************************!*\
          !*** ./node_modules/object-keys/isArguments.js ***!
          \*************************************************/
        /***/ ((module) => {
            "use strict";
            var toStr = Object.prototype.toString;
            module.exports = function isArguments(value) {
                var str = toStr.call(value);
                var isArgs = str === '[object Arguments]';
                if (!isArgs) {
                    isArgs = str !== '[object Array]' &&
                        value !== null &&
                        typeof value === 'object' &&
                        typeof value.length === 'number' &&
                        value.length >= 0 &&
                        toStr.call(value.callee) === '[object Function]';
                }
                return isArgs;
            };
            /***/ 
        }),
        /***/ "./node_modules/object.assign/implementation.js": 
        /*!******************************************************!*\
          !*** ./node_modules/object.assign/implementation.js ***!
          \******************************************************/
        /***/ ((module, __unused_webpack_exports, __webpack_require__) => {
            "use strict";
            // modified from https://github.com/es-shims/es6-shim
            var objectKeys = __webpack_require__(/*! object-keys */ "./node_modules/object-keys/index.js");
            var hasSymbols = __webpack_require__(/*! has-symbols/shams */ "./node_modules/has-symbols/shams.js")();
            var callBound = __webpack_require__(/*! call-bind/callBound */ "./node_modules/call-bind/callBound.js");
            var toObject = Object;
            var $push = callBound('Array.prototype.push');
            var $propIsEnumerable = callBound('Object.prototype.propertyIsEnumerable');
            var originalGetSymbols = hasSymbols ? Object.getOwnPropertySymbols : null;
            // eslint-disable-next-line no-unused-vars
            module.exports = function assign(target, source1) {
                if (target == null) {
                    throw new TypeError('target must be an object');
                }
                var to = toObject(target); // step 1
                if (arguments.length === 1) {
                    return to; // step 2
                }
                for (var s = 1; s < arguments.length; ++s) {
                    var from = toObject(arguments[s]); // step 3.a.i
                    // step 3.a.ii:
                    var keys = objectKeys(from);
                    var getSymbols = hasSymbols && (Object.getOwnPropertySymbols || originalGetSymbols);
                    if (getSymbols) {
                        var syms = getSymbols(from);
                        for (var j = 0; j < syms.length; ++j) {
                            var key = syms[j];
                            if ($propIsEnumerable(from, key)) {
                                $push(keys, key);
                            }
                        }
                    }
                    // step 3.a.iii:
                    for (var i = 0; i < keys.length; ++i) {
                        var nextKey = keys[i];
                        if ($propIsEnumerable(from, nextKey)) { // step 3.a.iii.2
                            var propValue = from[nextKey]; // step 3.a.iii.2.a
                            to[nextKey] = propValue; // step 3.a.iii.2.b
                        }
                    }
                }
                return to; // step 4
            };
            /***/ 
        }),
        /***/ "./node_modules/object.assign/index.js": 
        /*!*********************************************!*\
          !*** ./node_modules/object.assign/index.js ***!
          \*********************************************/
        /***/ ((module, __unused_webpack_exports, __webpack_require__) => {
            "use strict";
            var defineProperties = __webpack_require__(/*! define-properties */ "./node_modules/define-properties/index.js");
            var callBind = __webpack_require__(/*! call-bind */ "./node_modules/call-bind/index.js");
            var implementation = __webpack_require__(/*! ./implementation */ "./node_modules/object.assign/implementation.js");
            var getPolyfill = __webpack_require__(/*! ./polyfill */ "./node_modules/object.assign/polyfill.js");
            var shim = __webpack_require__(/*! ./shim */ "./node_modules/object.assign/shim.js");
            var polyfill = callBind.apply(getPolyfill());
            // eslint-disable-next-line no-unused-vars
            var bound = function assign(target, source1) {
                return polyfill(Object, arguments);
            };
            defineProperties(bound, {
                getPolyfill: getPolyfill,
                implementation: implementation,
                shim: shim
            });
            module.exports = bound;
            /***/ 
        }),
        /***/ "./node_modules/object.assign/polyfill.js": 
        /*!************************************************!*\
          !*** ./node_modules/object.assign/polyfill.js ***!
          \************************************************/
        /***/ ((module, __unused_webpack_exports, __webpack_require__) => {
            "use strict";
            var implementation = __webpack_require__(/*! ./implementation */ "./node_modules/object.assign/implementation.js");
            var lacksProperEnumerationOrder = function () {
                if (!Object.assign) {
                    return false;
                }
                /*
                 * v8, specifically in node 4.x, has a bug with incorrect property enumeration order
                 * note: this does not detect the bug unless there's 20 characters
                 */
                var str = 'abcdefghijklmnopqrst';
                var letters = str.split('');
                var map = {};
                for (var i = 0; i < letters.length; ++i) {
                    map[letters[i]] = letters[i];
                }
                var obj = Object.assign({}, map);
                var actual = '';
                for (var k in obj) {
                    actual += k;
                }
                return str !== actual;
            };
            var assignHasPendingExceptions = function () {
                if (!Object.assign || !Object.preventExtensions) {
                    return false;
                }
                /*
                 * Firefox 37 still has "pending exception" logic in its Object.assign implementation,
                 * which is 72% slower than our shim, and Firefox 40's native implementation.
                 */
                var thrower = Object.preventExtensions({ 1: 2 });
                try {
                    Object.assign(thrower, 'xy');
                }
                catch (e) {
                    return thrower[1] === 'y';
                }
                return false;
            };
            module.exports = function getPolyfill() {
                if (!Object.assign) {
                    return implementation;
                }
                if (lacksProperEnumerationOrder()) {
                    return implementation;
                }
                if (assignHasPendingExceptions()) {
                    return implementation;
                }
                return Object.assign;
            };
            /***/ 
        }),
        /***/ "./node_modules/object.assign/shim.js": 
        /*!********************************************!*\
          !*** ./node_modules/object.assign/shim.js ***!
          \********************************************/
        /***/ ((module, __unused_webpack_exports, __webpack_require__) => {
            "use strict";
            var define = __webpack_require__(/*! define-properties */ "./node_modules/define-properties/index.js");
            var getPolyfill = __webpack_require__(/*! ./polyfill */ "./node_modules/object.assign/polyfill.js");
            module.exports = function shimAssign() {
                var polyfill = getPolyfill();
                define(Object, { assign: polyfill }, { assign: function () { return Object.assign !== polyfill; } });
                return polyfill;
            };
            /***/ 
        }),
        /***/ "./node_modules/regexp.prototype.flags/implementation.js": 
        /*!***************************************************************!*\
          !*** ./node_modules/regexp.prototype.flags/implementation.js ***!
          \***************************************************************/
        /***/ ((module, __unused_webpack_exports, __webpack_require__) => {
            "use strict";
            var setFunctionName = __webpack_require__(/*! set-function-name */ "./node_modules/set-function-name/index.js");
            var $Object = Object;
            var $TypeError = TypeError;
            module.exports = setFunctionName(function flags() {
                if (this != null && this !== $Object(this)) {
                    throw new $TypeError('RegExp.prototype.flags getter called on non-object');
                }
                var result = '';
                if (this.hasIndices) {
                    result += 'd';
                }
                if (this.global) {
                    result += 'g';
                }
                if (this.ignoreCase) {
                    result += 'i';
                }
                if (this.multiline) {
                    result += 'm';
                }
                if (this.dotAll) {
                    result += 's';
                }
                if (this.unicode) {
                    result += 'u';
                }
                if (this.unicodeSets) {
                    result += 'v';
                }
                if (this.sticky) {
                    result += 'y';
                }
                return result;
            }, 'get flags', true);
            /***/ 
        }),
        /***/ "./node_modules/regexp.prototype.flags/index.js": 
        /*!******************************************************!*\
          !*** ./node_modules/regexp.prototype.flags/index.js ***!
          \******************************************************/
        /***/ ((module, __unused_webpack_exports, __webpack_require__) => {
            "use strict";
            var define = __webpack_require__(/*! define-properties */ "./node_modules/define-properties/index.js");
            var callBind = __webpack_require__(/*! call-bind */ "./node_modules/call-bind/index.js");
            var implementation = __webpack_require__(/*! ./implementation */ "./node_modules/regexp.prototype.flags/implementation.js");
            var getPolyfill = __webpack_require__(/*! ./polyfill */ "./node_modules/regexp.prototype.flags/polyfill.js");
            var shim = __webpack_require__(/*! ./shim */ "./node_modules/regexp.prototype.flags/shim.js");
            var flagsBound = callBind(getPolyfill());
            define(flagsBound, {
                getPolyfill: getPolyfill,
                implementation: implementation,
                shim: shim
            });
            module.exports = flagsBound;
            /***/ 
        }),
        /***/ "./node_modules/regexp.prototype.flags/polyfill.js": 
        /*!*********************************************************!*\
          !*** ./node_modules/regexp.prototype.flags/polyfill.js ***!
          \*********************************************************/
        /***/ ((module, __unused_webpack_exports, __webpack_require__) => {
            "use strict";
            var implementation = __webpack_require__(/*! ./implementation */ "./node_modules/regexp.prototype.flags/implementation.js");
            var supportsDescriptors = (__webpack_require__(/*! define-properties */ "./node_modules/define-properties/index.js").supportsDescriptors);
            var $gOPD = Object.getOwnPropertyDescriptor;
            module.exports = function getPolyfill() {
                if (supportsDescriptors && (/a/mig).flags === 'gim') {
                    var descriptor = $gOPD(RegExp.prototype, 'flags');
                    if (descriptor
                        && typeof descriptor.get === 'function'
                        && typeof RegExp.prototype.dotAll === 'boolean'
                        && typeof RegExp.prototype.hasIndices === 'boolean') {
                        /* eslint getter-return: 0 */
                        var calls = '';
                        var o = {};
                        Object.defineProperty(o, 'hasIndices', {
                            get: function () {
                                calls += 'd';
                            }
                        });
                        Object.defineProperty(o, 'sticky', {
                            get: function () {
                                calls += 'y';
                            }
                        });
                        if (calls === 'dy') {
                            return descriptor.get;
                        }
                    }
                }
                return implementation;
            };
            /***/ 
        }),
        /***/ "./node_modules/regexp.prototype.flags/shim.js": 
        /*!*****************************************************!*\
          !*** ./node_modules/regexp.prototype.flags/shim.js ***!
          \*****************************************************/
        /***/ ((module, __unused_webpack_exports, __webpack_require__) => {
            "use strict";
            var supportsDescriptors = (__webpack_require__(/*! define-properties */ "./node_modules/define-properties/index.js").supportsDescriptors);
            var getPolyfill = __webpack_require__(/*! ./polyfill */ "./node_modules/regexp.prototype.flags/polyfill.js");
            var gOPD = Object.getOwnPropertyDescriptor;
            var defineProperty = Object.defineProperty;
            var TypeErr = TypeError;
            var getProto = Object.getPrototypeOf;
            var regex = /a/;
            module.exports = function shimFlags() {
                if (!supportsDescriptors || !getProto) {
                    throw new TypeErr('RegExp.prototype.flags requires a true ES5 environment that supports property descriptors');
                }
                var polyfill = getPolyfill();
                var proto = getProto(regex);
                var descriptor = gOPD(proto, 'flags');
                if (!descriptor || descriptor.get !== polyfill) {
                    defineProperty(proto, 'flags', {
                        configurable: true,
                        enumerable: false,
                        get: polyfill
                    });
                }
                return polyfill;
            };
            /***/ 
        }),
        /***/ "./node_modules/sax/lib/sax.js": 
        /*!*************************************!*\
          !*** ./node_modules/sax/lib/sax.js ***!
          \*************************************/
        /***/ ((__unused_webpack_module, exports, __webpack_require__) => {
            ;
            (function (sax) {
                sax.parser = function (strict, opt) { return new SAXParser(strict, opt); };
                sax.SAXParser = SAXParser;
                sax.SAXStream = SAXStream;
                sax.createStream = createStream;
                // When we pass the MAX_BUFFER_LENGTH position, start checking for buffer overruns.
                // When we check, schedule the next check for MAX_BUFFER_LENGTH - (max(buffer lengths)),
                // since that's the earliest that a buffer overrun could occur.  This way, checks are
                // as rare as required, but as often as necessary to ensure never crossing this bound.
                // Furthermore, buffers are only tested at most once per write(), so passing a very
                // large string into write() might have undesirable effects, but this is manageable by
                // the caller, so it is assumed to be safe.  Thus, a call to write() may, in the extreme
                // edge case, result in creating at most one complete copy of the string passed in.
                // Set to Infinity to have unlimited buffers.
                sax.MAX_BUFFER_LENGTH = 64 * 1024;
                var buffers = [
                    'comment', 'sgmlDecl', 'textNode', 'tagName', 'doctype',
                    'procInstName', 'procInstBody', 'entity', 'attribName',
                    'attribValue', 'cdata', 'script'
                ];
                sax.EVENTS = [
                    'text',
                    'processinginstruction',
                    'sgmldeclaration',
                    'doctype',
                    'comment',
                    'opentagstart',
                    'attribute',
                    'opentag',
                    'closetag',
                    'opencdata',
                    'cdata',
                    'closecdata',
                    'error',
                    'end',
                    'ready',
                    'script',
                    'opennamespace',
                    'closenamespace'
                ];
                function SAXParser(strict, opt) {
                    if (!(this instanceof SAXParser)) {
                        return new SAXParser(strict, opt);
                    }
                    var parser = this;
                    clearBuffers(parser);
                    parser.q = parser.c = '';
                    parser.bufferCheckPosition = sax.MAX_BUFFER_LENGTH;
                    parser.opt = opt || {};
                    parser.opt.lowercase = parser.opt.lowercase || parser.opt.lowercasetags;
                    parser.looseCase = parser.opt.lowercase ? 'toLowerCase' : 'toUpperCase';
                    parser.tags = [];
                    parser.closed = parser.closedRoot = parser.sawRoot = false;
                    parser.tag = parser.error = null;
                    parser.strict = !!strict;
                    parser.noscript = !!(strict || parser.opt.noscript);
                    parser.state = S.BEGIN;
                    parser.strictEntities = parser.opt.strictEntities;
                    parser.ENTITIES = parser.strictEntities ? Object.create(sax.XML_ENTITIES) : Object.create(sax.ENTITIES);
                    parser.attribList = [];
                    // namespaces form a prototype chain.
                    // it always points at the current tag,
                    // which protos to its parent tag.
                    if (parser.opt.xmlns) {
                        parser.ns = Object.create(rootNS);
                    }
                    // mostly just for error reporting
                    parser.trackPosition = parser.opt.position !== false;
                    if (parser.trackPosition) {
                        parser.position = parser.line = parser.column = 0;
                    }
                    emit(parser, 'onready');
                }
                if (!Object.create) {
                    Object.create = function (o) {
                        function F() { }
                        F.prototype = o;
                        var newf = new F();
                        return newf;
                    };
                }
                if (!Object.keys) {
                    Object.keys = function (o) {
                        var a = [];
                        for (var i in o)
                            if (o.hasOwnProperty(i))
                                a.push(i);
                        return a;
                    };
                }
                function checkBufferLength(parser) {
                    var maxAllowed = Math.max(sax.MAX_BUFFER_LENGTH, 10);
                    var maxActual = 0;
                    for (var i = 0, l = buffers.length; i < l; i++) {
                        var len = parser[buffers[i]].length;
                        if (len > maxAllowed) {
                            // Text/cdata nodes can get big, and since they're buffered,
                            // we can get here under normal conditions.
                            // Avoid issues by emitting the text node now,
                            // so at least it won't get any bigger.
                            switch (buffers[i]) {
                                case 'textNode':
                                    closeText(parser);
                                    break;
                                case 'cdata':
                                    emitNode(parser, 'oncdata', parser.cdata);
                                    parser.cdata = '';
                                    break;
                                case 'script':
                                    emitNode(parser, 'onscript', parser.script);
                                    parser.script = '';
                                    break;
                                default:
                                    error(parser, 'Max buffer length exceeded: ' + buffers[i]);
                            }
                        }
                        maxActual = Math.max(maxActual, len);
                    }
                    // schedule the next check for the earliest possible buffer overrun.
                    var m = sax.MAX_BUFFER_LENGTH - maxActual;
                    parser.bufferCheckPosition = m + parser.position;
                }
                function clearBuffers(parser) {
                    for (var i = 0, l = buffers.length; i < l; i++) {
                        parser[buffers[i]] = '';
                    }
                }
                function flushBuffers(parser) {
                    closeText(parser);
                    if (parser.cdata !== '') {
                        emitNode(parser, 'oncdata', parser.cdata);
                        parser.cdata = '';
                    }
                    if (parser.script !== '') {
                        emitNode(parser, 'onscript', parser.script);
                        parser.script = '';
                    }
                }
                SAXParser.prototype = {
                    end: function () { end(this); },
                    write: write,
                    resume: function () { this.error = null; return this; },
                    close: function () { return this.write(null); },
                    flush: function () { flushBuffers(this); }
                };
                var Stream;
                try {
                    Stream = (__webpack_require__(/*! stream */ "stream").Stream);
                }
                catch (ex) {
                    Stream = function () { };
                }
                var streamWraps = sax.EVENTS.filter(function (ev) {
                    return ev !== 'error' && ev !== 'end';
                });
                function createStream(strict, opt) {
                    return new SAXStream(strict, opt);
                }
                function SAXStream(strict, opt) {
                    if (!(this instanceof SAXStream)) {
                        return new SAXStream(strict, opt);
                    }
                    Stream.apply(this);
                    this._parser = new SAXParser(strict, opt);
                    this.writable = true;
                    this.readable = true;
                    var me = this;
                    this._parser.onend = function () {
                        me.emit('end');
                    };
                    this._parser.onerror = function (er) {
                        me.emit('error', er);
                        // if didn't throw, then means error was handled.
                        // go ahead and clear error, so we can write again.
                        me._parser.error = null;
                    };
                    this._decoder = null;
                    streamWraps.forEach(function (ev) {
                        Object.defineProperty(me, 'on' + ev, {
                            get: function () {
                                return me._parser['on' + ev];
                            },
                            set: function (h) {
                                if (!h) {
                                    me.removeAllListeners(ev);
                                    me._parser['on' + ev] = h;
                                    return h;
                                }
                                me.on(ev, h);
                            },
                            enumerable: true,
                            configurable: false
                        });
                    });
                }
                SAXStream.prototype = Object.create(Stream.prototype, {
                    constructor: {
                        value: SAXStream
                    }
                });
                SAXStream.prototype.write = function (data) {
                    if (typeof Buffer === 'function' &&
                        typeof Buffer.isBuffer === 'function' &&
                        Buffer.isBuffer(data)) {
                        if (!this._decoder) {
                            var SD = (__webpack_require__(/*! string_decoder */ "string_decoder").StringDecoder);
                            this._decoder = new SD('utf8');
                        }
                        data = this._decoder.write(data);
                    }
                    this._parser.write(data.toString());
                    this.emit('data', data);
                    return true;
                };
                SAXStream.prototype.end = function (chunk) {
                    if (chunk && chunk.length) {
                        this.write(chunk);
                    }
                    this._parser.end();
                    return true;
                };
                SAXStream.prototype.on = function (ev, handler) {
                    var me = this;
                    if (!me._parser['on' + ev] && streamWraps.indexOf(ev) !== -1) {
                        me._parser['on' + ev] = function () {
                            var args = arguments.length === 1 ? [arguments[0]] : Array.apply(null, arguments);
                            args.splice(0, 0, ev);
                            me.emit.apply(me, args);
                        };
                    }
                    return Stream.prototype.on.call(me, ev, handler);
                };
                // this really needs to be replaced with character classes.
                // XML allows all manner of ridiculous numbers and digits.
                var CDATA = '[CDATA[';
                var DOCTYPE = 'DOCTYPE';
                var XML_NAMESPACE = 'http://www.w3.org/XML/1998/namespace';
                var XMLNS_NAMESPACE = 'http://www.w3.org/2000/xmlns/';
                var rootNS = { xml: XML_NAMESPACE, xmlns: XMLNS_NAMESPACE };
                // http://www.w3.org/TR/REC-xml/#NT-NameStartChar
                // This implementation works on strings, a single character at a time
                // as such, it cannot ever support astral-plane characters (10000-EFFFF)
                // without a significant breaking change to either this  parser, or the
                // JavaScript language.  Implementation of an emoji-capable xml parser
                // is left as an exercise for the reader.
                var nameStart = /[:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/;
                var nameBody = /[:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\u00B7\u0300-\u036F\u203F-\u2040.\d-]/;
                var entityStart = /[#:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/;
                var entityBody = /[#:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\u00B7\u0300-\u036F\u203F-\u2040.\d-]/;
                function isWhitespace(c) {
                    return c === ' ' || c === '\n' || c === '\r' || c === '\t';
                }
                function isQuote(c) {
                    return c === '"' || c === '\'';
                }
                function isAttribEnd(c) {
                    return c === '>' || isWhitespace(c);
                }
                function isMatch(regex, c) {
                    return regex.test(c);
                }
                function notMatch(regex, c) {
                    return !isMatch(regex, c);
                }
                var S = 0;
                sax.STATE = {
                    BEGIN: S++,
                    BEGIN_WHITESPACE: S++,
                    TEXT: S++,
                    TEXT_ENTITY: S++,
                    OPEN_WAKA: S++,
                    SGML_DECL: S++,
                    SGML_DECL_QUOTED: S++,
                    DOCTYPE: S++,
                    DOCTYPE_QUOTED: S++,
                    DOCTYPE_DTD: S++,
                    DOCTYPE_DTD_QUOTED: S++,
                    COMMENT_STARTING: S++,
                    COMMENT: S++,
                    COMMENT_ENDING: S++,
                    COMMENT_ENDED: S++,
                    CDATA: S++,
                    CDATA_ENDING: S++,
                    CDATA_ENDING_2: S++,
                    PROC_INST: S++,
                    PROC_INST_BODY: S++,
                    PROC_INST_ENDING: S++,
                    OPEN_TAG: S++,
                    OPEN_TAG_SLASH: S++,
                    ATTRIB: S++,
                    ATTRIB_NAME: S++,
                    ATTRIB_NAME_SAW_WHITE: S++,
                    ATTRIB_VALUE: S++,
                    ATTRIB_VALUE_QUOTED: S++,
                    ATTRIB_VALUE_CLOSED: S++,
                    ATTRIB_VALUE_UNQUOTED: S++,
                    ATTRIB_VALUE_ENTITY_Q: S++,
                    ATTRIB_VALUE_ENTITY_U: S++,
                    CLOSE_TAG: S++,
                    CLOSE_TAG_SAW_WHITE: S++,
                    SCRIPT: S++,
                    SCRIPT_ENDING: S++ // <script> ... <
                };
                sax.XML_ENTITIES = {
                    'amp': '&',
                    'gt': '>',
                    'lt': '<',
                    'quot': '"',
                    'apos': "'"
                };
                sax.ENTITIES = {
                    'amp': '&',
                    'gt': '>',
                    'lt': '<',
                    'quot': '"',
                    'apos': "'",
                    'AElig': 198,
                    'Aacute': 193,
                    'Acirc': 194,
                    'Agrave': 192,
                    'Aring': 197,
                    'Atilde': 195,
                    'Auml': 196,
                    'Ccedil': 199,
                    'ETH': 208,
                    'Eacute': 201,
                    'Ecirc': 202,
                    'Egrave': 200,
                    'Euml': 203,
                    'Iacute': 205,
                    'Icirc': 206,
                    'Igrave': 204,
                    'Iuml': 207,
                    'Ntilde': 209,
                    'Oacute': 211,
                    'Ocirc': 212,
                    'Ograve': 210,
                    'Oslash': 216,
                    'Otilde': 213,
                    'Ouml': 214,
                    'THORN': 222,
                    'Uacute': 218,
                    'Ucirc': 219,
                    'Ugrave': 217,
                    'Uuml': 220,
                    'Yacute': 221,
                    'aacute': 225,
                    'acirc': 226,
                    'aelig': 230,
                    'agrave': 224,
                    'aring': 229,
                    'atilde': 227,
                    'auml': 228,
                    'ccedil': 231,
                    'eacute': 233,
                    'ecirc': 234,
                    'egrave': 232,
                    'eth': 240,
                    'euml': 235,
                    'iacute': 237,
                    'icirc': 238,
                    'igrave': 236,
                    'iuml': 239,
                    'ntilde': 241,
                    'oacute': 243,
                    'ocirc': 244,
                    'ograve': 242,
                    'oslash': 248,
                    'otilde': 245,
                    'ouml': 246,
                    'szlig': 223,
                    'thorn': 254,
                    'uacute': 250,
                    'ucirc': 251,
                    'ugrave': 249,
                    'uuml': 252,
                    'yacute': 253,
                    'yuml': 255,
                    'copy': 169,
                    'reg': 174,
                    'nbsp': 160,
                    'iexcl': 161,
                    'cent': 162,
                    'pound': 163,
                    'curren': 164,
                    'yen': 165,
                    'brvbar': 166,
                    'sect': 167,
                    'uml': 168,
                    'ordf': 170,
                    'laquo': 171,
                    'not': 172,
                    'shy': 173,
                    'macr': 175,
                    'deg': 176,
                    'plusmn': 177,
                    'sup1': 185,
                    'sup2': 178,
                    'sup3': 179,
                    'acute': 180,
                    'micro': 181,
                    'para': 182,
                    'middot': 183,
                    'cedil': 184,
                    'ordm': 186,
                    'raquo': 187,
                    'frac14': 188,
                    'frac12': 189,
                    'frac34': 190,
                    'iquest': 191,
                    'times': 215,
                    'divide': 247,
                    'OElig': 338,
                    'oelig': 339,
                    'Scaron': 352,
                    'scaron': 353,
                    'Yuml': 376,
                    'fnof': 402,
                    'circ': 710,
                    'tilde': 732,
                    'Alpha': 913,
                    'Beta': 914,
                    'Gamma': 915,
                    'Delta': 916,
                    'Epsilon': 917,
                    'Zeta': 918,
                    'Eta': 919,
                    'Theta': 920,
                    'Iota': 921,
                    'Kappa': 922,
                    'Lambda': 923,
                    'Mu': 924,
                    'Nu': 925,
                    'Xi': 926,
                    'Omicron': 927,
                    'Pi': 928,
                    'Rho': 929,
                    'Sigma': 931,
                    'Tau': 932,
                    'Upsilon': 933,
                    'Phi': 934,
                    'Chi': 935,
                    'Psi': 936,
                    'Omega': 937,
                    'alpha': 945,
                    'beta': 946,
                    'gamma': 947,
                    'delta': 948,
                    'epsilon': 949,
                    'zeta': 950,
                    'eta': 951,
                    'theta': 952,
                    'iota': 953,
                    'kappa': 954,
                    'lambda': 955,
                    'mu': 956,
                    'nu': 957,
                    'xi': 958,
                    'omicron': 959,
                    'pi': 960,
                    'rho': 961,
                    'sigmaf': 962,
                    'sigma': 963,
                    'tau': 964,
                    'upsilon': 965,
                    'phi': 966,
                    'chi': 967,
                    'psi': 968,
                    'omega': 969,
                    'thetasym': 977,
                    'upsih': 978,
                    'piv': 982,
                    'ensp': 8194,
                    'emsp': 8195,
                    'thinsp': 8201,
                    'zwnj': 8204,
                    'zwj': 8205,
                    'lrm': 8206,
                    'rlm': 8207,
                    'ndash': 8211,
                    'mdash': 8212,
                    'lsquo': 8216,
                    'rsquo': 8217,
                    'sbquo': 8218,
                    'ldquo': 8220,
                    'rdquo': 8221,
                    'bdquo': 8222,
                    'dagger': 8224,
                    'Dagger': 8225,
                    'bull': 8226,
                    'hellip': 8230,
                    'permil': 8240,
                    'prime': 8242,
                    'Prime': 8243,
                    'lsaquo': 8249,
                    'rsaquo': 8250,
                    'oline': 8254,
                    'frasl': 8260,
                    'euro': 8364,
                    'image': 8465,
                    'weierp': 8472,
                    'real': 8476,
                    'trade': 8482,
                    'alefsym': 8501,
                    'larr': 8592,
                    'uarr': 8593,
                    'rarr': 8594,
                    'darr': 8595,
                    'harr': 8596,
                    'crarr': 8629,
                    'lArr': 8656,
                    'uArr': 8657,
                    'rArr': 8658,
                    'dArr': 8659,
                    'hArr': 8660,
                    'forall': 8704,
                    'part': 8706,
                    'exist': 8707,
                    'empty': 8709,
                    'nabla': 8711,
                    'isin': 8712,
                    'notin': 8713,
                    'ni': 8715,
                    'prod': 8719,
                    'sum': 8721,
                    'minus': 8722,
                    'lowast': 8727,
                    'radic': 8730,
                    'prop': 8733,
                    'infin': 8734,
                    'ang': 8736,
                    'and': 8743,
                    'or': 8744,
                    'cap': 8745,
                    'cup': 8746,
                    'int': 8747,
                    'there4': 8756,
                    'sim': 8764,
                    'cong': 8773,
                    'asymp': 8776,
                    'ne': 8800,
                    'equiv': 8801,
                    'le': 8804,
                    'ge': 8805,
                    'sub': 8834,
                    'sup': 8835,
                    'nsub': 8836,
                    'sube': 8838,
                    'supe': 8839,
                    'oplus': 8853,
                    'otimes': 8855,
                    'perp': 8869,
                    'sdot': 8901,
                    'lceil': 8968,
                    'rceil': 8969,
                    'lfloor': 8970,
                    'rfloor': 8971,
                    'lang': 9001,
                    'rang': 9002,
                    'loz': 9674,
                    'spades': 9824,
                    'clubs': 9827,
                    'hearts': 9829,
                    'diams': 9830
                };
                Object.keys(sax.ENTITIES).forEach(function (key) {
                    var e = sax.ENTITIES[key];
                    var s = typeof e === 'number' ? String.fromCharCode(e) : e;
                    sax.ENTITIES[key] = s;
                });
                for (var s in sax.STATE) {
                    sax.STATE[sax.STATE[s]] = s;
                }
                // shorthand
                S = sax.STATE;
                function emit(parser, event, data) {
                    parser[event] && parser[event](data);
                }
                function emitNode(parser, nodeType, data) {
                    if (parser.textNode)
                        closeText(parser);
                    emit(parser, nodeType, data);
                }
                function closeText(parser) {
                    parser.textNode = textopts(parser.opt, parser.textNode);
                    if (parser.textNode)
                        emit(parser, 'ontext', parser.textNode);
                    parser.textNode = '';
                }
                function textopts(opt, text) {
                    if (opt.trim)
                        text = text.trim();
                    if (opt.normalize)
                        text = text.replace(/\s+/g, ' ');
                    return text;
                }
                function error(parser, er) {
                    closeText(parser);
                    if (parser.trackPosition) {
                        er += '\nLine: ' + parser.line +
                            '\nColumn: ' + parser.column +
                            '\nChar: ' + parser.c;
                    }
                    er = new Error(er);
                    parser.error = er;
                    emit(parser, 'onerror', er);
                    return parser;
                }
                function end(parser) {
                    if (parser.sawRoot && !parser.closedRoot)
                        strictFail(parser, 'Unclosed root tag');
                    if ((parser.state !== S.BEGIN) &&
                        (parser.state !== S.BEGIN_WHITESPACE) &&
                        (parser.state !== S.TEXT)) {
                        error(parser, 'Unexpected end');
                    }
                    closeText(parser);
                    parser.c = '';
                    parser.closed = true;
                    emit(parser, 'onend');
                    SAXParser.call(parser, parser.strict, parser.opt);
                    return parser;
                }
                function strictFail(parser, message) {
                    if (typeof parser !== 'object' || !(parser instanceof SAXParser)) {
                        throw new Error('bad call to strictFail');
                    }
                    if (parser.strict) {
                        error(parser, message);
                    }
                }
                function newTag(parser) {
                    if (!parser.strict)
                        parser.tagName = parser.tagName[parser.looseCase]();
                    var parent = parser.tags[parser.tags.length - 1] || parser;
                    var tag = parser.tag = { name: parser.tagName, attributes: {} };
                    // will be overridden if tag contails an xmlns="foo" or xmlns:foo="bar"
                    if (parser.opt.xmlns) {
                        tag.ns = parent.ns;
                    }
                    parser.attribList.length = 0;
                    emitNode(parser, 'onopentagstart', tag);
                }
                function qname(name, attribute) {
                    var i = name.indexOf(':');
                    var qualName = i < 0 ? ['', name] : name.split(':');
                    var prefix = qualName[0];
                    var local = qualName[1];
                    // <x "xmlns"="http://foo">
                    if (attribute && name === 'xmlns') {
                        prefix = 'xmlns';
                        local = '';
                    }
                    return { prefix: prefix, local: local };
                }
                function attrib(parser) {
                    if (!parser.strict) {
                        parser.attribName = parser.attribName[parser.looseCase]();
                    }
                    if (parser.attribList.indexOf(parser.attribName) !== -1 ||
                        parser.tag.attributes.hasOwnProperty(parser.attribName)) {
                        parser.attribName = parser.attribValue = '';
                        return;
                    }
                    if (parser.opt.xmlns) {
                        var qn = qname(parser.attribName, true);
                        var prefix = qn.prefix;
                        var local = qn.local;
                        if (prefix === 'xmlns') {
                            // namespace binding attribute. push the binding into scope
                            if (local === 'xml' && parser.attribValue !== XML_NAMESPACE) {
                                strictFail(parser, 'xml: prefix must be bound to ' + XML_NAMESPACE + '\n' +
                                    'Actual: ' + parser.attribValue);
                            }
                            else if (local === 'xmlns' && parser.attribValue !== XMLNS_NAMESPACE) {
                                strictFail(parser, 'xmlns: prefix must be bound to ' + XMLNS_NAMESPACE + '\n' +
                                    'Actual: ' + parser.attribValue);
                            }
                            else {
                                var tag = parser.tag;
                                var parent = parser.tags[parser.tags.length - 1] || parser;
                                if (tag.ns === parent.ns) {
                                    tag.ns = Object.create(parent.ns);
                                }
                                tag.ns[local] = parser.attribValue;
                            }
                        }
                        // defer onattribute events until all attributes have been seen
                        // so any new bindings can take effect. preserve attribute order
                        // so deferred events can be emitted in document order
                        parser.attribList.push([parser.attribName, parser.attribValue]);
                    }
                    else {
                        // in non-xmlns mode, we can emit the event right away
                        parser.tag.attributes[parser.attribName] = parser.attribValue;
                        emitNode(parser, 'onattribute', {
                            name: parser.attribName,
                            value: parser.attribValue
                        });
                    }
                    parser.attribName = parser.attribValue = '';
                }
                function openTag(parser, selfClosing) {
                    if (parser.opt.xmlns) {
                        // emit namespace binding events
                        var tag = parser.tag;
                        // add namespace info to tag
                        var qn = qname(parser.tagName);
                        tag.prefix = qn.prefix;
                        tag.local = qn.local;
                        tag.uri = tag.ns[qn.prefix] || '';
                        if (tag.prefix && !tag.uri) {
                            strictFail(parser, 'Unbound namespace prefix: ' +
                                JSON.stringify(parser.tagName));
                            tag.uri = qn.prefix;
                        }
                        var parent = parser.tags[parser.tags.length - 1] || parser;
                        if (tag.ns && parent.ns !== tag.ns) {
                            Object.keys(tag.ns).forEach(function (p) {
                                emitNode(parser, 'onopennamespace', {
                                    prefix: p,
                                    uri: tag.ns[p]
                                });
                            });
                        }
                        // handle deferred onattribute events
                        // Note: do not apply default ns to attributes:
                        //   http://www.w3.org/TR/REC-xml-names/#defaulting
                        for (var i = 0, l = parser.attribList.length; i < l; i++) {
                            var nv = parser.attribList[i];
                            var name = nv[0];
                            var value = nv[1];
                            var qualName = qname(name, true);
                            var prefix = qualName.prefix;
                            var local = qualName.local;
                            var uri = prefix === '' ? '' : (tag.ns[prefix] || '');
                            var a = {
                                name: name,
                                value: value,
                                prefix: prefix,
                                local: local,
                                uri: uri
                            };
                            // if there's any attributes with an undefined namespace,
                            // then fail on them now.
                            if (prefix && prefix !== 'xmlns' && !uri) {
                                strictFail(parser, 'Unbound namespace prefix: ' +
                                    JSON.stringify(prefix));
                                a.uri = prefix;
                            }
                            parser.tag.attributes[name] = a;
                            emitNode(parser, 'onattribute', a);
                        }
                        parser.attribList.length = 0;
                    }
                    parser.tag.isSelfClosing = !!selfClosing;
                    // process the tag
                    parser.sawRoot = true;
                    parser.tags.push(parser.tag);
                    emitNode(parser, 'onopentag', parser.tag);
                    if (!selfClosing) {
                        // special case for <script> in non-strict mode.
                        if (!parser.noscript && parser.tagName.toLowerCase() === 'script') {
                            parser.state = S.SCRIPT;
                        }
                        else {
                            parser.state = S.TEXT;
                        }
                        parser.tag = null;
                        parser.tagName = '';
                    }
                    parser.attribName = parser.attribValue = '';
                    parser.attribList.length = 0;
                }
                function closeTag(parser) {
                    if (!parser.tagName) {
                        strictFail(parser, 'Weird empty close tag.');
                        parser.textNode += '</>';
                        parser.state = S.TEXT;
                        return;
                    }
                    if (parser.script) {
                        if (parser.tagName !== 'script') {
                            parser.script += '</' + parser.tagName + '>';
                            parser.tagName = '';
                            parser.state = S.SCRIPT;
                            return;
                        }
                        emitNode(parser, 'onscript', parser.script);
                        parser.script = '';
                    }
                    // first make sure that the closing tag actually exists.
                    // <a><b></c></b></a> will close everything, otherwise.
                    var t = parser.tags.length;
                    var tagName = parser.tagName;
                    if (!parser.strict) {
                        tagName = tagName[parser.looseCase]();
                    }
                    var closeTo = tagName;
                    while (t--) {
                        var close = parser.tags[t];
                        if (close.name !== closeTo) {
                            // fail the first time in strict mode
                            strictFail(parser, 'Unexpected close tag');
                        }
                        else {
                            break;
                        }
                    }
                    // didn't find it.  we already failed for strict, so just abort.
                    if (t < 0) {
                        strictFail(parser, 'Unmatched closing tag: ' + parser.tagName);
                        parser.textNode += '</' + parser.tagName + '>';
                        parser.state = S.TEXT;
                        return;
                    }
                    parser.tagName = tagName;
                    var s = parser.tags.length;
                    while (s-- > t) {
                        var tag = parser.tag = parser.tags.pop();
                        parser.tagName = parser.tag.name;
                        emitNode(parser, 'onclosetag', parser.tagName);
                        var x = {};
                        for (var i in tag.ns) {
                            x[i] = tag.ns[i];
                        }
                        var parent = parser.tags[parser.tags.length - 1] || parser;
                        if (parser.opt.xmlns && tag.ns !== parent.ns) {
                            // remove namespace bindings introduced by tag
                            Object.keys(tag.ns).forEach(function (p) {
                                var n = tag.ns[p];
                                emitNode(parser, 'onclosenamespace', { prefix: p, uri: n });
                            });
                        }
                    }
                    if (t === 0)
                        parser.closedRoot = true;
                    parser.tagName = parser.attribValue = parser.attribName = '';
                    parser.attribList.length = 0;
                    parser.state = S.TEXT;
                }
                function parseEntity(parser) {
                    var entity = parser.entity;
                    var entityLC = entity.toLowerCase();
                    var num;
                    var numStr = '';
                    if (parser.ENTITIES[entity]) {
                        return parser.ENTITIES[entity];
                    }
                    if (parser.ENTITIES[entityLC]) {
                        return parser.ENTITIES[entityLC];
                    }
                    entity = entityLC;
                    if (entity.charAt(0) === '#') {
                        if (entity.charAt(1) === 'x') {
                            entity = entity.slice(2);
                            num = parseInt(entity, 16);
                            numStr = num.toString(16);
                        }
                        else {
                            entity = entity.slice(1);
                            num = parseInt(entity, 10);
                            numStr = num.toString(10);
                        }
                    }
                    entity = entity.replace(/^0+/, '');
                    if (isNaN(num) || numStr.toLowerCase() !== entity) {
                        strictFail(parser, 'Invalid character entity');
                        return '&' + parser.entity + ';';
                    }
                    return String.fromCodePoint(num);
                }
                function beginWhiteSpace(parser, c) {
                    if (c === '<') {
                        parser.state = S.OPEN_WAKA;
                        parser.startTagPosition = parser.position;
                    }
                    else if (!isWhitespace(c)) {
                        // have to process this as a text node.
                        // weird, but happens.
                        strictFail(parser, 'Non-whitespace before first tag.');
                        parser.textNode = c;
                        parser.state = S.TEXT;
                    }
                }
                function charAt(chunk, i) {
                    var result = '';
                    if (i < chunk.length) {
                        result = chunk.charAt(i);
                    }
                    return result;
                }
                function write(chunk) {
                    var parser = this;
                    if (this.error) {
                        throw this.error;
                    }
                    if (parser.closed) {
                        return error(parser, 'Cannot write after close. Assign an onready handler.');
                    }
                    if (chunk === null) {
                        return end(parser);
                    }
                    if (typeof chunk === 'object') {
                        chunk = chunk.toString();
                    }
                    var i = 0;
                    var c = '';
                    while (true) {
                        c = charAt(chunk, i++);
                        parser.c = c;
                        if (!c) {
                            break;
                        }
                        if (parser.trackPosition) {
                            parser.position++;
                            if (c === '\n') {
                                parser.line++;
                                parser.column = 0;
                            }
                            else {
                                parser.column++;
                            }
                        }
                        switch (parser.state) {
                            case S.BEGIN:
                                parser.state = S.BEGIN_WHITESPACE;
                                if (c === '\uFEFF') {
                                    continue;
                                }
                                beginWhiteSpace(parser, c);
                                continue;
                            case S.BEGIN_WHITESPACE:
                                beginWhiteSpace(parser, c);
                                continue;
                            case S.TEXT:
                                if (parser.sawRoot && !parser.closedRoot) {
                                    var starti = i - 1;
                                    while (c && c !== '<' && c !== '&') {
                                        c = charAt(chunk, i++);
                                        if (c && parser.trackPosition) {
                                            parser.position++;
                                            if (c === '\n') {
                                                parser.line++;
                                                parser.column = 0;
                                            }
                                            else {
                                                parser.column++;
                                            }
                                        }
                                    }
                                    parser.textNode += chunk.substring(starti, i - 1);
                                }
                                if (c === '<' && !(parser.sawRoot && parser.closedRoot && !parser.strict)) {
                                    parser.state = S.OPEN_WAKA;
                                    parser.startTagPosition = parser.position;
                                }
                                else {
                                    if (!isWhitespace(c) && (!parser.sawRoot || parser.closedRoot)) {
                                        strictFail(parser, 'Text data outside of root node.');
                                    }
                                    if (c === '&') {
                                        parser.state = S.TEXT_ENTITY;
                                    }
                                    else {
                                        parser.textNode += c;
                                    }
                                }
                                continue;
                            case S.SCRIPT:
                                // only non-strict
                                if (c === '<') {
                                    parser.state = S.SCRIPT_ENDING;
                                }
                                else {
                                    parser.script += c;
                                }
                                continue;
                            case S.SCRIPT_ENDING:
                                if (c === '/') {
                                    parser.state = S.CLOSE_TAG;
                                }
                                else {
                                    parser.script += '<' + c;
                                    parser.state = S.SCRIPT;
                                }
                                continue;
                            case S.OPEN_WAKA:
                                // either a /, ?, !, or text is coming next.
                                if (c === '!') {
                                    parser.state = S.SGML_DECL;
                                    parser.sgmlDecl = '';
                                }
                                else if (isWhitespace(c)) {
                                    // wait for it...
                                }
                                else if (isMatch(nameStart, c)) {
                                    parser.state = S.OPEN_TAG;
                                    parser.tagName = c;
                                }
                                else if (c === '/') {
                                    parser.state = S.CLOSE_TAG;
                                    parser.tagName = '';
                                }
                                else if (c === '?') {
                                    parser.state = S.PROC_INST;
                                    parser.procInstName = parser.procInstBody = '';
                                }
                                else {
                                    strictFail(parser, 'Unencoded <');
                                    // if there was some whitespace, then add that in.
                                    if (parser.startTagPosition + 1 < parser.position) {
                                        var pad = parser.position - parser.startTagPosition;
                                        c = new Array(pad).join(' ') + c;
                                    }
                                    parser.textNode += '<' + c;
                                    parser.state = S.TEXT;
                                }
                                continue;
                            case S.SGML_DECL:
                                if ((parser.sgmlDecl + c).toUpperCase() === CDATA) {
                                    emitNode(parser, 'onopencdata');
                                    parser.state = S.CDATA;
                                    parser.sgmlDecl = '';
                                    parser.cdata = '';
                                }
                                else if (parser.sgmlDecl + c === '--') {
                                    parser.state = S.COMMENT;
                                    parser.comment = '';
                                    parser.sgmlDecl = '';
                                }
                                else if ((parser.sgmlDecl + c).toUpperCase() === DOCTYPE) {
                                    parser.state = S.DOCTYPE;
                                    if (parser.doctype || parser.sawRoot) {
                                        strictFail(parser, 'Inappropriately located doctype declaration');
                                    }
                                    parser.doctype = '';
                                    parser.sgmlDecl = '';
                                }
                                else if (c === '>') {
                                    emitNode(parser, 'onsgmldeclaration', parser.sgmlDecl);
                                    parser.sgmlDecl = '';
                                    parser.state = S.TEXT;
                                }
                                else if (isQuote(c)) {
                                    parser.state = S.SGML_DECL_QUOTED;
                                    parser.sgmlDecl += c;
                                }
                                else {
                                    parser.sgmlDecl += c;
                                }
                                continue;
                            case S.SGML_DECL_QUOTED:
                                if (c === parser.q) {
                                    parser.state = S.SGML_DECL;
                                    parser.q = '';
                                }
                                parser.sgmlDecl += c;
                                continue;
                            case S.DOCTYPE:
                                if (c === '>') {
                                    parser.state = S.TEXT;
                                    emitNode(parser, 'ondoctype', parser.doctype);
                                    parser.doctype = true; // just remember that we saw it.
                                }
                                else {
                                    parser.doctype += c;
                                    if (c === '[') {
                                        parser.state = S.DOCTYPE_DTD;
                                    }
                                    else if (isQuote(c)) {
                                        parser.state = S.DOCTYPE_QUOTED;
                                        parser.q = c;
                                    }
                                }
                                continue;
                            case S.DOCTYPE_QUOTED:
                                parser.doctype += c;
                                if (c === parser.q) {
                                    parser.q = '';
                                    parser.state = S.DOCTYPE;
                                }
                                continue;
                            case S.DOCTYPE_DTD:
                                parser.doctype += c;
                                if (c === ']') {
                                    parser.state = S.DOCTYPE;
                                }
                                else if (isQuote(c)) {
                                    parser.state = S.DOCTYPE_DTD_QUOTED;
                                    parser.q = c;
                                }
                                continue;
                            case S.DOCTYPE_DTD_QUOTED:
                                parser.doctype += c;
                                if (c === parser.q) {
                                    parser.state = S.DOCTYPE_DTD;
                                    parser.q = '';
                                }
                                continue;
                            case S.COMMENT:
                                if (c === '-') {
                                    parser.state = S.COMMENT_ENDING;
                                }
                                else {
                                    parser.comment += c;
                                }
                                continue;
                            case S.COMMENT_ENDING:
                                if (c === '-') {
                                    parser.state = S.COMMENT_ENDED;
                                    parser.comment = textopts(parser.opt, parser.comment);
                                    if (parser.comment) {
                                        emitNode(parser, 'oncomment', parser.comment);
                                    }
                                    parser.comment = '';
                                }
                                else {
                                    parser.comment += '-' + c;
                                    parser.state = S.COMMENT;
                                }
                                continue;
                            case S.COMMENT_ENDED:
                                if (c !== '>') {
                                    strictFail(parser, 'Malformed comment');
                                    // allow <!-- blah -- bloo --> in non-strict mode,
                                    // which is a comment of " blah -- bloo "
                                    parser.comment += '--' + c;
                                    parser.state = S.COMMENT;
                                }
                                else {
                                    parser.state = S.TEXT;
                                }
                                continue;
                            case S.CDATA:
                                if (c === ']') {
                                    parser.state = S.CDATA_ENDING;
                                }
                                else {
                                    parser.cdata += c;
                                }
                                continue;
                            case S.CDATA_ENDING:
                                if (c === ']') {
                                    parser.state = S.CDATA_ENDING_2;
                                }
                                else {
                                    parser.cdata += ']' + c;
                                    parser.state = S.CDATA;
                                }
                                continue;
                            case S.CDATA_ENDING_2:
                                if (c === '>') {
                                    if (parser.cdata) {
                                        emitNode(parser, 'oncdata', parser.cdata);
                                    }
                                    emitNode(parser, 'onclosecdata');
                                    parser.cdata = '';
                                    parser.state = S.TEXT;
                                }
                                else if (c === ']') {
                                    parser.cdata += ']';
                                }
                                else {
                                    parser.cdata += ']]' + c;
                                    parser.state = S.CDATA;
                                }
                                continue;
                            case S.PROC_INST:
                                if (c === '?') {
                                    parser.state = S.PROC_INST_ENDING;
                                }
                                else if (isWhitespace(c)) {
                                    parser.state = S.PROC_INST_BODY;
                                }
                                else {
                                    parser.procInstName += c;
                                }
                                continue;
                            case S.PROC_INST_BODY:
                                if (!parser.procInstBody && isWhitespace(c)) {
                                    continue;
                                }
                                else if (c === '?') {
                                    parser.state = S.PROC_INST_ENDING;
                                }
                                else {
                                    parser.procInstBody += c;
                                }
                                continue;
                            case S.PROC_INST_ENDING:
                                if (c === '>') {
                                    emitNode(parser, 'onprocessinginstruction', {
                                        name: parser.procInstName,
                                        body: parser.procInstBody
                                    });
                                    parser.procInstName = parser.procInstBody = '';
                                    parser.state = S.TEXT;
                                }
                                else {
                                    parser.procInstBody += '?' + c;
                                    parser.state = S.PROC_INST_BODY;
                                }
                                continue;
                            case S.OPEN_TAG:
                                if (isMatch(nameBody, c)) {
                                    parser.tagName += c;
                                }
                                else {
                                    newTag(parser);
                                    if (c === '>') {
                                        openTag(parser);
                                    }
                                    else if (c === '/') {
                                        parser.state = S.OPEN_TAG_SLASH;
                                    }
                                    else {
                                        if (!isWhitespace(c)) {
                                            strictFail(parser, 'Invalid character in tag name');
                                        }
                                        parser.state = S.ATTRIB;
                                    }
                                }
                                continue;
                            case S.OPEN_TAG_SLASH:
                                if (c === '>') {
                                    openTag(parser, true);
                                    closeTag(parser);
                                }
                                else {
                                    strictFail(parser, 'Forward-slash in opening tag not followed by >');
                                    parser.state = S.ATTRIB;
                                }
                                continue;
                            case S.ATTRIB:
                                // haven't read the attribute name yet.
                                if (isWhitespace(c)) {
                                    continue;
                                }
                                else if (c === '>') {
                                    openTag(parser);
                                }
                                else if (c === '/') {
                                    parser.state = S.OPEN_TAG_SLASH;
                                }
                                else if (isMatch(nameStart, c)) {
                                    parser.attribName = c;
                                    parser.attribValue = '';
                                    parser.state = S.ATTRIB_NAME;
                                }
                                else {
                                    strictFail(parser, 'Invalid attribute name');
                                }
                                continue;
                            case S.ATTRIB_NAME:
                                if (c === '=') {
                                    parser.state = S.ATTRIB_VALUE;
                                }
                                else if (c === '>') {
                                    strictFail(parser, 'Attribute without value');
                                    parser.attribValue = parser.attribName;
                                    attrib(parser);
                                    openTag(parser);
                                }
                                else if (isWhitespace(c)) {
                                    parser.state = S.ATTRIB_NAME_SAW_WHITE;
                                }
                                else if (isMatch(nameBody, c)) {
                                    parser.attribName += c;
                                }
                                else {
                                    strictFail(parser, 'Invalid attribute name');
                                }
                                continue;
                            case S.ATTRIB_NAME_SAW_WHITE:
                                if (c === '=') {
                                    parser.state = S.ATTRIB_VALUE;
                                }
                                else if (isWhitespace(c)) {
                                    continue;
                                }
                                else {
                                    strictFail(parser, 'Attribute without value');
                                    parser.tag.attributes[parser.attribName] = '';
                                    parser.attribValue = '';
                                    emitNode(parser, 'onattribute', {
                                        name: parser.attribName,
                                        value: ''
                                    });
                                    parser.attribName = '';
                                    if (c === '>') {
                                        openTag(parser);
                                    }
                                    else if (isMatch(nameStart, c)) {
                                        parser.attribName = c;
                                        parser.state = S.ATTRIB_NAME;
                                    }
                                    else {
                                        strictFail(parser, 'Invalid attribute name');
                                        parser.state = S.ATTRIB;
                                    }
                                }
                                continue;
                            case S.ATTRIB_VALUE:
                                if (isWhitespace(c)) {
                                    continue;
                                }
                                else if (isQuote(c)) {
                                    parser.q = c;
                                    parser.state = S.ATTRIB_VALUE_QUOTED;
                                }
                                else {
                                    strictFail(parser, 'Unquoted attribute value');
                                    parser.state = S.ATTRIB_VALUE_UNQUOTED;
                                    parser.attribValue = c;
                                }
                                continue;
                            case S.ATTRIB_VALUE_QUOTED:
                                if (c !== parser.q) {
                                    if (c === '&') {
                                        parser.state = S.ATTRIB_VALUE_ENTITY_Q;
                                    }
                                    else {
                                        parser.attribValue += c;
                                    }
                                    continue;
                                }
                                attrib(parser);
                                parser.q = '';
                                parser.state = S.ATTRIB_VALUE_CLOSED;
                                continue;
                            case S.ATTRIB_VALUE_CLOSED:
                                if (isWhitespace(c)) {
                                    parser.state = S.ATTRIB;
                                }
                                else if (c === '>') {
                                    openTag(parser);
                                }
                                else if (c === '/') {
                                    parser.state = S.OPEN_TAG_SLASH;
                                }
                                else if (isMatch(nameStart, c)) {
                                    strictFail(parser, 'No whitespace between attributes');
                                    parser.attribName = c;
                                    parser.attribValue = '';
                                    parser.state = S.ATTRIB_NAME;
                                }
                                else {
                                    strictFail(parser, 'Invalid attribute name');
                                }
                                continue;
                            case S.ATTRIB_VALUE_UNQUOTED:
                                if (!isAttribEnd(c)) {
                                    if (c === '&') {
                                        parser.state = S.ATTRIB_VALUE_ENTITY_U;
                                    }
                                    else {
                                        parser.attribValue += c;
                                    }
                                    continue;
                                }
                                attrib(parser);
                                if (c === '>') {
                                    openTag(parser);
                                }
                                else {
                                    parser.state = S.ATTRIB;
                                }
                                continue;
                            case S.CLOSE_TAG:
                                if (!parser.tagName) {
                                    if (isWhitespace(c)) {
                                        continue;
                                    }
                                    else if (notMatch(nameStart, c)) {
                                        if (parser.script) {
                                            parser.script += '</' + c;
                                            parser.state = S.SCRIPT;
                                        }
                                        else {
                                            strictFail(parser, 'Invalid tagname in closing tag.');
                                        }
                                    }
                                    else {
                                        parser.tagName = c;
                                    }
                                }
                                else if (c === '>') {
                                    closeTag(parser);
                                }
                                else if (isMatch(nameBody, c)) {
                                    parser.tagName += c;
                                }
                                else if (parser.script) {
                                    parser.script += '</' + parser.tagName;
                                    parser.tagName = '';
                                    parser.state = S.SCRIPT;
                                }
                                else {
                                    if (!isWhitespace(c)) {
                                        strictFail(parser, 'Invalid tagname in closing tag');
                                    }
                                    parser.state = S.CLOSE_TAG_SAW_WHITE;
                                }
                                continue;
                            case S.CLOSE_TAG_SAW_WHITE:
                                if (isWhitespace(c)) {
                                    continue;
                                }
                                if (c === '>') {
                                    closeTag(parser);
                                }
                                else {
                                    strictFail(parser, 'Invalid characters in closing tag');
                                }
                                continue;
                            case S.TEXT_ENTITY:
                            case S.ATTRIB_VALUE_ENTITY_Q:
                            case S.ATTRIB_VALUE_ENTITY_U:
                                var returnState;
                                var buffer;
                                switch (parser.state) {
                                    case S.TEXT_ENTITY:
                                        returnState = S.TEXT;
                                        buffer = 'textNode';
                                        break;
                                    case S.ATTRIB_VALUE_ENTITY_Q:
                                        returnState = S.ATTRIB_VALUE_QUOTED;
                                        buffer = 'attribValue';
                                        break;
                                    case S.ATTRIB_VALUE_ENTITY_U:
                                        returnState = S.ATTRIB_VALUE_UNQUOTED;
                                        buffer = 'attribValue';
                                        break;
                                }
                                if (c === ';') {
                                    parser[buffer] += parseEntity(parser);
                                    parser.entity = '';
                                    parser.state = returnState;
                                }
                                else if (isMatch(parser.entity.length ? entityBody : entityStart, c)) {
                                    parser.entity += c;
                                }
                                else {
                                    strictFail(parser, 'Invalid character in entity name');
                                    parser[buffer] += '&' + parser.entity + c;
                                    parser.entity = '';
                                    parser.state = returnState;
                                }
                                continue;
                            default:
                                throw new Error(parser, 'Unknown state: ' + parser.state);
                        }
                    } // while
                    if (parser.position >= parser.bufferCheckPosition) {
                        checkBufferLength(parser);
                    }
                    return parser;
                }
                /*! http://mths.be/fromcodepoint v0.1.0 by @mathias */
                /* istanbul ignore next */
                if (!String.fromCodePoint) {
                    (function () {
                        var stringFromCharCode = String.fromCharCode;
                        var floor = Math.floor;
                        var fromCodePoint = function () {
                            var MAX_SIZE = 0x4000;
                            var codeUnits = [];
                            var highSurrogate;
                            var lowSurrogate;
                            var index = -1;
                            var length = arguments.length;
                            if (!length) {
                                return '';
                            }
                            var result = '';
                            while (++index < length) {
                                var codePoint = Number(arguments[index]);
                                if (!isFinite(codePoint) || // `NaN`, `+Infinity`, or `-Infinity`
                                    codePoint < 0 || // not a valid Unicode code point
                                    codePoint > 0x10FFFF || // not a valid Unicode code point
                                    floor(codePoint) !== codePoint // not an integer
                                ) {
                                    throw RangeError('Invalid code point: ' + codePoint);
                                }
                                if (codePoint <= 0xFFFF) { // BMP code point
                                    codeUnits.push(codePoint);
                                }
                                else { // Astral code point; split in surrogate halves
                                    // http://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae
                                    codePoint -= 0x10000;
                                    highSurrogate = (codePoint >> 10) + 0xD800;
                                    lowSurrogate = (codePoint % 0x400) + 0xDC00;
                                    codeUnits.push(highSurrogate, lowSurrogate);
                                }
                                if (index + 1 === length || codeUnits.length > MAX_SIZE) {
                                    result += stringFromCharCode.apply(null, codeUnits);
                                    codeUnits.length = 0;
                                }
                            }
                            return result;
                        };
                        /* istanbul ignore next */
                        if (Object.defineProperty) {
                            Object.defineProperty(String, 'fromCodePoint', {
                                value: fromCodePoint,
                                configurable: true,
                                writable: true
                            });
                        }
                        else {
                            String.fromCodePoint = fromCodePoint;
                        }
                    }());
                }
            })(false ? 0 : exports);
            /***/ 
        }),
        /***/ "./node_modules/set-function-length/index.js": 
        /*!***************************************************!*\
          !*** ./node_modules/set-function-length/index.js ***!
          \***************************************************/
        /***/ ((module, __unused_webpack_exports, __webpack_require__) => {
            "use strict";
            var GetIntrinsic = __webpack_require__(/*! get-intrinsic */ "./node_modules/get-intrinsic/index.js");
            var define = __webpack_require__(/*! define-data-property */ "./node_modules/define-data-property/index.js");
            var hasDescriptors = __webpack_require__(/*! has-property-descriptors */ "./node_modules/has-property-descriptors/index.js")();
            var gOPD = __webpack_require__(/*! gopd */ "./node_modules/gopd/index.js");
            var $TypeError = GetIntrinsic('%TypeError%');
            var $floor = GetIntrinsic('%Math.floor%');
            /** @typedef {(...args: unknown[]) => unknown} Func */
            /** @type {<T extends Func = Func>(fn: T, length: number, loose?: boolean) => T} */
            module.exports = function setFunctionLength(fn, length) {
                if (typeof fn !== 'function') {
                    throw new $TypeError('`fn` is not a function');
                }
                if (typeof length !== 'number' || length < 0 || length > 0xFFFFFFFF || $floor(length) !== length) {
                    throw new $TypeError('`length` must be a positive 32-bit integer');
                }
                var loose = arguments.length > 2 && !!arguments[2];
                var functionLengthIsConfigurable = true;
                var functionLengthIsWritable = true;
                if ('length' in fn && gOPD) {
                    var desc = gOPD(fn, 'length');
                    if (desc && !desc.configurable) {
                        functionLengthIsConfigurable = false;
                    }
                    if (desc && !desc.writable) {
                        functionLengthIsWritable = false;
                    }
                }
                if (functionLengthIsConfigurable || functionLengthIsWritable || !loose) {
                    if (hasDescriptors) {
                        define(/** @type {Parameters<define>[0]} */ (fn), 'length', length, true, true);
                    }
                    else {
                        define(/** @type {Parameters<define>[0]} */ (fn), 'length', length);
                    }
                }
                return fn;
            };
            /***/ 
        }),
        /***/ "./node_modules/set-function-name/index.js": 
        /*!*************************************************!*\
          !*** ./node_modules/set-function-name/index.js ***!
          \*************************************************/
        /***/ ((module, __unused_webpack_exports, __webpack_require__) => {
            "use strict";
            var define = __webpack_require__(/*! define-data-property */ "./node_modules/define-data-property/index.js");
            var hasDescriptors = __webpack_require__(/*! has-property-descriptors */ "./node_modules/has-property-descriptors/index.js")();
            var functionsHaveConfigurableNames = (__webpack_require__(/*! functions-have-names */ "./node_modules/functions-have-names/index.js").functionsHaveConfigurableNames)();
            var $TypeError = TypeError;
            module.exports = function setFunctionName(fn, name) {
                if (typeof fn !== 'function') {
                    throw new $TypeError('`fn` is not a function');
                }
                var loose = arguments.length > 2 && !!arguments[2];
                if (!loose || functionsHaveConfigurableNames) {
                    if (hasDescriptors) {
                        define(fn, 'name', name, true, true);
                    }
                    else {
                        define(fn, 'name', name);
                    }
                }
                return fn;
            };
            /***/ 
        }),
        /***/ "./node_modules/side-channel/index.js": 
        /*!********************************************!*\
          !*** ./node_modules/side-channel/index.js ***!
          \********************************************/
        /***/ ((module, __unused_webpack_exports, __webpack_require__) => {
            "use strict";
            var GetIntrinsic = __webpack_require__(/*! get-intrinsic */ "./node_modules/get-intrinsic/index.js");
            var callBound = __webpack_require__(/*! call-bind/callBound */ "./node_modules/call-bind/callBound.js");
            var inspect = __webpack_require__(/*! object-inspect */ "./node_modules/object-inspect/index.js");
            var $TypeError = GetIntrinsic('%TypeError%');
            var $WeakMap = GetIntrinsic('%WeakMap%', true);
            var $Map = GetIntrinsic('%Map%', true);
            var $weakMapGet = callBound('WeakMap.prototype.get', true);
            var $weakMapSet = callBound('WeakMap.prototype.set', true);
            var $weakMapHas = callBound('WeakMap.prototype.has', true);
            var $mapGet = callBound('Map.prototype.get', true);
            var $mapSet = callBound('Map.prototype.set', true);
            var $mapHas = callBound('Map.prototype.has', true);
            /*
             * This function traverses the list returning the node corresponding to the
             * given key.
             *
             * That node is also moved to the head of the list, so that if it's accessed
             * again we don't need to traverse the whole list. By doing so, all the recently
             * used nodes can be accessed relatively quickly.
             */
            var listGetNode = function (list, key) {
                for (var prev = list, curr; (curr = prev.next) !== null; prev = curr) {
                    if (curr.key === key) {
                        prev.next = curr.next;
                        curr.next = list.next;
                        list.next = curr; // eslint-disable-line no-param-reassign
                        return curr;
                    }
                }
            };
            var listGet = function (objects, key) {
                var node = listGetNode(objects, key);
                return node && node.value;
            };
            var listSet = function (objects, key, value) {
                var node = listGetNode(objects, key);
                if (node) {
                    node.value = value;
                }
                else {
                    // Prepend the new node to the beginning of the list
                    objects.next = {
                        key: key,
                        next: objects.next,
                        value: value
                    };
                }
            };
            var listHas = function (objects, key) {
                return !!listGetNode(objects, key);
            };
            module.exports = function getSideChannel() {
                var $wm;
                var $m;
                var $o;
                var channel = {
                    assert: function (key) {
                        if (!channel.has(key)) {
                            throw new $TypeError('Side channel does not contain ' + inspect(key));
                        }
                    },
                    get: function (key) {
                        if ($WeakMap && key && (typeof key === 'object' || typeof key === 'function')) {
                            if ($wm) {
                                return $weakMapGet($wm, key);
                            }
                        }
                        else if ($Map) {
                            if ($m) {
                                return $mapGet($m, key);
                            }
                        }
                        else {
                            if ($o) { // eslint-disable-line no-lonely-if
                                return listGet($o, key);
                            }
                        }
                    },
                    has: function (key) {
                        if ($WeakMap && key && (typeof key === 'object' || typeof key === 'function')) {
                            if ($wm) {
                                return $weakMapHas($wm, key);
                            }
                        }
                        else if ($Map) {
                            if ($m) {
                                return $mapHas($m, key);
                            }
                        }
                        else {
                            if ($o) { // eslint-disable-line no-lonely-if
                                return listHas($o, key);
                            }
                        }
                        return false;
                    },
                    set: function (key, value) {
                        if ($WeakMap && key && (typeof key === 'object' || typeof key === 'function')) {
                            if (!$wm) {
                                $wm = new $WeakMap();
                            }
                            $weakMapSet($wm, key, value);
                        }
                        else if ($Map) {
                            if (!$m) {
                                $m = new $Map();
                            }
                            $mapSet($m, key, value);
                        }
                        else {
                            if (!$o) {
                                /*
                                 * Initialize the linked list as an empty node, so that we don't have
                                 * to special-case handling of the first node: we can always refer to
                                 * it as (previous node).next, instead of something like (list).head
                                 */
                                $o = { key: {}, next: null };
                            }
                            listSet($o, key, value);
                        }
                    }
                };
                return channel;
            };
            /***/ 
        }),
        /***/ "./node_modules/slash/index.js": 
        /*!*************************************!*\
          !*** ./node_modules/slash/index.js ***!
          \*************************************/
        /***/ ((module) => {
            "use strict";
            module.exports = path => {
                const isExtendedLengthPath = /^\\\\\?\\/.test(path);
                const hasNonAscii = /[^\u0000-\u0080]+/.test(path); // eslint-disable-line no-control-regex
                if (isExtendedLengthPath || hasNonAscii) {
                    return path;
                }
                return path.replace(/\\/g, '/');
            };
            /***/ 
        }),
        /***/ "./packages/api/app/query.js": 
        /*!***********************************!*\
          !*** ./packages/api/app/query.js ***!
          \***********************************/
        /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony export */ __webpack_require__.d(__webpack_exports__, {
                /* harmony export */ q: () => ( /* binding */q)
                /* harmony export */ 
            });
            function _array_like_to_array(arr, len) {
                if (len == null || len > arr.length)
                    len = arr.length;
                for (var i = 0, arr2 = new Array(len); i < len; i++)
                    arr2[i] = arr[i];
                return arr2;
            }
            function _array_without_holes(arr) {
                if (Array.isArray(arr))
                    return _array_like_to_array(arr);
            }
            function _class_call_check(instance, Constructor) {
                if (!(instance instanceof Constructor)) {
                    throw new TypeError("Cannot call a class as a function");
                }
            }
            function _defineProperties(target, props) {
                for (var i = 0; i < props.length; i++) {
                    var descriptor = props[i];
                    descriptor.enumerable = descriptor.enumerable || false;
                    descriptor.configurable = true;
                    if ("value" in descriptor)
                        descriptor.writable = true;
                    Object.defineProperty(target, descriptor.key, descriptor);
                }
            }
            function _create_class(Constructor, protoProps, staticProps) {
                if (protoProps)
                    _defineProperties(Constructor.prototype, protoProps);
                if (staticProps)
                    _defineProperties(Constructor, staticProps);
                return Constructor;
            }
            function _define_property(obj, key, value) {
                if (key in obj) {
                    Object.defineProperty(obj, key, {
                        value: value,
                        enumerable: true,
                        configurable: true,
                        writable: true
                    });
                }
                else {
                    obj[key] = value;
                }
                return obj;
            }
            function _iterable_to_array(iter) {
                if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
                    return Array.from(iter);
            }
            function _non_iterable_spread() {
                throw new TypeError("Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
            }
            function _object_spread(target) {
                for (var i = 1; i < arguments.length; i++) {
                    var source = arguments[i] != null ? arguments[i] : {};
                    var ownKeys = Object.keys(source);
                    if (typeof Object.getOwnPropertySymbols === "function") {
                        ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) {
                            return Object.getOwnPropertyDescriptor(source, sym).enumerable;
                        }));
                    }
                    ownKeys.forEach(function (key) {
                        _define_property(target, key, source[key]);
                    });
                }
                return target;
            }
            function ownKeys(object, enumerableOnly) {
                var keys = Object.keys(object);
                if (Object.getOwnPropertySymbols) {
                    var symbols = Object.getOwnPropertySymbols(object);
                    if (enumerableOnly) {
                        symbols = symbols.filter(function (sym) {
                            return Object.getOwnPropertyDescriptor(object, sym).enumerable;
                        });
                    }
                    keys.push.apply(keys, symbols);
                }
                return keys;
            }
            function _object_spread_props(target, source) {
                source = source != null ? source : {};
                if (Object.getOwnPropertyDescriptors) {
                    Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
                }
                else {
                    ownKeys(Object(source)).forEach(function (key) {
                        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
                    });
                }
                return target;
            }
            function _to_consumable_array(arr) {
                return _array_without_holes(arr) || _iterable_to_array(arr) || _unsupported_iterable_to_array(arr) || _non_iterable_spread();
            }
            function _unsupported_iterable_to_array(o, minLen) {
                if (!o)
                    return;
                if (typeof o === "string")
                    return _array_like_to_array(o, minLen);
                var n = Object.prototype.toString.call(o).slice(8, -1);
                if (n === "Object" && o.constructor)
                    n = o.constructor.name;
                if (n === "Map" || n === "Set")
                    return Array.from(n);
                if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
                    return _array_like_to_array(o, minLen);
            }
            var Query = /*#__PURE__*/ function () {
                "use strict";
                function Query(state) {
                    _class_call_check(this, Query);
                    this.state = _object_spread({
                        filterExpressions: state.filterExpressions || [],
                        selectExpressions: state.selectExpressions || [],
                        groupExpressions: state.groupExpressions || [],
                        orderExpressions: state.orderExpressions || [],
                        calculation: false,
                        rawMode: false,
                        withDead: false,
                        validateRefs: true,
                        limit: null,
                        offset: null
                    }, state);
                }
                _create_class(Query, [
                    {
                        key: "filter",
                        value: function filter(expr) {
                            return new Query(_object_spread_props(_object_spread({}, this.state), {
                                filterExpressions: _to_consumable_array(this.state.filterExpressions).concat([
                                    expr
                                ])
                            }));
                        }
                    },
                    {
                        key: "unfilter",
                        value: function unfilter(exprs) {
                            var exprSet = new Set(exprs);
                            return new Query(_object_spread_props(_object_spread({}, this.state), {
                                filterExpressions: this.state.filterExpressions.filter(function (expr) {
                                    return !exprSet.has(Object.keys(expr)[0]);
                                })
                            }));
                        }
                    },
                    {
                        key: "select",
                        value: function select() {
                            var exprs = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
                            if (!Array.isArray(exprs)) {
                                exprs = [
                                    exprs
                                ];
                            }
                            var query = new Query(_object_spread_props(_object_spread({}, this.state), {
                                selectExpressions: exprs
                            }));
                            query.state.calculation = false;
                            return query;
                        }
                    },
                    {
                        key: "calculate",
                        value: function calculate(expr) {
                            var query = this.select({
                                result: expr
                            });
                            query.state.calculation = true;
                            return query;
                        }
                    },
                    {
                        key: "groupBy",
                        value: function groupBy(exprs) {
                            if (!Array.isArray(exprs)) {
                                exprs = [
                                    exprs
                                ];
                            }
                            return new Query(_object_spread_props(_object_spread({}, this.state), {
                                groupExpressions: _to_consumable_array(this.state.groupExpressions).concat(_to_consumable_array(exprs))
                            }));
                        }
                    },
                    {
                        key: "orderBy",
                        value: function orderBy(exprs) {
                            if (!Array.isArray(exprs)) {
                                exprs = [
                                    exprs
                                ];
                            }
                            return new Query(_object_spread_props(_object_spread({}, this.state), {
                                orderExpressions: _to_consumable_array(this.state.orderExpressions).concat(_to_consumable_array(exprs))
                            }));
                        }
                    },
                    {
                        key: "limit",
                        value: function limit(num) {
                            return new Query(_object_spread_props(_object_spread({}, this.state), {
                                limit: num
                            }));
                        }
                    },
                    {
                        key: "offset",
                        value: function offset(num) {
                            return new Query(_object_spread_props(_object_spread({}, this.state), {
                                offset: num
                            }));
                        }
                    },
                    {
                        key: "raw",
                        value: function raw() {
                            return new Query(_object_spread_props(_object_spread({}, this.state), {
                                rawMode: true
                            }));
                        }
                    },
                    {
                        key: "withDead",
                        value: function withDead() {
                            return new Query(_object_spread_props(_object_spread({}, this.state), {
                                withDead: true
                            }));
                        }
                    },
                    {
                        key: "withoutValidatedRefs",
                        value: function withoutValidatedRefs() {
                            return new Query(_object_spread_props(_object_spread({}, this.state), {
                                validateRefs: false
                            }));
                        }
                    },
                    {
                        key: "options",
                        value: function options(opts) {
                            return new Query(_object_spread_props(_object_spread({}, this.state), {
                                tableOptions: opts
                            }));
                        }
                    },
                    {
                        key: "serialize",
                        value: function serialize() {
                            return this.state;
                        }
                    }
                ]);
                return Query;
            }();
            function q(table) {
                return new Query({
                    table: table
                });
            }
            /***/ 
        }),
        /***/ "./packages/api/injected.js": 
        /*!**********************************!*\
          !*** ./packages/api/injected.js ***!
          \**********************************/
        /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony export */ __webpack_require__.d(__webpack_exports__, {
                /* harmony export */ override: () => ( /* binding */override),
                /* harmony export */ send: () => ( /* binding */send)
                /* harmony export */ 
            });
            // TODO: comment on why it works this way
            var send;
            function override(sendImplementation) {
                send = sendImplementation;
            }
            /***/ 
        }),
        /***/ "./packages/api/methods.ts": 
        /*!*********************************!*\
          !*** ./packages/api/methods.ts ***!
          \*********************************/
        /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony export */ __webpack_require__.d(__webpack_exports__, {
                /* harmony export */ addTransactions: () => ( /* binding */addTransactions),
                /* harmony export */ batchBudgetUpdates: () => ( /* binding */batchBudgetUpdates),
                /* harmony export */ closeAccount: () => ( /* binding */closeAccount),
                /* harmony export */ createAccount: () => ( /* binding */createAccount),
                /* harmony export */ createCategory: () => ( /* binding */createCategory),
                /* harmony export */ createCategoryGroup: () => ( /* binding */createCategoryGroup),
                /* harmony export */ createPayee: () => ( /* binding */createPayee),
                /* harmony export */ createRule: () => ( /* binding */createRule),
                /* harmony export */ deleteAccount: () => ( /* binding */deleteAccount),
                /* harmony export */ deleteCategory: () => ( /* binding */deleteCategory),
                /* harmony export */ deleteCategoryGroup: () => ( /* binding */deleteCategoryGroup),
                /* harmony export */ deletePayee: () => ( /* binding */deletePayee),
                /* harmony export */ deleteRule: () => ( /* binding */deleteRule),
                /* harmony export */ deleteTransaction: () => ( /* binding */deleteTransaction),
                /* harmony export */ downloadBudget: () => ( /* binding */downloadBudget),
                /* harmony export */ getAccountBalance: () => ( /* binding */getAccountBalance),
                /* harmony export */ getAccounts: () => ( /* binding */getAccounts),
                /* harmony export */ getBudgetMonth: () => ( /* binding */getBudgetMonth),
                /* harmony export */ getBudgetMonths: () => ( /* binding */getBudgetMonths),
                /* harmony export */ getBudgets: () => ( /* binding */getBudgets),
                /* harmony export */ getCategories: () => ( /* binding */getCategories),
                /* harmony export */ getCategoryGroups: () => ( /* binding */getCategoryGroups),
                /* harmony export */ getCommonPayees: () => ( /* binding */getCommonPayees),
                /* harmony export */ getPayeeRules: () => ( /* binding */getPayeeRules),
                /* harmony export */ getPayees: () => ( /* binding */getPayees),
                /* harmony export */ getRules: () => ( /* binding */getRules),
                /* harmony export */ getTransactions: () => ( /* binding */getTransactions),
                /* harmony export */ importTransactions: () => ( /* binding */importTransactions),
                /* harmony export */ loadBudget: () => ( /* binding */loadBudget),
                /* harmony export */ mergePayees: () => ( /* binding */mergePayees),
                /* harmony export */ q: () => ( /* reexport safe */_app_query__WEBPACK_IMPORTED_MODULE_1__.q),
                /* harmony export */ reopenAccount: () => ( /* binding */reopenAccount),
                /* harmony export */ runBankSync: () => ( /* binding */runBankSync),
                /* harmony export */ runImport: () => ( /* binding */runImport),
                /* harmony export */ runQuery: () => ( /* binding */runQuery),
                /* harmony export */ setBudgetAmount: () => ( /* binding */setBudgetAmount),
                /* harmony export */ setBudgetCarryover: () => ( /* binding */setBudgetCarryover),
                /* harmony export */ sync: () => ( /* binding */sync),
                /* harmony export */ updateAccount: () => ( /* binding */updateAccount),
                /* harmony export */ updateCategory: () => ( /* binding */updateCategory),
                /* harmony export */ updateCategoryGroup: () => ( /* binding */updateCategoryGroup),
                /* harmony export */ updatePayee: () => ( /* binding */updatePayee),
                /* harmony export */ updateRule: () => ( /* binding */updateRule),
                /* harmony export */ updateTransaction: () => ( /* binding */updateTransaction)
                /* harmony export */ 
            });
            /* harmony import */ var _injected__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./injected */ "./packages/api/injected.js");
            /* harmony import */ var _app_query__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./app/query */ "./packages/api/app/query.js");
            // @ts-strict-ignore
            function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
                try {
                    var info = gen[key](arg);
                    var value = info.value;
                }
                catch (error) {
                    reject(error);
                    return;
                }
                if (info.done) {
                    resolve(value);
                }
                else {
                    Promise.resolve(value).then(_next, _throw);
                }
            }
            function _async_to_generator(fn) {
                return function () {
                    var self = this, args = arguments;
                    return new Promise(function (resolve, reject) {
                        var gen = fn.apply(self, args);
                        function _next(value) {
                            asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
                        }
                        function _throw(err) {
                            asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
                        }
                        _next(undefined);
                    });
                };
            }
            function _ts_generator(thisArg, body) {
                var f, y, t, g, _ = {
                    label: 0,
                    sent: function () {
                        if (t[0] & 1)
                            throw t[1];
                        return t[1];
                    },
                    trys: [],
                    ops: []
                };
                return g = {
                    next: verb(0),
                    "throw": verb(1),
                    "return": verb(2)
                }, typeof Symbol === "function" && (g[Symbol.iterator] = function () {
                    return this;
                }), g;
                function verb(n) {
                    return function (v) {
                        return step([
                            n,
                            v
                        ]);
                    };
                }
                function step(op) {
                    if (f)
                        throw new TypeError("Generator is already executing.");
                    while (_)
                        try {
                            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
                                return t;
                            if (y = 0, t)
                                op = [
                                    op[0] & 2,
                                    t.value
                                ];
                            switch (op[0]) {
                                case 0:
                                case 1:
                                    t = op;
                                    break;
                                case 4:
                                    _.label++;
                                    return {
                                        value: op[1],
                                        done: false
                                    };
                                case 5:
                                    _.label++;
                                    y = op[1];
                                    op = [
                                        0
                                    ];
                                    continue;
                                case 7:
                                    op = _.ops.pop();
                                    _.trys.pop();
                                    continue;
                                default:
                                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                                        _ = 0;
                                        continue;
                                    }
                                    if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                                        _.label = op[1];
                                        break;
                                    }
                                    if (op[0] === 6 && _.label < t[1]) {
                                        _.label = t[1];
                                        t = op;
                                        break;
                                    }
                                    if (t && _.label < t[2]) {
                                        _.label = t[2];
                                        _.ops.push(op);
                                        break;
                                    }
                                    if (t[2])
                                        _.ops.pop();
                                    _.trys.pop();
                                    continue;
                            }
                            op = body.call(thisArg, _);
                        }
                        catch (e) {
                            op = [
                                6,
                                e
                            ];
                            y = 0;
                        }
                        finally {
                            f = t = 0;
                        }
                    if (op[0] & 5)
                        throw op[1];
                    return {
                        value: op[0] ? op[1] : void 0,
                        done: true
                    };
                }
            }
            function send(name, args) {
                return _injected__WEBPACK_IMPORTED_MODULE_0__.send(name, args);
            }
            function runImport(name, func) {
                return _runImport.apply(this, arguments);
            }
            function _runImport() {
                _runImport = _async_to_generator(function (name, func) {
                    var e;
                    return _ts_generator(this, function (_state) {
                        switch (_state.label) {
                            case 0:
                                return [
                                    4,
                                    send('api/start-import', {
                                        budgetName: name
                                    })
                                ];
                            case 1:
                                _state.sent();
                                _state.label = 2;
                            case 2:
                                _state.trys.push([
                                    2,
                                    4,
                                    ,
                                    6
                                ]);
                                return [
                                    4,
                                    func()
                                ];
                            case 3:
                                _state.sent();
                                return [
                                    3,
                                    6
                                ];
                            case 4:
                                e = _state.sent();
                                return [
                                    4,
                                    send('api/abort-import')
                                ];
                            case 5:
                                _state.sent();
                                throw e;
                            case 6:
                                return [
                                    4,
                                    send('api/finish-import')
                                ];
                            case 7:
                                _state.sent();
                                return [
                                    2
                                ];
                        }
                    });
                });
                return _runImport.apply(this, arguments);
            }
            function loadBudget(budgetId) {
                return _loadBudget.apply(this, arguments);
            }
            function _loadBudget() {
                _loadBudget = _async_to_generator(function (budgetId) {
                    return _ts_generator(this, function (_state) {
                        return [
                            2,
                            send('api/load-budget', {
                                id: budgetId
                            })
                        ];
                    });
                });
                return _loadBudget.apply(this, arguments);
            }
            function downloadBudget(syncId) {
                return _downloadBudget.apply(this, arguments);
            }
            function _downloadBudget() {
                _downloadBudget = _async_to_generator(function (syncId) {
                    var password;
                    var _arguments = arguments;
                    return _ts_generator(this, function (_state) {
                        password = (_arguments.length > 1 && _arguments[1] !== void 0 ? _arguments[1] : {}).password;
                        return [
                            2,
                            send('api/download-budget', {
                                syncId: syncId,
                                password: password
                            })
                        ];
                    });
                });
                return _downloadBudget.apply(this, arguments);
            }
            function getBudgets() {
                return _getBudgets.apply(this, arguments);
            }
            function _getBudgets() {
                _getBudgets = _async_to_generator(function () {
                    return _ts_generator(this, function (_state) {
                        return [
                            2,
                            send('api/get-budgets')
                        ];
                    });
                });
                return _getBudgets.apply(this, arguments);
            }
            function sync() {
                return _sync.apply(this, arguments);
            }
            function _sync() {
                _sync = _async_to_generator(function () {
                    return _ts_generator(this, function (_state) {
                        return [
                            2,
                            send('api/sync')
                        ];
                    });
                });
                return _sync.apply(this, arguments);
            }
            function runBankSync(args) {
                return _runBankSync.apply(this, arguments);
            }
            function _runBankSync() {
                _runBankSync = _async_to_generator(function (args) {
                    return _ts_generator(this, function (_state) {
                        return [
                            2,
                            send('api/bank-sync', args)
                        ];
                    });
                });
                return _runBankSync.apply(this, arguments);
            }
            function batchBudgetUpdates(func) {
                return _batchBudgetUpdates.apply(this, arguments);
            }
            function _batchBudgetUpdates() {
                _batchBudgetUpdates = _async_to_generator(function (func) {
                    return _ts_generator(this, function (_state) {
                        switch (_state.label) {
                            case 0:
                                return [
                                    4,
                                    send('api/batch-budget-start')
                                ];
                            case 1:
                                _state.sent();
                                _state.label = 2;
                            case 2:
                                _state.trys.push([
                                    2,
                                    ,
                                    4,
                                    6
                                ]);
                                return [
                                    4,
                                    func()
                                ];
                            case 3:
                                _state.sent();
                                return [
                                    3,
                                    6
                                ];
                            case 4:
                                return [
                                    4,
                                    send('api/batch-budget-end')
                                ];
                            case 5:
                                _state.sent();
                                return [
                                    7
                                ];
                            case 6:
                                return [
                                    2
                                ];
                        }
                    });
                });
                return _batchBudgetUpdates.apply(this, arguments);
            }
            function runQuery(query) {
                return send('api/query', {
                    query: query.serialize()
                });
            }
            function getBudgetMonths() {
                return send('api/budget-months');
            }
            function getBudgetMonth(month) {
                return send('api/budget-month', {
                    month: month
                });
            }
            function setBudgetAmount(month, categoryId, value) {
                return send('api/budget-set-amount', {
                    month: month,
                    categoryId: categoryId,
                    amount: value
                });
            }
            function setBudgetCarryover(month, categoryId, flag) {
                return send('api/budget-set-carryover', {
                    month: month,
                    categoryId: categoryId,
                    flag: flag
                });
            }
            function addTransactions(accountId, transactions) {
                var _ref = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, _ref_learnCategories = _ref.learnCategories, learnCategories = _ref_learnCategories === void 0 ? false : _ref_learnCategories, _ref_runTransfers = _ref.runTransfers, runTransfers = _ref_runTransfers === void 0 ? false : _ref_runTransfers;
                return send('api/transactions-add', {
                    accountId: accountId,
                    transactions: transactions,
                    learnCategories: learnCategories,
                    runTransfers: runTransfers
                });
            }
            function importTransactions(accountId, transactions) {
                return send('api/transactions-import', {
                    accountId: accountId,
                    transactions: transactions
                });
            }
            function getTransactions(accountId, startDate, endDate) {
                return send('api/transactions-get', {
                    accountId: accountId,
                    startDate: startDate,
                    endDate: endDate
                });
            }
            function updateTransaction(id, fields) {
                return send('api/transaction-update', {
                    id: id,
                    fields: fields
                });
            }
            function deleteTransaction(id) {
                return send('api/transaction-delete', {
                    id: id
                });
            }
            function getAccounts() {
                return send('api/accounts-get');
            }
            function createAccount(account, initialBalance) {
                return send('api/account-create', {
                    account: account,
                    initialBalance: initialBalance
                });
            }
            function updateAccount(id, fields) {
                return send('api/account-update', {
                    id: id,
                    fields: fields
                });
            }
            function closeAccount(id, transferAccountId, transferCategoryId) {
                return send('api/account-close', {
                    id: id,
                    transferAccountId: transferAccountId,
                    transferCategoryId: transferCategoryId
                });
            }
            function reopenAccount(id) {
                return send('api/account-reopen', {
                    id: id
                });
            }
            function deleteAccount(id) {
                return send('api/account-delete', {
                    id: id
                });
            }
            function getAccountBalance(id, cutoff) {
                return send('api/account-balance', {
                    id: id,
                    cutoff: cutoff
                });
            }
            function getCategoryGroups() {
                return send('api/category-groups-get');
            }
            function createCategoryGroup(group) {
                return send('api/category-group-create', {
                    group: group
                });
            }
            function updateCategoryGroup(id, fields) {
                return send('api/category-group-update', {
                    id: id,
                    fields: fields
                });
            }
            function deleteCategoryGroup(id, transferCategoryId) {
                return send('api/category-group-delete', {
                    id: id,
                    transferCategoryId: transferCategoryId
                });
            }
            function getCategories() {
                return send('api/categories-get', {
                    grouped: false
                });
            }
            function createCategory(category) {
                return send('api/category-create', {
                    category: category
                });
            }
            function updateCategory(id, fields) {
                return send('api/category-update', {
                    id: id,
                    fields: fields
                });
            }
            function deleteCategory(id, transferCategoryId) {
                return send('api/category-delete', {
                    id: id,
                    transferCategoryId: transferCategoryId
                });
            }
            function getCommonPayees() {
                return send('api/common-payees-get');
            }
            function getPayees() {
                return send('api/payees-get');
            }
            function createPayee(payee) {
                return send('api/payee-create', {
                    payee: payee
                });
            }
            function updatePayee(id, fields) {
                return send('api/payee-update', {
                    id: id,
                    fields: fields
                });
            }
            function deletePayee(id) {
                return send('api/payee-delete', {
                    id: id
                });
            }
            function mergePayees(targetId, mergeIds) {
                return send('api/payees-merge', {
                    targetId: targetId,
                    mergeIds: mergeIds
                });
            }
            function getRules() {
                return send('api/rules-get');
            }
            function getPayeeRules(id) {
                return send('api/payee-rules-get', {
                    id: id
                });
            }
            function createRule(rule) {
                return send('api/rule-create', {
                    rule: rule
                });
            }
            function updateRule(rule) {
                return send('api/rule-update', {
                    rule: rule
                });
            }
            function deleteRule(id) {
                return send('api/rule-delete', {
                    id: id
                });
            }
            /***/ 
        }),
        /***/ "./packages/api/utils.js": 
        /*!*******************************!*\
          !*** ./packages/api/utils.js ***!
          \*******************************/
        /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony export */ __webpack_require__.d(__webpack_exports__, {
                /* harmony export */ amountToInteger: () => ( /* binding */amountToInteger),
                /* harmony export */ integerToAmount: () => ( /* binding */integerToAmount)
                /* harmony export */ 
            });
            function amountToInteger(n) {
                return Math.round(n * 100);
            }
            function integerToAmount(n) {
                return parseFloat((n / 100).toFixed(2));
            }
            /***/ 
        }),
        /***/ "./packages/loot-core/migrations/1632571489012_remove_cache.js": 
        /*!*********************************************************************!*\
          !*** ./packages/loot-core/migrations/1632571489012_remove_cache.js ***!
          \*********************************************************************/
        /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony export */ __webpack_require__.d(__webpack_exports__, {
                /* harmony export */ "default": () => ( /* binding */runMigration)
                /* harmony export */ 
            });
            async function runMigration(db) {
                function getValue(node) {
                    return node.expr != null ? node.expr : node.cachedValue;
                }
                db.execQuery(`
CREATE TABLE zero_budget_months
  (id TEXT PRIMARY KEY,
   buffered INTEGER DEFAULT 0);

CREATE TABLE zero_budgets
  (id TEXT PRIMARY KEY,
   month INTEGER,
   category TEXT,
   amount INTEGER DEFAULT 0,
   carryover INTEGER DEFAULT 0);

CREATE TABLE reflect_budgets
  (id TEXT PRIMARY KEY,
   month INTEGER,
   category TEXT,
   amount INTEGER DEFAULT 0,
   carryover INTEGER DEFAULT 0);

CREATE TABLE notes
  (id TEXT PRIMARY KEY,
   note TEXT);

CREATE TABLE kvcache (key TEXT PRIMARY KEY, value TEXT);
CREATE TABLE kvcache_key (id INTEGER PRIMARY KEY, key REAL);
`);
                // Migrate budget amounts and carryover
                const budget = db.runQuery(`SELECT * FROM spreadsheet_cells WHERE name LIKE 'budget%!budget-%'`, [], true);
                db.transaction(() => {
                    budget.forEach((monthBudget) => {
                        const match = monthBudget.name.match(/^(budget-report|budget)(\d+)!budget-(.+)$/);
                        if (match == null) {
                            console.log('Warning: invalid budget month name', monthBudget.name);
                            return;
                        }
                        const type = match[1];
                        const month = match[2].slice(0, 4) + '-' + match[2].slice(4);
                        const dbmonth = parseInt(match[2]);
                        const cat = match[3];
                        let amount = parseInt(getValue(monthBudget));
                        if (isNaN(amount)) {
                            amount = 0;
                        }
                        const sheetName = monthBudget.name.split('!')[0];
                        const carryover = db.runQuery('SELECT * FROM spreadsheet_cells WHERE name = ?', [
                            `${sheetName}!carryover-${cat}`
                        ], true);
                        const table = type === 'budget-report' ? 'reflect_budgets' : 'zero_budgets';
                        db.runQuery(`INSERT INTO ${table} (id, month, category, amount, carryover) VALUES (?, ?, ?, ?, ?)`, [
                            `${month}-${cat}`,
                            dbmonth,
                            cat,
                            amount,
                            carryover.length > 0 && getValue(carryover[0]) === 'true' ? 1 : 0
                        ]);
                    });
                });
                // Migrate buffers
                const buffers = db.runQuery(`SELECT * FROM spreadsheet_cells WHERE name LIKE 'budget%!buffered'`, [], true);
                db.transaction(() => {
                    buffers.forEach((buffer) => {
                        const match = buffer.name.match(/^budget(\d+)!buffered$/);
                        if (match) {
                            const month = match[1].slice(0, 4) + '-' + match[1].slice(4);
                            let amount = parseInt(getValue(buffer));
                            if (isNaN(amount)) {
                                amount = 0;
                            }
                            db.runQuery(`INSERT INTO zero_budget_months (id, buffered) VALUES (?, ?)`, [
                                month,
                                amount
                            ]);
                        }
                    });
                });
                // Migrate notes
                const notes = db.runQuery(`SELECT * FROM spreadsheet_cells WHERE name LIKE 'notes!%'`, [], true);
                const parseNote = (str) => {
                    try {
                        const value = JSON.parse(str);
                        return value && value !== '' ? value : null;
                    }
                    catch (e) {
                        return null;
                    }
                };
                db.transaction(() => {
                    notes.forEach((note) => {
                        const parsed = parseNote(getValue(note));
                        if (parsed) {
                            const [, id] = note.name.split('!');
                            db.runQuery(`INSERT INTO notes (id, note) VALUES (?, ?)`, [
                                id,
                                parsed
                            ]);
                        }
                    });
                });
                db.execQuery(`
    DROP TABLE spreadsheet_cells;
    ANALYZE;
    VACUUM;
  `);
            }
            /***/ 
        }),
        /***/ "./packages/loot-core/src/client/platform.electron.ts": 
        /*!************************************************************!*\
          !*** ./packages/loot-core/src/client/platform.electron.ts ***!
          \************************************************************/
        /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony export */ __webpack_require__.d(__webpack_exports__, {
                /* harmony export */ OS: () => ( /* binding */OS),
                /* harmony export */ env: () => ( /* binding */env),
                /* harmony export */ isBrowser: () => ( /* binding */isBrowser),
                /* harmony export */ isPlaywright: () => ( /* binding */isPlaywright)
                /* harmony export */ 
            });
            const os = __webpack_require__(/*! os */ "os");
            const isWindows = os.platform() === 'win32';
            const isMac = os.platform() === 'darwin';
            const isLinux = os.platform() === 'linux';
            const isPlaywright = false;
            const OS = isWindows ? 'windows' : isMac ? 'mac' : isLinux ? 'linux' : 'unknown';
            const env = 'unknown';
            const isBrowser = false;
            /***/ 
        }),
        /***/ "./packages/loot-core/src/mocks/budget.ts": 
        /*!************************************************!*\
          !*** ./packages/loot-core/src/mocks/budget.ts ***!
          \************************************************/
        /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony export */ __webpack_require__.d(__webpack_exports__, {
                /* harmony export */ createTestBudget: () => ( /* binding */createTestBudget)
                /* harmony export */ 
            });
            /* harmony import */ var _server_accounts_sync__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../server/accounts/sync */ "./packages/loot-core/src/server/accounts/sync.ts");
            /* harmony import */ var _server_aql__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../server/aql */ "./packages/loot-core/src/server/aql/index.ts");
            /* harmony import */ var _server_budget_actions__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../server/budget/actions */ "./packages/loot-core/src/server/budget/actions.ts");
            /* harmony import */ var _server_budget_base__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../server/budget/base */ "./packages/loot-core/src/server/budget/base.ts");
            /* harmony import */ var _server_db__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../server/db */ "./packages/loot-core/src/server/db/index.ts");
            /* harmony import */ var _server_mutators__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../server/mutators */ "./packages/loot-core/src/server/mutators.ts");
            /* harmony import */ var _server_sheet__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../server/sheet */ "./packages/loot-core/src/server/sheet.ts");
            /* harmony import */ var _server_sync__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../server/sync */ "./packages/loot-core/src/server/sync/index.ts");
            /* harmony import */ var _shared_months__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../shared/months */ "./packages/loot-core/src/shared/months.ts");
            /* harmony import */ var _shared_query__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../shared/query */ "./packages/loot-core/src/shared/query.ts");
            /* harmony import */ var _random__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./random */ "./packages/loot-core/src/mocks/random.ts");
            // @ts-strict-ignore
            function pickRandom(list) {
                return list[Math.floor((0, _random__WEBPACK_IMPORTED_MODULE_10__.random)() * list.length) % list.length];
            }
            function number(start, end) {
                return start + (end - start) * (0, _random__WEBPACK_IMPORTED_MODULE_10__.random)();
            }
            function integer(start, end) {
                return Math.round(number(start, end));
            }
            function findMin(items, field) {
                let item = items[0];
                for (let i = 0; i < items.length; i++) {
                    if (items[i][field] < item[field]) {
                        item = items[i];
                    }
                }
                return item;
            }
            function getStartingBalanceCat(categories) {
                return categories.find((c) => c.name === 'Starting Balances').id;
            }
            function extractCommonThings(payees, groups) {
                const incomePayee = payees.find((p) => p.name === 'Deposit');
                const expensePayees = payees.filter((p) => p.name !== 'Deposit' && p.name !== 'Starting Balance');
                const expenseGroup = groups.find((g) => !g.is_income);
                const incomeGroup = groups.find((g) => g.is_income);
                const categories = expenseGroup.categories.filter((c) => [
                    'Food',
                    'Restaurants',
                    'Entertainment',
                    'Clothing',
                    'General',
                    'Gift',
                    'Medical'
                ].indexOf(c.name) !== -1);
                return {
                    incomePayee,
                    expensePayees: expensePayees.filter((p) => !p.bill),
                    incomeGroup,
                    expenseCategories: categories,
                    billCategories: groups.find((g) => g.name === 'Bills').categories,
                    billPayees: expensePayees.filter((p) => p.bill)
                };
            }
            async function fillPrimaryChecking(handlers, account, payees, groups) {
                const { incomePayee, expensePayees, incomeGroup, expenseCategories, billCategories, billPayees } = extractCommonThings(payees, groups);
                const numTransactions = integer(100, 200);
                const transactions = [];
                for (let i = 0; i < numTransactions; i++) {
                    let payee;
                    if ((0, _random__WEBPACK_IMPORTED_MODULE_10__.random)() < 0.09) {
                        payee = incomePayee;
                    }
                    else {
                        payee = pickRandom(expensePayees);
                    }
                    let category;
                    if (payee.name === 'Deposit') {
                        category = incomeGroup.categories.find((c) => c.name === 'Income');
                    }
                    else {
                        category = pickRandom(expenseCategories);
                    }
                    let amount;
                    if (payee.name === 'Deposit') {
                        amount = integer(50000, 70000);
                    }
                    else {
                        amount = integer(0, (0, _random__WEBPACK_IMPORTED_MODULE_10__.random)() < 0.05 ? -8000 : -700);
                    }
                    const transaction = {
                        amount,
                        payee: payee.id,
                        account: account.id,
                        date: _shared_months__WEBPACK_IMPORTED_MODULE_8__.subDays(_shared_months__WEBPACK_IMPORTED_MODULE_8__.currentDay(), Math.floor(i / 3)),
                        category: category.id
                    };
                    transactions.push(transaction);
                    if ((0, _random__WEBPACK_IMPORTED_MODULE_10__.random)() < 0.2) {
                        const a = Math.round(transaction.amount / 3);
                        const pick = () => payee === incomePayee ? incomeGroup.categories.find((c) => c.name === 'Income').id : pickRandom(expenseCategories).id;
                        transaction.subtransactions = [
                            {
                                amount: a,
                                category: pick()
                            },
                            {
                                amount: a,
                                category: pick()
                            },
                            {
                                amount: transaction.amount - a * 2,
                                category: pick()
                            }
                        ];
                    }
                }
                const earliestMonth = _shared_months__WEBPACK_IMPORTED_MODULE_8__.monthFromDate(transactions[transactions.length - 1].date);
                const months = _shared_months__WEBPACK_IMPORTED_MODULE_8__.rangeInclusive(earliestMonth, _shared_months__WEBPACK_IMPORTED_MODULE_8__.currentMonth());
                const currentDay = _shared_months__WEBPACK_IMPORTED_MODULE_8__.currentDay();
                for (const month of months) {
                    let date = _shared_months__WEBPACK_IMPORTED_MODULE_8__.addDays(month, 12);
                    if (_shared_months__WEBPACK_IMPORTED_MODULE_8__.isBefore(date, currentDay)) {
                        transactions.push({
                            amount: -10000,
                            payee: billPayees.find((p) => p.name.toLowerCase().includes('power')).id,
                            account: account.id,
                            date,
                            category: billCategories.find((c) => c.name === 'Power').id
                        });
                    }
                    date = _shared_months__WEBPACK_IMPORTED_MODULE_8__.addDays(month, 18);
                    if (_shared_months__WEBPACK_IMPORTED_MODULE_8__.isBefore(date, currentDay)) {
                        transactions.push({
                            amount: -9000,
                            payee: billPayees.find((p) => p.name.toLowerCase().includes('water')).id,
                            account: account.id,
                            date,
                            category: billCategories.find((c) => c.name === 'Water').id
                        });
                    }
                    date = _shared_months__WEBPACK_IMPORTED_MODULE_8__.addDays(month, 2);
                    if (_shared_months__WEBPACK_IMPORTED_MODULE_8__.isBefore(date, currentDay)) {
                        transactions.push({
                            amount: -120000,
                            payee: billPayees.find((p) => p.name.toLowerCase().includes('housy')).id,
                            account: account.id,
                            date,
                            category: billCategories.find((c) => c.name === 'Mortgage').id
                        });
                    }
                    date = _shared_months__WEBPACK_IMPORTED_MODULE_8__.addDays(month, 20);
                    if (_shared_months__WEBPACK_IMPORTED_MODULE_8__.isBefore(date, currentDay)) {
                        transactions.push({
                            amount: -6000,
                            payee: billPayees.find((p) => p.name.toLowerCase().includes('internet')).id,
                            account: account.id,
                            date,
                            category: billCategories.find((c) => c.name === 'Internet').id
                        });
                    }
                    date = _shared_months__WEBPACK_IMPORTED_MODULE_8__.addDays(month, 23);
                    if (_shared_months__WEBPACK_IMPORTED_MODULE_8__.isBefore(date, currentDay)) {
                        transactions.push({
                            amount: -7500,
                            payee: billPayees.find((p) => p.name.toLowerCase().includes('t-mobile')).id,
                            account: account.id,
                            date,
                            category: billCategories.find((c) => c.name === 'Cell').id
                        });
                    }
                }
                let earliestDate = null;
                transactions.forEach((t) => {
                    if (earliestDate == null || t.date < earliestDate) {
                        earliestDate = t.date;
                    }
                });
                transactions.unshift({
                    amount: 100000,
                    payee: payees.find((p) => p.name === 'Starting Balance').id,
                    account: account.id,
                    date: earliestDate,
                    category: getStartingBalanceCat(incomeGroup.categories),
                    starting_balance_flag: true
                });
                return (0, _server_accounts_sync__WEBPACK_IMPORTED_MODULE_0__.addTransactions)(account.id, transactions);
            }
            async function fillChecking(handlers, account, payees, groups) {
                const { incomePayee, expensePayees, incomeGroup, expenseCategories } = extractCommonThings(payees, groups);
                const numTransactions = integer(20, 40);
                const transactions = [];
                for (let i = 0; i < numTransactions; i++) {
                    let payee;
                    if ((0, _random__WEBPACK_IMPORTED_MODULE_10__.random)() < 0.04) {
                        payee = incomePayee;
                    }
                    else {
                        payee = pickRandom(expensePayees);
                    }
                    let category;
                    if (payee.name === 'Deposit') {
                        category = incomeGroup.categories.find((c) => c.name === 'Income');
                    }
                    else {
                        category = pickRandom(expenseCategories);
                    }
                    const amount = payee.name === 'Deposit' ? integer(50000, 70000) : integer(0, -10000);
                    transactions.push({
                        amount,
                        payee: payee.id,
                        account: account.id,
                        date: _shared_months__WEBPACK_IMPORTED_MODULE_8__.subDays(_shared_months__WEBPACK_IMPORTED_MODULE_8__.currentDay(), i * 2),
                        category: category.id
                    });
                }
                transactions.unshift({
                    amount: integer(90000, 120000),
                    payee: payees.find((p) => p.name === 'Starting Balance').id,
                    account: account.id,
                    date: transactions[transactions.length - 1].date,
                    category: getStartingBalanceCat(incomeGroup.categories),
                    starting_balance_flag: true
                });
                await handlers['transactions-batch-update']({
                    added: transactions,
                    fastMode: true
                });
            }
            async function fillInvestment(handlers, account, payees, groups) {
                const { incomePayee, incomeGroup } = extractCommonThings(payees, groups);
                const numTransactions = integer(10, 30);
                const transactions = [];
                for (let i = 0; i < numTransactions; i++) {
                    const payee = incomePayee;
                    const category = incomeGroup.categories.find((c) => c.name === 'Income');
                    const amount = integer(10000, 20000);
                    transactions.push({
                        amount,
                        payee: payee.id,
                        account: account.id,
                        date: _shared_months__WEBPACK_IMPORTED_MODULE_8__.subDays(_shared_months__WEBPACK_IMPORTED_MODULE_8__.currentDay(), integer(10, 360)),
                        category: category.id
                    });
                }
                transactions.unshift({
                    amount: integer(10000, 20000),
                    payee: payees.find((p) => p.name === 'Starting Balance').id,
                    account: account.id,
                    date: findMin(transactions, 'date').date,
                    category: getStartingBalanceCat(incomeGroup.categories),
                    starting_balance_flag: true
                });
                await handlers['transactions-batch-update']({
                    added: transactions,
                    fastMode: true
                });
            }
            async function fillSavings(handlers, account, payees, groups) {
                const { incomePayee, expensePayees, incomeGroup, expenseCategories } = extractCommonThings(payees, groups);
                const numTransactions = integer(15, 40);
                const transactions = [];
                for (let i = 0; i < numTransactions; i++) {
                    let payee;
                    if ((0, _random__WEBPACK_IMPORTED_MODULE_10__.random)() < 0.3) {
                        payee = incomePayee;
                    }
                    else {
                        payee = pickRandom(expensePayees);
                    }
                    const category = payee === incomePayee ? incomeGroup.categories.find((c) => c.name === 'Income') : pickRandom(expenseCategories);
                    const amount = payee === incomePayee ? integer(10000, 80000) : integer(-10000, -2000);
                    transactions.push({
                        amount,
                        payee: payee.id,
                        account: account.id,
                        date: _shared_months__WEBPACK_IMPORTED_MODULE_8__.subDays(_shared_months__WEBPACK_IMPORTED_MODULE_8__.currentDay(), i * 5),
                        category: category.id
                    });
                }
                transactions.unshift({
                    amount: 30000,
                    payee: payees.find((p) => p.name === 'Starting Balance').id,
                    account: account.id,
                    date: transactions[transactions.length - 1].date,
                    category: getStartingBalanceCat(incomeGroup.categories),
                    starting_balance_flag: true
                });
                await handlers['transactions-batch-update']({
                    added: transactions,
                    fastMode: true
                });
            }
            async function fillMortgage(handlers, account, payees, groups) {
                const { incomePayee, incomeGroup } = extractCommonThings(payees, groups);
                const numTransactions = integer(7, 10);
                const amount = integer(100000, 200000);
                const category = incomeGroup.categories.find((c) => c.name === 'Income');
                const transactions = [
                    {
                        amount: integer(-3000, -3500) * 100 * 100,
                        payee: payees.find((p) => p.name === 'Starting Balance').id,
                        account: account.id,
                        date: _shared_months__WEBPACK_IMPORTED_MODULE_8__.subMonths(_shared_months__WEBPACK_IMPORTED_MODULE_8__.currentDay(), numTransactions) + '-02',
                        category: getStartingBalanceCat(incomeGroup.categories),
                        starting_balance_flag: true
                    }
                ];
                for (let i = 0; i < numTransactions; i++) {
                    const payee = incomePayee;
                    transactions.push({
                        amount,
                        payee: payee.id,
                        account: account.id,
                        date: _shared_months__WEBPACK_IMPORTED_MODULE_8__.subMonths(_shared_months__WEBPACK_IMPORTED_MODULE_8__.currentDay(), i) + '-02',
                        category: category.id,
                        starting_balance_flag: true
                    });
                }
                await handlers['transactions-batch-update']({
                    added: transactions,
                    fastMode: true
                });
            }
            async function fillOther(handlers, account, payees, groups) {
                const { incomePayee, incomeGroup } = extractCommonThings(payees, groups);
                const numTransactions = integer(3, 6);
                const category = incomeGroup.categories.find((c) => c.name === 'Income');
                const transactions = [
                    {
                        amount: integer(3250, 3700) * 100 * 100,
                        payee: payees.find((p) => p.name === 'Starting Balance').id,
                        account: account.id,
                        date: _shared_months__WEBPACK_IMPORTED_MODULE_8__.subMonths(_shared_months__WEBPACK_IMPORTED_MODULE_8__.currentDay(), numTransactions) + '-02',
                        category: getStartingBalanceCat(incomeGroup.categories),
                        starting_balance_flag: true
                    }
                ];
                for (let i = 0; i < numTransactions; i++) {
                    const payee = incomePayee;
                    const amount = integer(4, 9) * 100 * 100;
                    transactions.push({
                        amount,
                        payee: payee.id,
                        account: account.id,
                        date: _shared_months__WEBPACK_IMPORTED_MODULE_8__.subMonths(_shared_months__WEBPACK_IMPORTED_MODULE_8__.currentDay(), i) + '-02',
                        category: category.id
                    });
                }
                await handlers['transactions-batch-update']({
                    added: transactions,
                    fastMode: true
                });
            }
            async function createBudget(accounts, payees, groups) {
                const primaryAccount = accounts.find((a) => a.name = 'Bank of America');
                const earliestDate = (await _server_db__WEBPACK_IMPORTED_MODULE_4__.first(`SELECT * FROM v_transactions t LEFT JOIN accounts a ON t.account = a.id
       WHERE a.offbudget = 0 AND t.is_child = 0 ORDER BY date ASC LIMIT 1`)).date;
                const earliestPrimaryDate = (await _server_db__WEBPACK_IMPORTED_MODULE_4__.first(`SELECT * FROM v_transactions t LEFT JOIN accounts a ON t.account = a.id
       WHERE a.id = ? AND a.offbudget = 0 AND t.is_child = 0 ORDER BY date ASC LIMIT 1`, [
                    primaryAccount.id
                ])).date;
                const start = _shared_months__WEBPACK_IMPORTED_MODULE_8__.monthFromDate(_server_db__WEBPACK_IMPORTED_MODULE_4__.fromDateRepr(earliestDate));
                const end = _shared_months__WEBPACK_IMPORTED_MODULE_8__.currentMonth();
                const months = _shared_months__WEBPACK_IMPORTED_MODULE_8__.rangeInclusive(start, end);
                function category(name) {
                    for (const group of groups) {
                        const cat = group.categories.find((c) => c.name === name);
                        if (cat) {
                            return cat;
                        }
                    }
                }
                function setBudget(month, category, amount) {
                    return _server_budget_actions__WEBPACK_IMPORTED_MODULE_2__.setBudget({
                        month,
                        category: category.id,
                        amount
                    });
                }
                function setBudgetIfSpent(month, cat) {
                    const spent = _server_sheet__WEBPACK_IMPORTED_MODULE_6__.getCellValue(_shared_months__WEBPACK_IMPORTED_MODULE_8__.sheetForMonth(month), `sum-amount-${cat.id}`);
                    if (spent < 0) {
                        setBudget(month, cat, -spent);
                    }
                }
                await (0, _server_mutators__WEBPACK_IMPORTED_MODULE_5__.runMutator)(() => (0, _server_sync__WEBPACK_IMPORTED_MODULE_7__.batchMessages)(async () => {
                    for (const month of months) {
                        if (month >= _shared_months__WEBPACK_IMPORTED_MODULE_8__.monthFromDate(_server_db__WEBPACK_IMPORTED_MODULE_4__.fromDateRepr(earliestPrimaryDate))) {
                            setBudget(month, category('Food'), 40000);
                            setBudget(month, category('Restaurants'), 30000);
                            setBudget(month, category('Entertainment'), 10000);
                            setBudget(month, category('Clothing'), 3000);
                            setBudget(month, category('General'), 50000);
                            setBudget(month, category('Gift'), 7500);
                            setBudget(month, category('Medical'), 10000);
                            setBudget(month, category('Cell'), 7500);
                            setBudget(month, category('Internet'), 6000);
                            setBudget(month, category('Mortgage'), 120000);
                            setBudget(month, category('Water'), 9000);
                            setBudget(month, category('Power'), 10000);
                        }
                        else {
                            setBudgetIfSpent(month, category('Food'));
                            setBudgetIfSpent(month, category('Restaurants'));
                            setBudgetIfSpent(month, category('Entertainment'));
                            setBudgetIfSpent(month, category('Clothing'));
                            setBudgetIfSpent(month, category('General'));
                            setBudgetIfSpent(month, category('Gift'));
                            setBudgetIfSpent(month, category('Medical'));
                            setBudgetIfSpent(month, category('Cell'));
                            setBudgetIfSpent(month, category('Internet'));
                            setBudgetIfSpent(month, category('Mortgage'));
                            setBudgetIfSpent(month, category('Water'));
                            setBudgetIfSpent(month, category('Power'));
                        }
                    }
                }));
                await _server_sheet__WEBPACK_IMPORTED_MODULE_6__.waitOnSpreadsheet();
                await (0, _server_mutators__WEBPACK_IMPORTED_MODULE_5__.runMutator)(() => (0, _server_sync__WEBPACK_IMPORTED_MODULE_7__.batchMessages)(async () => {
                    let prevSaved = 0;
                    for (const month of months) {
                        if (month >= _shared_months__WEBPACK_IMPORTED_MODULE_8__.monthFromDate(_server_db__WEBPACK_IMPORTED_MODULE_4__.fromDateRepr(earliestPrimaryDate)) && month <= _shared_months__WEBPACK_IMPORTED_MODULE_8__.currentMonth()) {
                            const sheetName = _shared_months__WEBPACK_IMPORTED_MODULE_8__.sheetForMonth(month);
                            const toBudget = _server_sheet__WEBPACK_IMPORTED_MODULE_6__.getCellValue(sheetName, 'to-budget');
                            const available = toBudget - prevSaved;
                            if (available - 403000 > 0) {
                                setBudget(month, category('Savings'), available - 403000);
                                _server_budget_actions__WEBPACK_IMPORTED_MODULE_2__.setBuffer(month, 403000);
                                prevSaved += available - 403000;
                            }
                            else if (available > 0) {
                                _server_budget_actions__WEBPACK_IMPORTED_MODULE_2__.setBuffer(month, available);
                            }
                        }
                    }
                }));
                await _server_sheet__WEBPACK_IMPORTED_MODULE_6__.waitOnSpreadsheet();
                const sheetName = _shared_months__WEBPACK_IMPORTED_MODULE_8__.sheetForMonth(_shared_months__WEBPACK_IMPORTED_MODULE_8__.currentMonth());
                const toBudget = _server_sheet__WEBPACK_IMPORTED_MODULE_6__.getCellValue(sheetName, 'to-budget');
                if (toBudget < 0) {
                    await (0, _server_accounts_sync__WEBPACK_IMPORTED_MODULE_0__.addTransactions)(primaryAccount.id, [
                        {
                            amount: -toBudget,
                            category: category('Income').id,
                            date: _shared_months__WEBPACK_IMPORTED_MODULE_8__.currentMonth() + '-01'
                        }
                    ]);
                }
                // let sheetName = monthUtils.sheetForMonth(monthUtils.currentMonth());
                // let toBudget = sheet.getCellValue(sheetName, 'to-budget');
                // setBudget(monthUtils.currentMonth(), category('Savings'), toBudget);
                await _server_sheet__WEBPACK_IMPORTED_MODULE_6__.waitOnSpreadsheet();
            }
            async function createTestBudget(handlers) {
                (0, _server_sync__WEBPACK_IMPORTED_MODULE_7__.setSyncingMode)('import');
                await _server_db__WEBPACK_IMPORTED_MODULE_4__.execQuery('PRAGMA journal_mode = OFF');
                // Clear out the default categories. This is fine to do without
                // going through the sync system because we are in import mode and
                // these aren't tracked through messages anyway.
                await _server_db__WEBPACK_IMPORTED_MODULE_4__.runQuery('DELETE FROM categories;');
                await _server_db__WEBPACK_IMPORTED_MODULE_4__.runQuery('DELETE FROM category_groups');
                const accounts = [
                    {
                        name: 'Bank of America'
                    },
                    {
                        name: 'Ally Savings'
                    },
                    {
                        name: 'Capital One Checking'
                    },
                    {
                        name: 'HSBC'
                    },
                    {
                        name: 'Vanguard 401k',
                        offBudget: true
                    },
                    {
                        name: 'Mortgage',
                        offBudget: true
                    },
                    {
                        name: 'House Asset',
                        offBudget: true
                    },
                    {
                        name: 'Roth IRA',
                        offBudget: true
                    }
                ];
                await (0, _server_mutators__WEBPACK_IMPORTED_MODULE_5__.runMutator)(async () => {
                    for (const account of accounts) {
                        account.id = await handlers['account-create'](account);
                    }
                });
                const payees = [
                    {
                        name: 'Starting Balance'
                    },
                    {
                        name: 'Kroger'
                    },
                    {
                        name: 'Publix'
                    },
                    {
                        name: 'Home Depot'
                    },
                    {
                        name: 'Movies'
                    },
                    {
                        name: 'Online store'
                    },
                    {
                        name: 'Deposit'
                    },
                    {
                        name: 'Dominion Power',
                        bill: true
                    },
                    {
                        name: 'Extra Watery',
                        bill: true
                    },
                    {
                        name: 'Housy House',
                        bill: true
                    },
                    {
                        name: 'Fast Internet',
                        bill: true
                    },
                    {
                        name: 'T-mobile',
                        bill: true
                    }
                ];
                await (0, _server_mutators__WEBPACK_IMPORTED_MODULE_5__.runMutator)(() => (0, _server_sync__WEBPACK_IMPORTED_MODULE_7__.batchMessages)(async () => {
                    for (const payee of payees) {
                        payee.id = await handlers['payee-create']({
                            name: payee.name
                        });
                    }
                }));
                const categoryGroups = [
                    {
                        name: 'Usual Expenses',
                        categories: [
                            {
                                name: 'Savings'
                            },
                            {
                                name: 'Medical'
                            },
                            {
                                name: 'Gift'
                            },
                            {
                                name: 'General'
                            },
                            {
                                name: 'Clothing'
                            },
                            {
                                name: 'Entertainment'
                            },
                            {
                                name: 'Restaurants'
                            },
                            {
                                name: 'Food'
                            }
                        ]
                    },
                    {
                        name: 'Bills',
                        categories: [
                            {
                                name: 'Power'
                            },
                            {
                                name: 'Water'
                            },
                            {
                                name: 'Mortgage'
                            },
                            {
                                name: 'Internet'
                            },
                            {
                                name: 'Cell'
                            }
                        ]
                    },
                    {
                        name: 'Income',
                        is_income: true,
                        categories: [
                            {
                                name: 'Income',
                                is_income: true
                            },
                            {
                                name: 'Misc',
                                is_income: true
                            },
                            {
                                name: 'Starting Balances',
                                is_income: true
                            }
                        ]
                    }
                ];
                await (0, _server_mutators__WEBPACK_IMPORTED_MODULE_5__.runMutator)(async () => {
                    for (const group of categoryGroups) {
                        group.id = await handlers['category-group-create']({
                            name: group.name,
                            isIncome: group.is_income
                        });
                        for (const category of group.categories) {
                            category.id = await handlers['category-create']({
                                ...category,
                                isIncome: category.is_income ? 1 : 0,
                                groupId: group.id
                            });
                        }
                    }
                });
                const allGroups = (await (0, _server_mutators__WEBPACK_IMPORTED_MODULE_5__.runHandler)(handlers['get-categories'])).grouped;
                (0, _server_sync__WEBPACK_IMPORTED_MODULE_7__.setSyncingMode)('import');
                await (0, _server_mutators__WEBPACK_IMPORTED_MODULE_5__.runMutator)(() => (0, _server_sync__WEBPACK_IMPORTED_MODULE_7__.batchMessages)(async () => {
                    for (const account of accounts) {
                        if (account.name === 'Bank of America') {
                            await fillPrimaryChecking(handlers, account, payees, allGroups);
                        }
                        else if (account.name === 'Capital One Checking' || account.name === 'HSBC') {
                            await fillChecking(handlers, account, payees, allGroups);
                        }
                        else if (account.name === 'Ally Savings') {
                            await fillSavings(handlers, account, payees, allGroups);
                        }
                        else if (account.name === 'Vanguard 401k' || account.name === 'Roth IRA') {
                            await fillInvestment(handlers, account, payees, allGroups);
                        }
                        else if (account.name === 'Mortgage') {
                            await fillMortgage(handlers, account, payees, allGroups);
                        }
                        else if (account.name === 'House Asset') {
                            await fillOther(handlers, account, payees, allGroups);
                        }
                        else {
                            console.error('Unknown account name for test budget: ', account.name);
                            await fillChecking(handlers, account, payees, allGroups);
                        }
                    }
                }));
                (0, _server_sync__WEBPACK_IMPORTED_MODULE_7__.setSyncingMode)('import');
                // This checks to see if the primary account is in the negative.
                // This might happen depending on the transactions added, but we
                // don't want to show that as it'd be weird. We modify the latest
                // deposit transaction to force it to be positive
                const primaryAccount = accounts.find((a) => a.name = 'Bank of America');
                const { data: primaryBalance } = await (0, _server_aql__WEBPACK_IMPORTED_MODULE_1__.runQuery)((0, _shared_query__WEBPACK_IMPORTED_MODULE_9__.q)('transactions').filter({
                    account: primaryAccount.id
                }).calculate({
                    $sum: '$amount'
                }).serialize());
                if (primaryBalance < 0) {
                    const { data: results } = await (0, _server_aql__WEBPACK_IMPORTED_MODULE_1__.runQuery)((0, _shared_query__WEBPACK_IMPORTED_MODULE_9__.q)('transactions').filter({
                        account: primaryAccount.id,
                        amount: {
                            $gt: 0
                        }
                    }).limit(1).select([
                        'id',
                        'amount'
                    ]).serialize());
                    const lastDeposit = results[0];
                    await (0, _server_mutators__WEBPACK_IMPORTED_MODULE_5__.runHandler)(handlers['transaction-update'], {
                        ...lastDeposit,
                        amount: lastDeposit.amount + -primaryBalance + integer(10000, 20000)
                    });
                }
                // Bust the cache and reload the spreadsheet
                (0, _server_sync__WEBPACK_IMPORTED_MODULE_7__.setSyncingMode)('disabled');
                await _server_sheet__WEBPACK_IMPORTED_MODULE_6__.reloadSpreadsheet(_server_db__WEBPACK_IMPORTED_MODULE_4__);
                await _server_budget_base__WEBPACK_IMPORTED_MODULE_3__.createAllBudgets();
                await _server_sheet__WEBPACK_IMPORTED_MODULE_6__.waitOnSpreadsheet();
                // Create some schedules
                await (0, _server_mutators__WEBPACK_IMPORTED_MODULE_5__.runMutator)(() => (0, _server_sync__WEBPACK_IMPORTED_MODULE_7__.batchMessages)(async () => {
                    const account = accounts.find((acc) => acc.name === 'Bank of America');
                    await (0, _server_mutators__WEBPACK_IMPORTED_MODULE_5__.runHandler)(handlers['schedule/create'], {
                        schedule: {
                            name: 'Phone bills',
                            posts_transaction: false
                        },
                        conditions: [
                            {
                                op: 'is',
                                field: 'payee',
                                value: payees.find((item) => item.name === 'Dominion Power').id
                            },
                            {
                                op: 'is',
                                field: 'account',
                                value: account.id
                            },
                            {
                                op: 'is',
                                field: 'date',
                                value: {
                                    start: _shared_months__WEBPACK_IMPORTED_MODULE_8__.currentDay(),
                                    frequency: 'monthly',
                                    patterns: [],
                                    skipWeekend: false,
                                    weekendSolveMode: 'after'
                                }
                            },
                            {
                                op: 'isapprox',
                                field: 'amount',
                                value: -12000
                            }
                        ]
                    });
                    await (0, _server_mutators__WEBPACK_IMPORTED_MODULE_5__.runHandler)(handlers['schedule/create'], {
                        schedule: {
                            name: 'Internet bill',
                            posts_transaction: false
                        },
                        conditions: [
                            {
                                op: 'is',
                                field: 'payee',
                                value: payees.find((item) => item.name === 'Fast Internet').id
                            },
                            {
                                op: 'is',
                                field: 'account',
                                value: account.id
                            },
                            {
                                op: 'is',
                                field: 'date',
                                value: _shared_months__WEBPACK_IMPORTED_MODULE_8__.subDays(_shared_months__WEBPACK_IMPORTED_MODULE_8__.currentDay(), 1)
                            },
                            {
                                op: 'isapprox',
                                field: 'amount',
                                value: -14000
                            }
                        ]
                    });
                    await (0, _server_mutators__WEBPACK_IMPORTED_MODULE_5__.runHandler)(handlers['schedule/create'], {
                        schedule: {
                            name: 'Wedding',
                            posts_transaction: false
                        },
                        conditions: [
                            {
                                op: 'is',
                                field: 'date',
                                value: {
                                    start: _shared_months__WEBPACK_IMPORTED_MODULE_8__.subDays(_shared_months__WEBPACK_IMPORTED_MODULE_8__.currentDay(), 3),
                                    frequency: 'monthly',
                                    patterns: [],
                                    skipWeekend: false,
                                    weekendSolveMode: 'after'
                                }
                            },
                            {
                                op: 'is',
                                field: 'amount',
                                value: -2700000
                            }
                        ]
                    });
                    await (0, _server_mutators__WEBPACK_IMPORTED_MODULE_5__.runHandler)(handlers['schedule/create'], {
                        schedule: {
                            name: 'Utilities',
                            posts_transaction: false
                        },
                        conditions: [
                            {
                                op: 'is',
                                field: 'account',
                                value: account.id
                            },
                            {
                                op: 'is',
                                field: 'date',
                                value: {
                                    start: _shared_months__WEBPACK_IMPORTED_MODULE_8__.addDays(_shared_months__WEBPACK_IMPORTED_MODULE_8__.currentDay(), 1),
                                    frequency: 'monthly',
                                    patterns: [],
                                    skipWeekend: false,
                                    weekendSolveMode: 'after'
                                }
                            },
                            {
                                op: 'is',
                                field: 'amount',
                                value: -190000
                            }
                        ]
                    });
                }));
                // Create a budget
                await createBudget(accounts, payees, allGroups);
            }
            /***/ 
        }),
        /***/ "./packages/loot-core/src/mocks/random.ts": 
        /*!************************************************!*\
          !*** ./packages/loot-core/src/mocks/random.ts ***!
          \************************************************/
        /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony export */ __webpack_require__.d(__webpack_exports__, {
                /* harmony export */ random: () => ( /* binding */random)
                /* harmony export */ 
            });
            /* harmony import */ var _client_platform__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../client/platform */ "./packages/loot-core/src/client/platform.electron.ts");
            // Fake "random" function used to have stable data structures for
            // e2e and visual regression tests
            let pseudoRandomIterator = 0;
            function pseudoRandom() {
                pseudoRandomIterator += 0.45;
                if (pseudoRandomIterator > 1) {
                    pseudoRandomIterator = 0;
                }
                return pseudoRandomIterator;
            }
            const random = _client_platform__WEBPACK_IMPORTED_MODULE_0__.isPlaywright ? pseudoRandom : Math.random;
            /***/ 
        }),
        /***/ "./packages/loot-core/src/platform/exceptions/index.electron.ts": 
        /*!**********************************************************************!*\
          !*** ./packages/loot-core/src/platform/exceptions/index.electron.ts ***!
          \**********************************************************************/
        /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony export */ __webpack_require__.d(__webpack_exports__, {
                /* harmony export */ captureBreadcrumb: () => ( /* binding */captureBreadcrumb),
                /* harmony export */ captureException: () => ( /* binding */captureException)
                /* harmony export */ 
            });
            const captureException = function (exc) {
                console.log('[Exception]', exc);
            };
            const captureBreadcrumb = function () { };
            /***/ 
        }),
        /***/ "./packages/loot-core/src/platform/server/asyncStorage/index.electron.ts": 
        /*!*******************************************************************************!*\
          !*** ./packages/loot-core/src/platform/server/asyncStorage/index.electron.ts ***!
          \*******************************************************************************/
        /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony export */ __webpack_require__.d(__webpack_exports__, {
                /* harmony export */ getItem: () => ( /* binding */getItem),
                /* harmony export */ init: () => ( /* binding */init),
                /* harmony export */ multiGet: () => ( /* binding */multiGet),
                /* harmony export */ multiRemove: () => ( /* binding */multiRemove),
                /* harmony export */ multiSet: () => ( /* binding */multiSet),
                /* harmony export */ removeItem: () => ( /* binding */removeItem),
                /* harmony export */ setItem: () => ( /* binding */setItem)
                /* harmony export */ 
            });
            /* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! fs */ "fs");
            /* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/ __webpack_require__.n(fs__WEBPACK_IMPORTED_MODULE_0__);
            /* harmony import */ var path__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! path */ "path");
            /* harmony import */ var path__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/ __webpack_require__.n(path__WEBPACK_IMPORTED_MODULE_1__);
            /* harmony import */ var _fs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../fs */ "./packages/loot-core/src/platform/server/fs/index.electron.ts");
            // @ts-strict-ignore
            const getStorePath = () => (0, path__WEBPACK_IMPORTED_MODULE_1__.join)(_fs__WEBPACK_IMPORTED_MODULE_2__.getDataDir(), 'global-store.json');
            let store;
            let persisted = true;
            const init = function ({ persist = true } = {}) {
                if (persist) {
                    try {
                        store = JSON.parse(fs__WEBPACK_IMPORTED_MODULE_0__.readFileSync(getStorePath(), 'utf8'));
                    }
                    catch (e) {
                        store = {};
                    }
                }
                else {
                    store = {};
                }
                persisted = persist;
            };
            function _saveStore() {
                if (persisted) {
                    return new Promise(function (resolve, reject) {
                        fs__WEBPACK_IMPORTED_MODULE_0__.writeFile(getStorePath(), JSON.stringify(store), 'utf8', function (err) {
                            return err ? reject(err) : resolve(undefined);
                        });
                    });
                }
            }
            const getItem = function (key) {
                return new Promise(function (resolve) {
                    return resolve(store[key]);
                });
            };
            const setItem = function (key, value) {
                store[key] = value;
                return _saveStore();
            };
            const removeItem = function (key) {
                delete store[key];
                return _saveStore();
            };
            const multiGet = function (keys) {
                return new Promise(function (resolve) {
                    return resolve(keys.map(function (key) {
                        return [
                            key,
                            store[key]
                        ];
                    }));
                });
            };
            const multiSet = function (keyValues) {
                keyValues.forEach(function ([key, value]) {
                    store[key] = value;
                });
                return _saveStore();
            };
            const multiRemove = function (keys) {
                keys.forEach(function (key) {
                    delete store[key];
                });
                return _saveStore();
            };
            /***/ 
        }),
        /***/ "./packages/loot-core/src/platform/server/connection/index.api.ts": 
        /*!************************************************************************!*\
          !*** ./packages/loot-core/src/platform/server/connection/index.api.ts ***!
          \************************************************************************/
        /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony export */ __webpack_require__.d(__webpack_exports__, {
                /* harmony export */ getNumClients: () => ( /* binding */getNumClients),
                /* harmony export */ init: () => ( /* binding */init),
                /* harmony export */ send: () => ( /* binding */send)
                /* harmony export */ 
            });
            const init = function () { };
            const send = function () {
                // Nothing
            };
            const getNumClients = function () {
                return 1;
            };
            /***/ 
        }),
        /***/ "./packages/loot-core/src/platform/server/fetch/index.api.ts": 
        /*!*******************************************************************!*\
          !*** ./packages/loot-core/src/platform/server/fetch/index.api.ts ***!
          \*******************************************************************/
        /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony export */ __webpack_require__.d(__webpack_exports__, {
                /* harmony export */ fetch: () => ( /* binding */fetch)
                /* harmony export */ 
            });
            const fetch = globalThis.fetch;
            /***/ 
        }),
        /***/ "./packages/loot-core/src/platform/server/fs/index.electron.ts": 
        /*!*********************************************************************!*\
          !*** ./packages/loot-core/src/platform/server/fs/index.electron.ts ***!
          \*********************************************************************/
        /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony export */ __webpack_require__.d(__webpack_exports__, {
                /* harmony export */ _setDocumentDir: () => ( /* reexport safe */_shared__WEBPACK_IMPORTED_MODULE_2__._setDocumentDir),
                /* harmony export */ basename: () => ( /* binding */basename),
                /* harmony export */ bundledDatabasePath: () => ( /* binding */bundledDatabasePath),
                /* harmony export */ copyFile: () => ( /* binding */copyFile),
                /* harmony export */ demoBudgetPath: () => ( /* binding */demoBudgetPath),
                /* harmony export */ exists: () => ( /* binding */exists),
                /* harmony export */ getBudgetDir: () => ( /* reexport safe */_shared__WEBPACK_IMPORTED_MODULE_2__.getBudgetDir),
                /* harmony export */ getDataDir: () => ( /* binding */getDataDir),
                /* harmony export */ getDocumentDir: () => ( /* reexport safe */_shared__WEBPACK_IMPORTED_MODULE_2__.getDocumentDir),
                /* harmony export */ getModifiedTime: () => ( /* binding */getModifiedTime),
                /* harmony export */ init: () => ( /* binding */init),
                /* harmony export */ join: () => ( /* binding */join),
                /* harmony export */ listDir: () => ( /* binding */listDir),
                /* harmony export */ migrationsPath: () => ( /* binding */migrationsPath),
                /* harmony export */ mkdir: () => ( /* binding */mkdir),
                /* harmony export */ readFile: () => ( /* binding */readFile),
                /* harmony export */ removeDir: () => ( /* binding */removeDir),
                /* harmony export */ removeDirRecursively: () => ( /* binding */removeDirRecursively),
                /* harmony export */ removeFile: () => ( /* binding */removeFile),
                /* harmony export */ size: () => ( /* binding */size),
                /* harmony export */ writeFile: () => ( /* binding */writeFile)
                /* harmony export */ 
            });
            /* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! fs */ "fs");
            /* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/ __webpack_require__.n(fs__WEBPACK_IMPORTED_MODULE_0__);
            /* harmony import */ var path__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! path */ "path");
            /* harmony import */ var path__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/ __webpack_require__.n(path__WEBPACK_IMPORTED_MODULE_1__);
            /* harmony import */ var _shared__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./shared */ "./packages/loot-core/src/platform/server/fs/shared.ts");
            // @ts-strict-ignore
            let rootPath = path__WEBPACK_IMPORTED_MODULE_1__.join(__dirname, '..', '..', '..', '..');
            if (__filename.match('bundle')) {
                // The file name is not our filename and indicates that we're in the
                // bundled form. Because of this, the root path is different.
                rootPath = path__WEBPACK_IMPORTED_MODULE_1__.join(__dirname, '..');
            }
            const init = () => {
                // Nothing to do
            };
            const getDataDir = () => {
                if (!process.env.ACTUAL_DATA_DIR) {
                    throw new Error('ACTUAL_DATA_DIR env variable is required');
                }
                return process.env.ACTUAL_DATA_DIR;
            };
            const bundledDatabasePath = path__WEBPACK_IMPORTED_MODULE_1__.join(rootPath, 'default-db.sqlite');
            const migrationsPath = path__WEBPACK_IMPORTED_MODULE_1__.join(rootPath, 'migrations');
            const demoBudgetPath = path__WEBPACK_IMPORTED_MODULE_1__.join(rootPath, 'demo-budget');
            const join = path__WEBPACK_IMPORTED_MODULE_1__.join;
            const basename = (filepath) => path__WEBPACK_IMPORTED_MODULE_1__.basename(filepath);
            const listDir = (filepath) => new Promise((resolve, reject) => {
                fs__WEBPACK_IMPORTED_MODULE_0__.readdir(filepath, (err, files) => {
                    if (err) {
                        reject(err);
                    }
                    else {
                        resolve(files);
                    }
                });
            });
            const exists = (filepath) => new Promise((resolve) => {
                fs__WEBPACK_IMPORTED_MODULE_0__.access(filepath, fs__WEBPACK_IMPORTED_MODULE_0__.constants.F_OK, (err) => {
                    return resolve(!err);
                });
            });
            const mkdir = (filepath) => new Promise((resolve, reject) => {
                fs__WEBPACK_IMPORTED_MODULE_0__.mkdir(filepath, (err) => {
                    if (err) {
                        reject(err);
                    }
                    else {
                        resolve(undefined);
                    }
                });
            });
            const size = (filepath) => new Promise((resolve, reject) => {
                fs__WEBPACK_IMPORTED_MODULE_0__.stat(filepath, (err, stats) => {
                    if (err) {
                        reject(err);
                    }
                    else {
                        resolve(stats.size);
                    }
                });
            });
            const copyFile = (frompath, topath) => {
                return new Promise((resolve, reject) => {
                    const readStream = fs__WEBPACK_IMPORTED_MODULE_0__.createReadStream(frompath);
                    const writeStream = fs__WEBPACK_IMPORTED_MODULE_0__.createWriteStream(topath);
                    readStream.on('error', reject);
                    writeStream.on('error', reject);
                    writeStream.on('open', () => readStream.pipe(writeStream));
                    writeStream.once('close', resolve);
                });
            };
            const readFile = (filepath, encoding = 'utf8') => {
                if (encoding === 'binary') {
                    // `binary` is not actually a valid encoding, you pass `null` into node if
                    // you want a buffer
                    encoding = null;
                }
                // `any` as cannot refine return with two function overrides
                // eslint-disable-next-line @typescript-eslint/no-explicit-any
                return new Promise((resolve, reject) => {
                    fs__WEBPACK_IMPORTED_MODULE_0__.readFile(filepath, encoding, (err, data) => {
                        if (err) {
                            reject(err);
                        }
                        else {
                            resolve(data);
                        }
                    });
                });
            };
            const writeFile = (filepath, contents) => {
                return new Promise(function (resolve, reject) {
                    // @ts-expect-error contents type needs refining
                    fs__WEBPACK_IMPORTED_MODULE_0__.writeFile(filepath, contents, 'utf8', function (err) {
                        return err ? reject(err) : resolve(undefined);
                    });
                });
            };
            const removeFile = (filepath) => {
                return new Promise(function (resolve, reject) {
                    fs__WEBPACK_IMPORTED_MODULE_0__.unlink(filepath, (err) => {
                        return err ? reject(err) : resolve(undefined);
                    });
                });
            };
            const removeDir = (dirpath) => {
                return new Promise(function (resolve, reject) {
                    fs__WEBPACK_IMPORTED_MODULE_0__.rmdir(dirpath, (err) => {
                        return err ? reject(err) : resolve(undefined);
                    });
                });
            };
            const removeDirRecursively = async (dirpath) => {
                if (await exists(dirpath)) {
                    for (const file of (await listDir(dirpath))) {
                        const fullpath = join(dirpath, file);
                        if (fs__WEBPACK_IMPORTED_MODULE_0__.statSync(fullpath).isDirectory()) {
                            await removeDirRecursively(fullpath);
                        }
                        else {
                            await removeFile(fullpath);
                        }
                    }
                    await removeDir(dirpath);
                }
            };
            const getModifiedTime = (filepath) => {
                return new Promise(function (resolve, reject) {
                    fs__WEBPACK_IMPORTED_MODULE_0__.stat(filepath, (err, stats) => {
                        if (err) {
                            reject(err);
                        }
                        else {
                            resolve(new Date(stats.mtime));
                        }
                    });
                });
            };
            /***/ 
        }),
        /***/ "./packages/loot-core/src/platform/server/fs/path-join.electron.ts": 
        /*!*************************************************************************!*\
          !*** ./packages/loot-core/src/platform/server/fs/path-join.electron.ts ***!
          \*************************************************************************/
        /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony export */ __webpack_require__.d(__webpack_exports__, {
                /* harmony export */ join: () => ( /* reexport safe */path__WEBPACK_IMPORTED_MODULE_0__.join)
                /* harmony export */ 
            });
            /* harmony import */ var path__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! path */ "path");
            /* harmony import */ var path__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/ __webpack_require__.n(path__WEBPACK_IMPORTED_MODULE_0__);
            /***/ 
        }),
        /***/ "./packages/loot-core/src/platform/server/fs/shared.ts": 
        /*!*************************************************************!*\
          !*** ./packages/loot-core/src/platform/server/fs/shared.ts ***!
          \*************************************************************/
        /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony export */ __webpack_require__.d(__webpack_exports__, {
                /* harmony export */ _setDocumentDir: () => ( /* binding */_setDocumentDir),
                /* harmony export */ getBudgetDir: () => ( /* binding */getBudgetDir),
                /* harmony export */ getDocumentDir: () => ( /* binding */getDocumentDir)
                /* harmony export */ 
            });
            /* harmony import */ var _path_join__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./path-join */ "./packages/loot-core/src/platform/server/fs/path-join.electron.ts");
            // @ts-strict-ignore
            let documentDir;
            const _setDocumentDir = (dir) => documentDir = dir;
            const getDocumentDir = () => {
                if (!documentDir) {
                    throw new Error('Document directory is not set');
                }
                return documentDir;
            };
            const getBudgetDir = (id) => {
                if (!id) {
                    throw new Error('getDocumentDir: id is falsy: ' + id);
                }
                // TODO: This should be better
                //
                // A cheesy safe guard. The id is generated from the budget name,
                // so it provides an entry point for the user to accidentally (or
                // intentionally) access other parts of the system. Always
                // restrict it to only access files within the budget directory by
                // never allowing slashes.
                if (id.match(/[^A-Za-z0-9\-_]/)) {
                    throw new Error(`Invalid budget id ${id}. Check the id of your budget in the Advanced section of the settings page.`);
                }
                return (0, _path_join__WEBPACK_IMPORTED_MODULE_0__.join)(getDocumentDir(), id);
            };
            /***/ 
        }),
        /***/ "./packages/loot-core/src/platform/server/log/index.api.ts": 
        /*!*****************************************************************!*\
          !*** ./packages/loot-core/src/platform/server/log/index.api.ts ***!
          \*****************************************************************/
        /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony export */ __webpack_require__.d(__webpack_exports__, {
                /* harmony export */ logger: () => ( /* binding */logger)
                /* harmony export */ 
            });
            const logger = {
                info: (...args) => {
                    console.log(...args);
                },
                warn: (...args) => {
                    console.warn(...args);
                }
            };
            /***/ 
        }),
        /***/ "./packages/loot-core/src/platform/server/sqlite/index.electron.ts": 
        /*!*************************************************************************!*\
          !*** ./packages/loot-core/src/platform/server/sqlite/index.electron.ts ***!
          \*************************************************************************/
        /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony export */ __webpack_require__.d(__webpack_exports__, {
                /* harmony export */ asyncTransaction: () => ( /* binding */asyncTransaction),
                /* harmony export */ closeDatabase: () => ( /* binding */closeDatabase),
                /* harmony export */ execQuery: () => ( /* binding */execQuery),
                /* harmony export */ exportDatabase: () => ( /* binding */exportDatabase),
                /* harmony export */ init: () => ( /* binding */init),
                /* harmony export */ openDatabase: () => ( /* binding */openDatabase),
                /* harmony export */ prepare: () => ( /* binding */prepare),
                /* harmony export */ runQuery: () => ( /* binding */runQuery),
                /* harmony export */ transaction: () => ( /* binding */transaction)
                /* harmony export */ 
            });
            /* harmony import */ var better_sqlite3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! better-sqlite3 */ "better-sqlite3");
            /* harmony import */ var better_sqlite3__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/ __webpack_require__.n(better_sqlite3__WEBPACK_IMPORTED_MODULE_0__);
            /* harmony import */ var uuid__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! uuid */ "./node_modules/uuid/dist/esm-node/v4.js");
            /* harmony import */ var _fs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../fs */ "./packages/loot-core/src/platform/server/fs/index.electron.ts");
            /* harmony import */ var _normalise__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./normalise */ "./packages/loot-core/src/platform/server/sqlite/normalise.ts");
            /* harmony import */ var _unicodeLike__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./unicodeLike */ "./packages/loot-core/src/platform/server/sqlite/unicodeLike.ts");
            // @ts-strict-ignore
            function verifyParamTypes(sql, arr) {
                arr.forEach((val) => {
                    if (typeof val !== 'string' && typeof val !== 'number' && val !== null) {
                        console.log(sql, arr);
                        throw new Error('Invalid field type ' + val + ' for sql ' + sql);
                    }
                });
            }
            async function init() { }
            function prepare(db, sql) {
                return db.prepare(sql);
            }
            function runQuery(db, sql, params = [], fetchAll = false) {
                if (params) {
                    verifyParamTypes(sql, params);
                }
                let stmt;
                try {
                    stmt = typeof sql === 'string' ? db.prepare(sql) : sql;
                }
                catch (e) {
                    console.log('error', sql);
                    throw e;
                }
                if (fetchAll) {
                    try {
                        const result = stmt.all(...params);
                        return result;
                    }
                    catch (e) {
                        console.log('error', sql);
                        throw e;
                    }
                }
                else {
                    try {
                        const info = stmt.run(...params);
                        return {
                            changes: info.changes,
                            insertId: info.lastInsertRowid
                        };
                    }
                    catch (e) {
                        // console.log('error', sql);
                        throw e;
                    }
                }
            }
            function execQuery(db, sql) {
                db.exec(sql);
            }
            function transaction(db, fn) {
                db.transaction(fn)();
            }
            // **Important**: this is an unsafe function since sqlite executes
            // executes statements sequentially. It would be easy for other code
            // to run statements in between our transaction and get caught up in
            // it. This is rarely used, and only needed for specific cases (like
            // batch importing a bunch of data). Don't use this.
            let transactionDepth = 0;
            async function asyncTransaction(db, fn) {
                // Support nested transactions by "coalescing" them into the parent
                // one if one is already started
                if (transactionDepth === 0) {
                    db.exec('BEGIN TRANSACTION');
                }
                transactionDepth++;
                try {
                    await fn();
                }
                finally {
                    transactionDepth--;
                    // We always commit because rollback is more dangerous - any
                    // queries that ran *in-between* this async function would be
                    // lost. Right now we are only using transactions for speed
                    // purposes unfortunately
                    if (transactionDepth === 0) {
                        db.exec('COMMIT');
                    }
                }
            }
            function regexp(regex, text) {
                return new RegExp(regex).test(text) ? 1 : 0;
            }
            function openDatabase(pathOrBuffer) {
                const db = new (better_sqlite3__WEBPACK_IMPORTED_MODULE_0___default())(pathOrBuffer);
                // Define Unicode-aware LOWER, UPPER, and LIKE implementation.
                // This is necessary because better-sqlite3 uses SQLite build without ICU support.
                // @ts-expect-error @types/better-sqlite3 does not support setting strict 3rd argument
                db.function('UNICODE_LOWER', {
                    deterministic: true
                }, (arg) => arg?.toLowerCase());
                // @ts-expect-error @types/better-sqlite3 does not support setting strict 3rd argument
                db.function('UNICODE_UPPER', {
                    deterministic: true
                }, (arg) => arg?.toUpperCase());
                // @ts-expect-error @types/better-sqlite3 does not support setting strict 3rd argument
                db.function('UNICODE_LIKE', {
                    deterministic: true
                }, _unicodeLike__WEBPACK_IMPORTED_MODULE_3__.unicodeLike);
                // @ts-expect-error @types/better-sqlite3 does not support setting strict 3rd argument
                db.function('REGEXP', {
                    deterministic: true
                }, regexp);
                // @ts-expect-error @types/better-sqlite3 does not support setting strict 3rd argument
                db.function('NORMALISE', {
                    deterministic: true
                }, _normalise__WEBPACK_IMPORTED_MODULE_2__.normalise);
                return db;
            }
            function closeDatabase(db) {
                return db.close();
            }
            async function exportDatabase(db) {
                // electron does not support better-sqlite serialize since v21
                // save to file and read in the raw data.
                const name = `backup-for-export-${(0, uuid__WEBPACK_IMPORTED_MODULE_4__["default"])()}.db`;
                await db.backup(name);
                const data = await (0, _fs__WEBPACK_IMPORTED_MODULE_1__.readFile)(name, 'binary');
                await (0, _fs__WEBPACK_IMPORTED_MODULE_1__.removeFile)(name);
                return data;
            }
            /***/ 
        }),
        /***/ "./packages/loot-core/src/platform/server/sqlite/normalise.ts": 
        /*!********************************************************************!*\
          !*** ./packages/loot-core/src/platform/server/sqlite/normalise.ts ***!
          \********************************************************************/
        /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony export */ __webpack_require__.d(__webpack_exports__, {
                /* harmony export */ normalise: () => ( /* binding */normalise)
                /* harmony export */ 
            });
            /* harmony import */ var _shared_normalisation__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../shared/normalisation */ "./packages/loot-core/src/shared/normalisation.ts");
            function normalise(value) {
                if (!value) {
                    return null;
                }
                return (0, _shared_normalisation__WEBPACK_IMPORTED_MODULE_0__.getNormalisedString)(value);
            }
            /***/ 
        }),
        /***/ "./packages/loot-core/src/platform/server/sqlite/unicodeLike.ts": 
        /*!**********************************************************************!*\
          !*** ./packages/loot-core/src/platform/server/sqlite/unicodeLike.ts ***!
          \**********************************************************************/
        /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony export */ __webpack_require__.d(__webpack_exports__, {
                /* harmony export */ unicodeLike: () => ( /* binding */unicodeLike)
                /* harmony export */ 
            });
            /* harmony import */ var lru_cache__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lru-cache */ "./node_modules/lru-cache/index.js");
            /* harmony import */ var lru_cache__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/ __webpack_require__.n(lru_cache__WEBPACK_IMPORTED_MODULE_0__);
            // @ts-strict-ignore
            const likePatternCache = new (lru_cache__WEBPACK_IMPORTED_MODULE_0___default())({
                max: 500
            });
            function unicodeLike(pattern, value) {
                if (!pattern) {
                    return 0;
                }
                if (!value) {
                    value = '';
                }
                let cachedRegExp = likePatternCache.get(pattern);
                if (!cachedRegExp) {
                    // we don't escape ? and % because we don't know
                    // whether they originate from the user input or from our query compiler.
                    // Maybe improve the query compiler to correctly process these characters?
                    const processedPattern = pattern.replace(/[.*+^${}()|[\]\\]/g, '\\$&').replaceAll('?', '.').replaceAll('%', '.*');
                    cachedRegExp = new RegExp(processedPattern, 'i');
                    likePatternCache.set(pattern, cachedRegExp);
                }
                return cachedRegExp.test(value) ? 1 : 0;
            }
            /***/ 
        }),
        /***/ "./packages/loot-core/src/server/accounts/export-to-csv.ts": 
        /*!*****************************************************************!*\
          !*** ./packages/loot-core/src/server/accounts/export-to-csv.ts ***!
          \*****************************************************************/
        /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony export */ __webpack_require__.d(__webpack_exports__, {
                /* harmony export */ exportQueryToCSV: () => ( /* binding */exportQueryToCSV),
                /* harmony export */ exportToCSV: () => ( /* binding */exportToCSV)
                /* harmony export */ 
            });
            /* harmony import */ var csv_stringify_lib_sync__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! csv-stringify/lib/sync */ "./node_modules/csv-stringify/lib/sync.js");
            /* harmony import */ var csv_stringify_lib_sync__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/ __webpack_require__.n(csv_stringify_lib_sync__WEBPACK_IMPORTED_MODULE_0__);
            /* harmony import */ var _shared_util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../shared/util */ "./packages/loot-core/src/shared/util.ts");
            /* harmony import */ var _aql__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../aql */ "./packages/loot-core/src/server/aql/index.ts");
            // @ts-strict-ignore
            async function exportToCSV(transactions, accounts, categoryGroups, payees) {
                const accountNamesById = accounts.reduce((reduced, { id, name }) => {
                    reduced[id] = name;
                    return reduced;
                }, {});
                const categoryNamesById = categoryGroups.reduce((reduced, { name, categories: subCategories }) => {
                    subCategories.forEach((subCategory) => reduced[subCategory.id] = `${name}: ${subCategory.name}`);
                    return reduced;
                }, {});
                const payeeNamesById = payees.reduce((reduced, { id, name }) => {
                    reduced[id] = name;
                    return reduced;
                }, {});
                const transactionsForExport = transactions.map(({ account, date, payee, notes, category, amount, cleared, reconciled }) => ({
                    Account: accountNamesById[account],
                    Date: date,
                    Payee: payeeNamesById[payee],
                    Notes: notes,
                    Category: categoryNamesById[category],
                    Amount: amount == null ? 0 : (0, _shared_util__WEBPACK_IMPORTED_MODULE_1__.integerToAmount)(amount),
                    Cleared: cleared,
                    Reconciled: reconciled
                }));
                return csv_stringify_lib_sync__WEBPACK_IMPORTED_MODULE_0___default()(transactionsForExport, {
                    header: true
                });
            }
            async function exportQueryToCSV(query) {
                const { data: transactions } = await (0, _aql__WEBPACK_IMPORTED_MODULE_2__.runQuery)(query.select([
                    {
                        Id: 'id'
                    },
                    {
                        Account: 'account.name'
                    },
                    {
                        Date: 'date'
                    },
                    {
                        Payee: 'payee.name'
                    },
                    {
                        ParentId: 'parent_id'
                    },
                    {
                        IsParent: 'is_parent'
                    },
                    {
                        IsChild: 'is_child'
                    },
                    {
                        SortOrder: 'sort_order'
                    },
                    {
                        Notes: 'notes'
                    },
                    {
                        Category: 'category.name'
                    },
                    {
                        Amount: 'amount'
                    },
                    {
                        Cleared: 'cleared'
                    },
                    {
                        Reconciled: 'reconciled'
                    }
                ]).options({
                    splits: 'all'
                }));
                // initialize a map to allow splits to have correct number of split from
                const parentsChildCount = new Map();
                const childSplitOrder = new Map();
                // find children, their order, and total # siblings
                for (const trans of transactions) {
                    if (trans.IsChild) {
                        let childNumber = parentsChildCount.get(trans.ParentId) || 0;
                        childNumber++;
                        childSplitOrder.set(trans.Id, childNumber);
                        parentsChildCount.set(trans.ParentId, childNumber);
                    }
                }
                // map final properties for export and grab the child count for splits from their parent transaction
                const transactionsForExport = transactions.map((trans) => {
                    return {
                        Account: trans.Account,
                        Date: trans.Date,
                        Payee: trans.Payee,
                        Notes: trans.IsParent ? '(SPLIT INTO ' + parentsChildCount.get(trans.Id) + ') ' + (trans.Notes || '') : trans.IsChild ? '(SPLIT ' + childSplitOrder.get(trans.Id) + ' OF ' + parentsChildCount.get(trans.ParentId) + ') ' + (trans.Notes || '') : trans.Notes,
                        Category: trans.Category,
                        Amount: trans.IsParent ? 0 : trans.Amount == null ? 0 : (0, _shared_util__WEBPACK_IMPORTED_MODULE_1__.integerToAmount)(trans.Amount),
                        Split_Amount: trans.IsParent ? (0, _shared_util__WEBPACK_IMPORTED_MODULE_1__.integerToAmount)(trans.Amount) : 0,
                        Cleared: trans.Reconciled === true ? 'Reconciled' : trans.Cleared === true ? 'Cleared' : 'Not cleared'
                    };
                });
                return csv_stringify_lib_sync__WEBPACK_IMPORTED_MODULE_0___default()(transactionsForExport, {
                    header: true
                });
            }
            /***/ 
        }),
        /***/ "./packages/loot-core/src/server/accounts/link.ts": 
        /*!********************************************************!*\
          !*** ./packages/loot-core/src/server/accounts/link.ts ***!
          \********************************************************/
        /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony export */ __webpack_require__.d(__webpack_exports__, {
                /* harmony export */ findOrCreateBank: () => ( /* binding */findOrCreateBank)
                /* harmony export */ 
            });
            /* harmony import */ var uuid__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! uuid */ "./node_modules/uuid/dist/esm-node/v4.js");
            /* harmony import */ var _db__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../db */ "./packages/loot-core/src/server/db/index.ts");
            // @ts-strict-ignore
            async function findOrCreateBank(institution, requisitionId) {
                const bank = await _db__WEBPACK_IMPORTED_MODULE_0__.first('SELECT id, bank_id, name FROM banks WHERE bank_id = ?', [
                    requisitionId
                ]);
                if (bank) {
                    return bank;
                }
                const bankData = {
                    id: (0, uuid__WEBPACK_IMPORTED_MODULE_1__["default"])(),
                    bank_id: requisitionId,
                    name: institution.name
                };
                await _db__WEBPACK_IMPORTED_MODULE_0__.insertWithUUID('banks', bankData);
                return bankData;
            }
            /***/ 
        }),
        /***/ "./packages/loot-core/src/server/accounts/ofx2json.ts": 
        /*!************************************************************!*\
          !*** ./packages/loot-core/src/server/accounts/ofx2json.ts ***!
          \************************************************************/
        /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony export */ __webpack_require__.d(__webpack_exports__, {
                /* harmony export */ ofx2json: () => ( /* binding */ofx2json)
                /* harmony export */ 
            });
            /* harmony import */ var xml2js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! xml2js */ "./node_modules/xml2js/lib/xml2js.js");
            /* harmony import */ var xml2js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/ __webpack_require__.n(xml2js__WEBPACK_IMPORTED_MODULE_0__);
            /* harmony import */ var _shared_months__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../shared/months */ "./packages/loot-core/src/shared/months.ts");
            // @ts-strict-ignore
            function sgml2Xml(sgml) {
                return sgml.replace(/&/g, '&#038;') // Replace ampersands
                    .replace(/&amp;/g, '&#038;').replace(/>\s+</g, '><') // remove whitespace inbetween tag close/open
                    .replace(/\s+</g, '<') // remove whitespace before a close tag
                    .replace(/>\s+/g, '>') // remove whitespace after a close tag
                    .replace(/\.(?=[^<>]*>)/g, '') // Remove dots in tag names
                    .replace(/<(\w+?)>([^<]+)/g, '<$1>$2</<added>$1>') // Add a new end-tags for the ofx elements
                    .replace(/<\/<added>(\w+?)>(<\/\1>)?/g, '</$1>'); // Remove duplicate end-tags
            }
            function html2Plain(value) {
                return value?.replace(/&amp;/g, '&') // ampersands
                    .replace(/&#038;/g, '&') // other ampersands
                    .replace(/&lt;/g, '<') // lessthan
                    .replace(/&gt;/g, '>') // greaterthan
                    .replace(/&#39;/g, "'") // eslint-disable-line rulesdir/typography
                    .replace(/&quot;/g, '"'); // eslint-disable-line rulesdir/typography
            }
            async function parseXml(content) {
                return await (0, xml2js__WEBPACK_IMPORTED_MODULE_0__.parseStringPromise)(content, {
                    explicitArray: false
                });
            }
            function getStmtTrn(data) {
                const ofx = data?.['OFX'];
                if (ofx?.['CREDITCARDMSGSRSV1'] != null) {
                    return getCcStmtTrn(ofx);
                }
                else if (ofx?.['INVSTMTMSGSRSV1'] != null) {
                    return getInvStmtTrn(ofx);
                }
                else {
                    return getBankStmtTrn(ofx);
                }
            }
            function getBankStmtTrn(ofx) {
                // Somes values could be an array or a single object.
                // xml2js serializes single item to an object and multiple to an array.
                const msg = ofx?.['BANKMSGSRSV1'];
                const stmtTrnRs = getAsArray(msg?.['STMTTRNRS']);
                const result = stmtTrnRs.flatMap((s) => {
                    const stmtRs = s?.['STMTRS'];
                    const tranList = stmtRs?.['BANKTRANLIST'];
                    const stmtTrn = tranList?.['STMTTRN'];
                    return getAsArray(stmtTrn);
                });
                return result;
            }
            function getCcStmtTrn(ofx) {
                // Some values could be an array or a single object.
                // xml2js serializes single item to an object and multiple to an array.
                const msg = ofx?.['CREDITCARDMSGSRSV1'];
                const stmtTrnRs = getAsArray(msg?.['CCSTMTTRNRS']);
                const result = stmtTrnRs.flatMap((s) => {
                    const stmtRs = s?.['CCSTMTRS'];
                    const tranList = stmtRs?.['BANKTRANLIST'];
                    const stmtTrn = tranList?.['STMTTRN'];
                    return getAsArray(stmtTrn);
                });
                return result;
            }
            function getInvStmtTrn(ofx) {
                // Somes values could be an array or a single object.
                // xml2js serializes single item to an object and multiple to an array.
                const msg = ofx?.['INVSTMTMSGSRSV1'];
                const stmtTrnRs = getAsArray(msg?.['INVSTMTTRNRS']);
                const result = stmtTrnRs.flatMap((s) => {
                    const stmtRs = s?.['INVSTMTRS'];
                    const tranList = stmtRs?.['INVTRANLIST'];
                    const stmtTrn = tranList?.['INVBANKTRAN']?.flatMap((t) => t?.['STMTTRN']);
                    return getAsArray(stmtTrn);
                });
                return result;
            }
            function getAsArray(value) {
                return Array.isArray(value) ? value : value === undefined ? [] : [
                    value
                ];
            }
            function mapOfxTransaction(stmtTrn) {
                // YYYYMMDDHHMMSS format. We just need the date.
                const dtPosted = stmtTrn['DTPOSTED'];
                const transactionDate = dtPosted ? new Date(Number(dtPosted.substring(0, 4)), Number(dtPosted.substring(4, 6)) - 1, Number(dtPosted.substring(6, 8))) : null;
                return {
                    amount: stmtTrn['TRNAMT'],
                    type: stmtTrn['TRNTYPE'],
                    fitId: stmtTrn['FITID'],
                    date: (0, _shared_months__WEBPACK_IMPORTED_MODULE_1__.dayFromDate)(transactionDate),
                    name: html2Plain(stmtTrn['NAME']),
                    memo: html2Plain(stmtTrn['MEMO'])
                };
            }
            async function ofx2json(ofx) {
                // firstly, split into the header attributes and the footer sgml
                const contents = ofx.split('<OFX>', 2);
                // firstly, parse the headers
                const headerString = contents[0].split(/\r?\n/);
                const headers = {};
                headerString.forEach((attrs) => {
                    if (attrs) {
                        const headAttr = attrs.split(/:/, 2);
                        headers[headAttr[0]] = headAttr[1];
                    }
                });
                // make the SGML and the XML
                const content = `<OFX>${contents[1]}`;
                // Parse the XML/SGML portion of the file into an object
                // Try as XML first, and if that fails do the SGML->XML mangling
                let dataParsed = null;
                try {
                    dataParsed = await parseXml(content);
                }
                catch (e) {
                    const sanitized = sgml2Xml(content);
                    dataParsed = await parseXml(sanitized);
                }
                return {
                    headers,
                    transactions: getStmtTrn(dataParsed).map(mapOfxTransaction)
                };
            }
            /***/ 
        }),
        /***/ "./packages/loot-core/src/server/accounts/parse-file.ts": 
        /*!**************************************************************!*\
          !*** ./packages/loot-core/src/server/accounts/parse-file.ts ***!
          \**************************************************************/
        /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony export */ __webpack_require__.d(__webpack_exports__, {
                /* harmony export */ parseFile: () => ( /* binding */parseFile)
                /* harmony export */ 
            });
            /* harmony import */ var csv_parse_lib_sync__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! csv-parse/lib/sync */ "./node_modules/csv-parse/lib/sync.js");
            /* harmony import */ var csv_parse_lib_sync__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/ __webpack_require__.n(csv_parse_lib_sync__WEBPACK_IMPORTED_MODULE_0__);
            /* harmony import */ var _platform_server_fs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../platform/server/fs */ "./packages/loot-core/src/platform/server/fs/index.electron.ts");
            /* harmony import */ var _shared_util__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../shared/util */ "./packages/loot-core/src/shared/util.ts");
            /* harmony import */ var _ofx2json__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./ofx2json */ "./packages/loot-core/src/server/accounts/ofx2json.ts");
            /* harmony import */ var _qif2json__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./qif2json */ "./packages/loot-core/src/server/accounts/qif2json.ts");
            /* harmony import */ var _xmlcamt2json__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./xmlcamt2json */ "./packages/loot-core/src/server/accounts/xmlcamt2json.ts");
            // @ts-strict-ignore
            async function parseFile(filepath, options = {}) {
                const errors = Array();
                const m = filepath.match(/\.[^.]*$/);
                if (m) {
                    const ext = m[0];
                    switch (ext.toLowerCase()) {
                        case '.qif':
                            return parseQIF(filepath);
                        case '.csv':
                        case '.tsv':
                            return parseCSV(filepath, options);
                        case '.ofx':
                        case '.qfx':
                            return parseOFX(filepath, options);
                        case '.xml':
                            return parseCAMT(filepath);
                        default:
                    }
                }
                errors.push({
                    message: 'Invalid file type',
                    internal: ''
                });
                return {
                    errors,
                    transactions: []
                };
            }
            async function parseCSV(filepath, options) {
                const errors = Array();
                const contents = await _platform_server_fs__WEBPACK_IMPORTED_MODULE_1__.readFile(filepath);
                let data;
                try {
                    data = csv_parse_lib_sync__WEBPACK_IMPORTED_MODULE_0___default()(contents, {
                        columns: options?.hasHeaderRow,
                        bom: true,
                        delimiter: options?.delimiter || ',',
                        // eslint-disable-next-line rulesdir/typography
                        quote: '"',
                        trim: true,
                        relax_column_count: true,
                        skip_empty_lines: true
                    });
                }
                catch (err) {
                    errors.push({
                        message: 'Failed parsing: ' + err.message,
                        internal: err.message
                    });
                    return {
                        errors,
                        transactions: []
                    };
                }
                return {
                    errors,
                    transactions: data
                };
            }
            async function parseQIF(filepath) {
                const errors = Array();
                const contents = await _platform_server_fs__WEBPACK_IMPORTED_MODULE_1__.readFile(filepath);
                let data;
                try {
                    data = (0, _qif2json__WEBPACK_IMPORTED_MODULE_4__.qif2json)(contents);
                }
                catch (err) {
                    errors.push({
                        message: 'Failed parsing: doesnt look like a valid QIF file.',
                        internal: err.stack
                    });
                    return {
                        errors,
                        transactions: []
                    };
                }
                return {
                    errors: [],
                    transactions: data.transactions.map((trans) => ({
                        amount: trans.amount != null ? (0, _shared_util__WEBPACK_IMPORTED_MODULE_2__.looselyParseAmount)(trans.amount) : null,
                        date: trans.date,
                        payee_name: trans.payee,
                        imported_payee: trans.payee,
                        notes: trans.memo || null
                    })).filter((trans) => trans.date != null && trans.amount != null)
                };
            }
            async function parseOFX(filepath, options) {
                const errors = Array();
                const contents = await _platform_server_fs__WEBPACK_IMPORTED_MODULE_1__.readFile(filepath);
                let data;
                try {
                    data = await (0, _ofx2json__WEBPACK_IMPORTED_MODULE_3__.ofx2json)(contents);
                }
                catch (err) {
                    errors.push({
                        message: 'Failed importing file',
                        internal: err.stack
                    });
                    return {
                        errors
                    };
                }
                // Banks don't always implement the OFX standard properly
                // If no payee is available try and fallback to memo
                const useMemoFallback = options.fallbackMissingPayeeToMemo;
                return {
                    errors,
                    transactions: data.transactions.map((trans) => {
                        return {
                            amount: Number(trans.amount),
                            imported_id: trans.fitId,
                            date: trans.date,
                            payee_name: trans.name || (useMemoFallback ? trans.memo : null),
                            imported_payee: trans.name || (useMemoFallback ? trans.memo : null),
                            notes: !!trans.name || !useMemoFallback ? trans.memo || null : null
                        };
                    })
                };
            }
            async function parseCAMT(filepath) {
                const errors = Array();
                const contents = await _platform_server_fs__WEBPACK_IMPORTED_MODULE_1__.readFile(filepath);
                let data;
                try {
                    data = await (0, _xmlcamt2json__WEBPACK_IMPORTED_MODULE_5__.xmlCAMT2json)(contents);
                }
                catch (err) {
                    console.error(err);
                    errors.push({
                        message: 'Failed importing file',
                        internal: err.stack
                    });
                    return {
                        errors
                    };
                }
                return {
                    errors,
                    transactions: data
                };
            }
            /***/ 
        }),
        /***/ "./packages/loot-core/src/server/accounts/payees.ts": 
        /*!**********************************************************!*\
          !*** ./packages/loot-core/src/server/accounts/payees.ts ***!
          \**********************************************************/
        /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony export */ __webpack_require__.d(__webpack_exports__, {
                /* harmony export */ createPayee: () => ( /* binding */createPayee),
                /* harmony export */ getStartingBalancePayee: () => ( /* binding */getStartingBalancePayee)
                /* harmony export */ 
            });
            /* harmony import */ var _db__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../db */ "./packages/loot-core/src/server/db/index.ts");
            // @ts-strict-ignore
            /* eslint-disable import/no-unused-modules */ async function createPayee(description) {
                // Check to make sure no payee already exists with exactly the same
                // name
                const row = await _db__WEBPACK_IMPORTED_MODULE_0__.first(`SELECT id FROM payees WHERE UNICODE_LOWER(name) = ? AND tombstone = 0`, [
                    description.toLowerCase()
                ]);
                if (row) {
                    return row.id;
                }
                else {
                    return _db__WEBPACK_IMPORTED_MODULE_0__.insertPayee({
                        name: description
                    });
                }
            }
            async function getStartingBalancePayee() {
                let category = await _db__WEBPACK_IMPORTED_MODULE_0__.first(`
    SELECT * FROM categories
      WHERE is_income = 1 AND
      LOWER(name) = 'starting balances' AND
      tombstone = 0
  `);
                if (category === null) {
                    category = await _db__WEBPACK_IMPORTED_MODULE_0__.first('SELECT * FROM categories WHERE is_income = 1 AND tombstone = 0');
                }
                const id = await createPayee('Starting Balance');
                return {
                    id,
                    category: category ? category.id : null
                };
            }
            /***/ 
        }),
        /***/ "./packages/loot-core/src/server/accounts/qif2json.ts": 
        /*!************************************************************!*\
          !*** ./packages/loot-core/src/server/accounts/qif2json.ts ***!
          \************************************************************/
        /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony export */ __webpack_require__.d(__webpack_exports__, {
                /* harmony export */ qif2json: () => ( /* binding */qif2json)
                /* harmony export */ 
            });
            // @ts-strict-ignore
            function qif2json(qif, options = {}) {
                const lines = qif.split('\n');
                let line = lines.shift();
                const type = /!Type:([^$]*)$/.exec(line.trim());
                const data = {
                    dateFormat: options.dateFormat,
                    transactions: []
                };
                const transactions = data.transactions;
                let transaction = {};
                if (!type || !type.length) {
                    throw new Error('File does not appear to be a valid qif file: ' + line);
                }
                data.type = type[1];
                let division = {};
                while (line = lines.shift()) {
                    line = line.trim();
                    if (line === '^') {
                        transactions.push(transaction);
                        transaction = {};
                        continue;
                    }
                    switch (line[0]) {
                        case 'D':
                            transaction.date = line.substring(1);
                            break;
                        case 'T':
                            transaction.amount = line.substring(1);
                            break;
                        case 'N':
                            transaction.number = line.substring(1);
                            break;
                        case 'M':
                            transaction.memo = line.substring(1);
                            break;
                        case 'A':
                            transaction.address = (transaction.address || []).concat(line.substring(1));
                            break;
                        case 'P':
                            transaction.payee = line.substring(1).replace(/&amp;/g, '&');
                            break;
                        case 'L':
                            const lArray = line.substring(1).split(':');
                            transaction.category = lArray[0];
                            if (lArray[1] !== undefined) {
                                transaction.subcategory = lArray[1];
                            }
                            break;
                        case 'C':
                            transaction.clearedStatus = line.substring(1);
                            break;
                        case 'S':
                            const sArray = line.substring(1).split(':');
                            division.category = sArray[0];
                            if (sArray[1] !== undefined) {
                                division.subcategory = sArray[1];
                            }
                            break;
                        case 'E':
                            division.description = line.substring(1);
                            break;
                        case '$':
                            division.amount = parseFloat(line.substring(1));
                            if (!(transaction.division instanceof Array)) {
                                transaction.division = [];
                            }
                            transaction.division.push(division);
                            division = {};
                            break;
                        default:
                            throw new Error('Unknown Detail Code: ' + line[0]);
                    }
                }
                if (Object.keys(transaction).length) {
                    transactions.push(transaction);
                }
                return data;
            }
            /***/ 
        }),
        /***/ "./packages/loot-core/src/server/accounts/rules.ts": 
        /*!*********************************************************!*\
          !*** ./packages/loot-core/src/server/accounts/rules.ts ***!
          \*********************************************************/
        /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony export */ __webpack_require__.d(__webpack_exports__, {
                /* harmony export */ Action: () => ( /* binding */Action),
                /* harmony export */ Condition: () => ( /* binding */Condition),
                /* harmony export */ Rule: () => ( /* binding */Rule),
                /* harmony export */ RuleIndexer: () => ( /* binding */RuleIndexer),
                /* harmony export */ execActions: () => ( /* binding */execActions),
                /* harmony export */ iterateIds: () => ( /* binding */iterateIds),
                /* harmony export */ migrateIds: () => ( /* binding */migrateIds),
                /* harmony export */ parseDateString: () => ( /* binding */parseDateString),
                /* harmony export */ rankRules: () => ( /* binding */rankRules)
                /* harmony export */ 
            });
            /* harmony import */ var date_fns__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! date-fns */ "./node_modules/date-fns/esm/isValid/index.js");
            /* harmony import */ var date_fns__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! date-fns */ "./node_modules/date-fns/esm/parseISO/index.js");
            /* harmony import */ var date_fns__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! date-fns */ "./node_modules/date-fns/esm/subDays/index.js");
            /* harmony import */ var date_fns__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! date-fns */ "./node_modules/date-fns/esm/addDays/index.js");
            /* harmony import */ var _shared_months__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../shared/months */ "./packages/loot-core/src/shared/months.ts");
            /* harmony import */ var _shared_rules__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../shared/rules */ "./packages/loot-core/src/shared/rules.ts");
            /* harmony import */ var _shared_schedules__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../shared/schedules */ "./packages/loot-core/src/shared/schedules.ts");
            /* harmony import */ var _shared_transactions__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../shared/transactions */ "./packages/loot-core/src/shared/transactions.ts");
            /* harmony import */ var _shared_util__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../shared/util */ "./packages/loot-core/src/shared/util.ts");
            /* harmony import */ var _errors__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../errors */ "./packages/loot-core/src/server/errors.ts");
            /* harmony import */ var _util_rschedule__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../util/rschedule */ "./packages/loot-core/src/server/util/rschedule.ts");
            // @ts-strict-ignore
            function assert(test, type, msg) {
                if (!test) {
                    throw new _errors__WEBPACK_IMPORTED_MODULE_5__.RuleError(type, msg);
                }
            }
            function parseRecurDate(desc) {
                try {
                    const rules = (0, _shared_schedules__WEBPACK_IMPORTED_MODULE_2__.recurConfigToRSchedule)(desc);
                    return {
                        type: 'recur',
                        schedule: new _util_rschedule__WEBPACK_IMPORTED_MODULE_6__.Schedule({
                            rrules: rules,
                            data: {
                                skipWeekend: desc.skipWeekend,
                                weekendSolve: desc.weekendSolveMode
                            }
                        })
                    };
                }
                catch (e) {
                    throw new _errors__WEBPACK_IMPORTED_MODULE_5__.RuleError('parse-recur-date', e.message);
                }
            }
            function parseDateString(str) {
                if (typeof str !== 'string') {
                    return null;
                }
                else if (str.length === 10) {
                    // YYYY-MM-DD
                    if (!date_fns__WEBPACK_IMPORTED_MODULE_7__["default"](date_fns__WEBPACK_IMPORTED_MODULE_8__["default"](str))) {
                        return null;
                    }
                    return {
                        type: 'date',
                        date: str
                    };
                }
                else if (str.length === 7) {
                    // YYYY-MM
                    if (!date_fns__WEBPACK_IMPORTED_MODULE_7__["default"](date_fns__WEBPACK_IMPORTED_MODULE_8__["default"](str + '-01'))) {
                        return null;
                    }
                    return {
                        type: 'month',
                        date: str
                    };
                }
                else if (str.length === 4) {
                    // YYYY
                    if (!date_fns__WEBPACK_IMPORTED_MODULE_7__["default"](date_fns__WEBPACK_IMPORTED_MODULE_8__["default"](str + '-01-01'))) {
                        return null;
                    }
                    return {
                        type: 'year',
                        date: str
                    };
                }
                return null;
            }
            function parseBetweenAmount(between) {
                const { num1, num2 } = between;
                if (typeof num1 !== 'number' || typeof num2 !== 'number') {
                    return null;
                }
                return {
                    type: 'between',
                    num1,
                    num2
                };
            }
            const CONDITION_TYPES = {
                date: {
                    ops: [
                        'is',
                        'isapprox',
                        'gt',
                        'gte',
                        'lt',
                        'lte'
                    ],
                    nullable: false,
                    parse(op, value, fieldName) {
                        const parsed = typeof value === 'string' ? parseDateString(value) : value.frequency != null ? parseRecurDate(value) : null;
                        assert(parsed, 'date-format', `Invalid date format (field: ${fieldName})`);
                        // Approximate only works with exact & recurring dates
                        if (op === 'isapprox') {
                            assert(parsed.type === 'date' || parsed.type === 'recur', 'date-format', `Invalid date value for isapprox (field: ${fieldName})`);
                        }
                        else if (op === 'gt' || op === 'gte' || op === 'lt' || op === 'lte') {
                            assert(parsed.type === 'date', 'date-format', `Invalid date value for ${op} (field: ${fieldName})`);
                        }
                        return parsed;
                    }
                },
                id: {
                    ops: [
                        'is',
                        'contains',
                        'matches',
                        'oneOf',
                        'isNot',
                        'doesNotContain',
                        'notOneOf'
                    ],
                    nullable: true,
                    parse(op, value, fieldName) {
                        if (op === 'oneOf' || op === 'notOneOf') {
                            assert(Array.isArray(value), 'no-empty-array', `oneOf must have an array value (field: ${fieldName})`);
                            return value;
                        }
                        return value;
                    }
                },
                string: {
                    ops: [
                        'is',
                        'contains',
                        'matches',
                        'oneOf',
                        'isNot',
                        'doesNotContain',
                        'notOneOf'
                    ],
                    nullable: true,
                    parse(op, value, fieldName) {
                        if (op === 'oneOf' || op === 'notOneOf') {
                            assert(Array.isArray(value), 'no-empty-array', `oneOf must have an array value (field: ${fieldName}): ${JSON.stringify(value)}`);
                            return value.filter(Boolean).map((val) => val.toLowerCase());
                        }
                        if (op === 'contains' || op === 'matches' || op === 'doesNotContain') {
                            assert(typeof value === 'string' && value.length > 0, 'no-empty-string', `contains must have non-empty string (field: ${fieldName})`);
                        }
                        return value.toLowerCase();
                    }
                },
                number: {
                    ops: [
                        'is',
                        'isapprox',
                        'isbetween',
                        'gt',
                        'gte',
                        'lt',
                        'lte'
                    ],
                    nullable: false,
                    parse(op, value, fieldName) {
                        const parsed = typeof value === 'number' ? {
                            type: 'literal',
                            value
                        } : parseBetweenAmount(value);
                        assert(parsed != null, 'not-number', `Value must be a number or between amount: ${JSON.stringify(value)} (field: ${fieldName})`);
                        if (op === 'isbetween') {
                            assert(parsed.type === 'between', 'number-format', `Invalid between value for ${op} (field: ${fieldName})`);
                        }
                        else {
                            assert(parsed.type === 'literal', 'number-format', `Invalid number value for ${op} (field: ${fieldName})`);
                        }
                        return parsed;
                    }
                },
                boolean: {
                    ops: [
                        'is'
                    ],
                    nullable: false,
                    parse(op, value, fieldName) {
                        assert(typeof value === 'boolean', 'not-boolean', `Value must be a boolean: ${value} (field: ${fieldName})`);
                        return value;
                    }
                }
            };
            class Condition {
                constructor(op, field, value, options, fieldTypes) {
                    const typeName = fieldTypes.get(field);
                    assert(typeName, 'internal', 'Invalid condition field: ' + field);
                    const type = CONDITION_TYPES[typeName];
                    // It's important to validate rules because a faulty rule might mess
                    // up the user's transaction (and be very confusing)
                    assert(type, 'internal', `Invalid condition type: ${typeName} (field: ${field})`);
                    assert(type.ops.includes(op), 'internal', `Invalid condition operator: ${op} (type: ${typeName}, field: ${field})`);
                    if (type.nullable !== true) {
                        assert(value != null, 'no-null', `Field cannot be empty: ${field}`);
                    }
                    // For strings, an empty string is equal to null
                    if (typeName === 'string' && type.nullable !== true) {
                        assert(value !== '', 'no-null', `Field cannot be empty: ${field}`);
                    }
                    this.rawValue = value;
                    this.unparsedValue = value;
                    this.op = op;
                    this.field = field;
                    this.value = type.parse ? type.parse(op, value, field) : value;
                    this.options = options;
                    this.type = typeName;
                }
                eval(object) {
                    let fieldValue = object[this.field];
                    if (fieldValue === undefined) {
                        return false;
                    }
                    if (typeof fieldValue === 'string') {
                        fieldValue = fieldValue.toLowerCase();
                    }
                    const type = this.type;
                    if (type === 'number' && this.options) {
                        if (this.options.outflow) {
                            if (fieldValue > 0) {
                                return false;
                            }
                            fieldValue = -fieldValue;
                        }
                        else if (this.options.inflow) {
                            if (fieldValue < 0) {
                                return false;
                            }
                        }
                    }
                    const extractValue = (v) => type === 'number' ? v.value : v;
                    switch (this.op) {
                        case 'isapprox':
                        case 'is':
                            if (type === 'date') {
                                if (fieldValue == null) {
                                    return false;
                                }
                                if (this.value.type === 'recur') {
                                    const { schedule } = this.value;
                                    if (this.op === 'isapprox') {
                                        const fieldDate = (0, _shared_months__WEBPACK_IMPORTED_MODULE_0__.parseDate)(fieldValue);
                                        return schedule.occursBetween(date_fns__WEBPACK_IMPORTED_MODULE_9__["default"](fieldDate, 2), date_fns__WEBPACK_IMPORTED_MODULE_10__["default"](fieldDate, 2));
                                    }
                                    else {
                                        return schedule.occursOn({
                                            date: (0, _shared_months__WEBPACK_IMPORTED_MODULE_0__.parseDate)(fieldValue)
                                        });
                                    }
                                }
                                else {
                                    const { date } = this.value;
                                    if (this.op === 'isapprox') {
                                        const fullDate = (0, _shared_months__WEBPACK_IMPORTED_MODULE_0__.parseDate)(date);
                                        const high = (0, _shared_months__WEBPACK_IMPORTED_MODULE_0__.addDays)(fullDate, 2);
                                        const low = (0, _shared_months__WEBPACK_IMPORTED_MODULE_0__.subDays)(fullDate, 2);
                                        return fieldValue >= low && fieldValue <= high;
                                    }
                                    else {
                                        switch (this.value.type) {
                                            case 'date':
                                                return fieldValue === date;
                                            case 'month':
                                                return (0, _shared_months__WEBPACK_IMPORTED_MODULE_0__.monthFromDate)(fieldValue) === date;
                                            case 'year':
                                                return (0, _shared_months__WEBPACK_IMPORTED_MODULE_0__.yearFromDate)(fieldValue) === date;
                                            default:
                                        }
                                    }
                                }
                            }
                            else if (type === 'number') {
                                const number = this.value.value;
                                if (this.op === 'isapprox') {
                                    const threshold = (0, _shared_rules__WEBPACK_IMPORTED_MODULE_1__.getApproxNumberThreshold)(number);
                                    return fieldValue >= number - threshold && fieldValue <= number + threshold;
                                }
                                return fieldValue === number;
                            }
                            return fieldValue === this.value;
                        case 'isNot':
                            return fieldValue !== this.value;
                        case 'isbetween':
                            {
                                // The parsing logic already checks that the value is of the
                                // right type (only numbers with high and low)
                                const [low, high] = (0, _shared_rules__WEBPACK_IMPORTED_MODULE_1__.sortNumbers)(this.value.num1, this.value.num2);
                                return fieldValue >= low && fieldValue <= high;
                            }
                        case 'contains':
                            if (fieldValue === null) {
                                return false;
                            }
                            return fieldValue.indexOf(this.value) !== -1;
                        case 'doesNotContain':
                            if (fieldValue === null) {
                                return false;
                            }
                            return fieldValue.indexOf(this.value) === -1;
                        case 'oneOf':
                            if (fieldValue === null) {
                                return false;
                            }
                            return this.value.indexOf(fieldValue) !== -1;
                        case 'notOneOf':
                            if (fieldValue === null) {
                                return false;
                            }
                            return this.value.indexOf(fieldValue) === -1;
                        case 'gt':
                            if (fieldValue === null) {
                                return false;
                            }
                            else if (type === 'date') {
                                return (0, _shared_months__WEBPACK_IMPORTED_MODULE_0__.isAfter)(fieldValue, this.value.date);
                            }
                            return fieldValue > extractValue(this.value);
                        case 'gte':
                            if (fieldValue === null) {
                                return false;
                            }
                            else if (type === 'date') {
                                return fieldValue === this.value.date || (0, _shared_months__WEBPACK_IMPORTED_MODULE_0__.isAfter)(fieldValue, this.value.date);
                            }
                            return fieldValue >= extractValue(this.value);
                        case 'lt':
                            if (fieldValue === null) {
                                return false;
                            }
                            else if (type === 'date') {
                                return (0, _shared_months__WEBPACK_IMPORTED_MODULE_0__.isBefore)(fieldValue, this.value.date);
                            }
                            return fieldValue < extractValue(this.value);
                        case 'lte':
                            if (fieldValue === null) {
                                return false;
                            }
                            else if (type === 'date') {
                                return fieldValue === this.value.date || (0, _shared_months__WEBPACK_IMPORTED_MODULE_0__.isBefore)(fieldValue, this.value.date);
                            }
                            return fieldValue <= extractValue(this.value);
                        default:
                    }
                    return false;
                }
                getValue() {
                    return this.value;
                }
                serialize() {
                    return {
                        op: this.op,
                        field: this.field,
                        value: this.unparsedValue,
                        type: this.type,
                        ...this.options ? {
                            options: this.options
                        } : null
                    };
                }
            }
            const ACTION_OPS = [
                'set',
                'set-split-amount',
                'link-schedule'
            ];
            class Action {
                constructor(op, field, value, options, fieldTypes) {
                    assert(ACTION_OPS.includes(op), 'internal', `Invalid action operation: ${op}`);
                    if (op === 'set') {
                        const typeName = fieldTypes.get(field);
                        assert(typeName, 'internal', `Invalid field for action: ${field}`);
                        this.field = field;
                        this.type = typeName;
                    }
                    else if (op === 'set-split-amount') {
                        this.field = null;
                        this.type = 'number';
                    }
                    else if (op === 'link-schedule') {
                        this.field = null;
                        this.type = 'id';
                    }
                    if (field === 'account') {
                        assert(value, 'no-null', `Field cannot be empty: ${field}`);
                    }
                    this.op = op;
                    this.rawValue = value;
                    this.value = value;
                    this.options = options;
                }
                exec(object) {
                    switch (this.op) {
                        case 'set':
                            object[this.field] = this.value;
                            break;
                        case 'set-split-amount':
                            switch (this.options.method) {
                                case 'fixed-amount':
                                    object.amount = this.value;
                                    break;
                                default:
                            }
                            break;
                        case 'link-schedule':
                            object.schedule = this.value;
                            break;
                        default:
                    }
                }
                serialize() {
                    return {
                        op: this.op,
                        field: this.field,
                        value: this.value,
                        type: this.type,
                        ...this.options ? {
                            options: this.options
                        } : null
                    };
                }
            }
            function execNonSplitActions(actions, transaction) {
                const update = transaction;
                actions.forEach((action) => action.exec(update));
                return update;
            }
            function execActions(actions, transaction) {
                const parentActions = actions.filter((action) => !action.options?.splitIndex);
                const childActions = actions.filter((action) => action.options?.splitIndex);
                const totalSplitCount = actions.reduce((prev, cur) => Math.max(prev, cur.options?.splitIndex ?? 0), 0) + 1;
                let update = execNonSplitActions(parentActions, transaction);
                if (totalSplitCount === 1) {
                    // No splits, no need to do anything else.
                    return update;
                }
                if (update.is_child) {
                    // Rules with splits can't be applied to child transactions.
                    return update;
                }
                const splitAmountActions = childActions.filter((action) => action.op === 'set-split-amount');
                const fixedSplitAmountActions = splitAmountActions.filter((action) => action.options.method === 'fixed-amount');
                const fixedAmountsBySplit = {};
                fixedSplitAmountActions.forEach((action) => {
                    const splitIndex = action.options.splitIndex ?? 0;
                    fixedAmountsBySplit[splitIndex] = action.value;
                });
                const fixedAmountSplitCount = Object.keys(fixedAmountsBySplit).length;
                const totalFixedAmount = Object.values(fixedAmountsBySplit).reduce((prev, cur) => prev + cur, 0);
                if (fixedAmountSplitCount === totalSplitCount && totalFixedAmount !== (transaction.amount ?? totalFixedAmount)) {
                    // Not all value would be distributed to a split.
                    return transaction;
                }
                const { data, newTransaction } = (0, _shared_transactions__WEBPACK_IMPORTED_MODULE_3__.splitTransaction)((0, _shared_transactions__WEBPACK_IMPORTED_MODULE_3__.ungroupTransaction)(update), transaction.id);
                update = (0, _shared_transactions__WEBPACK_IMPORTED_MODULE_3__.recalculateSplit)(newTransaction);
                data[0] = update;
                let newTransactions = data;
                for (const action of childActions) {
                    const splitIndex = action.options?.splitIndex ?? 0;
                    if (splitIndex >= update.subtransactions.length) {
                        const { data, newTransaction } = (0, _shared_transactions__WEBPACK_IMPORTED_MODULE_3__.addSplitTransaction)(newTransactions, transaction.id);
                        update = (0, _shared_transactions__WEBPACK_IMPORTED_MODULE_3__.recalculateSplit)(newTransaction);
                        data[0] = update;
                        newTransactions = data;
                    }
                    action.exec(update.subtransactions[splitIndex]);
                }
                // Make sure every transaction has an amount.
                if (fixedAmountSplitCount !== totalSplitCount) {
                    // This is the amount that will be distributed to the splits that
                    // don't have a fixed amount. The last split will get the remainder.
                    // The amount will be zero if the parent transaction has no amount.
                    const amountToDistribute = (transaction.amount ?? totalFixedAmount) - totalFixedAmount;
                    let remainingAmount = amountToDistribute;
                    // First distribute the fixed percentages.
                    splitAmountActions.filter((action) => action.options.method === 'fixed-percent').forEach((action) => {
                        const splitIndex = action.options.splitIndex;
                        const percent = action.value / 100;
                        const amount = Math.round(amountToDistribute * percent);
                        update.subtransactions[splitIndex].amount = amount;
                        remainingAmount -= amount;
                    });
                    // Then distribute the remainder.
                    const remainderSplitAmountActions = splitAmountActions.filter((action) => action.options.method === 'remainder');
                    // Check if there is any value left to distribute after all fixed
                    // (percentage and amount) splits have been distributed.
                    if (remainingAmount !== 0) {
                        // If there are no remainder splits explicitly added by the user,
                        // distribute the remainder to a virtual split that will be
                        // adjusted for the remainder.
                        if (remainderSplitAmountActions.length === 0) {
                            const splitIndex = totalSplitCount;
                            const { newTransaction } = (0, _shared_transactions__WEBPACK_IMPORTED_MODULE_3__.addSplitTransaction)(newTransactions, transaction.id);
                            update = (0, _shared_transactions__WEBPACK_IMPORTED_MODULE_3__.recalculateSplit)(newTransaction);
                            update.subtransactions[splitIndex].amount = remainingAmount;
                        }
                        else {
                            const amountPerRemainderSplit = Math.round(remainingAmount / remainderSplitAmountActions.length);
                            let lastNonFixedIndex = -1;
                            remainderSplitAmountActions.forEach((action) => {
                                const splitIndex = action.options.splitIndex;
                                update.subtransactions[splitIndex].amount = amountPerRemainderSplit;
                                remainingAmount -= amountPerRemainderSplit;
                                lastNonFixedIndex = Math.max(lastNonFixedIndex, splitIndex);
                            });
                            // The last non-fixed split will be adjusted for the remainder.
                            update.subtransactions[lastNonFixedIndex].amount -= remainingAmount;
                        }
                        update = (0, _shared_transactions__WEBPACK_IMPORTED_MODULE_3__.recalculateSplit)(update);
                    }
                }
                // The split index 0 is reserved for "Apply to all" actions.
                // Remove that entry from the subtransactions.
                update.subtransactions = update.subtransactions.slice(1);
                return update;
            }
            class Rule {
                constructor({ id, stage, conditionsOp, conditions, actions, fieldTypes }) {
                    this.id = id;
                    this.stage = stage;
                    this.conditionsOp = conditionsOp;
                    this.conditions = conditions.map((c) => new Condition(c.op, c.field, c.value, c.options, fieldTypes));
                    this.actions = actions.map((a) => new Action(a.op, a.field, a.value, a.options, fieldTypes));
                }
                evalConditions(object) {
                    if (this.conditions.length === 0) {
                        return false;
                    }
                    const method = this.conditionsOp === 'or' ? 'some' : 'every';
                    return this.conditions[method]((condition) => {
                        return condition.eval(object);
                    });
                }
                execActions(object) {
                    const result = execActions(this.actions, {
                        ...object
                    });
                    const changes = Object.keys(result).reduce((prev, cur) => {
                        if (result[cur] !== object[cur]) {
                            prev[cur] = result[cur];
                        }
                        return prev;
                    }, {});
                    return changes;
                }
                exec(object) {
                    if (this.evalConditions(object)) {
                        return this.execActions(object);
                    }
                    return null;
                }
                // Apply is similar to exec but applies the changes for you
                apply(object) {
                    const changes = this.exec(object);
                    return Object.assign({}, object, changes);
                }
                getId() {
                    return this.id;
                }
                serialize() {
                    return {
                        id: this.id,
                        stage: this.stage,
                        conditionsOp: this.conditionsOp,
                        conditions: this.conditions.map((c) => c.serialize()),
                        actions: this.actions.map((a) => a.serialize())
                    };
                }
            }
            class RuleIndexer {
                constructor({ field, method }) {
                    this.field = field;
                    this.method = method;
                    this.rules = new Map();
                }
                getIndex(key) {
                    if (!this.rules.has(key)) {
                        this.rules.set(key, new Set());
                    }
                    return this.rules.get(key);
                }
                getIndexForValue(value) {
                    return this.getIndex(this.getKey(value) || '*');
                }
                getKey(value) {
                    if (typeof value === 'string' && value !== '') {
                        if (this.method === 'firstchar') {
                            return value[0].toLowerCase();
                        }
                        return value.toLowerCase();
                    }
                    return null;
                }
                getIndexes(rule) {
                    const cond = rule.conditions.find((cond) => cond.field === this.field);
                    const indexes = [];
                    if (cond && (cond.op === 'oneOf' || cond.op === 'is' || cond.op === 'isNot' || cond.op === 'notOneOf')) {
                        if (cond.op === 'oneOf' || cond.op === 'notOneOf') {
                            cond.value.forEach((val) => indexes.push(this.getIndexForValue(val)));
                        }
                        else {
                            indexes.push(this.getIndexForValue(cond.value));
                        }
                    }
                    else {
                        indexes.push(this.getIndex('*'));
                    }
                    return indexes;
                }
                index(rule) {
                    const indexes = this.getIndexes(rule);
                    indexes.forEach((index) => {
                        index.add(rule);
                    });
                }
                remove(rule) {
                    const indexes = this.getIndexes(rule);
                    indexes.forEach((index) => {
                        index.delete(rule);
                    });
                }
                getApplicableRules(object) {
                    let indexedRules;
                    if (this.field in object) {
                        const key = this.getKey(object[this.field]);
                        if (key) {
                            indexedRules = this.rules.get(key);
                        }
                    }
                    return (0, _shared_util__WEBPACK_IMPORTED_MODULE_4__.fastSetMerge)(indexedRules || new Set(), this.rules.get('*') || new Set());
                }
            }
            const OP_SCORES = {
                is: 10,
                isNot: 10,
                oneOf: 9,
                notOneOf: 9,
                isapprox: 5,
                isbetween: 5,
                gt: 1,
                gte: 1,
                lt: 1,
                lte: 1,
                contains: 0,
                doesNotContain: 0,
                matches: 0
            };
            function computeScore(rule) {
                const initialScore = rule.conditions.reduce((score, condition) => {
                    if (OP_SCORES[condition.op] == null) {
                        console.log(`Found invalid operation while ranking: ${condition.op}`);
                        return 0;
                    }
                    return score + OP_SCORES[condition.op];
                }, 0);
                if (rule.conditions.every((cond) => cond.op === 'is' || cond.op === 'isNot' || cond.op === 'isapprox' || cond.op === 'oneOf' || cond.op === 'notOneOf')) {
                    return initialScore * 2;
                }
                return initialScore;
            }
            function _rankRules(rules) {
                const scores = new Map();
                rules.forEach((rule) => {
                    scores.set(rule, computeScore(rule));
                });
                // No matter the order of rules, this must always return exactly the same
                // order. That's why rules have ids: if two rules have the same score, it
                // sorts by id
                return [
                    ...rules
                ].sort((r1, r2) => {
                    const score1 = scores.get(r1);
                    const score2 = scores.get(r2);
                    if (score1 < score2) {
                        return -1;
                    }
                    else if (score1 > score2) {
                        return 1;
                    }
                    else {
                        const id1 = r1.getId();
                        const id2 = r2.getId();
                        return id1 < id2 ? -1 : id1 > id2 ? 1 : 0;
                    }
                });
            }
            function rankRules(rules) {
                let pre = [];
                let normal = [];
                let post = [];
                for (const rule of rules) {
                    switch (rule.stage) {
                        case 'pre':
                            pre.push(rule);
                            break;
                        case 'post':
                            post.push(rule);
                            break;
                        default:
                            normal.push(rule);
                    }
                }
                pre = _rankRules(pre);
                normal = _rankRules(normal);
                post = _rankRules(post);
                return pre.concat(normal).concat(post);
            }
            function migrateIds(rule, mappings) {
                // Go through the in-memory rules and patch up ids that have been
                // "migrated" to other ids. This is a little tricky, but a lot
                // easier than trying to keep an up-to-date mapping in the db. This
                // is necessary because ids can be transparently mapped as items are
                // merged/deleted in the system.
                //
                // It's very important here that we look at `rawValue` specifically,
                // and only apply the patches to the other `value` fields. We always
                // need to keep the original id around because undo can walk
                // backwards, and we need to be able to consistently apply a
                // "projection" of these mapped values. For example: if we have ids
                // [1, 2] and applying mappings transforms it to [2, 2], if `1` gets
                // mapped to something else there's no way to no to map *only* the
                // first id back to make [1, 2]. Keeping the original value around
                // solves this.
                for (let ci = 0; ci < rule.conditions.length; ci++) {
                    const cond = rule.conditions[ci];
                    if (cond.type === 'id') {
                        switch (cond.op) {
                            case 'is':
                                cond.value = mappings.get(cond.rawValue) || cond.rawValue;
                                cond.unparsedValue = cond.value;
                                break;
                            case 'isNot':
                                cond.value = mappings.get(cond.rawValue) || cond.rawValue;
                                cond.unparsedValue = cond.value;
                                break;
                            case 'oneOf':
                                cond.value = cond.rawValue.map((v) => mappings.get(v) || v);
                                cond.unparsedValue = [
                                    ...cond.value
                                ];
                                break;
                            case 'notOneOf':
                                cond.value = cond.rawValue.map((v) => mappings.get(v) || v);
                                cond.unparsedValue = [
                                    ...cond.value
                                ];
                                break;
                            default:
                        }
                    }
                }
                for (let ai = 0; ai < rule.actions.length; ai++) {
                    const action = rule.actions[ai];
                    if (action.type === 'id') {
                        if (action.op === 'set') {
                            action.value = mappings.get(action.rawValue) || action.rawValue;
                        }
                    }
                }
            }
            // This finds all the rules that reference the `id`
            function iterateIds(rules, fieldName, func) {
                let i;
                ruleiter: for (i = 0; i < rules.length; i++) {
                    const rule = rules[i];
                    for (let ci = 0; ci < rule.conditions.length; ci++) {
                        const cond = rule.conditions[ci];
                        if (cond.type === 'id' && cond.field === fieldName) {
                            switch (cond.op) {
                                case 'is':
                                    if (func(rule, cond.value)) {
                                        continue ruleiter;
                                    }
                                    break;
                                case 'isNot':
                                    if (func(rule, cond.value)) {
                                        continue ruleiter;
                                    }
                                    break;
                                case 'oneOf':
                                    for (let vi = 0; vi < cond.value.length; vi++) {
                                        if (func(rule, cond.value[vi])) {
                                            continue ruleiter;
                                        }
                                    }
                                    break;
                                case 'notOneOf':
                                    for (let vi = 0; vi < cond.value.length; vi++) {
                                        if (func(rule, cond.value[vi])) {
                                            continue ruleiter;
                                        }
                                    }
                                    break;
                                default:
                            }
                        }
                    }
                    for (let ai = 0; ai < rule.actions.length; ai++) {
                        const action = rule.actions[ai];
                        if (action.type === 'id' && action.field === fieldName) {
                            // Currently `set` is the only op, but if we add more this
                            // will need to be extended
                            if (action.op === 'set') {
                                if (func(rule, action.value)) {
                                    break;
                                }
                            }
                        }
                    }
                }
            }
            /***/ 
        }),
        /***/ "./packages/loot-core/src/server/accounts/sync.ts": 
        /*!********************************************************!*\
          !*** ./packages/loot-core/src/server/accounts/sync.ts ***!
          \********************************************************/
        /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony export */ __webpack_require__.d(__webpack_exports__, {
                /* harmony export */ addTransactions: () => ( /* binding */addTransactions),
                /* harmony export */ getGoCardlessAccounts: () => ( /* binding */getGoCardlessAccounts),
                /* harmony export */ matchTransactions: () => ( /* binding */matchTransactions),
                /* harmony export */ reconcileTransactions: () => ( /* binding */reconcileTransactions),
                /* harmony export */ syncAccount: () => ( /* binding */syncAccount)
                /* harmony export */ 
            });
            /* harmony import */ var date_fns__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! date-fns */ "./node_modules/date-fns/esm/differenceInMilliseconds/index.js");
            /* harmony import */ var date_fns__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! date-fns */ "./node_modules/date-fns/esm/parseISO/index.js");
            /* harmony import */ var date_fns__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! date-fns */ "./node_modules/date-fns/esm/max/index.js");
            /* harmony import */ var uuid__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! uuid */ "./node_modules/uuid/dist/esm-node/v4.js");
            /* harmony import */ var _platform_server_asyncStorage__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../platform/server/asyncStorage */ "./packages/loot-core/src/platform/server/asyncStorage/index.electron.ts");
            /* harmony import */ var _shared_months__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../shared/months */ "./packages/loot-core/src/shared/months.ts");
            /* harmony import */ var _shared_transactions__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../shared/transactions */ "./packages/loot-core/src/shared/transactions.ts");
            /* harmony import */ var _shared_util__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../shared/util */ "./packages/loot-core/src/shared/util.ts");
            /* harmony import */ var _db__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../db */ "./packages/loot-core/src/server/db/index.ts");
            /* harmony import */ var _mutators__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../mutators */ "./packages/loot-core/src/server/mutators.ts");
            /* harmony import */ var _post__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../post */ "./packages/loot-core/src/server/post.ts");
            /* harmony import */ var _server_config__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../server-config */ "./packages/loot-core/src/server/server-config.ts");
            /* harmony import */ var _sync__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../sync */ "./packages/loot-core/src/server/sync/index.ts");
            /* harmony import */ var _payees__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./payees */ "./packages/loot-core/src/server/accounts/payees.ts");
            /* harmony import */ var _title__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./title */ "./packages/loot-core/src/server/accounts/title/index.ts");
            /* harmony import */ var _transaction_rules__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./transaction-rules */ "./packages/loot-core/src/server/accounts/transaction-rules.ts");
            /* harmony import */ var _transactions__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./transactions */ "./packages/loot-core/src/server/accounts/transactions.ts");
            // @ts-strict-ignore
            function BankSyncError(type, code) {
                return {
                    type: 'BankSyncError',
                    category: type,
                    code
                };
            }
            function makeSplitTransaction(trans, subtransactions) {
                // We need to calculate the final state of split transactions
                const { subtransactions: sub, ...parent } = (0, _shared_transactions__WEBPACK_IMPORTED_MODULE_2__.recalculateSplit)({
                    ...trans,
                    is_parent: true,
                    subtransactions: subtransactions.map((transaction, idx) => (0, _shared_transactions__WEBPACK_IMPORTED_MODULE_2__.makeChild)(trans, {
                        ...transaction,
                        sort_order: 0 - idx
                    }))
                });
                return [
                    parent,
                    ...sub
                ];
            }
            function getAccountBalance(account) {
                // Debt account types need their balance reversed
                switch (account.type) {
                    case 'credit':
                    case 'loan':
                        return -account.balances.current;
                    default:
                        return account.balances.current;
                }
            }
            async function updateAccountBalance(id, balance) {
                await _db__WEBPACK_IMPORTED_MODULE_4__.runQuery('UPDATE accounts SET balance_current = ? WHERE id = ?', [
                    (0, _shared_util__WEBPACK_IMPORTED_MODULE_3__.amountToInteger)(balance),
                    id
                ]);
            }
            async function getGoCardlessAccounts(userId, userKey, id) {
                const userToken = await _platform_server_asyncStorage__WEBPACK_IMPORTED_MODULE_0__.getItem('user-token');
                if (!userToken)
                    return;
                const res = await (0, _post__WEBPACK_IMPORTED_MODULE_6__.post)((0, _server_config__WEBPACK_IMPORTED_MODULE_7__.getServer)().GOCARDLESS_SERVER + '/accounts', {
                    userId,
                    key: userKey,
                    item_id: id
                }, {
                    'X-ACTUAL-TOKEN': userToken
                });
                const { accounts } = res;
                accounts.forEach((acct) => {
                    acct.balances.current = getAccountBalance(acct);
                });
                return accounts;
            }
            async function downloadGoCardlessTransactions(userId, userKey, acctId, bankId, since) {
                const userToken = await _platform_server_asyncStorage__WEBPACK_IMPORTED_MODULE_0__.getItem('user-token');
                if (!userToken)
                    return;
                console.log('Pulling transactions from GoCardless');
                const res = await (0, _post__WEBPACK_IMPORTED_MODULE_6__.post)((0, _server_config__WEBPACK_IMPORTED_MODULE_7__.getServer)().GOCARDLESS_SERVER + '/transactions', {
                    userId,
                    key: userKey,
                    requisitionId: bankId,
                    accountId: acctId,
                    startDate: since
                }, {
                    'X-ACTUAL-TOKEN': userToken
                });
                if (res.error_code) {
                    throw BankSyncError(res.error_type, res.error_code);
                }
                const { transactions: { all }, balances, startingBalance } = res;
                console.log('Response:', res);
                return {
                    transactions: all,
                    accountBalance: balances,
                    startingBalance
                };
            }
            async function downloadSimpleFinTransactions(acctId, since) {
                const userToken = await _platform_server_asyncStorage__WEBPACK_IMPORTED_MODULE_0__.getItem('user-token');
                if (!userToken)
                    return;
                console.log('Pulling transactions from SimpleFin');
                const res = await (0, _post__WEBPACK_IMPORTED_MODULE_6__.post)((0, _server_config__WEBPACK_IMPORTED_MODULE_7__.getServer)().SIMPLEFIN_SERVER + '/transactions', {
                    accountId: acctId,
                    startDate: since
                }, {
                    'X-ACTUAL-TOKEN': userToken
                }, 60000);
                if (res.error_code) {
                    throw BankSyncError(res.error_type, res.error_code);
                }
                const { transactions: { all }, balances, startingBalance } = res;
                console.log('Response:', res);
                return {
                    transactions: all,
                    accountBalance: balances,
                    startingBalance
                };
            }
            async function resolvePayee(trans, payeeName, payeesToCreate) {
                if (trans.payee == null && payeeName) {
                    // First check our registry of new payees (to avoid a db access)
                    // then check the db for existing payees
                    let payee = payeesToCreate.get(payeeName.toLowerCase());
                    payee = payee || await _db__WEBPACK_IMPORTED_MODULE_4__.getPayeeByName(payeeName);
                    if (payee != null) {
                        return payee.id;
                    }
                    else {
                        // Otherwise we're going to create a new one
                        const newPayee = {
                            id: (0, uuid__WEBPACK_IMPORTED_MODULE_13__["default"])(),
                            name: payeeName
                        };
                        payeesToCreate.set(payeeName.toLowerCase(), newPayee);
                        return newPayee.id;
                    }
                }
                return trans.payee;
            }
            async function normalizeTransactions(transactions, acctId, { rawPayeeName = false } = {}) {
                const payeesToCreate = new Map();
                const normalized = [];
                for (let trans of transactions) {
                    // Validate the date because we do some stuff with it. The db
                    // layer does better validation, but this will give nicer errors
                    if (trans.date == null) {
                        throw new Error('`date` is required when adding a transaction');
                    }
                    // Strip off the irregular properties
                    const { payee_name: originalPayeeName, subtransactions, ...rest } = trans;
                    trans = rest;
                    let payee_name = originalPayeeName;
                    if (payee_name) {
                        const trimmed = payee_name.trim();
                        if (trimmed === '') {
                            payee_name = null;
                        }
                        else {
                            payee_name = rawPayeeName ? trimmed : (0, _title__WEBPACK_IMPORTED_MODULE_10__.title)(trimmed);
                        }
                    }
                    trans.imported_payee = trans.imported_payee || payee_name;
                    if (trans.imported_payee) {
                        trans.imported_payee = trans.imported_payee.trim();
                    }
                    // It's important to resolve both the account and payee early so
                    // when rules are run, they have the right data. Resolving payees
                    // also simplifies the payee creation process
                    trans.account = acctId;
                    trans.payee = await resolvePayee(trans, payee_name, payeesToCreate);
                    normalized.push({
                        payee_name,
                        subtransactions: subtransactions ? subtransactions.map((t) => ({
                            ...t,
                            account: acctId
                        })) : null,
                        trans
                    });
                }
                return {
                    normalized,
                    payeesToCreate
                };
            }
            async function normalizeBankSyncTransactions(transactions, acctId) {
                const payeesToCreate = new Map();
                const normalized = [];
                for (const trans of transactions) {
                    if (!trans.amount) {
                        trans.amount = trans.transactionAmount.amount;
                    }
                    // Validate the date because we do some stuff with it. The db
                    // layer does better validation, but this will give nicer errors
                    if (trans.date == null) {
                        throw new Error('`date` is required when adding a transaction');
                    }
                    if (trans.payeeName == null) {
                        throw new Error('`payeeName` is required when adding a transaction');
                    }
                    trans.imported_payee = trans.imported_payee || trans.payeeName;
                    if (trans.imported_payee) {
                        trans.imported_payee = trans.imported_payee.trim();
                    }
                    // It's important to resolve both the account and payee early so
                    // when rules are run, they have the right data. Resolving payees
                    // also simplifies the payee creation process
                    trans.account = acctId;
                    trans.payee = await resolvePayee(trans, trans.payeeName, payeesToCreate);
                    trans.cleared = Boolean(trans.booked);
                    normalized.push({
                        payee_name: trans.payeeName,
                        trans: {
                            amount: (0, _shared_util__WEBPACK_IMPORTED_MODULE_3__.amountToInteger)(trans.amount),
                            payee: trans.payee,
                            account: trans.account,
                            date: trans.date,
                            notes: trans.remittanceInformationUnstructured || (trans.remittanceInformationUnstructuredArray || []).join(', '),
                            imported_id: trans.transactionId,
                            imported_payee: trans.imported_payee,
                            cleared: trans.cleared
                        }
                    });
                }
                return {
                    normalized,
                    payeesToCreate
                };
            }
            async function createNewPayees(payeesToCreate, addsAndUpdates) {
                const usedPayeeIds = new Set(addsAndUpdates.map((t) => t.payee));
                await (0, _sync__WEBPACK_IMPORTED_MODULE_8__.batchMessages)(async () => {
                    for (const payee of payeesToCreate.values()) {
                        // Only create the payee if it ended up being used
                        if (usedPayeeIds.has(payee.id)) {
                            await _db__WEBPACK_IMPORTED_MODULE_4__.insertPayee(payee);
                        }
                    }
                });
            }
            async function reconcileTransactions(acctId, transactions, isBankSyncAccount = false, isPreview = false) {
                console.log('Performing transaction reconciliation');
                const updated = [];
                const added = [];
                const updatedPreview = [];
                const existingPayeeMap = new Map();
                const { payeesToCreate, transactionsStep1, transactionsStep2, transactionsStep3 } = await matchTransactions(acctId, transactions, isBankSyncAccount);
                // Finally, generate & commit the changes
                for (const { trans, subtransactions, match } of transactionsStep3) {
                    if (match && !trans.forceAddTransaction) {
                        // Skip updating already reconciled (locked) transactions
                        if (match.reconciled) {
                            updatedPreview.push({
                                transaction: trans,
                                ignored: true
                            });
                            continue;
                        }
                        // TODO: change the above sql query to use aql
                        const existing = {
                            ...match,
                            cleared: match.cleared === 1,
                            date: _db__WEBPACK_IMPORTED_MODULE_4__.fromDateRepr(match.date)
                        };
                        // Update the transaction
                        const updates = {
                            imported_id: trans.imported_id || null,
                            payee: existing.payee || trans.payee || null,
                            category: existing.category || trans.category || null,
                            imported_payee: trans.imported_payee || null,
                            notes: existing.notes || trans.notes || null,
                            cleared: trans.cleared != null ? trans.cleared : true
                        };
                        if ((0, _shared_util__WEBPACK_IMPORTED_MODULE_3__.hasFieldsChanged)(existing, updates, Object.keys(updates))) {
                            updated.push({
                                id: existing.id,
                                ...updates
                            });
                            if (!existingPayeeMap.has(existing.payee)) {
                                const payee = await _db__WEBPACK_IMPORTED_MODULE_4__.getPayee(existing.payee);
                                existingPayeeMap.set(existing.payee, payee?.name);
                            }
                            existing.payee_name = existingPayeeMap.get(existing.payee);
                            existing.amount = (0, _shared_util__WEBPACK_IMPORTED_MODULE_3__.integerToAmount)(existing.amount);
                            updatedPreview.push({
                                transaction: trans,
                                existing
                            });
                        }
                        else {
                            updatedPreview.push({
                                transaction: trans,
                                ignored: true
                            });
                        }
                        if (existing.is_parent && existing.cleared !== updates.cleared) {
                            const children = await _db__WEBPACK_IMPORTED_MODULE_4__.all('SELECT id FROM v_transactions WHERE parent_id = ?', [
                                existing.id
                            ]);
                            for (const child of children) {
                                updated.push({
                                    id: child.id,
                                    cleared: updates.cleared
                                });
                            }
                        }
                    }
                    else {
                        // Insert a new transaction
                        const { forceAddTransaction, ...newTrans } = trans;
                        const finalTransaction = {
                            ...newTrans,
                            id: (0, uuid__WEBPACK_IMPORTED_MODULE_13__["default"])(),
                            category: trans.category || null,
                            cleared: trans.cleared != null ? trans.cleared : true
                        };
                        if (subtransactions && subtransactions.length > 0) {
                            added.push(...makeSplitTransaction(finalTransaction, subtransactions));
                        }
                        else {
                            added.push(finalTransaction);
                        }
                    }
                }
                if (!isPreview) {
                    await createNewPayees(payeesToCreate, [
                        ...added,
                        ...updated
                    ]);
                    await (0, _transactions__WEBPACK_IMPORTED_MODULE_12__.batchUpdateTransactions)({
                        added,
                        updated
                    });
                }
                console.log('Debug data for the operations:', {
                    transactionsStep1,
                    transactionsStep2,
                    transactionsStep3,
                    added,
                    updated,
                    updatedPreview
                });
                return {
                    added: added.map((trans) => trans.id),
                    updated: updated.map((trans) => trans.id),
                    updatedPreview
                };
            }
            async function matchTransactions(acctId, transactions, isBankSyncAccount = false) {
                console.log('Performing transaction reconciliation matching');
                const hasMatched = new Set();
                const transactionNormalization = isBankSyncAccount ? normalizeBankSyncTransactions : normalizeTransactions;
                const { normalized, payeesToCreate } = await transactionNormalization(transactions, acctId);
                // The first pass runs the rules, and preps data for fuzzy matching
                const transactionsStep1 = [];
                for (const { payee_name, trans: originalTrans, subtransactions } of normalized) {
                    // Run the rules
                    const trans = (0, _transaction_rules__WEBPACK_IMPORTED_MODULE_11__.runRules)(originalTrans);
                    let match = null;
                    let fuzzyDataset = null;
                    // First, match with an existing transaction's imported_id. This
                    // is the highest fidelity match and should always be attempted
                    // first.
                    if (trans.imported_id) {
                        match = await _db__WEBPACK_IMPORTED_MODULE_4__.first('SELECT * FROM v_transactions WHERE imported_id = ? AND account = ?', [
                            trans.imported_id,
                            acctId
                        ]);
                        if (match) {
                            hasMatched.add(match.id);
                        }
                    }
                    // If it didn't match, query data needed for fuzzy matching
                    if (!match) {
                        // Look 7 days ahead and 7 days back when fuzzy matching. This
                        // needs to select all fields that need to be read from the
                        // matched transaction. See the final pass below for the needed
                        // fields.
                        fuzzyDataset = await _db__WEBPACK_IMPORTED_MODULE_4__.all(`SELECT id, is_parent, date, imported_id, payee, imported_payee, category, notes, reconciled, cleared, amount FROM v_transactions
           WHERE date >= ? AND date <= ? AND amount = ? AND account = ?`, [
                            _db__WEBPACK_IMPORTED_MODULE_4__.toDateRepr(_shared_months__WEBPACK_IMPORTED_MODULE_1__.subDays(trans.date, 7)),
                            _db__WEBPACK_IMPORTED_MODULE_4__.toDateRepr(_shared_months__WEBPACK_IMPORTED_MODULE_1__.addDays(trans.date, 7)),
                            trans.amount || 0,
                            acctId
                        ]);
                        // Sort the matched transactions according to the distance from the original
                        // transactions date. i.e. if the original transaction is in 21-02-2024 and
                        // the matched transactions are: 20-02-2024, 21-02-2024, 29-02-2024 then
                        // the resulting data-set should be: 21-02-2024, 20-02-2024, 29-02-2024.
                        fuzzyDataset = fuzzyDataset.sort((a, b) => {
                            const aDistance = Math.abs(date_fns__WEBPACK_IMPORTED_MODULE_14__["default"](date_fns__WEBPACK_IMPORTED_MODULE_15__["default"](trans.date), date_fns__WEBPACK_IMPORTED_MODULE_15__["default"](_db__WEBPACK_IMPORTED_MODULE_4__.fromDateRepr(a.date))));
                            const bDistance = Math.abs(date_fns__WEBPACK_IMPORTED_MODULE_14__["default"](date_fns__WEBPACK_IMPORTED_MODULE_15__["default"](trans.date), date_fns__WEBPACK_IMPORTED_MODULE_15__["default"](_db__WEBPACK_IMPORTED_MODULE_4__.fromDateRepr(b.date))));
                            return aDistance > bDistance ? 1 : -1;
                        });
                    }
                    transactionsStep1.push({
                        payee_name,
                        trans,
                        subtransactions: trans.subtransactions || subtransactions,
                        match,
                        fuzzyDataset
                    });
                }
                // Next, do the fuzzy matching. This first pass matches based on the
                // payee id. We do this in multiple passes so that higher fidelity
                // matching always happens first, i.e. a transaction should match
                // match with low fidelity if a later transaction is going to match
                // the same one with high fidelity.
                const transactionsStep2 = transactionsStep1.map((data) => {
                    if (!data.match && data.fuzzyDataset) {
                        // Try to find one where the payees match.
                        const match = data.fuzzyDataset.find((row) => !hasMatched.has(row.id) && data.trans.payee === row.payee);
                        if (match) {
                            hasMatched.add(match.id);
                            return {
                                ...data,
                                match
                            };
                        }
                    }
                    return data;
                });
                // The final fuzzy matching pass. This is the lowest fidelity
                // matching: it just find the first transaction that hasn't been
                // matched yet. Remember the dataset only contains transactions
                // around the same date with the same amount.
                const transactionsStep3 = transactionsStep2.map((data) => {
                    if (!data.match && data.fuzzyDataset) {
                        const match = data.fuzzyDataset.find((row) => !hasMatched.has(row.id));
                        if (match) {
                            hasMatched.add(match.id);
                            return {
                                ...data,
                                match
                            };
                        }
                    }
                    return data;
                });
                return {
                    payeesToCreate,
                    transactionsStep1,
                    transactionsStep2,
                    transactionsStep3
                };
            }
            // This is similar to `reconcileTransactions` except much simpler: it
            // does not try to match any transactions. It just adds them
            async function addTransactions(acctId, transactions, { runTransfers = true, learnCategories = false } = {}) {
                const added = [];
                const { normalized, payeesToCreate } = await normalizeTransactions(transactions, acctId, {
                    rawPayeeName: true
                });
                for (const { trans: originalTrans, subtransactions } of normalized) {
                    // Run the rules
                    const trans = (0, _transaction_rules__WEBPACK_IMPORTED_MODULE_11__.runRules)(originalTrans);
                    const finalTransaction = {
                        id: (0, uuid__WEBPACK_IMPORTED_MODULE_13__["default"])(),
                        ...trans,
                        account: acctId,
                        cleared: trans.cleared != null ? trans.cleared : true
                    };
                    // Add split transactions if they are given
                    const updatedSubtransactions = finalTransaction.subtransactions || subtransactions;
                    if (updatedSubtransactions && updatedSubtransactions.length > 0) {
                        added.push(...makeSplitTransaction(finalTransaction, updatedSubtransactions));
                    }
                    else {
                        added.push(finalTransaction);
                    }
                }
                await createNewPayees(payeesToCreate, added);
                let newTransactions;
                if (runTransfers || learnCategories) {
                    const res = await (0, _transactions__WEBPACK_IMPORTED_MODULE_12__.batchUpdateTransactions)({
                        added,
                        learnCategories,
                        runTransfers
                    });
                    newTransactions = res.added.map((t) => t.id);
                }
                else {
                    await (0, _sync__WEBPACK_IMPORTED_MODULE_8__.batchMessages)(async () => {
                        newTransactions = await Promise.all(added.map(async (trans) => _db__WEBPACK_IMPORTED_MODULE_4__.insertTransaction(trans)));
                    });
                }
                return newTransactions;
            }
            async function syncAccount(userId, userKey, id, acctId, bankId) {
                // TODO: Handle the case where transactions exist in the future
                // (that will make start date after end date)
                const latestTransaction = await _db__WEBPACK_IMPORTED_MODULE_4__.first('SELECT * FROM v_transactions WHERE account = ? ORDER BY date DESC LIMIT 1', [
                    id
                ]);
                const acctRow = await _db__WEBPACK_IMPORTED_MODULE_4__.select('accounts', id);
                if (latestTransaction) {
                    const startingTransaction = await _db__WEBPACK_IMPORTED_MODULE_4__.first('SELECT date FROM v_transactions WHERE account = ? ORDER BY date ASC LIMIT 1', [
                        id
                    ]);
                    const startingDate = _db__WEBPACK_IMPORTED_MODULE_4__.fromDateRepr(startingTransaction.date);
                    // assert(startingTransaction)
                    const startDate = _shared_months__WEBPACK_IMPORTED_MODULE_1__.dayFromDate(date_fns__WEBPACK_IMPORTED_MODULE_16__["default"]([
                        // Many GoCardless integrations do not support getting more than 90 days
                        // worth of data, so make that the earliest possible limit.
                        _shared_months__WEBPACK_IMPORTED_MODULE_1__.parseDate(_shared_months__WEBPACK_IMPORTED_MODULE_1__.subDays(_shared_months__WEBPACK_IMPORTED_MODULE_1__.currentDay(), 90)),
                        // Never download transactions before the starting date.
                        _shared_months__WEBPACK_IMPORTED_MODULE_1__.parseDate(startingDate)
                    ]));
                    let download;
                    if (acctRow.account_sync_source === 'simpleFin') {
                        download = await downloadSimpleFinTransactions(acctId, startDate);
                    }
                    else if (acctRow.account_sync_source === 'goCardless') {
                        download = await downloadGoCardlessTransactions(userId, userKey, acctId, bankId, startDate);
                    }
                    else {
                        throw new Error(`Unrecognized bank-sync provider: ${acctRow.account_sync_source}`);
                    }
                    const { transactions: originalTransactions, accountBalance } = download;
                    if (originalTransactions.length === 0) {
                        return {
                            added: [],
                            updated: []
                        };
                    }
                    const transactions = originalTransactions.map((trans) => ({
                        ...trans,
                        account: id
                    }));
                    return (0, _mutators__WEBPACK_IMPORTED_MODULE_5__.runMutator)(async () => {
                        const result = await reconcileTransactions(id, transactions, true);
                        await updateAccountBalance(id, accountBalance);
                        return result;
                    });
                }
                else {
                    let download;
                    // Otherwise, download transaction for the past 90 days
                    const startingDay = _shared_months__WEBPACK_IMPORTED_MODULE_1__.subDays(_shared_months__WEBPACK_IMPORTED_MODULE_1__.currentDay(), 90);
                    if (acctRow.account_sync_source === 'simpleFin') {
                        download = await downloadSimpleFinTransactions(acctId, startingDay);
                    }
                    else if (acctRow.account_sync_source === 'goCardless') {
                        download = await downloadGoCardlessTransactions(userId, userKey, acctId, bankId, startingDay);
                    }
                    const { transactions } = download;
                    let balanceToUse = download.startingBalance;
                    if (acctRow.account_sync_source === 'simpleFin') {
                        const currentBalance = download.startingBalance;
                        const previousBalance = transactions.reduce((total, trans) => {
                            return total - parseInt(trans.transactionAmount.amount.replace('.', ''));
                        }, currentBalance);
                        balanceToUse = previousBalance;
                    }
                    const oldestTransaction = transactions[transactions.length - 1];
                    const oldestDate = transactions.length > 0 ? oldestTransaction.date : _shared_months__WEBPACK_IMPORTED_MODULE_1__.currentDay();
                    const payee = await (0, _payees__WEBPACK_IMPORTED_MODULE_9__.getStartingBalancePayee)();
                    return (0, _mutators__WEBPACK_IMPORTED_MODULE_5__.runMutator)(async () => {
                        const initialId = await _db__WEBPACK_IMPORTED_MODULE_4__.insertTransaction({
                            account: id,
                            amount: balanceToUse,
                            category: acctRow.offbudget === 0 ? payee.category : null,
                            payee: payee.id,
                            date: oldestDate,
                            cleared: true,
                            starting_balance_flag: true
                        });
                        const result = await reconcileTransactions(id, transactions, true);
                        return {
                            ...result,
                            added: [
                                initialId,
                                ...result.added
                            ]
                        };
                    });
                }
            }
            /***/ 
        }),
        /***/ "./packages/loot-core/src/server/accounts/title/index.ts": 
        /*!***************************************************************!*\
          !*** ./packages/loot-core/src/server/accounts/title/index.ts ***!
          \***************************************************************/
        /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony export */ __webpack_require__.d(__webpack_exports__, {
                /* harmony export */ title: () => ( /* binding */title)
                /* harmony export */ 
            });
            /* harmony import */ var _lower_case__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./lower-case */ "./packages/loot-core/src/server/accounts/title/lower-case.ts");
            /* harmony import */ var _specials__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./specials */ "./packages/loot-core/src/server/accounts/title/specials.ts");
            // @ts-strict-ignore
            // Utilities
            const character = '[0-9\u0041-\u005A\u0061-\u007A\u00AA\u00B5\u00BA\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376-\u0377\u037A-\u037D\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u0523\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0621-\u064A\u066E-\u066F\u0671-\u06D3\u06D5\u06E5-\u06E6\u06EE-\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4-\u07F5\u07FA\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0972\u097B-\u097F\u0985-\u098C\u098F-\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC-\u09DD\u09DF-\u09E1\u09F0-\u09F1\u0A05-\u0A0A\u0A0F-\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32-\u0A33\u0A35-\u0A36\u0A38-\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2-\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0-\u0AE1\u0B05-\u0B0C\u0B0F-\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32-\u0B33\u0B35-\u0B39\u0B3D\u0B5C-\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99-\u0B9A\u0B9C\u0B9E-\u0B9F\u0BA3-\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C33\u0C35-\u0C39\u0C3D\u0C58-\u0C59\u0C60-\u0C61\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0-\u0CE1\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D28\u0D2A-\u0D39\u0D3D\u0D60-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32-\u0E33\u0E40-\u0E46\u0E81-\u0E82\u0E84\u0E87-\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA-\u0EAB\u0EAD-\u0EB0\u0EB2-\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDD\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8B\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065-\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10D0-\u10FA\u10FC\u1100-\u1159\u115F-\u11A2\u11A8-\u11F9\u1200-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F4\u1401-\u166C\u166F-\u1676\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F0\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u1900-\u191C\u1950-\u196D\u1970-\u1974\u1980-\u19A9\u19C1-\u19C7\u1A00-\u1A16\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE-\u1BAF\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u2094\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2C6F\u2C71-\u2C7D\u2C80-\u2CE4\u2D00-\u2D25\u2D30-\u2D65\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31B7\u31F0-\u31FF\u3400\u4DB5\u4E00\u9FC3\uA000-\uA48C\uA500-\uA60C\uA610-\uA61F\uA62A-\uA62B\uA640-\uA65F\uA662-\uA66E\uA67F-\uA697\uA717-\uA71F\uA722-\uA788\uA78B-\uA78C\uA7FB-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA90A-\uA925\uA930-\uA946\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAC00\uD7A3\uF900-\uFA2D\uFA30-\uFA6A\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40-\uFB41\uFB43-\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]';
            const regex = new RegExp(`(?:(?:(\\s?(?:^|[.\\(\\)!?;:"-])\\s*)(${character}))|(${character}))(${character}*[']*${character}*)`, 'g');
            const convertToRegExp = (specials) => specials.map((s) => [
                new RegExp(`\\b${s}\\b`, 'gi'),
                s
            ]);
            function parseMatch(match) {
                const firstCharacter = match[0];
                // test first character
                if (/\s/.test(firstCharacter)) {
                    // if whitespace - trim and return
                    return match.substr(1);
                }
                if (/[()]/.test(firstCharacter)) {
                    // if parens - this shouldn't be replaced
                    return null;
                }
                return match;
            }
            function title(str, options = {
                special: undefined
            }) {
                str = str.toLowerCase().replace(regex, (m, lead = '', forced, lower, rest) => {
                    const parsedMatch = parseMatch(m);
                    if (!parsedMatch) {
                        return m;
                    }
                    if (!forced) {
                        const fullLower = lower + rest;
                        if (_lower_case__WEBPACK_IMPORTED_MODULE_0__.lowerCaseSet.has(fullLower)) {
                            return parsedMatch;
                        }
                    }
                    return lead + (lower || forced).toUpperCase() + rest;
                });
                const customSpecials = options.special || [];
                const replace = [
                    ..._specials__WEBPACK_IMPORTED_MODULE_1__.specials,
                    ...customSpecials
                ];
                const replaceRegExp = convertToRegExp(replace);
                replaceRegExp.forEach(([pattern, s]) => {
                    str = str.replace(pattern, s);
                });
                return str;
            }
            /***/ 
        }),
        /***/ "./packages/loot-core/src/server/accounts/title/lower-case.ts": 
        /*!********************************************************************!*\
          !*** ./packages/loot-core/src/server/accounts/title/lower-case.ts ***!
          \********************************************************************/
        /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony export */ __webpack_require__.d(__webpack_exports__, {
                /* harmony export */ lowerCaseSet: () => ( /* binding */lowerCaseSet)
                /* harmony export */ 
            });
            const conjunctions = [
                'for',
                'and',
                'nor',
                'but',
                'or',
                'yet',
                'so'
            ];
            const articles = [
                'a',
                'an',
                'the'
            ];
            const prepositions = [
                'aboard',
                'about',
                'above',
                'across',
                'after',
                'against',
                'along',
                'amid',
                'among',
                'anti',
                'around',
                'as',
                'at',
                'before',
                'behind',
                'below',
                'beneath',
                'beside',
                'besides',
                'between',
                'beyond',
                'but',
                'by',
                'concerning',
                'considering',
                'despite',
                'down',
                'during',
                'except',
                'excepting',
                'excluding',
                'following',
                'for',
                'from',
                'in',
                'inside',
                'into',
                'like',
                'minus',
                'near',
                'of',
                'off',
                'on',
                'onto',
                'opposite',
                'over',
                'past',
                'per',
                'plus',
                'regarding',
                'round',
                'save',
                'since',
                'than',
                'through',
                'to',
                'toward',
                'towards',
                'under',
                'underneath',
                'unlike',
                'until',
                'up',
                'upon',
                'versus',
                'via',
                'with',
                'within',
                'without'
            ];
            const lowerCaseSet = new Set([
                ...conjunctions,
                ...articles,
                ...prepositions
            ]);
            /***/ 
        }),
        /***/ "./packages/loot-core/src/server/accounts/title/specials.ts": 
        /*!******************************************************************!*\
          !*** ./packages/loot-core/src/server/accounts/title/specials.ts ***!
          \******************************************************************/
        /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony export */ __webpack_require__.d(__webpack_exports__, {
                /* harmony export */ specials: () => ( /* binding */specials)
                /* harmony export */ 
            });
            const specials = [
                'CLI',
                'API',
                'HTTP',
                'HTTPS',
                'JSX',
                'DNS',
                'URL',
                'CI',
                'CDN',
                'GitHub',
                'CSS',
                'JS',
                'JavaScript',
                'TypeScript',
                'HTML',
                'WordPress',
                'JavaScript',
                'Next.js',
                'Node.js'
            ];
            /***/ 
        }),
        /***/ "./packages/loot-core/src/server/accounts/transaction-rules.ts": 
        /*!*********************************************************************!*\
          !*** ./packages/loot-core/src/server/accounts/transaction-rules.ts ***!
          \*********************************************************************/
        /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony export */ __webpack_require__.d(__webpack_exports__, {
                /* harmony export */ applyActions: () => ( /* binding */applyActions),
                /* harmony export */ conditionsToAQL: () => ( /* binding */conditionsToAQL),
                /* harmony export */ deleteRule: () => ( /* binding */deleteRule),
                /* harmony export */ getProbableCategory: () => ( /* binding */getProbableCategory),
                /* harmony export */ getRules: () => ( /* binding */getRules),
                /* harmony export */ getRulesForPayee: () => ( /* binding */getRulesForPayee),
                /* harmony export */ insertRule: () => ( /* binding */insertRule),
                /* harmony export */ iterateIds: () => ( /* reexport safe */_rules__WEBPACK_IMPORTED_MODULE_10__.iterateIds),
                /* harmony export */ loadRules: () => ( /* binding */loadRules),
                /* harmony export */ makeRule: () => ( /* binding */makeRule),
                /* harmony export */ parseConditionsOrActions: () => ( /* binding */parseConditionsOrActions),
                /* harmony export */ resetState: () => ( /* binding */resetState),
                /* harmony export */ ruleModel: () => ( /* binding */ruleModel),
                /* harmony export */ runRules: () => ( /* binding */runRules),
                /* harmony export */ serializeConditionsOrActions: () => ( /* binding */serializeConditionsOrActions),
                /* harmony export */ updateCategoryRules: () => ( /* binding */updateCategoryRules),
                /* harmony export */ updatePayeeRenameRule: () => ( /* binding */updatePayeeRenameRule),
                /* harmony export */ updateRule: () => ( /* binding */updateRule)
                /* harmony export */ 
            });
            /* harmony import */ var _shared_months__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../shared/months */ "./packages/loot-core/src/shared/months.ts");
            /* harmony import */ var _shared_rules__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../shared/rules */ "./packages/loot-core/src/shared/rules.ts");
            /* harmony import */ var _shared_transactions__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../shared/transactions */ "./packages/loot-core/src/shared/transactions.ts");
            /* harmony import */ var _shared_util__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../shared/util */ "./packages/loot-core/src/shared/util.ts");
            /* harmony import */ var _aql__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../aql */ "./packages/loot-core/src/server/aql/index.ts");
            /* harmony import */ var _db__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../db */ "./packages/loot-core/src/server/db/index.ts");
            /* harmony import */ var _db_mappings__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../db/mappings */ "./packages/loot-core/src/server/db/mappings.ts");
            /* harmony import */ var _errors__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../errors */ "./packages/loot-core/src/server/errors.ts");
            /* harmony import */ var _models__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../models */ "./packages/loot-core/src/server/models.ts");
            /* harmony import */ var _sync__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../sync */ "./packages/loot-core/src/server/sync/index.ts");
            /* harmony import */ var _rules__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./rules */ "./packages/loot-core/src/server/accounts/rules.ts");
            /* harmony import */ var _transactions__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./transactions */ "./packages/loot-core/src/server/accounts/transactions.ts");
            // @ts-strict-ignore
            // TODO: Detect if it looks like the user is creating a rename rule
            // and prompt to create it in the pre phase instead
            // * We could also make the "create rule" button a dropdown that
            //   provides different "templates" like "create renaming rule"
            let allRules;
            let unlistenSync;
            let firstcharIndexer;
            let payeeIndexer;
            function resetState() {
                allRules = new Map();
                firstcharIndexer = new _rules__WEBPACK_IMPORTED_MODULE_10__.RuleIndexer({
                    field: 'imported_payee',
                    method: 'firstchar'
                });
                payeeIndexer = new _rules__WEBPACK_IMPORTED_MODULE_10__.RuleIndexer({
                    field: 'payee'
                });
            }
            // Database functions
            function invert(obj) {
                return Object.fromEntries(Object.entries(obj).map((entry) => {
                    return [
                        entry[1],
                        entry[0]
                    ];
                }));
            }
            const internalFields = _aql__WEBPACK_IMPORTED_MODULE_4__.schemaConfig.views.transactions.fields;
            const publicFields = invert(_aql__WEBPACK_IMPORTED_MODULE_4__.schemaConfig.views.transactions.fields);
            function fromInternalField(obj) {
                return {
                    ...obj,
                    field: publicFields[obj.field] || obj.field
                };
            }
            function toInternalField(obj) {
                return {
                    ...obj,
                    field: internalFields[obj.field] || obj.field
                };
            }
            function parseArray(str) {
                let value;
                try {
                    value = typeof str === 'string' ? JSON.parse(str) : str;
                }
                catch (e) {
                    throw new _errors__WEBPACK_IMPORTED_MODULE_7__.RuleError('internal', 'Cannot parse rule json');
                }
                if (!Array.isArray(value)) {
                    throw new _errors__WEBPACK_IMPORTED_MODULE_7__.RuleError('internal', 'Rule json must be an array');
                }
                return value;
            }
            function parseConditionsOrActions(str) {
                return str ? parseArray(str).map((item) => fromInternalField(item)) : [];
            }
            function serializeConditionsOrActions(arr) {
                return JSON.stringify(arr.map((item) => toInternalField(item)));
            }
            const ruleModel = {
                validate(rule, { update } = {}) {
                    (0, _models__WEBPACK_IMPORTED_MODULE_8__.requiredFields)('rules', rule, [
                        'conditions',
                        'actions'
                    ], update);
                    if (!update || 'stage' in rule) {
                        if (rule.stage !== 'pre' && rule.stage !== 'post' && rule.stage !== null) {
                            throw new Error('Invalid rule stage: ' + rule.stage);
                        }
                    }
                    if (!update || 'conditionsOp' in rule) {
                        if (![
                            'and',
                            'or'
                        ].includes(rule.conditionsOp)) {
                            throw new Error('Invalid rule conditionsOp: ' + rule.conditionsOp);
                        }
                    }
                    return rule;
                },
                toJS(row) {
                    const { conditions, conditions_op, actions, ...fields } = row;
                    return {
                        ...fields,
                        conditionsOp: conditions_op,
                        conditions: parseConditionsOrActions(conditions),
                        actions: parseConditionsOrActions(actions)
                    };
                },
                fromJS(rule) {
                    const { conditions, conditionsOp, actions, ...row } = rule;
                    if (conditionsOp) {
                        row.conditions_op = conditionsOp;
                    }
                    if (Array.isArray(conditions)) {
                        row.conditions = serializeConditionsOrActions(conditions);
                    }
                    if (Array.isArray(actions)) {
                        row.actions = serializeConditionsOrActions(actions);
                    }
                    return row;
                }
            };
            function makeRule(data) {
                let rule;
                try {
                    rule = new _rules__WEBPACK_IMPORTED_MODULE_10__.Rule({
                        ...ruleModel.toJS(data),
                        fieldTypes: _shared_rules__WEBPACK_IMPORTED_MODULE_1__.FIELD_TYPES
                    });
                }
                catch (e) {
                    console.warn('Invalid rule', e);
                    if (e instanceof _errors__WEBPACK_IMPORTED_MODULE_7__.RuleError) {
                        return null;
                    }
                    throw e;
                }
                // This is needed because we map ids on the fly, and they might
                // not be persisted into the db. Mappings allow items to
                // transparently merge with other items
                (0, _rules__WEBPACK_IMPORTED_MODULE_10__.migrateIds)(rule, (0, _db_mappings__WEBPACK_IMPORTED_MODULE_6__.getMappings)());
                return rule;
            }
            async function loadRules() {
                resetState();
                const rules = await _db__WEBPACK_IMPORTED_MODULE_5__.all(`
    SELECT * FROM rules
      WHERE conditions IS NOT NULL AND actions IS NOT NULL AND tombstone = 0
  `);
                for (let i = 0; i < rules.length; i++) {
                    const desc = rules[i];
                    // These are old stages, can be removed before release
                    if (desc.stage === 'cleanup' || desc.stage === 'modify') {
                        desc.stage = 'pre';
                    }
                    const rule = makeRule(desc);
                    if (rule) {
                        allRules.set(rule.id, rule);
                        firstcharIndexer.index(rule);
                        payeeIndexer.index(rule);
                    }
                }
                if (unlistenSync) {
                    unlistenSync();
                }
                unlistenSync = (0, _sync__WEBPACK_IMPORTED_MODULE_9__.addSyncListener)(onApplySync);
            }
            function getRules() {
                // This can simply return the in-memory data
                return [
                    ...allRules.values()
                ];
            }
            async function insertRule(rule) {
                rule = ruleModel.validate(rule);
                return _db__WEBPACK_IMPORTED_MODULE_5__.insertWithUUID('rules', ruleModel.fromJS(rule));
            }
            async function updateRule(rule) {
                rule = ruleModel.validate(rule, {
                    update: true
                });
                return _db__WEBPACK_IMPORTED_MODULE_5__.update('rules', ruleModel.fromJS(rule));
            }
            async function deleteRule(rule) {
                const schedule = await _db__WEBPACK_IMPORTED_MODULE_5__.first('SELECT id FROM schedules WHERE rule = ?', [
                    rule.id
                ]);
                if (schedule) {
                    return false;
                }
                return _db__WEBPACK_IMPORTED_MODULE_5__.delete_('rules', rule.id);
            }
            // Sync projections
            function onApplySync(oldValues, newValues) {
                newValues.forEach((items, table) => {
                    if (table === 'rules') {
                        items.forEach((newValue) => {
                            const oldRule = allRules.get(newValue.id);
                            if (newValue.tombstone === 1) {
                                // Deleted, need to remove it from in-memory
                                const rule = allRules.get(newValue.id);
                                if (rule) {
                                    allRules.delete(rule.getId());
                                    firstcharIndexer.remove(rule);
                                    payeeIndexer.remove(rule);
                                }
                            }
                            else {
                                // Inserted/updated
                                const rule = makeRule(newValue);
                                if (rule) {
                                    if (oldRule) {
                                        firstcharIndexer.remove(oldRule);
                                        payeeIndexer.remove(oldRule);
                                    }
                                    allRules.set(newValue.id, rule);
                                    firstcharIndexer.index(rule);
                                    payeeIndexer.index(rule);
                                }
                            }
                        });
                    }
                });
                // If any of the mapping tables have changed, we need to refresh the
                // ids
                const tables = [
                    ...newValues.keys()
                ];
                if (tables.find((table) => table.indexOf('mapping') !== -1)) {
                    getRules().forEach((rule) => {
                        (0, _rules__WEBPACK_IMPORTED_MODULE_10__.migrateIds)(rule, (0, _db_mappings__WEBPACK_IMPORTED_MODULE_6__.getMappings)());
                    });
                }
            }
            // Runner
            function runRules(trans) {
                let finalTrans = {
                    ...trans
                };
                const rules = (0, _rules__WEBPACK_IMPORTED_MODULE_10__.rankRules)((0, _shared_util__WEBPACK_IMPORTED_MODULE_3__.fastSetMerge)(firstcharIndexer.getApplicableRules(trans), payeeIndexer.getApplicableRules(trans)));
                for (let i = 0; i < rules.length; i++) {
                    finalTrans = rules[i].apply(finalTrans);
                }
                return finalTrans;
            }
            // This does the inverse: finds all the transactions matching a rule
            function conditionsToAQL(conditions, { recurDateBounds = 100 } = {}) {
                const errors = [];
                conditions = conditions.map((cond) => {
                    if (cond instanceof _rules__WEBPACK_IMPORTED_MODULE_10__.Condition) {
                        return cond;
                    }
                    try {
                        return new _rules__WEBPACK_IMPORTED_MODULE_10__.Condition(cond.op, cond.field, cond.value, cond.options, _shared_rules__WEBPACK_IMPORTED_MODULE_1__.FIELD_TYPES);
                    }
                    catch (e) {
                        errors.push(e.type || 'internal');
                        console.log('conditionsToAQL: invalid condition: ' + e.message);
                        return null;
                    }
                }).filter(Boolean);
                // rule -> actualql
                const filters = conditions.map((cond) => {
                    const { type, field, op, value, options } = cond;
                    const getValue = (value) => {
                        if (type === 'number') {
                            return value.value;
                        }
                        return value;
                    };
                    const apply = (field, op, value) => {
                        if (type === 'number') {
                            if (options) {
                                if (options.outflow) {
                                    return {
                                        $and: [
                                            {
                                                amount: {
                                                    $lt: 0
                                                }
                                            },
                                            {
                                                [field]: {
                                                    $transform: '$neg',
                                                    [op]: value
                                                }
                                            }
                                        ]
                                    };
                                }
                                else if (options.inflow) {
                                    return {
                                        $and: [
                                            {
                                                amount: {
                                                    $gt: 0
                                                }
                                            },
                                            {
                                                [field]: {
                                                    [op]: value
                                                }
                                            }
                                        ]
                                    };
                                }
                            }
                            return {
                                amount: {
                                    [op]: value
                                }
                            };
                        }
                        else if (type === 'string') {
                            return {
                                [field]: {
                                    $transform: '$lower',
                                    [op]: value
                                }
                            };
                        }
                        else if (type === 'date') {
                            return {
                                [field]: {
                                    [op]: value.date
                                }
                            };
                        }
                        return {
                            [field]: {
                                [op]: value
                            }
                        };
                    };
                    switch (op) {
                        case 'isapprox':
                        case 'is':
                            if (type === 'date') {
                                if (value.type === 'recur') {
                                    const dates = value.schedule.occurrences({
                                        take: recurDateBounds
                                    }).toArray().map((d) => (0, _shared_months__WEBPACK_IMPORTED_MODULE_0__.dayFromDate)(d.date));
                                    return {
                                        $or: dates.map((d) => {
                                            if (op === 'isapprox') {
                                                return {
                                                    $and: [
                                                        {
                                                            date: {
                                                                $gte: (0, _shared_months__WEBPACK_IMPORTED_MODULE_0__.subDays)(d, 2)
                                                            }
                                                        },
                                                        {
                                                            date: {
                                                                $lte: (0, _shared_months__WEBPACK_IMPORTED_MODULE_0__.addDays)(d, 2)
                                                            }
                                                        }
                                                    ]
                                                };
                                            }
                                            return {
                                                date: d
                                            };
                                        })
                                    };
                                }
                                else {
                                    if (op === 'isapprox') {
                                        const fullDate = (0, _shared_months__WEBPACK_IMPORTED_MODULE_0__.parseDate)(value.date);
                                        const high = (0, _shared_months__WEBPACK_IMPORTED_MODULE_0__.addDays)(fullDate, 2);
                                        const low = (0, _shared_months__WEBPACK_IMPORTED_MODULE_0__.subDays)(fullDate, 2);
                                        return {
                                            $and: [
                                                {
                                                    date: {
                                                        $gte: low
                                                    }
                                                },
                                                {
                                                    date: {
                                                        $lte: high
                                                    }
                                                }
                                            ]
                                        };
                                    }
                                    else {
                                        switch (value.type) {
                                            case 'date':
                                                return {
                                                    date: value.date
                                                };
                                            case 'month':
                                                {
                                                    const low = value.date + '-00';
                                                    const high = value.date + '-99';
                                                    return {
                                                        $and: [
                                                            {
                                                                date: {
                                                                    $gte: low
                                                                }
                                                            },
                                                            {
                                                                date: {
                                                                    $lte: high
                                                                }
                                                            }
                                                        ]
                                                    };
                                                }
                                            case 'year':
                                                {
                                                    const low = value.date + '-00-00';
                                                    const high = value.date + '-99-99';
                                                    return {
                                                        $and: [
                                                            {
                                                                date: {
                                                                    $gte: low
                                                                }
                                                            },
                                                            {
                                                                date: {
                                                                    $lte: high
                                                                }
                                                            }
                                                        ]
                                                    };
                                                }
                                            default:
                                        }
                                    }
                                }
                            }
                            else if (type === 'number') {
                                const number = value.value;
                                if (op === 'isapprox') {
                                    const threshold = (0, _shared_rules__WEBPACK_IMPORTED_MODULE_1__.getApproxNumberThreshold)(number);
                                    return {
                                        $and: [
                                            apply(field, '$gte', number - threshold),
                                            apply(field, '$lte', number + threshold)
                                        ]
                                    };
                                }
                                return apply(field, '$eq', number);
                            }
                            else if (type === 'string') {
                                if (value === '') {
                                    return {
                                        $or: [
                                            apply(field, '$eq', null),
                                            apply(field, '$eq', '')
                                        ]
                                    };
                                }
                            }
                            return apply(field, '$eq', value);
                        case 'isNot':
                            return apply(field, '$ne', value);
                        case 'isbetween':
                            // This operator is only applicable to the specific `between`
                            // number type so we don't use `apply`
                            const [low, high] = (0, _shared_rules__WEBPACK_IMPORTED_MODULE_1__.sortNumbers)(value.num1, value.num2);
                            return {
                                [field]: [
                                    {
                                        $gte: low
                                    },
                                    {
                                        $lte: high
                                    }
                                ]
                            };
                        case 'contains':
                            // Running contains with id will automatically reach into
                            // the `name` of the referenced table and do a string match
                            return apply(type === 'id' ? field + '.name' : field, '$like', '%' + value + '%');
                        case 'matches':
                            // Running contains with id will automatically reach into
                            // the `name` of the referenced table and do a regex match
                            return apply(type === 'id' ? field + '.name' : field, '$regexp', value);
                        case 'doesNotContain':
                            // Running contains with id will automatically reach into
                            // the `name` of the referenced table and do a string match
                            return apply(type === 'id' ? field + '.name' : field, '$notlike', '%' + value + '%');
                        case 'oneOf':
                            const values = value;
                            if (values.length === 0) {
                                // This forces it to match nothing
                                return {
                                    id: null
                                };
                            }
                            return {
                                $or: values.map((v) => apply(field, '$eq', v))
                            };
                        case 'notOneOf':
                            const notValues = value;
                            if (notValues.length === 0) {
                                // This forces it to match nothing
                                return {
                                    id: null
                                };
                            }
                            return {
                                $and: notValues.map((v) => apply(field, '$ne', v))
                            };
                        case 'gt':
                            return apply(field, '$gt', getValue(value));
                        case 'gte':
                            return apply(field, '$gte', getValue(value));
                        case 'lt':
                            return apply(field, '$lt', getValue(value));
                        case 'lte':
                            return apply(field, '$lte', getValue(value));
                        case 'true':
                            return apply(field, '$eq', true);
                        case 'false':
                            return apply(field, '$eq', false);
                        default:
                            throw new Error('Unhandled operator: ' + op);
                    }
                });
                return {
                    filters,
                    errors
                };
            }
            async function applyActions(transactions, actions) {
                const parsedActions = actions.map((action) => {
                    if (action instanceof _rules__WEBPACK_IMPORTED_MODULE_10__.Action) {
                        return action;
                    }
                    try {
                        if (action.op === 'set-split-amount') {
                            return new _rules__WEBPACK_IMPORTED_MODULE_10__.Action(action.op, null, action.value, action.options, _shared_rules__WEBPACK_IMPORTED_MODULE_1__.FIELD_TYPES);
                        }
                        else if (action.op === 'link-schedule') {
                            return new _rules__WEBPACK_IMPORTED_MODULE_10__.Action(action.op, null, action.value, null, _shared_rules__WEBPACK_IMPORTED_MODULE_1__.FIELD_TYPES);
                        }
                        return new _rules__WEBPACK_IMPORTED_MODULE_10__.Action(action.op, action.field, action.value, action.options, _shared_rules__WEBPACK_IMPORTED_MODULE_1__.FIELD_TYPES);
                    }
                    catch (e) {
                        console.log('Action error', e);
                        return null;
                    }
                }).filter(Boolean);
                if (parsedActions.length !== actions.length) {
                    // An error happened while parsing
                    return null;
                }
                const updated = transactions.flatMap((trans) => {
                    return (0, _shared_transactions__WEBPACK_IMPORTED_MODULE_2__.ungroupTransaction)((0, _rules__WEBPACK_IMPORTED_MODULE_10__.execActions)(parsedActions, trans));
                });
                return (0, _transactions__WEBPACK_IMPORTED_MODULE_11__.batchUpdateTransactions)({
                    updated
                });
            }
            function getRulesForPayee(payeeId) {
                const rules = new Set();
                (0, _rules__WEBPACK_IMPORTED_MODULE_10__.iterateIds)(getRules(), 'payee', (rule, id) => {
                    if (id === payeeId) {
                        rules.add(rule);
                    }
                });
                return (0, _rules__WEBPACK_IMPORTED_MODULE_10__.rankRules)([
                    ...rules
                ]);
            }
            function* getIsSetterRules(stage, condField, actionField, { condValue, actionValue }) {
                const rules = getRules();
                for (let i = 0; i < rules.length; i++) {
                    const rule = rules[i];
                    if (rule.stage === stage && rule.actions.length === 1 && rule.actions[0].op === 'set' && rule.actions[0].field === actionField && (actionValue === undefined || rule.actions[0].value === actionValue) && rule.conditions.length === 1 && (rule.conditions[0].op === 'is' || rule.conditions[0].op === 'isNot') && rule.conditions[0].field === condField && (condValue === undefined || rule.conditions[0].value === condValue)) {
                        yield rule.serialize();
                    }
                }
                return null;
            }
            function* getOneOfSetterRules(stage, condField, actionField, { condValue, actionValue }) {
                const rules = getRules();
                for (let i = 0; i < rules.length; i++) {
                    const rule = rules[i];
                    if (rule.stage === stage && rule.actions.length === 1 && rule.actions[0].op === 'set' && rule.actions[0].field === actionField && (actionValue == null || rule.actions[0].value === actionValue) && rule.conditions.length === 1 && (rule.conditions[0].op === 'oneOf' || rule.conditions[0].op === 'oneOf') && rule.conditions[0].field === condField && (condValue == null || rule.conditions[0].value.indexOf(condValue) !== -1)) {
                        yield rule.serialize();
                    }
                }
                return null;
            }
            async function updatePayeeRenameRule(fromNames, to) {
                const renameRule = getOneOfSetterRules('pre', 'imported_payee', 'payee', {
                    actionValue: to
                }).next().value;
                // Note that we don't check for existing rules that set this
                // `imported_payee` to something else. It's important to do
                // that for categories because categories will be changes frequently
                // for the same payee, but renames won't be changed much. It's a use
                // case we could improve in the future, but this is fine for now.
                if (renameRule) {
                    const condition = renameRule.conditions[0];
                    const newValue = [
                        ...(0, _shared_util__WEBPACK_IMPORTED_MODULE_3__.fastSetMerge)(new Set(condition.value), new Set(fromNames.filter((name) => name !== '')))
                    ];
                    const rule = {
                        ...renameRule,
                        conditions: [
                            {
                                ...condition,
                                value: newValue
                            }
                        ]
                    };
                    await updateRule(rule);
                    return renameRule.id;
                }
                else {
                    const rule = new _rules__WEBPACK_IMPORTED_MODULE_10__.Rule({
                        stage: 'pre',
                        conditionsOp: 'and',
                        conditions: [
                            {
                                op: 'oneOf',
                                field: 'imported_payee',
                                value: fromNames
                            }
                        ],
                        actions: [
                            {
                                op: 'set',
                                field: 'payee',
                                value: to
                            }
                        ],
                        fieldTypes: _shared_rules__WEBPACK_IMPORTED_MODULE_1__.FIELD_TYPES
                    });
                    return insertRule(rule.serialize());
                }
            }
            function getProbableCategory(transactions) {
                const scores = new Map();
                transactions.forEach((trans) => {
                    if (trans.category) {
                        scores.set(trans.category, (scores.get(trans.category) || 0) + 1);
                    }
                });
                const winner = transactions.reduce((winner, trans) => {
                    const score = scores.get(trans.category);
                    if (!winner || score > winner.score) {
                        return {
                            score,
                            category: trans.category
                        };
                    }
                    return winner;
                }, null);
                return winner.score >= 3 ? winner.category : null;
            }
            async function updateCategoryRules(transactions) {
                if (transactions.length === 0) {
                    return;
                }
                const payeeIds = new Set(transactions.map((trans) => trans.payee));
                const transIds = new Set(transactions.map((trans) => trans.id));
                // It's going to be quickest to get the oldest date and then query
                // all transactions since then so we can work in memory
                let oldestDate = null;
                for (let i = 0; i < transactions.length; i++) {
                    if (oldestDate === null || transactions[i].date < oldestDate) {
                        oldestDate = transactions[i].date;
                    }
                }
                // We look 6 months behind to include any other transaction. This
                // makes it so we, 1. don't have to load in all transactions ever
                // and 2. "forget" really old transactions which might be nice and
                // 3. don't have to individually run a query for each payee
                oldestDate = (0, _shared_months__WEBPACK_IMPORTED_MODULE_0__.subDays)(oldestDate, 180);
                // Also look 180 days in the future to get any future transactions
                // (this might change when we think about scheduled transactions)
                const register = await _db__WEBPACK_IMPORTED_MODULE_5__.all(`SELECT t.* FROM v_transactions t
     LEFT JOIN accounts a ON a.id = t.account
     WHERE date >= ? AND date <= ? AND is_parent = 0 AND a.closed = 0
     ORDER BY date DESC`, [
                    (0, _models__WEBPACK_IMPORTED_MODULE_8__.toDateRepr)(oldestDate),
                    (0, _models__WEBPACK_IMPORTED_MODULE_8__.toDateRepr)((0, _shared_months__WEBPACK_IMPORTED_MODULE_0__.addDays)((0, _shared_months__WEBPACK_IMPORTED_MODULE_0__.currentDay)(), 180))
                ]);
                const allTransactions = (0, _shared_util__WEBPACK_IMPORTED_MODULE_3__.partitionByField)(register, 'payee');
                const categoriesToSet = new Map();
                for (const payeeId of payeeIds) {
                    // Don't do anything if payee is null
                    if (payeeId) {
                        const latestTrans = (allTransactions.get(payeeId) || []).slice(0, 5);
                        // Check if one of the latest transactions was one that was
                        // updated. We only want to update anything if so.
                        if (latestTrans.find((trans) => transIds.has(trans.id))) {
                            const category = getProbableCategory(latestTrans);
                            if (category) {
                                categoriesToSet.set(payeeId, category);
                            }
                        }
                    }
                }
                await (0, _sync__WEBPACK_IMPORTED_MODULE_9__.batchMessages)(async () => {
                    for (const [payeeId, category] of categoriesToSet.entries()) {
                        const ruleSetters = [
                            ...getIsSetterRules(null, 'payee', 'category', {
                                condValue: payeeId
                            })
                        ];
                        if (ruleSetters.length > 0) {
                            // If there are existing rules, change all of them to the new
                            // category (if they aren't already using it). We set all of
                            // them because it's possible that multiple rules exist
                            // because 2 clients made them independently. Not really a big
                            // deal, but to make sure our update gets applied set it to
                            // all of them
                            for (const rule of ruleSetters) {
                                const action = rule.actions[0];
                                if (action.value !== category) {
                                    await updateRule({
                                        ...rule,
                                        actions: [
                                            {
                                                ...action,
                                                value: category
                                            }
                                        ]
                                    });
                                }
                            }
                        }
                        else {
                            // No existing rules, so create one
                            const newRule = new _rules__WEBPACK_IMPORTED_MODULE_10__.Rule({
                                stage: null,
                                conditionsOp: 'and',
                                conditions: [
                                    {
                                        op: 'is',
                                        field: 'payee',
                                        value: payeeId
                                    }
                                ],
                                actions: [
                                    {
                                        op: 'set',
                                        field: 'category',
                                        value: category
                                    }
                                ],
                                fieldTypes: _shared_rules__WEBPACK_IMPORTED_MODULE_1__.FIELD_TYPES
                            });
                            await insertRule(newRule.serialize());
                        }
                    }
                });
            }
            /***/ 
        }),
        /***/ "./packages/loot-core/src/server/accounts/transactions.ts": 
        /*!****************************************************************!*\
          !*** ./packages/loot-core/src/server/accounts/transactions.ts ***!
          \****************************************************************/
        /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony export */ __webpack_require__.d(__webpack_exports__, {
                /* harmony export */ batchUpdateTransactions: () => ( /* binding */batchUpdateTransactions)
                /* harmony export */ 
            });
            /* harmony import */ var _platform_server_connection__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../platform/server/connection */ "./packages/loot-core/src/platform/server/connection/index.api.ts");
            /* harmony import */ var _db__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../db */ "./packages/loot-core/src/server/db/index.ts");
            /* harmony import */ var _db_util__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../db/util */ "./packages/loot-core/src/server/db/util.ts");
            /* harmony import */ var _sync__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../sync */ "./packages/loot-core/src/server/sync/index.ts");
            /* harmony import */ var _transaction_rules__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./transaction-rules */ "./packages/loot-core/src/server/accounts/transaction-rules.ts");
            /* harmony import */ var _transfer__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./transfer */ "./packages/loot-core/src/server/accounts/transfer.ts");
            // @ts-strict-ignore
            async function idsWithChildren(ids) {
                const whereIds = (0, _db_util__WEBPACK_IMPORTED_MODULE_2__.whereIn)(ids, 'parent_id');
                const rows = await _db__WEBPACK_IMPORTED_MODULE_1__.all(`SELECT id FROM v_transactions_internal WHERE ${whereIds}`);
                const set = new Set(ids);
                for (const row of rows) {
                    set.add(row.id);
                }
                return [
                    ...set
                ];
            }
            async function getTransactionsByIds(ids) {
                // TODO: convert to whereIn
                //
                // or better yet, use ActualQL
                return (0, _db_util__WEBPACK_IMPORTED_MODULE_2__.incrFetch)((query, params) => _db__WEBPACK_IMPORTED_MODULE_1__.selectWithSchema('transactions', query, params), ids, // eslint-disable-next-line rulesdir/typography
                (id) => `id = '${id}'`, (where) => `SELECT * FROM v_transactions_internal WHERE ${where}`);
            }
            async function batchUpdateTransactions({ added, deleted, updated, learnCategories = false, detectOrphanPayees = true, runTransfers = true }) {
                // Track the ids of each type of transaction change (see below for why)
                let addedIds = [];
                const updatedIds = updated ? updated.map((u) => u.id) : [];
                const deletedIds = deleted ? await idsWithChildren(deleted.map((d) => d.id)) : [];
                const oldPayees = new Set();
                const accounts = await _db__WEBPACK_IMPORTED_MODULE_1__.all('SELECT * FROM accounts WHERE tombstone = 0');
                // We need to get all the payees of updated transactions _before_
                // making changes
                if (updated) {
                    const descUpdatedIds = updated.filter((update) => update.payee).map((update) => update.id);
                    const transactions = await getTransactionsByIds(descUpdatedIds);
                    for (let i = 0; i < transactions.length; i++) {
                        oldPayees.add(transactions[i].payee);
                    }
                }
                // Apply all the updates. We can batch this now! This is important
                // and makes bulk updates much faster
                await (0, _sync__WEBPACK_IMPORTED_MODULE_3__.batchMessages)(async () => {
                    if (added) {
                        addedIds = await Promise.all(added.map(async (t) => _db__WEBPACK_IMPORTED_MODULE_1__.insertTransaction(t)));
                    }
                    if (deleted) {
                        await Promise.all(// It's important to use `deletedIds` and not `deleted` here
                        // because we've expanded it to include children above. The
                        // inconsistency of the delete APIs is annoying and should
                        // be fixed (it should only take an id)
                        deletedIds.map(async (id) => {
                            await _db__WEBPACK_IMPORTED_MODULE_1__.deleteTransaction({
                                id
                            });
                        }));
                    }
                    if (updated) {
                        await Promise.all(updated.map(async (t) => {
                            if (t.account) {
                                // Moving transactions off budget should always clear the
                                // category
                                const account = accounts.find((acct) => acct.id === t.account);
                                if (account.offbudget === 1) {
                                    t.category = null;
                                }
                            }
                            await _db__WEBPACK_IMPORTED_MODULE_1__.updateTransaction(t);
                        }));
                    }
                });
                // Get all of the full transactions that were changed. This is
                // needed to run any cascading logic that depends on the full
                // transaction. Things like transfers, analyzing rule updates, and
                // more
                const allAdded = await getTransactionsByIds(addedIds);
                const allUpdated = await getTransactionsByIds(updatedIds);
                const allDeleted = await getTransactionsByIds(deletedIds);
                // Post-processing phase: first do any updates to transfers.
                // Transfers update the transactions and we need to return updates
                // to the client so that can apply them. Note that added
                // transactions just return the full transaction.
                const resultAdded = allAdded;
                const resultUpdated = allUpdated;
                let transfersUpdated;
                if (runTransfers) {
                    await (0, _sync__WEBPACK_IMPORTED_MODULE_3__.batchMessages)(async () => {
                        await Promise.all(allAdded.map((t) => _transfer__WEBPACK_IMPORTED_MODULE_5__.onInsert(t)));
                        // Return any updates from here
                        transfersUpdated = (await Promise.all(allUpdated.map((t) => _transfer__WEBPACK_IMPORTED_MODULE_5__.onUpdate(t)))).filter(Boolean);
                        await Promise.all(allDeleted.map((t) => _transfer__WEBPACK_IMPORTED_MODULE_5__.onDelete(t)));
                    });
                }
                if (learnCategories) {
                    // Analyze any updated categories and update rules to learn from
                    // the user's activity
                    const ids = new Set([
                        ...added ? added.filter((add) => add.category).map((add) => add.id) : [],
                        ...updated ? updated.filter((update) => update.category).map((update) => update.id) : []
                    ]);
                    await _transaction_rules__WEBPACK_IMPORTED_MODULE_4__.updateCategoryRules(allAdded.concat(allUpdated).filter((trans) => ids.has(trans.id)));
                }
                if (detectOrphanPayees) {
                    // Look for any orphaned payees and notify the user about merging
                    // them
                    if (updated) {
                        const newPayeeIds = updated.map((u) => u.payee).filter(Boolean);
                        if (newPayeeIds.length > 0) {
                            const allOrphaned = new Set(await _db__WEBPACK_IMPORTED_MODULE_1__.getOrphanedPayees());
                            const orphanedIds = [
                                ...oldPayees
                            ].filter((id) => allOrphaned.has(id));
                            if (orphanedIds.length > 0) {
                                _platform_server_connection__WEBPACK_IMPORTED_MODULE_0__.send('orphaned-payees', {
                                    orphanedIds,
                                    updatedPayeeIds: newPayeeIds
                                });
                            }
                        }
                    }
                }
                return {
                    added: resultAdded,
                    updated: runTransfers ? transfersUpdated : resultUpdated
                };
            }
            /***/ 
        }),
        /***/ "./packages/loot-core/src/server/accounts/transfer.ts": 
        /*!************************************************************!*\
          !*** ./packages/loot-core/src/server/accounts/transfer.ts ***!
          \************************************************************/
        /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony export */ __webpack_require__.d(__webpack_exports__, {
                /* harmony export */ addTransfer: () => ( /* binding */addTransfer),
                /* harmony export */ onDelete: () => ( /* binding */onDelete),
                /* harmony export */ onInsert: () => ( /* binding */onInsert),
                /* harmony export */ onUpdate: () => ( /* binding */onUpdate),
                /* harmony export */ removeTransfer: () => ( /* binding */removeTransfer),
                /* harmony export */ updateTransfer: () => ( /* binding */updateTransfer)
                /* harmony export */ 
            });
            /* harmony import */ var _db__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../db */ "./packages/loot-core/src/server/db/index.ts");
            // @ts-strict-ignore
            async function getPayee(acct) {
                return _db__WEBPACK_IMPORTED_MODULE_0__.first('SELECT * FROM payees WHERE transfer_acct = ?', [
                    acct
                ]);
            }
            async function getTransferredAccount(transaction) {
                if (transaction.payee) {
                    const { transfer_acct } = await _db__WEBPACK_IMPORTED_MODULE_0__.first('SELECT id, transfer_acct FROM v_payees WHERE id = ?', [
                        transaction.payee
                    ]);
                    return transfer_acct;
                }
                return null;
            }
            async function clearCategory(transaction, transferAcct) {
                const { offbudget: fromOffBudget } = await _db__WEBPACK_IMPORTED_MODULE_0__.first('SELECT offbudget FROM accounts WHERE id = ?', [
                    transaction.account
                ]);
                const { offbudget: toOffBudget } = await _db__WEBPACK_IMPORTED_MODULE_0__.first('SELECT offbudget FROM accounts WHERE id = ?', [
                    transferAcct
                ]);
                // We should clear the category to make sure it's not being
                // accounted for in the budget, unless it should be in the case of
                // transferring from an on-budget to off-budget account
                if (fromOffBudget === toOffBudget) {
                    await _db__WEBPACK_IMPORTED_MODULE_0__.updateTransaction({
                        id: transaction.id,
                        category: null
                    });
                    return true;
                }
                return false;
            }
            async function addTransfer(transaction, transferredAccount) {
                if (transaction.is_parent) {
                    // For split transactions, we should create transfers using child transactions.
                    // This is to ensure that the amounts received by the transferred account
                    // reflects the amounts in the child transactions and not the parent transaction
                    // amount which is the total amount.
                    return null;
                }
                const { id: fromPayee } = await _db__WEBPACK_IMPORTED_MODULE_0__.first('SELECT id FROM payees WHERE transfer_acct = ?', [
                    transaction.account
                ]);
                // We need to enforce certain constraints with child transaction transfers
                if (transaction.parent_id) {
                    const row = await _db__WEBPACK_IMPORTED_MODULE_0__.first(`
        SELECT p.id, p.transfer_acct FROM v_transactions t
        LEFT JOIN payees p ON p.id = t.payee
        WHERE t.id = ?
      `, [
                        transaction.parent_id
                    ]);
                    if (row.transfer_acct) {
                        if (row.id !== transaction.payee) {
                            // This child transaction is trying to use a transfer payee,
                            // but the parent is already using a different transfer payee.
                            // This is not allowed, so not only do we do nothing, we clear
                            // the payee of the child transaction to make it clear
                            await _db__WEBPACK_IMPORTED_MODULE_0__.updateTransaction({
                                id: transaction.id,
                                payee: null
                            });
                            return {
                                id: transaction.id,
                                payee: null
                            };
                        }
                    }
                }
                const id = await _db__WEBPACK_IMPORTED_MODULE_0__.insertTransaction({
                    account: transferredAccount,
                    amount: -transaction.amount,
                    payee: fromPayee,
                    date: transaction.date,
                    transfer_id: transaction.id,
                    notes: transaction.notes || null,
                    schedule: transaction.schedule,
                    cleared: false
                });
                await _db__WEBPACK_IMPORTED_MODULE_0__.updateTransaction({
                    id: transaction.id,
                    transfer_id: id
                });
                const categoryCleared = await clearCategory(transaction, transferredAccount);
                return {
                    id: transaction.id,
                    transfer_id: id,
                    ...categoryCleared ? {
                        category: null
                    } : {}
                };
            }
            async function removeTransfer(transaction) {
                const transferTrans = await _db__WEBPACK_IMPORTED_MODULE_0__.getTransaction(transaction.transfer_id);
                // Perform operations on the transfer transaction only
                // if it is found. For example: when users delete both
                // (in & out) transfer transactions at the same time -
                // transfer transaction will not be found.
                if (transferTrans) {
                    if (transferTrans.is_child) {
                        // If it's a child transaction, we don't delete it because that
                        // would invalidate the whole split transaction. Instead of turn
                        // it into a normal transaction
                        await _db__WEBPACK_IMPORTED_MODULE_0__.updateTransaction({
                            id: transaction.transfer_id,
                            transfer_id: null,
                            payee: null
                        });
                    }
                    else {
                        await _db__WEBPACK_IMPORTED_MODULE_0__.deleteTransaction({
                            id: transaction.transfer_id
                        });
                    }
                }
                await _db__WEBPACK_IMPORTED_MODULE_0__.updateTransaction({
                    id: transaction.id,
                    transfer_id: null
                });
                return {
                    id: transaction.id,
                    transfer_id: null
                };
            }
            async function updateTransfer(transaction, transferredAccount) {
                const payee = await getPayee(transaction.account);
                await _db__WEBPACK_IMPORTED_MODULE_0__.updateTransaction({
                    id: transaction.transfer_id,
                    account: transferredAccount,
                    // Make sure to update the payee on the other side in case the
                    // user moved this transaction into another account
                    payee: payee.id,
                    date: transaction.date,
                    notes: transaction.notes,
                    amount: -transaction.amount,
                    schedule: transaction.schedule
                });
                const categoryCleared = await clearCategory(transaction, transferredAccount);
                if (categoryCleared) {
                    return {
                        id: transaction.id,
                        category: null
                    };
                }
            }
            async function onInsert(transaction) {
                const transferredAccount = await getTransferredAccount(transaction);
                if (transferredAccount) {
                    return addTransfer(transaction, transferredAccount);
                }
            }
            async function onDelete(transaction) {
                if (transaction.transfer_id) {
                    await removeTransfer(transaction);
                }
            }
            async function onUpdate(transaction) {
                const transferredAccount = await getTransferredAccount(transaction);
                if (transaction.is_parent) {
                    return removeTransfer(transaction);
                }
                if (transferredAccount && !transaction.transfer_id) {
                    return addTransfer(transaction, transferredAccount);
                }
                if (!transferredAccount && transaction.transfer_id) {
                    return removeTransfer(transaction);
                }
                if (transferredAccount && transaction.transfer_id) {
                    return updateTransfer(transaction, transferredAccount);
                }
            }
            /***/ 
        }),
        /***/ "./packages/loot-core/src/server/accounts/xmlcamt2json.ts": 
        /*!****************************************************************!*\
          !*** ./packages/loot-core/src/server/accounts/xmlcamt2json.ts ***!
          \****************************************************************/
        /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony export */ __webpack_require__.d(__webpack_exports__, {
                /* harmony export */ xmlCAMT2json: () => ( /* binding */xmlCAMT2json)
                /* harmony export */ 
            });
            /* harmony import */ var xml2js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! xml2js */ "./node_modules/xml2js/lib/xml2js.js");
            /* harmony import */ var xml2js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/ __webpack_require__.n(xml2js__WEBPACK_IMPORTED_MODULE_0__);
            // @ts-strict-ignore
            function findKeys(obj, key) {
                let result = [];
                for (const i in obj) {
                    if (!obj.hasOwnProperty(i))
                        continue;
                    if (i === key) {
                        if (Array.isArray(obj[i])) {
                            result = result.concat(obj[i]);
                        }
                        else {
                            result.push(obj[i]);
                        }
                    }
                    if (typeof obj[i] === 'object') {
                        result = result.concat(findKeys(obj[i], key));
                    }
                }
                return result;
            }
            function getPayeeNameFromTxDtls(TxDtls, isDebit) {
                if (TxDtls?.RltdPties) {
                    const key = isDebit ? TxDtls.RltdPties.Cdtr : TxDtls.RltdPties.Dbtr;
                    const Nm = findKeys(key, 'Nm');
                    return Nm.length > 0 ? Nm[0] : null;
                }
                return null;
            }
            function getNotesFromTxDtls(TxDtls) {
                if (TxDtls?.RmtInf) {
                    const Ustrd = TxDtls.RmtInf.Ustrd;
                    return Array.isArray(Ustrd) ? Ustrd.join(' ') : Ustrd;
                }
                return null;
            }
            function convertToNumberOrNull(value) {
                const number = Number(value);
                return isNaN(number) ? null : number;
            }
            function getDtOrDtTm(Date) {
                if (!Date) {
                    return null;
                }
                if ('DtTm' in Date) {
                    return Date.DtTm.slice(0, 10);
                }
                return Date?.Dt;
            }
            async function xmlCAMT2json(content) {
                const data = await (0, xml2js__WEBPACK_IMPORTED_MODULE_0__.parseStringPromise)(content, {
                    explicitArray: false
                });
                const entries = findKeys(data, 'Ntry');
                const transactions = [];
                for (const entry of entries) {
                    /*
                  For (camt.052/054) could filter on entry.Sts= BOOK or PDNG, currently importing all entries
                */ const id = entry.AcctSvcrRef;
                    const amount = convertToNumberOrNull(entry.Amt?._);
                    const isDebit = entry.CdtDbtInd === 'DBIT';
                    const date = getDtOrDtTm(entry.ValDt) || getDtOrDtTm(entry.BookgDt);
                    if (Array.isArray(entry.NtryDtls?.TxDtls)) {
                        // we add subtransactions as normal transactions as importing split with subtransactions is not supported
                        // amount, and payee_name are not processed correctly for subtransaction.
                        entry.NtryDtls.TxDtls.forEach((TxDtls) => {
                            const subPayee = getPayeeNameFromTxDtls(TxDtls, isDebit);
                            const subNotes = getNotesFromTxDtls(TxDtls);
                            const Amt = findKeys(TxDtls, 'Amt');
                            const amount = Amt.length > 0 ? convertToNumberOrNull(Amt[0]._) : null;
                            transactions.push({
                                amount: isDebit ? -amount : amount,
                                date,
                                payee_name: subPayee,
                                imported_payee: subPayee,
                                notes: subNotes
                            });
                        });
                    }
                    else {
                        let payee_name;
                        let notes;
                        payee_name = getPayeeNameFromTxDtls(entry.NtryDtls?.TxDtls, isDebit);
                        if (!payee_name && entry.AddtlNtryInf) {
                            payee_name = entry.AddtlNtryInf;
                        }
                        notes = getNotesFromTxDtls(entry.NtryDtls?.TxDtls);
                        if (!notes && entry.AddtlNtryInf && entry.AddtlNtryInf !== payee_name) {
                            notes = entry.AddtlNtryInf;
                        }
                        if (!payee_name && !notes && entry.NtryRef) {
                            notes = entry.NtryRef;
                        }
                        if (payee_name && notes && payee_name.includes(notes)) {
                            notes = null;
                        }
                        const transaction = {
                            amount: isDebit ? -amount : amount,
                            date,
                            payee_name,
                            imported_payee: payee_name,
                            notes
                        };
                        if (id) {
                            transaction.imported_id = id;
                        }
                        transactions.push(transaction);
                    }
                }
                return transactions.filter((trans) => trans.date != null && trans.amount != null);
            }
            /***/ 
        }),
        /***/ "./packages/loot-core/src/server/api-models.ts": 
        /*!*****************************************************!*\
          !*** ./packages/loot-core/src/server/api-models.ts ***!
          \*****************************************************/
        /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony export */ __webpack_require__.d(__webpack_exports__, {
                /* harmony export */ accountModel: () => ( /* binding */accountModel),
                /* harmony export */ budgetModel: () => ( /* binding */budgetModel),
                /* harmony export */ categoryGroupModel: () => ( /* binding */categoryGroupModel),
                /* harmony export */ categoryModel: () => ( /* binding */categoryModel),
                /* harmony export */ payeeModel: () => ( /* binding */payeeModel),
                /* harmony export */ remoteFileModel: () => ( /* binding */remoteFileModel)
                /* harmony export */ 
            });
            /* harmony import */ var _models__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./models */ "./packages/loot-core/src/server/models.ts");
            const accountModel = {
                ..._models__WEBPACK_IMPORTED_MODULE_0__.accountModel,
                toExternal(account) {
                    return {
                        id: account.id,
                        name: account.name,
                        offbudget: account.offbudget ? true : false,
                        closed: account.closed ? true : false
                    };
                },
                fromExternal(account) {
                    const result = {
                        ...account
                    };
                    if ('offbudget' in account) {
                        result.offbudget = account.offbudget ? 1 : 0;
                    }
                    if ('closed' in account) {
                        result.closed = account.closed ? 1 : 0;
                    }
                    return result;
                }
            };
            const categoryModel = {
                ..._models__WEBPACK_IMPORTED_MODULE_0__.categoryModel,
                toExternal(category) {
                    return {
                        id: category.id,
                        name: category.name,
                        is_income: category.is_income ? true : false,
                        hidden: category.hidden ? true : false,
                        group_id: category.cat_group
                    };
                },
                fromExternal(category) {
                    const { group_id: _, ...result } = category;
                    if ('group_id' in category) {
                        result.cat_group = category.group_id;
                    }
                    return result;
                }
            };
            const categoryGroupModel = {
                ..._models__WEBPACK_IMPORTED_MODULE_0__.categoryGroupModel,
                toExternal(group) {
                    return {
                        id: group.id,
                        name: group.name,
                        is_income: group.is_income ? true : false,
                        hidden: group.hidden ? true : false,
                        categories: group.categories?.map(categoryModel.toExternal) || []
                    };
                },
                fromExternal(group) {
                    const result = {
                        ...group
                    };
                    if ('categories' in group) {
                        result.categories = group.categories.map(categoryModel.fromExternal);
                    }
                    return result;
                }
            };
            const payeeModel = {
                ..._models__WEBPACK_IMPORTED_MODULE_0__.payeeModel,
                toExternal(payee) {
                    return {
                        id: payee.id,
                        name: payee.name,
                        transfer_acct: payee.transfer_acct
                    };
                },
                fromExternal(payee) {
                    // No translation is needed
                    return payee;
                }
            };
            const remoteFileModel = {
                toExternal(file) {
                    if (file.deleted) {
                        return null;
                    }
                    return {
                        cloudFileId: file.fileId,
                        state: 'remote',
                        groupId: file.groupId,
                        name: file.name,
                        encryptKeyId: file.encryptKeyId,
                        hasKey: file.hasKey
                    };
                },
                fromExternal(file) {
                    return {
                        deleted: false,
                        fileId: file.cloudFileId,
                        ...file
                    };
                }
            };
            const budgetModel = {
                toExternal(file) {
                    return file;
                },
                fromExternal(file) {
                    return file;
                }
            };
            /***/ 
        }),
        /***/ "./packages/loot-core/src/server/api.ts": 
        /*!**********************************************!*\
          !*** ./packages/loot-core/src/server/api.ts ***!
          \**********************************************/
        /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony export */ __webpack_require__.d(__webpack_exports__, {
                /* harmony export */ installAPI: () => ( /* binding */installAPI)
                /* harmony export */ 
            });
            /* harmony import */ var _actual_app_crdt__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @actual-app/crdt */ "@actual-app/crdt");
            /* harmony import */ var _actual_app_crdt__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/ __webpack_require__.n(_actual_app_crdt__WEBPACK_IMPORTED_MODULE_0__);
            /* harmony import */ var _platform_server_connection__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../platform/server/connection */ "./packages/loot-core/src/platform/server/connection/index.api.ts");
            /* harmony import */ var _shared_errors__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../shared/errors */ "./packages/loot-core/src/shared/errors.ts");
            /* harmony import */ var _shared_months__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../shared/months */ "./packages/loot-core/src/shared/months.ts");
            /* harmony import */ var _shared_query__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../shared/query */ "./packages/loot-core/src/shared/query.ts");
            /* harmony import */ var _shared_transactions__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../shared/transactions */ "./packages/loot-core/src/shared/transactions.ts");
            /* harmony import */ var _shared_util__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../shared/util */ "./packages/loot-core/src/shared/util.ts");
            /* harmony import */ var _accounts_sync__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./accounts/sync */ "./packages/loot-core/src/server/accounts/sync.ts");
            /* harmony import */ var _api_models__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./api-models */ "./packages/loot-core/src/server/api-models.ts");
            /* harmony import */ var _aql__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./aql */ "./packages/loot-core/src/server/aql/index.ts");
            /* harmony import */ var _cloud_storage__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./cloud-storage */ "./packages/loot-core/src/server/cloud-storage.ts");
            /* harmony import */ var _db__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./db */ "./packages/loot-core/src/server/db/index.ts");
            /* harmony import */ var _errors__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./errors */ "./packages/loot-core/src/server/errors.ts");
            /* harmony import */ var _mutators__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./mutators */ "./packages/loot-core/src/server/mutators.ts");
            /* harmony import */ var _prefs__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./prefs */ "./packages/loot-core/src/server/prefs.ts");
            /* harmony import */ var _sheet__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./sheet */ "./packages/loot-core/src/server/sheet.ts");
            /* harmony import */ var _sync__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./sync */ "./packages/loot-core/src/server/sync/index.ts");
            // @ts-strict-ignore
            let IMPORT_MODE = false;
            // The API is different in two ways: we never want undo enabled, and
            // we also need to notify the UI manually if stuff has changed (if
            // they are connecting to an already running instance, the UI should
            // update). The wrapper handles that.
            function withMutation(handler) {
                return (args) => {
                    return (0, _mutators__WEBPACK_IMPORTED_MODULE_13__.runMutator)(async () => {
                        const latestTimestamp = (0, _actual_app_crdt__WEBPACK_IMPORTED_MODULE_0__.getClock)().timestamp.toString();
                        const result = await handler(args);
                        const rows = await _db__WEBPACK_IMPORTED_MODULE_11__.all('SELECT DISTINCT dataset FROM messages_crdt WHERE timestamp > ?', [
                            latestTimestamp
                        ]);
                        // Only send the sync event if anybody else is connected
                        if (_platform_server_connection__WEBPACK_IMPORTED_MODULE_1__.getNumClients() > 1) {
                            _platform_server_connection__WEBPACK_IMPORTED_MODULE_1__.send('sync-event', {
                                type: 'success',
                                tables: rows.map((row) => row.dataset)
                            });
                        }
                        return result;
                    }, {
                        undoDisabled: true
                    });
                };
            }
            let handlers = {};
            async function validateMonth(month) {
                if (!month.match(/^\d{4}-\d{2}$/)) {
                    throw (0, _errors__WEBPACK_IMPORTED_MODULE_12__.APIError)('Invalid month format, use YYYY-MM: ' + month);
                }
                if (!IMPORT_MODE) {
                    const { start, end } = await handlers['get-budget-bounds']();
                    const range = _shared_months__WEBPACK_IMPORTED_MODULE_3__.range(start, end);
                    if (!range.includes(month)) {
                        throw (0, _errors__WEBPACK_IMPORTED_MODULE_12__.APIError)('No budget exists for month: ' + month);
                    }
                }
            }
            async function validateExpenseCategory(debug, id) {
                if (id == null) {
                    throw (0, _errors__WEBPACK_IMPORTED_MODULE_12__.APIError)(`${debug}: category id is required`);
                }
                const row = await _db__WEBPACK_IMPORTED_MODULE_11__.first('SELECT is_income FROM categories WHERE id = ?', [
                    id
                ]);
                if (!row) {
                    throw (0, _errors__WEBPACK_IMPORTED_MODULE_12__.APIError)(`${debug}: category ${id} does not exist`);
                }
                if (row.is_income !== 0) {
                    throw (0, _errors__WEBPACK_IMPORTED_MODULE_12__.APIError)(`${debug}: category ${id} is not an expense category`);
                }
            }
            function checkFileOpen() {
                if (!(_prefs__WEBPACK_IMPORTED_MODULE_14__.getPrefs() || {}).id) {
                    throw (0, _errors__WEBPACK_IMPORTED_MODULE_12__.APIError)('No budget file is open');
                }
            }
            let batchPromise = null;
            handlers['api/batch-budget-start'] = async function () {
                if (batchPromise) {
                    throw (0, _errors__WEBPACK_IMPORTED_MODULE_12__.APIError)('Cannot start a batch process: batch already started');
                }
                // If we are importing, all we need to do is start a raw database
                // transaction. Updating spreadsheet cells doesn't go through the
                // syncing layer in that case.
                if (IMPORT_MODE) {
                    _db__WEBPACK_IMPORTED_MODULE_11__.asyncTransaction(() => {
                        return new Promise((resolve, reject) => {
                            batchPromise = {
                                resolve,
                                reject
                            };
                        });
                    });
                }
                else {
                    (0, _sync__WEBPACK_IMPORTED_MODULE_16__.batchMessages)(() => {
                        return new Promise((resolve, reject) => {
                            batchPromise = {
                                resolve,
                                reject
                            };
                        });
                    });
                }
            };
            handlers['api/batch-budget-end'] = async function () {
                if (!batchPromise) {
                    throw (0, _errors__WEBPACK_IMPORTED_MODULE_12__.APIError)('Cannot end a batch process: no batch started');
                }
                batchPromise.resolve();
                batchPromise = null;
            };
            handlers['api/load-budget'] = async function ({ id }) {
                const { id: currentId } = _prefs__WEBPACK_IMPORTED_MODULE_14__.getPrefs() || {};
                if (currentId !== id) {
                    _platform_server_connection__WEBPACK_IMPORTED_MODULE_1__.send('start-load');
                    const { error } = await handlers['load-budget']({
                        id
                    });
                    if (!error) {
                        _platform_server_connection__WEBPACK_IMPORTED_MODULE_1__.send('finish-load');
                    }
                    else {
                        _platform_server_connection__WEBPACK_IMPORTED_MODULE_1__.send('show-budgets');
                        throw new Error((0, _shared_errors__WEBPACK_IMPORTED_MODULE_2__.getSyncError)(error, id));
                    }
                }
            };
            handlers['api/download-budget'] = async function ({ syncId, password }) {
                const { id: currentId } = _prefs__WEBPACK_IMPORTED_MODULE_14__.getPrefs() || {};
                if (currentId) {
                    await handlers['close-budget']();
                }
                const budgets = await handlers['get-budgets']();
                const localBudget = budgets.find((b) => b.groupId === syncId);
                let remoteBudget;
                // Load a remote file if we could not find the file locally
                if (!localBudget) {
                    const files = await handlers['get-remote-files']();
                    if (!files) {
                        throw new Error('Could not get remote files');
                    }
                    const file = files.find((f) => f.groupId === syncId);
                    if (!file) {
                        throw new Error(`Budget ${syncId} not found. Check the sync id of your budget in the Advanced section of the settings page.`);
                    }
                    remoteBudget = file;
                }
                const activeFile = remoteBudget ? remoteBudget : localBudget;
                // Set the e2e encryption keys
                if (activeFile.encryptKeyId) {
                    if (!password) {
                        throw new Error(`File ${activeFile.name} is encrypted. Please provide a password.`);
                    }
                    const result = await handlers['key-test']({
                        fileId: remoteBudget ? remoteBudget.fileId : localBudget.cloudFileId,
                        password
                    });
                    if (result.error) {
                        throw new Error((0, _shared_errors__WEBPACK_IMPORTED_MODULE_2__.getTestKeyError)(result.error));
                    }
                }
                // Sync the local budget file
                if (localBudget) {
                    await handlers['load-budget']({
                        id: localBudget.id
                    });
                    const result = await handlers['sync-budget']();
                    if (result.error) {
                        throw new Error((0, _shared_errors__WEBPACK_IMPORTED_MODULE_2__.getSyncError)(result.error, localBudget.id));
                    }
                    return;
                }
                // Download the remote file (no need to perform a sync as the file will already be up-to-date)
                const result = await handlers['download-budget']({
                    fileId: remoteBudget.fileId
                });
                if (result.error) {
                    console.log('Full error details', result.error);
                    throw new Error((0, _shared_errors__WEBPACK_IMPORTED_MODULE_2__.getDownloadError)(result.error));
                }
                await handlers['load-budget']({
                    id: result.id
                });
            };
            handlers['api/get-budgets'] = async function () {
                const budgets = await handlers['get-budgets']();
                const files = await handlers['get-remote-files']() || [];
                return [
                    ...budgets.map((file) => _api_models__WEBPACK_IMPORTED_MODULE_8__.budgetModel.toExternal(file)),
                    ...files.map((file) => _api_models__WEBPACK_IMPORTED_MODULE_8__.remoteFileModel.toExternal(file)).filter((file) => file)
                ];
            };
            handlers['api/sync'] = async function () {
                const { id } = _prefs__WEBPACK_IMPORTED_MODULE_14__.getPrefs();
                const result = await handlers['sync-budget']();
                if (result.error) {
                    throw new Error((0, _shared_errors__WEBPACK_IMPORTED_MODULE_2__.getSyncError)(result.error, id));
                }
            };
            handlers['api/bank-sync'] = async function (args) {
                const { errors } = await handlers['accounts-bank-sync']({
                    id: args?.accountId
                });
                const [firstError] = errors;
                if (firstError) {
                    throw new Error((0, _shared_errors__WEBPACK_IMPORTED_MODULE_2__.getBankSyncError)(firstError));
                }
            };
            handlers['api/start-import'] = async function ({ budgetName }) {
                // Notify UI to close budget
                await handlers['close-budget']();
                // Create the budget
                await handlers['create-budget']({
                    budgetName,
                    avoidUpload: true
                });
                // Clear out the default expense categories
                await _db__WEBPACK_IMPORTED_MODULE_11__.runQuery('DELETE FROM categories WHERE is_income = 0');
                await _db__WEBPACK_IMPORTED_MODULE_11__.runQuery('DELETE FROM category_groups WHERE is_income = 0');
                // Turn syncing off
                (0, _sync__WEBPACK_IMPORTED_MODULE_16__.setSyncingMode)('import');
                _platform_server_connection__WEBPACK_IMPORTED_MODULE_1__.send('start-import');
                IMPORT_MODE = true;
            };
            handlers['api/finish-import'] = async function () {
                checkFileOpen();
                _sheet__WEBPACK_IMPORTED_MODULE_15__.get().markCacheDirty();
                // We always need to fully reload the app. Importing doesn't touch
                // the spreadsheet, but we can't just recreate the spreadsheet
                // either; there is other internal state that isn't created
                const { id } = _prefs__WEBPACK_IMPORTED_MODULE_14__.getPrefs();
                await handlers['close-budget']();
                await handlers['load-budget']({
                    id
                });
                await handlers['get-budget-bounds']();
                await _sheet__WEBPACK_IMPORTED_MODULE_15__.waitOnSpreadsheet();
                await _cloud_storage__WEBPACK_IMPORTED_MODULE_10__.upload().catch(() => { });
                _platform_server_connection__WEBPACK_IMPORTED_MODULE_1__.send('finish-import');
                IMPORT_MODE = false;
            };
            handlers['api/abort-import'] = async function () {
                if (IMPORT_MODE) {
                    checkFileOpen();
                    const { id } = _prefs__WEBPACK_IMPORTED_MODULE_14__.getPrefs();
                    await handlers['close-budget']();
                    await handlers['delete-budget']({
                        id
                    });
                    _platform_server_connection__WEBPACK_IMPORTED_MODULE_1__.send('show-budgets');
                }
                IMPORT_MODE = false;
            };
            handlers['api/query'] = async function ({ query }) {
                checkFileOpen();
                return (0, _aql__WEBPACK_IMPORTED_MODULE_9__.runQuery)(query);
            };
            handlers['api/budget-months'] = async function () {
                checkFileOpen();
                const { start, end } = await handlers['get-budget-bounds']();
                return _shared_months__WEBPACK_IMPORTED_MODULE_3__.range(start, end);
            };
            handlers['api/budget-month'] = async function ({ month }) {
                checkFileOpen();
                await validateMonth(month);
                const groups = await _db__WEBPACK_IMPORTED_MODULE_11__.getCategoriesGrouped();
                const sheetName = _shared_months__WEBPACK_IMPORTED_MODULE_3__.sheetForMonth(month);
                function value(name) {
                    const v = _sheet__WEBPACK_IMPORTED_MODULE_15__.get().getCellValue(sheetName, name);
                    return v === '' ? 0 : v;
                }
                // This is duplicated from main.js because the return format is
                // different (for now)
                return {
                    month,
                    incomeAvailable: value('available-funds'),
                    lastMonthOverspent: value('last-month-overspent'),
                    forNextMonth: value('buffered'),
                    totalBudgeted: value('total-budgeted'),
                    toBudget: value('to-budget'),
                    fromLastMonth: value('from-last-month'),
                    totalIncome: value('total-income'),
                    totalSpent: value('total-spent'),
                    totalBalance: value('total-leftover'),
                    categoryGroups: groups.map((group) => {
                        if (group.is_income) {
                            return {
                                ..._api_models__WEBPACK_IMPORTED_MODULE_8__.categoryGroupModel.toExternal(group),
                                received: value('total-income'),
                                categories: group.categories.map((cat) => ({
                                    ..._api_models__WEBPACK_IMPORTED_MODULE_8__.categoryModel.toExternal(cat),
                                    received: value(`sum-amount-${cat.id}`)
                                }))
                            };
                        }
                        return {
                            ..._api_models__WEBPACK_IMPORTED_MODULE_8__.categoryGroupModel.toExternal(group),
                            budgeted: value(`group-budget-${group.id}`),
                            spent: value(`group-sum-amount-${group.id}`),
                            balance: value(`group-leftover-${group.id}`),
                            categories: group.categories.map((cat) => ({
                                ..._api_models__WEBPACK_IMPORTED_MODULE_8__.categoryModel.toExternal(cat),
                                budgeted: value(`budget-${cat.id}`),
                                spent: value(`sum-amount-${cat.id}`),
                                balance: value(`leftover-${cat.id}`),
                                carryover: value(`carryover-${cat.id}`)
                            }))
                        };
                    })
                };
            };
            handlers['api/budget-set-amount'] = withMutation(async function ({ month, categoryId, amount }) {
                checkFileOpen();
                return handlers['budget/budget-amount']({
                    month,
                    category: categoryId,
                    amount
                });
            });
            handlers['api/budget-set-carryover'] = withMutation(async function ({ month, categoryId, flag }) {
                checkFileOpen();
                await validateMonth(month);
                await validateExpenseCategory('budget-set-carryover', categoryId);
                return handlers['budget/set-carryover']({
                    startMonth: month,
                    category: categoryId,
                    flag
                });
            });
            handlers['api/transactions-export'] = async function ({ transactions, categoryGroups, payees }) {
                checkFileOpen();
                return handlers['transactions-export']({
                    transactions,
                    categoryGroups,
                    payees
                });
            };
            handlers['api/transactions-import'] = withMutation(async function ({ accountId, transactions, isPreview = false }) {
                checkFileOpen();
                return handlers['transactions-import']({
                    accountId,
                    transactions,
                    isPreview
                });
            });
            handlers['api/transactions-add'] = withMutation(async function ({ accountId, transactions, runTransfers = false, learnCategories = false }) {
                checkFileOpen();
                await (0, _accounts_sync__WEBPACK_IMPORTED_MODULE_7__.addTransactions)(accountId, transactions, {
                    runTransfers,
                    learnCategories
                });
                return 'ok';
            });
            handlers['api/transactions-get'] = async function ({ accountId, startDate, endDate }) {
                checkFileOpen();
                const { data } = await (0, _aql__WEBPACK_IMPORTED_MODULE_9__.runQuery)((0, _shared_query__WEBPACK_IMPORTED_MODULE_4__.q)('transactions').filter({
                    $and: [
                        accountId && {
                            account: accountId
                        },
                        startDate && {
                            date: {
                                $gte: startDate
                            }
                        },
                        endDate && {
                            date: {
                                $lte: endDate
                            }
                        }
                    ].filter(Boolean)
                }).select('*').options({
                    splits: 'grouped'
                }));
                return data;
            };
            handlers['api/transaction-update'] = withMutation(async function ({ id, fields }) {
                checkFileOpen();
                const { data } = await (0, _aql__WEBPACK_IMPORTED_MODULE_9__.runQuery)((0, _shared_query__WEBPACK_IMPORTED_MODULE_4__.q)('transactions').filter({
                    id
                }).select('*').options({
                    splits: 'grouped'
                }));
                const transactions = (0, _shared_transactions__WEBPACK_IMPORTED_MODULE_5__.ungroupTransactions)(data);
                if (transactions.length === 0) {
                    return [];
                }
                const { diff } = (0, _shared_transactions__WEBPACK_IMPORTED_MODULE_5__.updateTransaction)(transactions, {
                    id,
                    ...fields
                });
                return handlers['transactions-batch-update'](diff);
            });
            handlers['api/transaction-delete'] = withMutation(async function ({ id }) {
                checkFileOpen();
                const { data } = await (0, _aql__WEBPACK_IMPORTED_MODULE_9__.runQuery)((0, _shared_query__WEBPACK_IMPORTED_MODULE_4__.q)('transactions').filter({
                    id
                }).select('*').options({
                    splits: 'grouped'
                }));
                const transactions = (0, _shared_transactions__WEBPACK_IMPORTED_MODULE_5__.ungroupTransactions)(data);
                if (transactions.length === 0) {
                    return [];
                }
                const { diff } = (0, _shared_transactions__WEBPACK_IMPORTED_MODULE_5__.deleteTransaction)(transactions, id);
                return handlers['transactions-batch-update'](diff);
            });
            handlers['api/accounts-get'] = async function () {
                checkFileOpen();
                const accounts = await _db__WEBPACK_IMPORTED_MODULE_11__.getAccounts();
                return accounts.map((account) => _api_models__WEBPACK_IMPORTED_MODULE_8__.accountModel.toExternal(account));
            };
            handlers['api/account-create'] = withMutation(async function ({ account, initialBalance = null }) {
                checkFileOpen();
                return handlers['account-create']({
                    name: account.name,
                    offBudget: account.offbudget,
                    closed: account.closed,
                    // Current the API expects an amount but it really should expect
                    // an integer
                    balance: initialBalance != null ? (0, _shared_util__WEBPACK_IMPORTED_MODULE_6__.integerToAmount)(initialBalance) : null
                });
            });
            handlers['api/account-update'] = withMutation(async function ({ id, fields }) {
                checkFileOpen();
                return _db__WEBPACK_IMPORTED_MODULE_11__.updateAccount({
                    id,
                    ..._api_models__WEBPACK_IMPORTED_MODULE_8__.accountModel.fromExternal(fields)
                });
            });
            handlers['api/account-close'] = withMutation(async function ({ id, transferAccountId, transferCategoryId }) {
                checkFileOpen();
                return handlers['account-close']({
                    id,
                    transferAccountId,
                    categoryId: transferCategoryId
                });
            });
            handlers['api/account-reopen'] = withMutation(async function ({ id }) {
                checkFileOpen();
                return handlers['account-reopen']({
                    id
                });
            });
            handlers['api/account-delete'] = withMutation(async function ({ id }) {
                checkFileOpen();
                return handlers['account-close']({
                    id,
                    forced: true
                });
            });
            handlers['api/account-balance'] = withMutation(async function ({ id, cutoff = new Date() }) {
                checkFileOpen();
                return handlers['account-balance']({
                    id,
                    cutoff
                });
            });
            handlers['api/categories-get'] = async function ({ grouped } = {}) {
                checkFileOpen();
                const result = await handlers['get-categories']();
                return grouped ? result.grouped.map(_api_models__WEBPACK_IMPORTED_MODULE_8__.categoryGroupModel.toExternal) : result.list.map(_api_models__WEBPACK_IMPORTED_MODULE_8__.categoryModel.toExternal);
            };
            handlers['api/category-groups-get'] = async function () {
                checkFileOpen();
                return handlers['get-category-groups']();
            };
            handlers['api/category-group-create'] = withMutation(async function ({ group }) {
                checkFileOpen();
                return handlers['category-group-create']({
                    name: group.name
                });
            });
            handlers['api/category-group-update'] = withMutation(async function ({ id, fields }) {
                checkFileOpen();
                return handlers['category-group-update']({
                    id,
                    ..._api_models__WEBPACK_IMPORTED_MODULE_8__.categoryGroupModel.fromExternal(fields)
                });
            });
            handlers['api/category-group-delete'] = withMutation(async function ({ id, transferCategoryId }) {
                checkFileOpen();
                return handlers['category-group-delete']({
                    id,
                    transferId: transferCategoryId
                });
            });
            handlers['api/category-create'] = withMutation(async function ({ category }) {
                checkFileOpen();
                return handlers['category-create']({
                    name: category.name,
                    groupId: category.group_id,
                    isIncome: category.is_income,
                    hidden: category.hidden
                });
            });
            handlers['api/category-update'] = withMutation(async function ({ id, fields }) {
                checkFileOpen();
                return handlers['category-update']({
                    id,
                    ..._api_models__WEBPACK_IMPORTED_MODULE_8__.categoryModel.fromExternal(fields)
                });
            });
            handlers['api/category-delete'] = withMutation(async function ({ id, transferCategoryId }) {
                checkFileOpen();
                return handlers['category-delete']({
                    id,
                    transferId: transferCategoryId
                });
            });
            handlers['api/common-payees-get'] = async function () {
                checkFileOpen();
                const payees = await handlers['common-payees-get']();
                return payees.map(_api_models__WEBPACK_IMPORTED_MODULE_8__.payeeModel.toExternal);
            };
            handlers['api/payees-get'] = async function () {
                checkFileOpen();
                const payees = await handlers['payees-get']();
                return payees.map(_api_models__WEBPACK_IMPORTED_MODULE_8__.payeeModel.toExternal);
            };
            handlers['api/payee-create'] = withMutation(async function ({ payee }) {
                checkFileOpen();
                return handlers['payee-create']({
                    name: payee.name
                });
            });
            handlers['api/payee-update'] = withMutation(async function ({ id, fields }) {
                checkFileOpen();
                return handlers['payees-batch-change']({
                    updated: [
                        {
                            id,
                            ..._api_models__WEBPACK_IMPORTED_MODULE_8__.payeeModel.fromExternal(fields)
                        }
                    ]
                });
            });
            handlers['api/payee-delete'] = withMutation(async function ({ id }) {
                checkFileOpen();
                return handlers['payees-batch-change']({
                    deleted: [
                        {
                            id
                        }
                    ]
                });
            });
            handlers['api/payees-merge'] = withMutation(async function ({ targetId, mergeIds }) {
                checkFileOpen();
                return handlers['payees-merge']({
                    targetId,
                    mergeIds
                });
            });
            handlers['api/rules-get'] = async function () {
                checkFileOpen();
                return handlers['rules-get']();
            };
            handlers['api/payee-rules-get'] = async function ({ id }) {
                checkFileOpen();
                return handlers['payees-get-rules']({
                    id
                });
            };
            handlers['api/rule-create'] = withMutation(async function ({ rule }) {
                checkFileOpen();
                const addedRule = await handlers['rule-add'](rule);
                if ('error' in addedRule) {
                    throw (0, _errors__WEBPACK_IMPORTED_MODULE_12__.APIError)('Failed creating a new rule', addedRule.error);
                }
                return addedRule;
            });
            handlers['api/rule-update'] = withMutation(async function ({ rule }) {
                checkFileOpen();
                const updatedRule = handlers['rule-update'](rule);
                if ('error' in updatedRule) {
                    throw (0, _errors__WEBPACK_IMPORTED_MODULE_12__.APIError)('Failed updating the rule', updatedRule.error);
                }
                return updatedRule;
            });
            handlers['api/rule-delete'] = withMutation(async function ({ id }) {
                checkFileOpen();
                return handlers['rule-delete'](id);
            });
            function installAPI(serverHandlers) {
                const merged = Object.assign({}, serverHandlers, handlers);
                handlers = merged;
                return merged;
            }
            /***/ 
        }),
        /***/ "./packages/loot-core/src/server/app.ts": 
        /*!**********************************************!*\
          !*** ./packages/loot-core/src/server/app.ts ***!
          \**********************************************/
        /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony export */ __webpack_require__.d(__webpack_exports__, {
                /* harmony export */ createApp: () => ( /* binding */createApp)
                /* harmony export */ 
            });
            /* harmony import */ var mitt__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! mitt */ "./node_modules/mitt/dist/mitt.mjs");
            /* harmony import */ var _platform_exceptions__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../platform/exceptions */ "./packages/loot-core/src/platform/exceptions/index.electron.ts");
            // @ts-strict-ignore
            // This is a simple helper abstraction for defining methods exposed to
            // the client. It doesn't do much, but checks for naming conflicts and
            // makes it cleaner to combine methods. We call a group of related
            // methods an "app".
            class App {
                constructor() {
                    this.handlers = {};
                    this.services = [];
                    this.events = (0, mitt__WEBPACK_IMPORTED_MODULE_0__["default"])();
                    this.unlistenServices = [];
                }
                method(name, func) {
                    if (this.handlers[name] != null) {
                        throw new Error('Conflicting method name, names must be globally unique: ' + name);
                    }
                    this.handlers[name] = func;
                }
                service(func) {
                    this.services.push(func);
                }
                combine(...apps) {
                    for (const app of apps) {
                        Object.keys(app.handlers).forEach((name) => {
                            this.method(name, app.handlers[name]);
                        });
                        app.services.forEach((service) => {
                            this.service(service);
                        });
                        for (const [name, listeners] of app.events.all.entries()) {
                            for (const listener of listeners) {
                                this.events.on(name, listener);
                            }
                        }
                    }
                }
                startServices() {
                    if (this.unlistenServices.length > 0) {
                        (0, _platform_exceptions__WEBPACK_IMPORTED_MODULE_1__.captureException)(new Error('App: startServices called while services are already running'));
                    }
                    this.unlistenServices = this.services.map((service) => service());
                }
                stopServices() {
                    this.unlistenServices.forEach((unlisten) => {
                        if (unlisten) {
                            unlisten();
                        }
                    });
                    this.unlistenServices = [];
                }
            }
            function createApp() {
                return new App();
            }
            /***/ 
        }),
        /***/ "./packages/loot-core/src/server/aql/compiler.ts": 
        /*!*******************************************************!*\
          !*** ./packages/loot-core/src/server/aql/compiler.ts ***!
          \*******************************************************/
        /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony export */ __webpack_require__.d(__webpack_exports__, {
                /* harmony export */ compileQuery: () => ( /* binding */compileQuery),
                /* harmony export */ defaultConstructQuery: () => ( /* binding */defaultConstructQuery),
                /* harmony export */ generateSQLWithState: () => ( /* binding */generateSQLWithState),
                /* harmony export */ isAggregateQuery: () => ( /* binding */isAggregateQuery),
                /* harmony export */ quoteAlias: () => ( /* binding */quoteAlias)
                /* harmony export */ 
            });
            /* harmony import */ var _shared_normalisation__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../shared/normalisation */ "./packages/loot-core/src/shared/normalisation.ts");
            // @ts-strict-ignore
            let _uid = 0;
            function resetUid() {
                _uid = 0;
            }
            function uid(tableName) {
                _uid++;
                return tableName + _uid;
            }
            class CompileError extends Error {
            }
            function nativeDateToInt(date) {
                const pad = (x) => (x < 10 ? '0' : '') + x;
                return date.getFullYear() + pad(date.getMonth() + 1) + pad(date.getDate());
            }
            function dateToInt(date) {
                return parseInt(date.replace(/-/g, ''));
            }
            function addTombstone(schema, tableName, tableId, whereStr) {
                const hasTombstone = schema[tableName].tombstone != null;
                return hasTombstone ? `${whereStr} AND ${tableId}.tombstone = 0` : whereStr;
            }
            function popPath(path) {
                const parts = path.split('.');
                return {
                    path: parts.slice(0, -1).join('.'),
                    field: parts[parts.length - 1]
                };
            }
            function isKeyword(str) {
                return str === 'group';
            }
            function quoteAlias(alias) {
                // eslint-disable-next-line rulesdir/typography
                return alias.indexOf('.') === -1 && !isKeyword(alias) ? alias : `"${alias}"`;
            }
            function typed(value, type, { literal = false } = {}) {
                return {
                    value,
                    type,
                    literal
                };
            }
            function getFieldDescription(schema, tableName, field) {
                if (schema[tableName] == null) {
                    throw new CompileError(`Table ${tableName} does not exist in the schema`);
                }
                const fieldDesc = schema[tableName][field];
                if (fieldDesc == null) {
                    throw new CompileError(`Field ${field} does not exist in table ${tableName}`);
                }
                return fieldDesc;
            }
            function makePath(state, path) {
                const { schema, paths } = state;
                const parts = path.split('.');
                if (parts.length < 2) {
                    throw new CompileError('Invalid path: ' + path);
                }
                const initialTable = parts[0];
                const tableName = parts.slice(1).reduce((tableName, field) => {
                    const table = schema[tableName];
                    if (table == null) {
                        throw new CompileError(`Path error: ${tableName} table does not exist`);
                    }
                    if (!table[field] || table[field].ref == null) {
                        throw new CompileError(`Field not joinable on table ${tableName}: ${field}`);
                    }
                    return table[field].ref;
                }, initialTable);
                let joinTable;
                const parentParts = parts.slice(0, -1);
                if (parentParts.length === 1) {
                    joinTable = parentParts[0];
                }
                else {
                    const parentPath = parentParts.join('.');
                    const parentDesc = paths.get(parentPath);
                    if (!parentDesc) {
                        throw new CompileError('Path does not exist: ' + parentPath);
                    }
                    joinTable = parentDesc.tableId;
                }
                return {
                    tableName,
                    tableId: uid(tableName),
                    joinField: parts[parts.length - 1],
                    joinTable
                };
            }
            function resolvePath(state, path) {
                let paths = path.split('.');
                paths = paths.reduce((acc, name) => {
                    const fullName = acc.context + '.' + name;
                    return {
                        context: fullName,
                        path: [
                            ...acc.path,
                            fullName
                        ]
                    };
                }, {
                    context: state.implicitTableName,
                    path: []
                }).path;
                paths.forEach((path) => {
                    if (!state.paths.get(path)) {
                        state.paths.set(path, makePath(state, path));
                    }
                });
                const pathInfo = state.paths.get(paths[paths.length - 1]);
                return pathInfo;
            }
            function transformField(state, name) {
                if (typeof name !== 'string') {
                    throw new CompileError('Invalid field name, must be a string');
                }
                const { path, field: originalField } = popPath(name);
                let field = originalField;
                let pathInfo;
                if (path === '') {
                    pathInfo = {
                        tableName: state.implicitTableName,
                        tableId: state.implicitTableId
                    };
                }
                else {
                    pathInfo = resolvePath(state, path);
                }
                const fieldDesc = getFieldDescription(state.schema, pathInfo.tableName, field);
                // If this is a field that references an item in another table, that
                // item could have been deleted. If that's the case, we want to
                // return `null` instead of an id pointing to a deleted item. This
                // converts an id reference into a path that pulls the id through a
                // table join which will filter out dead items, resulting in a
                // `null` id if the item is deleted
                if (state.validateRefs && fieldDesc.ref && fieldDesc.type === 'id' && field !== 'id') {
                    const refPath = state.implicitTableName + '.' + name;
                    let refPathInfo = state.paths.get(refPath);
                    if (!refPathInfo) {
                        refPathInfo = makePath(state, refPath);
                        refPathInfo.noMapping = true;
                        state.paths.set(refPath, refPathInfo);
                    }
                    field = 'id';
                    pathInfo = refPathInfo;
                }
                const fieldStr = pathInfo.tableId + '.' + field;
                return typed(fieldStr, fieldDesc.type);
            }
            function parseDate(str) {
                const m = str.match(/^(\d{4}-\d{2}-\d{2})$/);
                if (m) {
                    return typed(dateToInt(m[1]), 'date', {
                        literal: true
                    });
                }
                return null;
            }
            function parseMonth(str) {
                const m = str.match(/^(\d{4}-\d{2})$/);
                if (m) {
                    return typed(dateToInt(m[1]), 'date', {
                        literal: true
                    });
                }
                return null;
            }
            function parseYear(str) {
                const m = str.match(/^(\d{4})$/);
                if (m) {
                    return typed(dateToInt(m[1]), 'date', {
                        literal: true
                    });
                }
                return null;
            }
            function badDateFormat(str, type) {
                throw new CompileError(`Bad ${type} format: ${str}`);
            }
            function inferParam(param, type) {
                const existingType = param.paramType;
                if (existingType) {
                    const casts = {
                        date: [
                            'string'
                        ],
                        'date-month': [
                            'date'
                        ],
                        'date-year': [
                            'date',
                            'date-month'
                        ],
                        id: [
                            'string'
                        ],
                        float: [
                            'integer'
                        ]
                    };
                    if (existingType !== type && (!casts[type] || !casts[type].includes(existingType))) {
                        throw new Error(`Parameter ${param.paramName} cant convert to ${type} (already inferred as ${existingType})`);
                    }
                }
                else {
                    param.paramType = type;
                }
            }
            function castInput(state, expr, type) {
                if (expr.type === type) {
                    return expr;
                }
                else if (expr.type === 'param') {
                    inferParam(expr, type);
                    return typed(expr.value, type);
                }
                else if (expr.type === 'null') {
                    if (!expr.literal) {
                        throw new CompileError('A non-literal null doesnt make sense');
                    }
                    if (type === 'boolean') {
                        return typed(0, 'boolean', {
                            literal: true
                        });
                    }
                    return expr;
                }
                // These are all things that can be safely casted automatically
                if (type === 'date') {
                    if (expr.type === 'string') {
                        if (expr.literal) {
                            return parseDate(expr.value) || badDateFormat(expr.value, 'date');
                        }
                        else {
                            throw new CompileError('Casting string fields to dates is not supported');
                        }
                    }
                    throw new CompileError(`Cant cast ${expr.type} to date`);
                }
                else if (type === 'date-month') {
                    let expr2;
                    if (expr.type === 'date') {
                        expr2 = expr;
                    }
                    else if (expr.type === 'string' || expr.type === 'any') {
                        expr2 = parseMonth(expr.value) || parseDate(expr.value) || badDateFormat(expr.value, 'date-month');
                    }
                    else {
                        throw new CompileError(`Cant cast ${expr.type} to date-month`);
                    }
                    if (expr2.literal) {
                        return typed(dateToInt(expr2.value.toString().slice(0, 6)), 'date-month', {
                            literal: true
                        });
                    }
                    else {
                        return typed(`CAST(SUBSTR(${expr2.value}, 1, 6) AS integer)`, 'date-month');
                    }
                }
                else if (type === 'date-year') {
                    let expr2;
                    if (expr.type === 'date' || expr.type === 'date-month') {
                        expr2 = expr;
                    }
                    else if (expr.type === 'string') {
                        expr2 = parseYear(expr.value) || parseMonth(expr.value) || parseDate(expr.value) || badDateFormat(expr.value, 'date-year');
                    }
                    else {
                        throw new CompileError(`Cant cast ${expr.type} to date-year`);
                    }
                    if (expr2.literal) {
                        return typed(dateToInt(expr2.value.toString().slice(0, 4)), 'date-year', {
                            literal: true
                        });
                    }
                    else {
                        return typed(`CAST(SUBSTR(${expr2.value}, 1, 4) AS integer)`, 'date-year');
                    }
                }
                else if (type === 'id') {
                    if (expr.type === 'string') {
                        return typed(expr.value, 'id', {
                            literal: expr.literal
                        });
                    }
                }
                else if (type === 'float') {
                    if (expr.type === 'integer') {
                        return typed(expr.value, 'float', {
                            literal: expr.literal
                        });
                    }
                }
                if (expr.type === 'any') {
                    return typed(expr.value, type, {
                        literal: expr.literal
                    });
                }
                throw new CompileError(`Cant convert ${expr.type} to ${type}`);
            }
            // TODO: remove state from these functions
            function val(state, expr, type) {
                let castedExpr = expr;
                // Cast the type if necessary
                if (type) {
                    castedExpr = castInput(state, expr, type);
                }
                if (castedExpr.literal) {
                    /* eslint-disable rulesdir/typography */ if (castedExpr.type === 'id') {
                        return `'${castedExpr.value}'`;
                    }
                    else if (castedExpr.type === 'string') {
                        // Escape quotes
                        const value = castedExpr.value.replace(/'/g, "''");
                        return `'${value}'`;
                    }
                    /* eslint-enable rulesdir/typography */ }
                return castedExpr.value;
            }
            function valArray(state, arr, types) {
                return arr.map((value, idx) => val(state, value, types ? types[idx] : null));
            }
            function validateArgLength(arr, min, max) {
                if (max == null) {
                    max = min;
                }
                if (min != null && arr.length < min) {
                    throw new CompileError('Too few arguments');
                }
                if (max != null && arr.length > max) {
                    throw new CompileError('Too many arguments');
                }
            }
            //// Nice errors
            function saveStack(type, func) {
                return (state, ...args) => {
                    if (state == null || state.compileStack == null) {
                        throw new CompileError('This function cannot track error data. ' + 'It needs to accept the compiler state as the first argument.');
                    }
                    state.compileStack.push({
                        type,
                        args
                    });
                    const ret = func(state, ...args);
                    state.compileStack.pop();
                    return ret;
                };
            }
            function prettyValue(value) {
                if (typeof value === 'string') {
                    return value;
                }
                else if (value === undefined) {
                    return 'undefined';
                }
                const str = JSON.stringify(value);
                if (str.length > 70) {
                    const expanded = JSON.stringify(value, null, 2);
                    return expanded.split('\n').join('\n  ');
                }
                return str;
            }
            function getCompileError(error, stack) {
                if (stack.length === 0) {
                    return error;
                }
                let stackStr = stack.slice(1).reverse().map((entry) => {
                    switch (entry.type) {
                        case 'expr':
                        case 'function':
                            return prettyValue(entry.args[0]);
                        case 'op':
                            {
                                const [fieldRef, opData] = entry.args;
                                return prettyValue({
                                    [fieldRef]: opData
                                });
                            }
                        case 'value':
                            return prettyValue(entry.value);
                        default:
                            return '';
                    }
                }).map((str) => '\n  ' + str).join('');
                const rootMethod = stack[0].type;
                const methodArgs = stack[0].args[0];
                stackStr += `\n  ${rootMethod}(${prettyValue(methodArgs.length === 1 ? methodArgs[0] : methodArgs)})`;
                // In production, hide internal stack traces
                if (false) { }
                error.message = `${error.message}\n\nExpression stack:` + stackStr;
                return error;
            }
            //// Compiler
            function compileLiteral(value) {
                if (value === undefined) {
                    throw new CompileError('`undefined` is not a valid query value');
                }
                else if (value === null) {
                    return typed('NULL', 'null', {
                        literal: true
                    });
                }
                else if (value instanceof Date) {
                    return typed(nativeDateToInt(value), 'date', {
                        literal: true
                    });
                }
                else if (typeof value === 'string') {
                    // Allow user to escape $, and quote the string to make it a
                    // string literal in the output
                    value = value.replace(/\\\$/g, '$');
                    return typed(value, 'string', {
                        literal: true
                    });
                }
                else if (typeof value === 'boolean') {
                    return typed(value ? 1 : 0, 'boolean', {
                        literal: true
                    });
                }
                else if (typeof value === 'number') {
                    return typed(value, Number.isInteger(value) ? 'integer' : 'float', {
                        literal: true
                    });
                }
                else if (Array.isArray(value)) {
                    return typed(value, 'array', {
                        literal: true
                    });
                }
                else {
                    throw new CompileError('Unsupported type of expression: ' + JSON.stringify(value));
                }
            }
            const compileExpr = saveStack('expr', (state, expr) => {
                if (typeof expr === 'string') {
                    // Field reference
                    if (expr[0] === '$') {
                        const fieldRef = expr === '$' ? state.implicitField : expr.slice(1);
                        if (fieldRef == null || fieldRef === '') {
                            throw new CompileError('Invalid field reference: ' + expr);
                        }
                        return transformField(state, fieldRef);
                    }
                    // Named parameter
                    if (expr[0] === ':') {
                        const param = {
                            value: '?',
                            type: 'param',
                            paramName: expr.slice(1)
                        };
                        state.namedParameters.push(param);
                        return param;
                    }
                }
                if (expr !== null) {
                    if (Array.isArray(expr)) {
                        return compileLiteral(expr);
                    }
                    else if (typeof expr === 'object' && Object.keys(expr).find((k) => k[0] === '$')) {
                        // It's a function call
                        return compileFunction(state, expr);
                    }
                }
                return compileLiteral(expr);
            });
            const compileFunction = saveStack('function', (state, func) => {
                const [name] = Object.keys(func);
                let argExprs = func[name];
                if (!Array.isArray(argExprs)) {
                    argExprs = [
                        argExprs
                    ];
                }
                if (name[0] !== '$') {
                    throw new CompileError(`Unknown property ${name}. Did you mean to call a function? Try prefixing it with $`);
                }
                let args = argExprs;
                // `$condition` is a special-case where it will be evaluated later
                if (name !== '$condition') {
                    args = argExprs.map((arg) => compileExpr(state, arg));
                }
                switch (name) {
                    // aggregate functions
                    case '$sum':
                        {
                            validateArgLength(args, 1);
                            const [arg1] = valArray(state, args, [
                                'float'
                            ]);
                            return typed(`SUM(${arg1})`, args[0].type);
                        }
                    case '$sumOver':
                        {
                            const [arg1] = valArray(state, args, [
                                'float'
                            ]);
                            const order = state.orders ? 'ORDER BY ' + compileOrderBy(state, state.orders) : '';
                            return typed(`(SUM(${arg1}) OVER (${order} ROWS BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING))`, args[0].type);
                        }
                    case '$count':
                        {
                            validateArgLength(args, 1);
                            const [arg1] = valArray(state, args);
                            return typed(`COUNT(${arg1})`, 'integer');
                        }
                    // string functions
                    case '$substr':
                        {
                            validateArgLength(args, 2, 3);
                            const [arg1, arg2, arg3] = valArray(state, args, [
                                'string',
                                'integer',
                                'integer'
                            ]);
                            return typed(`SUBSTR(${arg1}, ${arg2}, ${arg3})`, 'string');
                        }
                    case '$lower':
                        {
                            validateArgLength(args, 1);
                            const [arg1] = valArray(state, args, [
                                'string'
                            ]);
                            return typed(`UNICODE_LOWER(${arg1})`, 'string');
                        }
                    // integer/float functions
                    case '$neg':
                        {
                            validateArgLength(args, 1);
                            valArray(state, args, [
                                'float'
                            ]);
                            return typed(`(-${val(state, args[0])})`, args[0].type);
                        }
                    case '$abs':
                        {
                            validateArgLength(args, 1);
                            valArray(state, args, [
                                'float'
                            ]);
                            return typed(`ABS(${val(state, args[0])})`, args[0].type);
                        }
                    case '$idiv':
                        {
                            validateArgLength(args, 2);
                            valArray(state, args, [
                                'integer',
                                'integer'
                            ]);
                            return typed(`(${val(state, args[0])} / ${val(state, args[1])})`, args[0].type);
                        }
                    // id functions
                    case '$id':
                        {
                            validateArgLength(args, 1);
                            return typed(val(state, args[0]), args[0].type);
                        }
                    // date functions
                    case '$day':
                        {
                            validateArgLength(args, 1);
                            return castInput(state, args[0], 'date');
                        }
                    case '$month':
                        {
                            validateArgLength(args, 1);
                            return castInput(state, args[0], 'date-month');
                        }
                    case '$year':
                        {
                            validateArgLength(args, 1);
                            return castInput(state, args[0], 'date-year');
                        }
                    // various functions
                    case '$condition':
                        validateArgLength(args, 1);
                        const conds = compileConditions(state, args[0]);
                        return typed(conds.join(' AND '), 'boolean');
                    case '$nocase':
                        validateArgLength(args, 1);
                        const [arg1] = valArray(state, args, [
                            'string'
                        ]);
                        return typed(`${arg1} COLLATE NOCASE`, args[0].type);
                    case '$literal':
                        {
                            validateArgLength(args, 1);
                            if (!args[0].literal) {
                                throw new CompileError('Literal not passed to $literal');
                            }
                            return args[0];
                        }
                    default:
                        throw new CompileError(`Unknown function: ${name}`);
                }
            });
            const compileOp = saveStack('op', (state, fieldRef, opData) => {
                const { $transform, ...opExpr } = opData;
                const [op] = Object.keys(opExpr);
                const rhs = compileExpr(state, opData[op]);
                let lhs;
                if ($transform) {
                    lhs = compileFunction({
                        ...state,
                        implicitField: fieldRef
                    }, typeof $transform === 'string' ? {
                        [$transform]: '$'
                    } : $transform);
                }
                else {
                    lhs = compileExpr(state, '$' + fieldRef);
                }
                switch (op) {
                    case '$gte':
                        {
                            const [left, right] = valArray(state, [
                                lhs,
                                rhs
                            ], [
                                null,
                                lhs.type
                            ]);
                            return `${left} >= ${right}`;
                        }
                    case '$lte':
                        {
                            const [left, right] = valArray(state, [
                                lhs,
                                rhs
                            ], [
                                null,
                                lhs.type
                            ]);
                            return `${left} <= ${right}`;
                        }
                    case '$gt':
                        {
                            const [left, right] = valArray(state, [
                                lhs,
                                rhs
                            ], [
                                null,
                                lhs.type
                            ]);
                            return `${left} > ${right}`;
                        }
                    case '$lt':
                        {
                            const [left, right] = valArray(state, [
                                lhs,
                                rhs
                            ], [
                                null,
                                lhs.type
                            ]);
                            return `${left} < ${right}`;
                        }
                    case '$eq':
                        {
                            if (castInput(state, rhs, lhs.type).type === 'null') {
                                return `${val(state, lhs)} IS NULL`;
                            }
                            const [left, right] = valArray(state, [
                                lhs,
                                rhs
                            ], [
                                null,
                                lhs.type
                            ]);
                            if (rhs.type === 'param') {
                                const orders = state.namedParameters.map((param) => {
                                    return param === rhs || param === lhs ? [
                                        param,
                                        {
                                            ...param
                                        }
                                    ] : param;
                                });
                                state.namedParameters = [].concat.apply([], orders);
                                return `CASE
          WHEN ${left} IS NULL THEN ${right} IS NULL
          ELSE ${left} = ${right}
        END`;
                            }
                            return `${left} = ${right}`;
                        }
                    case '$ne':
                        {
                            if (castInput(state, rhs, lhs.type).type === 'null') {
                                return `${val(state, lhs)} IS NULL`;
                            }
                            const [left, right] = valArray(state, [
                                lhs,
                                rhs
                            ], [
                                null,
                                lhs.type
                            ]);
                            if (rhs.type === 'param') {
                                const orders = state.namedParameters.map((param) => {
                                    return param === rhs || param === lhs ? [
                                        param,
                                        {
                                            ...param
                                        }
                                    ] : param;
                                });
                                state.namedParameters = [].concat.apply([], orders);
                                return `CASE
          WHEN ${left} IS NULL THEN ${right} IS NULL
          ELSE ${left} != ${right}
        END`;
                            }
                            return `${left} != ${right}`;
                        }
                    case '$oneof':
                        {
                            const [left, right] = valArray(state, [
                                lhs,
                                rhs
                            ], [
                                null,
                                'array'
                            ]);
                            // Dedupe the ids
                            const ids = [
                                ...new Set(right)
                            ];
                            // eslint-disable-next-line rulesdir/typography
                            return `${left} IN (` + ids.map((id) => `'${id}'`).join(',') + ')';
                        }
                    case '$like':
                        {
                            const [left, right] = valArray(state, [
                                lhs,
                                rhs
                            ], [
                                'string',
                                'string'
                            ]);
                            return `UNICODE_LIKE(${(0, _shared_normalisation__WEBPACK_IMPORTED_MODULE_0__.getNormalisedString)(right)}, NORMALISE(${left}))`;
                        }
                    case '$regexp':
                        {
                            const [left, right] = valArray(state, [
                                lhs,
                                rhs
                            ], [
                                'string',
                                'string'
                            ]);
                            return `REGEXP(${right}, ${left})`;
                        }
                    case '$notlike':
                        {
                            const [left, right] = valArray(state, [
                                lhs,
                                rhs
                            ], [
                                'string',
                                'string'
                            ]);
                            return `(NOT UNICODE_LIKE(${(0, _shared_normalisation__WEBPACK_IMPORTED_MODULE_0__.getNormalisedString)(right)}, NORMALISE(${left}))\n OR ${left} IS NULL)`;
                        }
                    default:
                        throw new CompileError(`Unknown operator: ${op}`);
                }
            });
            function compileConditions(state, conds) {
                if (!Array.isArray(conds)) {
                    // Convert the object form `{foo: 1, bar:2}` into the array form
                    // `[{foo: 1}, {bar:2}]`
                    conds = Object.entries(conds).map((cond) => {
                        return {
                            [cond[0]]: cond[1]
                        };
                    });
                }
                return conds.filter(Boolean).reduce((res, condsObj) => {
                    const compiled = Object.entries(condsObj).map(([field, cond]) => {
                        // Allow a falsy value in the lhs of $and and $or to allow for
                        // quick forms like `$or: amount != 0 && ...`
                        if (field === '$and') {
                            if (!cond) {
                                return null;
                            }
                            return compileAnd(state, cond);
                        }
                        else if (field === '$or') {
                            if (!cond) {
                                return null;
                            }
                            return compileOr(state, cond);
                        }
                        if (typeof cond === 'string' || typeof cond === 'number' || typeof cond === 'boolean' || cond instanceof Date || cond == null) {
                            return compileOp(state, field, {
                                $eq: cond
                            });
                        }
                        if (Array.isArray(cond)) {
                            // An array of conditions for a field is implicitly an `and`
                            return cond.map((c) => compileOp(state, field, c)).join(' AND ');
                        }
                        return compileOp(state, field, cond);
                    }).filter(Boolean);
                    return [
                        ...res,
                        ...compiled
                    ];
                }, []);
            }
            function compileOr(state, conds) {
                // Same as above
                if (!conds) {
                    return '0';
                }
                const res = compileConditions(state, conds);
                if (res.length === 0) {
                    return '0';
                }
                return '(' + res.join('\n  OR ') + ')';
            }
            function compileAnd(state, conds) {
                // Same as above
                if (!conds) {
                    return '1';
                }
                const res = compileConditions(state, conds);
                if (res.length === 0) {
                    return '1';
                }
                return '(' + res.join('\n  AND ') + ')';
            }
            const compileWhere = saveStack('filter', (state, conds) => {
                return compileAnd(state, conds);
            });
            function compileJoins(state, tableRef, internalTableFilters) {
                const joins = [];
                state.paths.forEach((desc, path) => {
                    const { tableName, tableId, joinField, joinTable, noMapping } = state.paths.get(path);
                    let on = `${tableId}.id = ${tableRef(joinTable)}.${quoteAlias(joinField)}`;
                    const filters = internalTableFilters(tableName);
                    if (filters.length > 0) {
                        on += ' AND ' + compileAnd({
                            ...state,
                            implicitTableName: tableName,
                            implicitTableId: tableId
                        }, filters);
                    }
                    joins.push(`LEFT JOIN ${noMapping ? tableName : tableRef(tableName, true)} ${tableId} ON ${addTombstone(state.schema, tableName, tableId, on)}`);
                    if (state.dependencies.indexOf(tableName) === -1) {
                        state.dependencies.push(tableName);
                    }
                });
                return joins.join('\n');
            }
            function expandStar(state, expr) {
                let path;
                let pathInfo;
                if (expr === '*') {
                    pathInfo = {
                        tableName: state.implicitTableName,
                        tableId: state.implicitTableId
                    };
                }
                else if (expr.match(/\.\*$/)) {
                    const result = popPath(expr);
                    path = result.path;
                    pathInfo = resolvePath(state, result.path);
                }
                const table = state.schema[pathInfo.tableName];
                if (table == null) {
                    throw new Error(`Table ${pathInfo.tableName} does not exist`);
                }
                return Object.keys(table).map((field) => path ? `${path}.${field}` : field);
            }
            const compileSelect = saveStack('select', (state, exprs, isAggregate, orders) => {
                // Always include the id if it's not an aggregate
                if (!isAggregate && !exprs.includes('id') && !exprs.includes('*')) {
                    exprs = exprs.concat([
                        'id'
                    ]);
                }
                const select = exprs.map((expr) => {
                    if (typeof expr === 'string') {
                        if (expr.indexOf('*') !== -1) {
                            const fields = expandStar(state, expr);
                            return fields.map((field) => {
                                const compiled = compileExpr(state, '$' + field);
                                state.outputTypes.set(field, compiled.type);
                                return compiled.value + ' AS ' + quoteAlias(field);
                            }).join(', ');
                        }
                        const compiled = compileExpr(state, '$' + expr);
                        state.outputTypes.set(expr, compiled.type);
                        return compiled.value + ' AS ' + quoteAlias(expr);
                    }
                    const [name, value] = Object.entries(expr)[0];
                    if (name[0] === '$') {
                        state.compileStack.push({
                            type: 'value',
                            value: expr
                        });
                        throw new CompileError(`Invalid field ${name}, are you trying to select a function? You need to name the expression`);
                    }
                    if (typeof value === 'string') {
                        const compiled = compileExpr(state, '$' + value);
                        state.outputTypes.set(name, compiled.type);
                        return `${compiled.value} AS ${quoteAlias(name)}`;
                    }
                    const compiled = compileFunction({
                        ...state,
                        orders
                    }, value);
                    state.outputTypes.set(name, compiled.type);
                    return compiled.value + ` AS ${quoteAlias(name)}`;
                });
                return select.join(', ');
            });
            const compileGroupBy = saveStack('groupBy', (state, exprs) => {
                const groupBy = exprs.map((expr) => {
                    if (typeof expr === 'string') {
                        return compileExpr(state, '$' + expr).value;
                    }
                    return compileFunction(state, expr).value;
                });
                return groupBy.join(', ');
            });
            const compileOrderBy = saveStack('orderBy', (state, exprs) => {
                const orderBy = exprs.map((expr) => {
                    let compiled;
                    let dir = null;
                    if (typeof expr === 'string') {
                        compiled = compileExpr(state, '$' + expr).value;
                    }
                    else {
                        const entries = Object.entries(expr);
                        const entry = entries[0];
                        // Check if this is a field reference
                        if (entries.length === 1 && entry[0][0] !== '$') {
                            dir = entry[1];
                            compiled = compileExpr(state, '$' + entry[0]).value;
                        }
                        else {
                            // Otherwise it's a function
                            const { $dir, ...func } = expr;
                            dir = $dir;
                            compiled = compileFunction(state, func).value;
                        }
                    }
                    if (dir != null) {
                        if (dir !== 'desc' && dir !== 'asc') {
                            throw new CompileError('Invalid order direction: ' + dir);
                        }
                        return `${compiled} ${dir}`;
                    }
                    return compiled;
                });
                return orderBy.join(', ');
            });
            const AGGREGATE_FUNCTIONS = [
                '$sum',
                '$count'
            ];
            function isAggregateFunction(expr) {
                if (typeof expr !== 'object' || Array.isArray(expr)) {
                    return false;
                }
                const [name, originalArgExprs] = Object.entries(expr)[0];
                let argExprs = originalArgExprs;
                if (!Array.isArray(argExprs)) {
                    argExprs = [
                        argExprs
                    ];
                }
                if (AGGREGATE_FUNCTIONS.indexOf(name) !== -1) {
                    return true;
                }
                return !!argExprs.find((ex) => isAggregateFunction(ex));
            }
            function isAggregateQuery(queryState) {
                // it's aggregate if:
                // either an aggregate function is used in `select`
                // or a `groupBy` exists
                if (queryState.groupExpressions.length > 0) {
                    return true;
                }
                return !!queryState.selectExpressions.find((expr) => {
                    if (typeof expr !== 'string') {
                        const [_, value] = Object.entries(expr)[0];
                        return isAggregateFunction(value);
                    }
                    return false;
                });
            }
            function compileQuery(queryState, schema, schemaConfig = {}) {
                const { withDead, validateRefs = true, tableOptions, rawMode } = queryState;
                const { tableViews = {}, tableFilters = () => [], customizeQuery = (queryState) => queryState } = schemaConfig;
                const internalTableFilters = (name) => {
                    const filters = tableFilters(name);
                    // These filters cannot join tables and must be simple strings
                    for (const filter of filters) {
                        if (Array.isArray(filter)) {
                            throw new CompileError('Invalid internal table filter: only object filters are supported');
                        }
                        if (Object.keys(filter)[0].indexOf('.') !== -1) {
                            throw new CompileError('Invalid internal table filter: field names cannot contain paths');
                        }
                    }
                    return filters;
                };
                const tableRef = (name, isJoin) => {
                    const view = typeof tableViews === 'function' ? tableViews(name, {
                        withDead,
                        isJoin,
                        tableOptions
                    }) : tableViews[name];
                    return view || name;
                };
                const tableName = queryState.table;
                const { filterExpressions, selectExpressions, groupExpressions, orderExpressions, limit, offset } = customizeQuery(queryState);
                let select = '';
                let where = '';
                let joins = '';
                let groupBy = '';
                let orderBy = '';
                const state = {
                    schema,
                    implicitTableName: tableName,
                    implicitTableId: tableRef(tableName),
                    paths: new Map(),
                    dependencies: [
                        tableName
                    ],
                    compileStack: [],
                    outputTypes: new Map(),
                    validateRefs,
                    namedParameters: []
                };
                resetUid();
                try {
                    select = compileSelect(state, selectExpressions, isAggregateQuery(queryState), orderExpressions);
                    if (filterExpressions.length > 0) {
                        const result = compileWhere(state, filterExpressions);
                        where = 'WHERE ' + result;
                    }
                    else {
                        where = 'WHERE 1';
                    }
                    if (!rawMode) {
                        const filters = internalTableFilters(tableName);
                        if (filters.length > 0) {
                            where += ' AND ' + compileAnd(state, filters);
                        }
                    }
                    if (groupExpressions.length > 0) {
                        const result = compileGroupBy(state, groupExpressions);
                        groupBy = 'GROUP BY ' + result;
                    }
                    // Orders don't matter if doing a single calculation
                    if (orderExpressions.length > 0) {
                        const result = compileOrderBy(state, orderExpressions);
                        orderBy = 'ORDER BY ' + result;
                    }
                    if (state.paths.size > 0) {
                        joins = compileJoins(state, tableRef, internalTableFilters);
                    }
                }
                catch (e) {
                    if (e instanceof CompileError) {
                        throw getCompileError(e, state.compileStack);
                    }
                    throw e;
                }
                const sqlPieces = {
                    select,
                    from: tableRef(tableName),
                    joins,
                    where,
                    groupBy,
                    orderBy,
                    limit,
                    offset
                };
                return {
                    sqlPieces,
                    state
                };
            }
            function defaultConstructQuery(queryState, state, sqlPieces) {
                const s = sqlPieces;
                const where = queryState.withDead ? s.where : addTombstone(state.schema, state.implicitTableName, state.implicitTableId, s.where);
                return `
    SELECT ${s.select} FROM ${s.from}
    ${s.joins}
    ${where}
    ${s.groupBy}
    ${s.orderBy}
    ${s.limit != null ? `LIMIT ${s.limit}` : ''}
    ${s.offset != null ? `OFFSET ${s.offset}` : ''}
  `;
            }
            function generateSQLWithState(queryState, schema, schemaConfig) {
                const { sqlPieces, state } = compileQuery(queryState, schema, schemaConfig);
                return {
                    sql: defaultConstructQuery(queryState, state, sqlPieces),
                    state
                };
            }
            /***/ 
        }),
        /***/ "./packages/loot-core/src/server/aql/exec.ts": 
        /*!***************************************************!*\
          !*** ./packages/loot-core/src/server/aql/exec.ts ***!
          \***************************************************/
        /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony export */ __webpack_require__.d(__webpack_exports__, {
                /* harmony export */ execQuery: () => ( /* binding */execQuery),
                /* harmony export */ runCompiledQuery: () => ( /* binding */runCompiledQuery),
                /* harmony export */ runQuery: () => ( /* binding */runQuery)
                /* harmony export */ 
            });
            /* harmony import */ var _db__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../db */ "./packages/loot-core/src/server/db/index.ts");
            /* harmony import */ var _compiler__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./compiler */ "./packages/loot-core/src/server/aql/compiler.ts");
            /* harmony import */ var _schema_helpers__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./schema-helpers */ "./packages/loot-core/src/server/aql/schema-helpers.ts");
            // @ts-strict-ignore
            // TODO (compiler):
            // * Properly safeguard all inputs against SQL injection
            // * Functions for incr/decr dates
            // * Support HAVING
            // * Allow creating in-memory tables to run queries against static
            //   data
            // * For aggregate functions on selected ids, manually implement
            //   them only only support a specific few (sum amount / etc)
            // * Select expressions should be evaluated first, and added to a
            //   global "field lookup" table that other filter/groupBy/etc
            //   expressions can reference
            function applyTypes(data, outputTypes) {
                for (let i = 0; i < data.length; i++) {
                    const item = data[i];
                    Object.keys(item).forEach((name) => {
                        item[name] = (0, _schema_helpers__WEBPACK_IMPORTED_MODULE_2__.convertOutputType)(item[name], outputTypes.get(name));
                    });
                }
            }
            async function execQuery(queryState, state, sqlPieces, params, outputTypes) {
                const sql = (0, _compiler__WEBPACK_IMPORTED_MODULE_1__.defaultConstructQuery)(queryState, state, sqlPieces);
                const data = await _db__WEBPACK_IMPORTED_MODULE_0__.all(sql, params);
                applyTypes(data, outputTypes);
                return data;
            }
            async function runCompiledQuery(query, pieces, state, { params = {}, executors = {} } = {}) {
                const paramArray = state.namedParameters.map((param) => {
                    const name = param.paramName;
                    if (params[name] === undefined) {
                        throw new Error(`Parameter ${name} not provided to query`);
                    }
                    return (0, _schema_helpers__WEBPACK_IMPORTED_MODULE_2__.convertInputType)(params[name], param.paramType);
                });
                let data;
                if (executors[state.implicitTableName]) {
                    data = await executors[state.implicitTableName](state, query, pieces, paramArray, state.outputTypes);
                }
                else {
                    data = await execQuery(query, state, pieces, paramArray, state.outputTypes);
                }
                if (query.calculation) {
                    if (data.length > 0) {
                        const row = data[0];
                        const k = Object.keys(row)[0];
                        // TODO: the function being run should be the one to
                        // determine the default value, not hardcoded as 0
                        data = row[k] || 0;
                    }
                    else {
                        data = null;
                    }
                }
                return data;
            }
            async function runQuery(schema, schemaConfig, query, options) {
                const { sqlPieces, state } = (0, _compiler__WEBPACK_IMPORTED_MODULE_1__.compileQuery)(query, schema, schemaConfig);
                const data = await runCompiledQuery(query, sqlPieces, state, options);
                return {
                    data,
                    dependencies: state.dependencies
                };
            }
            /***/ 
        }),
        /***/ "./packages/loot-core/src/server/aql/index.ts": 
        /*!****************************************************!*\
          !*** ./packages/loot-core/src/server/aql/index.ts ***!
          \****************************************************/
        /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony export */ __webpack_require__.d(__webpack_exports__, {
                /* harmony export */ compileQuery: () => ( /* reexport safe */_compiler__WEBPACK_IMPORTED_MODULE_1__.compileQuery),
                /* harmony export */ convertForInsert: () => ( /* reexport safe */_schema_helpers__WEBPACK_IMPORTED_MODULE_0__.convertForInsert),
                /* harmony export */ convertForUpdate: () => ( /* reexport safe */_schema_helpers__WEBPACK_IMPORTED_MODULE_0__.convertForUpdate),
                /* harmony export */ convertFromSelect: () => ( /* reexport safe */_schema_helpers__WEBPACK_IMPORTED_MODULE_0__.convertFromSelect),
                /* harmony export */ convertInputType: () => ( /* reexport safe */_schema_helpers__WEBPACK_IMPORTED_MODULE_0__.convertInputType),
                /* harmony export */ makeViews: () => ( /* reexport safe */_views__WEBPACK_IMPORTED_MODULE_2__.makeViews),
                /* harmony export */ runCompiledQuery: () => ( /* reexport safe */_schema_run_query__WEBPACK_IMPORTED_MODULE_4__.runCompiledQuery),
                /* harmony export */ runQuery: () => ( /* reexport safe */_schema_run_query__WEBPACK_IMPORTED_MODULE_4__.runQuery),
                /* harmony export */ schema: () => ( /* reexport safe */_schema__WEBPACK_IMPORTED_MODULE_3__.schema),
                /* harmony export */ schemaConfig: () => ( /* reexport safe */_schema__WEBPACK_IMPORTED_MODULE_3__.schemaConfig)
                /* harmony export */ 
            });
            /* harmony import */ var _schema_helpers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./schema-helpers */ "./packages/loot-core/src/server/aql/schema-helpers.ts");
            /* harmony import */ var _compiler__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./compiler */ "./packages/loot-core/src/server/aql/compiler.ts");
            /* harmony import */ var _views__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./views */ "./packages/loot-core/src/server/aql/views.ts");
            /* harmony import */ var _schema__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./schema */ "./packages/loot-core/src/server/aql/schema/index.ts");
            /* harmony import */ var _schema_run_query__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./schema/run-query */ "./packages/loot-core/src/server/aql/schema/run-query.ts");
            /***/ 
        }),
        /***/ "./packages/loot-core/src/server/aql/schema-helpers.ts": 
        /*!*************************************************************!*\
          !*** ./packages/loot-core/src/server/aql/schema-helpers.ts ***!
          \*************************************************************/
        /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony export */ __webpack_require__.d(__webpack_exports__, {
                /* harmony export */ conform: () => ( /* binding */conform),
                /* harmony export */ convertForInsert: () => ( /* binding */convertForInsert),
                /* harmony export */ convertForUpdate: () => ( /* binding */convertForUpdate),
                /* harmony export */ convertFromSelect: () => ( /* binding */convertFromSelect),
                /* harmony export */ convertInputType: () => ( /* binding */convertInputType),
                /* harmony export */ convertOutputType: () => ( /* binding */convertOutputType)
                /* harmony export */ 
            });
            /* harmony import */ var _shared_months__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../shared/months */ "./packages/loot-core/src/shared/months.ts");
            /* harmony import */ var _models__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../models */ "./packages/loot-core/src/server/models.ts");
            // @ts-strict-ignore
            function isRequired(name, fieldDesc) {
                return fieldDesc.required || name === 'id';
            }
            // TODO: All of the data type needs to check the input value. This
            // doesn't just convert, it casts. See integer handling.
            function convertInputType(value, type) {
                if (value === undefined) {
                    throw new Error('Query value cannot be undefined');
                }
                else if (value === null) {
                    if (type === 'boolean') {
                        return 0;
                    }
                    return null;
                }
                switch (type) {
                    case 'date':
                        if (value instanceof Date) {
                            return (0, _models__WEBPACK_IMPORTED_MODULE_1__.toDateRepr)((0, _shared_months__WEBPACK_IMPORTED_MODULE_0__.dayFromDate)(value));
                        }
                        else if (value.match(/^\d{4}-\d{2}-\d{2}$/) == null || value.date < '2000-01-01') {
                            throw new Error('Invalid date: ' + value);
                        }
                        return (0, _models__WEBPACK_IMPORTED_MODULE_1__.toDateRepr)(value);
                    case 'date-month':
                        return (0, _models__WEBPACK_IMPORTED_MODULE_1__.toDateRepr)(value.slice(0, 7));
                    case 'date-year':
                        return (0, _models__WEBPACK_IMPORTED_MODULE_1__.toDateRepr)(value.slice(0, 4));
                    case 'boolean':
                        return value ? 1 : 0;
                    case 'id':
                        if (typeof value !== 'string' && value !== null) {
                            throw new Error('Invalid id, must be string: ' + value);
                        }
                        return value;
                    case 'integer':
                        if (typeof value === 'number' && Number.isInteger(value)) {
                            return value;
                        }
                        else {
                            throw new Error('Cant convert to integer: ' + JSON.stringify(value));
                        }
                    case 'json':
                        return JSON.stringify(value);
                    default:
                }
                return value;
            }
            function convertOutputType(value, type) {
                if (value === null) {
                    if (type === 'boolean') {
                        return false;
                    }
                    return null;
                }
                switch (type) {
                    case 'date':
                        return (0, _models__WEBPACK_IMPORTED_MODULE_1__.fromDateRepr)(value);
                    case 'date-month':
                        return (0, _models__WEBPACK_IMPORTED_MODULE_1__.fromDateRepr)(value).slice(0, 7);
                    case 'date-year':
                        return (0, _models__WEBPACK_IMPORTED_MODULE_1__.fromDateRepr)(value).slice(0, 4);
                    case 'boolean':
                        return value === 1;
                    case 'json':
                    case 'json/fallback':
                        try {
                            return JSON.parse(value);
                        }
                        catch (e) {
                            return type === 'json/fallback' ? value : null;
                        }
                    default:
                }
                return value;
            }
            function conform(schema, schemaConfig, table, obj, { skipNull = false } = {}) {
                const tableSchema = schema[table];
                if (tableSchema == null) {
                    throw new Error(`Table ${table} does not exist`);
                }
                const views = schemaConfig.views || {};
                // Rename fields if necessary
                const fieldRef = (field) => {
                    if (views[table] && views[table].fields) {
                        return views[table].fields[field] || field;
                    }
                    return field;
                };
                return Object.fromEntries(Object.keys(obj).map((field) => {
                    // Fields that start with an underscore are ignored
                    if (field[0] === '_') {
                        return null;
                    }
                    const fieldDesc = tableSchema[field];
                    if (fieldDesc == null) {
                        throw new Error(`Field ${field} does not exist on table ${table}: ${JSON.stringify(obj)}`);
                    }
                    if (isRequired(field, fieldDesc) && obj[field] == null) {
                        throw new Error(`${field} is required for table ${table}: ${JSON.stringify(obj)}`);
                    }
                    // This option removes null values (see `convertForInsert`)
                    if (skipNull && obj[field] == null) {
                        return null;
                    }
                    return [
                        fieldRef(field),
                        convertInputType(obj[field], fieldDesc.type)
                    ];
                }).filter(Boolean));
            }
            function convertForInsert(schema, schemaConfig, table, rawObj) {
                const obj = {
                    ...rawObj
                };
                const tableSchema = schema[table];
                if (tableSchema == null) {
                    throw new Error(`Error inserting: table ${table} does not exist`);
                }
                // Inserting checks all the fields in the table and adds any default
                // values necessary
                Object.keys(tableSchema).forEach((field) => {
                    const fieldDesc = tableSchema[field];
                    if (obj[field] == null) {
                        if (fieldDesc.default !== undefined) {
                            obj[field] = typeof fieldDesc.default === 'function' ? fieldDesc.default() : fieldDesc.default;
                        }
                        else if (isRequired(field, fieldDesc)) {
                            // Although this check is also done in `conform`, it only
                            // checks the fields in `obj`. For insert, we need to do it
                            // here to check that all required fields in the table exist
                            throw new Error(`${field} is required for table ${table}: ${JSON.stringify(obj)}`);
                        }
                    }
                });
                // We use `skipNull` to remove any null values. There's no need to
                // set those when inserting, that will be the default and it reduces
                // the amount of messages generated to sync
                return conform(schema, schemaConfig, table, obj, {
                    skipNull: true
                });
            }
            function convertForUpdate(schema, schemaConfig, table, rawObj) {
                const obj = {
                    ...rawObj
                };
                const tableSchema = schema[table];
                if (tableSchema == null) {
                    throw new Error(`Error updating: table ${table} does not exist`);
                }
                return conform(schema, schemaConfig, table, obj);
            }
            function convertFromSelect(schema, schemaConfig, table, obj) {
                const tableSchema = schema[table];
                if (tableSchema == null) {
                    throw new Error(`Table ${table} does not exist`);
                }
                const fields = Object.keys(tableSchema);
                const result = {};
                for (let i = 0; i < fields.length; i++) {
                    const fieldName = fields[i];
                    const fieldDesc = tableSchema[fieldName];
                    result[fieldName] = convertOutputType(obj[fieldName], fieldDesc.type);
                }
                return result;
            }
            /***/ 
        }),
        /***/ "./packages/loot-core/src/server/aql/schema/executors.ts": 
        /*!***************************************************************!*\
          !*** ./packages/loot-core/src/server/aql/schema/executors.ts ***!
          \***************************************************************/
        /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony export */ __webpack_require__.d(__webpack_exports__, {
                /* harmony export */ isHappyPathQuery: () => ( /* binding */isHappyPathQuery),
                /* harmony export */ schemaExecutors: () => ( /* binding */schemaExecutors)
                /* harmony export */ 
            });
            /* harmony import */ var _db__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../db */ "./packages/loot-core/src/server/db/index.ts");
            /* harmony import */ var _db_util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../db/util */ "./packages/loot-core/src/server/db/util.ts");
            /* harmony import */ var _compiler__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../compiler */ "./packages/loot-core/src/server/aql/compiler.ts");
            /* harmony import */ var _exec__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../exec */ "./packages/loot-core/src/server/aql/exec.ts");
            /* harmony import */ var _schema_helpers__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../schema-helpers */ "./packages/loot-core/src/server/aql/schema-helpers.ts");
            // @ts-strict-ignore
            // Transactions executor
            function toGroup(parents, children, mapper = (x) => x) {
                return parents.reduce((list, parent) => {
                    const childs = children.get(parent.id) || [];
                    list.push({
                        ...mapper(parent),
                        subtransactions: childs.map(mapper)
                    });
                    return list;
                }, []);
            }
            // These two queries will return very different things:
            //
            // q('transactions').select({ $count: 'id' })
            // q('transactions', { splits: "grouped" }).select({ $count: 'id' })
            //
            // The first will return the count of non-split and child
            // transactions, and the second will return the count of all parent
            // (or non-split) transactions
            function execTransactions(state, query, sql, params, outputTypes) {
                const tableOptions = query.tableOptions || {};
                const splitType = tableOptions.splits || 'inline';
                if ([
                    'all',
                    'inline',
                    'none',
                    'grouped'
                ].indexOf(splitType) === -1) {
                    throw new Error(`Invalid splits option for transactions: ${splitType}`);
                }
                if (splitType === 'all' || splitType === 'inline' || splitType === 'none') {
                    return execTransactionsBasic(state, query, sql, params, splitType, outputTypes);
                }
                else if (splitType === 'grouped') {
                    return execTransactionsGrouped(state, query, sql, params, splitType, outputTypes);
                }
            }
            function _isUnhappy(filter) {
                // These fields can be filtered - all split transactions will
                // still be returned regardless
                for (const key of Object.keys(filter)) {
                    if (key === '$or' || key === '$and') {
                        if (filter[key] && _isUnhappy(filter[key])) {
                            return true;
                        }
                    }
                    else if (!(key.indexOf('account') === 0 || key === 'date')) {
                        return true;
                    }
                }
                return false;
            }
            function isHappyPathQuery(queryState) {
                return queryState.filterExpressions.find(_isUnhappy) == null;
            }
            async function execTransactionsGrouped(state, queryState, sql, params, splitType, outputTypes) {
                const { withDead } = queryState;
                const whereDead = withDead ? '' : `AND ${sql.from}.tombstone = 0`;
                // Aggregate queries don't make sense for a grouped transactions
                // query. We never should include both parent and children
                // transactions as it would duplicate amounts and the final number
                // would never make sense. In this case, switch back to the "inline"
                // type where only non-parent transactions are considered
                if ((0, _compiler__WEBPACK_IMPORTED_MODULE_2__.isAggregateQuery)(queryState)) {
                    const s = {
                        ...sql
                    };
                    // Modify the where to only include non-parents
                    s.where = `${s.where} AND ${s.from}.is_parent = 0`;
                    // We also want to exclude deleted transactions. Normally we
                    // handle this manually down below, but now that we are doing a
                    // normal query we want to rely on the view. Unfortunately, SQL
                    // has already been generated so we can't easily change the view
                    // name here; instead, we change it and map it back to the name
                    // used elsewhere in the query. Ideally we'd improve this
                    if (!withDead) {
                        s.from = 'v_transactions_internal_alive v_transactions_internal';
                    }
                    return (0, _exec__WEBPACK_IMPORTED_MODULE_3__.execQuery)(queryState, state, s, params, outputTypes);
                }
                let rows;
                let matched = null;
                if (isHappyPathQuery(queryState)) {
                    // This is just an optimization - we can just filter out children
                    // directly and only list parents
                    const rowSql = `
      SELECT ${sql.from}.id as group_id
      FROM ${sql.from}
      ${sql.joins}
      ${sql.where} AND is_child = 0 ${whereDead}
      ${sql.orderBy}
      ${sql.limit != null ? `LIMIT ${sql.limit}` : ''}
      ${sql.offset != null ? `OFFSET ${sql.offset}` : ''}
    `;
                    rows = await _db__WEBPACK_IMPORTED_MODULE_0__.all(rowSql, params);
                }
                else {
                    // TODO: phew, what a doozy. write docs why it works this way
                    //
                    // prettier-ignore
                    const rowSql = `
      SELECT group_id, matched FROM (
        SELECT
          group_id,
          GROUP_CONCAT(id) as matched
          FROM (
            SELECT ${sql.from}.id, IFNULL(${sql.from}.parent_id, ${sql.from}.id) as group_id
            FROM ${sql.from}
            LEFT JOIN transactions _t2 ON ${sql.from}.is_child = 1 AND _t2.id = ${sql.from}.parent_id
            ${sql.joins}
            ${sql.where} AND ${sql.from}.tombstone = 0 AND IFNULL(_t2.tombstone, 0) = 0
          )
        GROUP BY group_id
      )
      LEFT JOIN ${sql.from} ON ${sql.from}.id = group_id
      ${sql.joins}
      ${sql.orderBy}
      ${sql.limit != null ? `LIMIT ${sql.limit}` : ''}
      ${sql.offset != null ? `OFFSET ${sql.offset}` : ''}
    `;
                    rows = await _db__WEBPACK_IMPORTED_MODULE_0__.all(rowSql, params);
                    matched = new Set([].concat.apply([], rows.map((row) => row.matched.split(','))));
                }
                const where = (0, _db_util__WEBPACK_IMPORTED_MODULE_1__.whereIn)(rows.map((row) => row.group_id), `IFNULL(${sql.from}.parent_id, ${sql.from}.id)`);
                const finalSql = `
    SELECT ${sql.select}, parent_id AS _parent_id FROM ${sql.from}
    ${sql.joins}
    WHERE ${where} ${whereDead}
    ${sql.orderBy}
  `;
                const allRows = await _db__WEBPACK_IMPORTED_MODULE_0__.all(finalSql);
                // Group the parents and children up
                const { parents, children } = allRows.reduce((acc, trans) => {
                    const pid = trans._parent_id;
                    delete trans._parent_id;
                    if (pid == null) {
                        acc.parents.push(trans);
                    }
                    else {
                        const arr = acc.children.get(pid) || [];
                        arr.push(trans);
                        acc.children.set(pid, arr);
                    }
                    return acc;
                }, {
                    parents: [],
                    children: new Map()
                });
                const mapper = (trans) => {
                    Object.keys(trans).forEach((name) => {
                        trans[name] = (0, _schema_helpers__WEBPACK_IMPORTED_MODULE_4__.convertOutputType)(trans[name], outputTypes.get(name));
                    });
                    if (matched && !matched.has(trans.id)) {
                        trans._unmatched = true;
                    }
                    return trans;
                };
                return toGroup(parents, children, mapper);
            }
            async function execTransactionsBasic(state, queryState, sql, params, splitType, outputTypes) {
                const s = {
                    ...sql
                };
                if (splitType !== 'all') {
                    if (splitType === 'none') {
                        s.where = `${s.where} AND ${s.from}.parent_id IS NULL`;
                    }
                    else {
                        s.where = `${s.where} AND ${s.from}.is_parent = 0`;
                    }
                }
                return (0, _exec__WEBPACK_IMPORTED_MODULE_3__.execQuery)(queryState, state, s, params, outputTypes);
            }
            const schemaExecutors = {
                transactions: execTransactions
            };
            /***/ 
        }),
        /***/ "./packages/loot-core/src/server/aql/schema/index.ts": 
        /*!***********************************************************!*\
          !*** ./packages/loot-core/src/server/aql/schema/index.ts ***!
          \***********************************************************/
        /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony export */ __webpack_require__.d(__webpack_exports__, {
                /* harmony export */ schema: () => ( /* binding */schema),
                /* harmony export */ schemaConfig: () => ( /* binding */schemaConfig)
                /* harmony export */ 
            });
            // @ts-strict-ignore
            function f(type, opts) {
                return {
                    type,
                    ...opts
                };
            }
            // This is the table schema!
            //
            // The schema itself is the public API for querying and updating data.
            // The schema config provides a lot of control over how queries are
            // constructed other metadata used by the executors. The goal is to
            // provide a simple interface to the app, but allow the backend to
            // highly optimize how queries are run.
            //
            // A few notes:
            //
            // * `transactions` is a special table and is has a highly customized
            // executor (see `executors.js`) for performace. It should mostly be
            // transparent to you, but it's worth reading the comments in there if
            // requirements change, especially regarding split transactions.
            //
            // * You should rarely change the schema and only add to it, but it is
            // relatively safe to change if needed. The only problem is changing a
            // public API, but that could be mitigated with an option in schema
            // config to map field name for backwards compatibility.
            //
            // * It's important that the table names here in the schema map to the
            // real tables in sqlite that are updated. Otherwise subscriptions
            // might not work because the dependencies are wrong. If needed in the
            // future, we can provide another option in the schema config to map a
            // table name the internal table that is updated.
            const schema = {
                transactions: {
                    id: f('id'),
                    is_parent: f('boolean'),
                    is_child: f('boolean'),
                    parent_id: f('id'),
                    account: f('id', {
                        ref: 'accounts',
                        required: true
                    }),
                    category: f('id', {
                        ref: 'categories'
                    }),
                    amount: f('integer', {
                        default: 0,
                        required: true
                    }),
                    payee: f('id', {
                        ref: 'payees'
                    }),
                    notes: f('string'),
                    date: f('date', {
                        required: true
                    }),
                    imported_id: f('string'),
                    error: f('json'),
                    imported_payee: f('string'),
                    starting_balance_flag: f('boolean'),
                    transfer_id: f('id'),
                    sort_order: f('float', {
                        default: () => Date.now()
                    }),
                    cleared: f('boolean', {
                        default: true
                    }),
                    reconciled: f('boolean', {
                        default: false
                    }),
                    tombstone: f('boolean'),
                    schedule: f('id', {
                        ref: 'schedules'
                    })
                },
                payees: {
                    id: f('id'),
                    name: f('string', {
                        required: true
                    }),
                    transfer_acct: f('id', {
                        ref: 'accounts'
                    }),
                    tombstone: f('boolean'),
                    favorite: f('boolean')
                },
                accounts: {
                    id: f('id'),
                    name: f('string', {
                        required: true
                    }),
                    offbudget: f('boolean'),
                    closed: f('boolean'),
                    sort_order: f('float'),
                    tombstone: f('boolean'),
                    account_id: f('string'),
                    official_name: f('string'),
                    account_sync_source: f('string')
                },
                categories: {
                    id: f('id'),
                    name: f('string'),
                    is_income: f('boolean'),
                    hidden: f('boolean'),
                    group: f('id', {
                        ref: 'category_groups'
                    }),
                    sort_order: f('float'),
                    tombstone: f('boolean')
                },
                category_groups: {
                    id: f('id'),
                    name: f('string'),
                    is_income: f('boolean'),
                    hidden: f('boolean'),
                    sort_order: f('float'),
                    tombstone: f('boolean')
                },
                schedules: {
                    id: f('id'),
                    name: f('string'),
                    rule: f('id', {
                        ref: 'rules',
                        required: true
                    }),
                    next_date: f('date'),
                    completed: f('boolean'),
                    posts_transaction: f('boolean'),
                    tombstone: f('boolean'),
                    // These are special fields that are actually pulled from the
                    // underlying rule
                    _payee: f('id', {
                        ref: 'payees'
                    }),
                    _account: f('id', {
                        ref: 'accounts'
                    }),
                    _amount: f('json/fallback'),
                    _amountOp: f('string'),
                    _date: f('json/fallback'),
                    _conditions: f('json'),
                    _actions: f('json')
                },
                rules: {
                    id: f('id'),
                    stage: f('string'),
                    conditions_op: f('string'),
                    conditions: f('json'),
                    actions: f('json'),
                    tombstone: f('boolean')
                },
                notes: {
                    id: f('id'),
                    note: f('string')
                },
                transaction_filters: {
                    id: f('id'),
                    name: f('string'),
                    conditions_op: f('string'),
                    conditions: f('json'),
                    tombstone: f('boolean')
                },
                custom_reports: {
                    id: f('id'),
                    name: f('string'),
                    start_date: f('string', {
                        default: '2023-06'
                    }),
                    end_date: f('string', {
                        default: '2023-09'
                    }),
                    date_static: f('integer', {
                        default: 0
                    }),
                    date_range: f('string'),
                    mode: f('string', {
                        default: 'total'
                    }),
                    group_by: f('string', {
                        default: 'Category'
                    }),
                    balance_type: f('string', {
                        default: 'Expense'
                    }),
                    show_empty: f('integer', {
                        default: 0
                    }),
                    show_offbudget: f('integer', {
                        default: 0
                    }),
                    show_hidden: f('integer', {
                        default: 0
                    }),
                    show_uncategorized: f('integer', {
                        default: 0
                    }),
                    include_current: f('integer', {
                        default: 0
                    }),
                    selected_categories: f('json'),
                    graph_type: f('string', {
                        default: 'BarGraph'
                    }),
                    conditions: f('json'),
                    conditions_op: f('string'),
                    metadata: f('json'),
                    interval: f('string', {
                        default: 'Monthly'
                    }),
                    color_scheme: f('json'),
                    tombstone: f('boolean')
                },
                reflect_budgets: {
                    id: f('id'),
                    month: f('integer'),
                    category: f('string'),
                    amount: f('integer'),
                    carryover: f('integer'),
                    goal: f('integer'),
                    long_goal: f('integer')
                },
                zero_budgets: {
                    id: f('id'),
                    month: f('integer'),
                    category: f('string'),
                    amount: f('integer'),
                    carryover: f('integer'),
                    goal: f('integer'),
                    long_goal: f('integer')
                }
            };
            const schemaConfig = {
                // Note: these views *must* represent the underlying table that we
                // are mapping here. The compiler makes optimizations with this
                // assumption
                tableViews(name, { isJoin, withDead, tableOptions = {
                    splits: undefined
                } }) {
                    switch (name) {
                        case 'transactions':
                            {
                                // If joining, we always only show alive transactions. There's
                                // no way to configure join behavior yet
                                if (isJoin) {
                                    return 'v_transactions_internal_alive';
                                }
                                const splitType = tableOptions.splits || 'inline';
                                // Use the view to exclude dead transactions if using `inline` or `none`
                                if (!withDead && (splitType === 'inline' || splitType === 'none')) {
                                    return 'v_transactions_internal_alive';
                                }
                                // Otherwse we disregard the `withDead` option here and handle
                                // that in the executors to improve performance
                                return 'v_transactions_internal';
                            }
                        case 'schedules':
                            return 'v_schedules';
                        case 'categories':
                            return 'v_categories';
                        case 'payees':
                            return 'v_payees';
                        default:
                    }
                    return name;
                },
                customizeQuery(queryState) {
                    const { table: tableName } = queryState;
                    function orderBy(orders) {
                        // If order was specified, always add id as the last sort to make
                        // it deterministic
                        if (orders.length > 0) {
                            return orders.concat([
                                'id'
                            ]);
                        }
                        // Otherwise, these are the default orders for each table
                        switch (tableName) {
                            case 'transactions':
                                return [
                                    {
                                        date: 'desc'
                                    },
                                    'starting_balance_flag',
                                    {
                                        sort_order: 'desc'
                                    },
                                    'id'
                                ];
                            case 'payees':
                                return [
                                    {
                                        $condition: {
                                            transfer_acct: null
                                        },
                                        $dir: 'desc'
                                    },
                                    {
                                        $nocase: '$name'
                                    }
                                ];
                            case 'accounts':
                                return [
                                    'sort_order',
                                    'name'
                                ];
                            case 'schedules':
                                return [
                                    {
                                        $condition: {
                                            completed: true
                                        }
                                    },
                                    'next_date'
                                ];
                            default:
                        }
                        return [];
                    }
                    return {
                        ...queryState,
                        orderExpressions: orderBy(queryState.orderExpressions)
                    };
                },
                views: {
                    payees: {
                        v_payees: (internalFields) => {
                            const fields = internalFields({
                                name: 'COALESCE(__accounts.name, _.name)'
                            });
                            return `
          SELECT ${fields} FROM payees _
          LEFT JOIN accounts __accounts ON (_.transfer_acct = __accounts.id AND __accounts.tombstone = 0)
          -- We never want to show transfer payees that are pointing to deleted accounts.
          -- Either this is not a transfer payee, if the account exists
          WHERE _.transfer_acct IS NULL OR __accounts.id IS NOT NULL
        `;
                        }
                    },
                    categories: {
                        fields: {
                            group: 'cat_group'
                        },
                        v_categories: (internalFields) => {
                            const fields = internalFields({
                                group: 'cat_group'
                            });
                            return `SELECT ${fields} FROM categories _`;
                        }
                    },
                    schedules: {
                        v_schedules: (internalFields) => {
                            /* eslint-disable rulesdir/typography */ const fields = internalFields({
                                next_date: `
            CASE
              WHEN _nd.local_next_date_ts = _nd.base_next_date_ts THEN _nd.local_next_date
              ELSE _nd.base_next_date
            END
          `,
                                _payee: `pm.targetId`,
                                _account: `json_extract(_rules.conditions, _paths.account || '.value')`,
                                _amount: `json_extract(_rules.conditions, _paths.amount || '.value')`,
                                _amountOp: `json_extract(_rules.conditions, _paths.amount || '.op')`,
                                _date: `json_extract(_rules.conditions, _paths.date || '.value')`,
                                _conditions: '_rules.conditions',
                                _actions: '_rules.actions'
                            });
                            return `
        SELECT ${fields} FROM schedules _
        LEFT JOIN schedules_next_date _nd ON _nd.schedule_id = _.id
        LEFT JOIN schedules_json_paths _paths ON _paths.schedule_id = _.id
        LEFT JOIN rules _rules ON _rules.id = _.rule
        LEFT JOIN payee_mapping pm ON pm.id = json_extract(_rules.conditions, _paths.payee || '.value')
        `;
                            /* eslint-enable rulesdir/typography */ 
                        }
                    },
                    transactions: {
                        fields: {
                            is_parent: 'isParent',
                            is_child: 'isChild',
                            account: 'acct',
                            imported_id: 'financial_id',
                            imported_payee: 'imported_description',
                            transfer_id: 'transferred_id',
                            payee: 'description'
                        },
                        v_transactions_internal: (internalFields) => {
                            // Override some fields to make custom stuff
                            const fields = internalFields({
                                payee: 'pm.targetId',
                                category: `CASE WHEN _.isParent = 1 THEN NULL ELSE cm.transferId END`,
                                amount: `IFNULL(_.amount, 0)`,
                                parent_id: 'CASE WHEN _.isChild = 0 THEN NULL ELSE _.parent_id END'
                            });
                            return `
          SELECT ${fields} FROM transactions _
          LEFT JOIN category_mapping cm ON cm.id = _.category
          LEFT JOIN payee_mapping pm ON pm.id = _.description
          WHERE
           _.date IS NOT NULL AND
           _.acct IS NOT NULL AND
           (_.isChild = 0 OR _.parent_id IS NOT NULL)
        `;
                        },
                        // We join on t2 to only include valid child transactions. We
                        // want to only include ones with valid parents, which is when
                        // an alive parent transaction exists
                        v_transactions_internal_alive: `
        SELECT _.* FROM v_transactions_internal _
        LEFT JOIN transactions t2 ON (_.is_child = 1 AND t2.id = _.parent_id)
        WHERE IFNULL(_.tombstone, 0) = 0 AND (_.is_child = 0 OR t2.tombstone = 0)
      `,
                        v_transactions: (_, publicFields) => {
                            const fields = publicFields({
                                payee: 'p.id',
                                category: 'c.id',
                                account: 'a.id'
                            });
                            // This adds an order, and also validates any id references by
                            // selecting the ids through a join which return null if they
                            // are dead
                            return `
          SELECT ${fields} FROM v_transactions_internal_alive _
          LEFT JOIN payees p ON (p.id = _.payee AND p.tombstone = 0)
          LEFT JOIN categories c ON (c.id = _.category AND c.tombstone = 0)
          LEFT JOIN accounts a ON (a.id = _.account AND a.tombstone = 0)
          ORDER BY _.date desc, _.starting_balance_flag, _.sort_order desc, _.id;
        `;
                        }
                    }
                }
            };
            /***/ 
        }),
        /***/ "./packages/loot-core/src/server/aql/schema/run-query.ts": 
        /*!***************************************************************!*\
          !*** ./packages/loot-core/src/server/aql/schema/run-query.ts ***!
          \***************************************************************/
        /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony export */ __webpack_require__.d(__webpack_exports__, {
                /* harmony export */ runCompiledQuery: () => ( /* binding */runCompiledQuery),
                /* harmony export */ runQuery: () => ( /* binding */runQuery)
                /* harmony export */ 
            });
            /* harmony import */ var _shared_query__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../shared/query */ "./packages/loot-core/src/shared/query.ts");
            /* harmony import */ var _exec__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../exec */ "./packages/loot-core/src/server/aql/exec.ts");
            /* harmony import */ var _executors__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./executors */ "./packages/loot-core/src/server/aql/schema/executors.ts");
            /* harmony import */ var _index__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./index */ "./packages/loot-core/src/server/aql/schema/index.ts");
            // @ts-strict-ignore
            function runCompiledQuery(query, sqlPieces, state, params) {
                return (0, _exec__WEBPACK_IMPORTED_MODULE_1__.runCompiledQuery)(query, sqlPieces, state, {
                    params,
                    executors: _executors__WEBPACK_IMPORTED_MODULE_2__.schemaExecutors
                });
            }
            function runQuery(query, params) {
                if (query instanceof _shared_query__WEBPACK_IMPORTED_MODULE_0__.Query) {
                    query = query.serialize();
                }
                return (0, _exec__WEBPACK_IMPORTED_MODULE_1__.runQuery)(_index__WEBPACK_IMPORTED_MODULE_3__.schema, _index__WEBPACK_IMPORTED_MODULE_3__.schemaConfig, query, {
                    params,
                    executors: _executors__WEBPACK_IMPORTED_MODULE_2__.schemaExecutors
                });
            }
            /***/ 
        }),
        /***/ "./packages/loot-core/src/server/aql/views.ts": 
        /*!****************************************************!*\
          !*** ./packages/loot-core/src/server/aql/views.ts ***!
          \****************************************************/
        /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony export */ __webpack_require__.d(__webpack_exports__, {
                /* harmony export */ makeViews: () => ( /* binding */makeViews)
                /* harmony export */ 
            });
            /* harmony import */ var _compiler__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./compiler */ "./packages/loot-core/src/server/aql/compiler.ts");
            // @ts-strict-ignore
            function selectFields(fields) {
                return Object.keys(fields).map((as) => {
                    let field = fields[as];
                    const needsAs = field !== as;
                    // If it's just an identifier, we automatically prefix it with
                    // `_.` which makes sure it references the root table
                    if (!field.match(/[ .]/)) {
                        field = `_.${field}`;
                    }
                    return needsAs ? `${field} AS ${(0, _compiler__WEBPACK_IMPORTED_MODULE_0__.quoteAlias)(as)}` : `${field}`;
                }).join(', ');
            }
            function makeViews(schema, schemaConfig) {
                const views = schemaConfig.views;
                const viewStrs = [];
                Object.keys(views).forEach((table) => {
                    const { fields: fieldMappings = {}, ...tableViews } = views[table];
                    const publicFields = Object.fromEntries(Object.keys(schema[table]).map((name) => [
                        name,
                        name
                    ]));
                    const internalFields = {
                        ...publicFields,
                        ...fieldMappings
                    };
                    Object.keys(tableViews).forEach((viewName) => {
                        const publicMaker = (overrides) => {
                            const fields = {
                                ...publicFields,
                                ...overrides
                            };
                            return selectFields(fields);
                        };
                        const internalMaker = (overrides) => {
                            const fields = {
                                ...internalFields,
                                ...overrides
                            };
                            return selectFields(fields);
                        };
                        let sql;
                        if (typeof tableViews[viewName] === 'function') {
                            sql = tableViews[viewName](internalMaker, publicMaker);
                        }
                        else {
                            sql = tableViews[viewName];
                        }
                        sql = sql.trim().replace(/;$/, '');
                        viewStrs.push(`
        DROP VIEW IF EXISTS ${viewName};
        CREATE VIEW ${viewName} AS ${sql};
      `);
                    });
                });
                return viewStrs.join('\n');
            }
            /***/ 
        }),
        /***/ "./packages/loot-core/src/server/backups.ts": 
        /*!**************************************************!*\
          !*** ./packages/loot-core/src/server/backups.ts ***!
          \**************************************************/
        /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony export */ __webpack_require__.d(__webpack_exports__, {
                /* harmony export */ getAvailableBackups: () => ( /* binding */getAvailableBackups),
                /* harmony export */ loadBackup: () => ( /* binding */loadBackup),
                /* harmony export */ makeBackup: () => ( /* binding */makeBackup),
                /* harmony export */ startBackupService: () => ( /* binding */startBackupService),
                /* harmony export */ stopBackupService: () => ( /* binding */stopBackupService),
                /* harmony export */ updateBackups: () => ( /* binding */updateBackups)
                /* harmony export */ 
            });
            /* harmony import */ var date_fns__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! date-fns */ "./node_modules/date-fns/esm/format/index.js");
            /* harmony import */ var uuid__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! uuid */ "./node_modules/uuid/dist/esm-node/v4.js");
            /* harmony import */ var _platform_server_connection__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../platform/server/connection */ "./packages/loot-core/src/platform/server/connection/index.api.ts");
            /* harmony import */ var _platform_server_fs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../platform/server/fs */ "./packages/loot-core/src/platform/server/fs/index.electron.ts");
            /* harmony import */ var _platform_server_sqlite__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../platform/server/sqlite */ "./packages/loot-core/src/platform/server/sqlite/index.electron.ts");
            /* harmony import */ var _shared_months__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../shared/months */ "./packages/loot-core/src/shared/months.ts");
            /* harmony import */ var _cloud_storage__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./cloud-storage */ "./packages/loot-core/src/server/cloud-storage.ts");
            /* harmony import */ var _prefs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./prefs */ "./packages/loot-core/src/server/prefs.ts");
            // @ts-strict-ignore
            // A special backup that represents the latest version of the db that
            // can be reverted to after loading a backup
            const LATEST_BACKUP_FILENAME = 'db.latest.sqlite';
            let serviceInterval = null;
            async function getBackups(id) {
                const budgetDir = _platform_server_fs__WEBPACK_IMPORTED_MODULE_1__.getBudgetDir(id);
                const backupDir = _platform_server_fs__WEBPACK_IMPORTED_MODULE_1__.join(budgetDir, 'backups');
                let paths = [];
                if (await _platform_server_fs__WEBPACK_IMPORTED_MODULE_1__.exists(backupDir)) {
                    paths = await _platform_server_fs__WEBPACK_IMPORTED_MODULE_1__.listDir(backupDir);
                    paths = paths.filter((file) => file.match(/\.sqlite$/));
                }
                const backups = await Promise.all(paths.map(async (path) => {
                    const mtime = await _platform_server_fs__WEBPACK_IMPORTED_MODULE_1__.getModifiedTime(_platform_server_fs__WEBPACK_IMPORTED_MODULE_1__.join(backupDir, path));
                    return {
                        id: path,
                        date: new Date(mtime)
                    };
                }));
                backups.sort((b1, b2) => {
                    if (b1.date < b2.date) {
                        return 1;
                    }
                    else if (b1.date > b2.date) {
                        return -1;
                    }
                    return 0;
                });
                return backups;
            }
            async function getLatestBackup(id) {
                const budgetDir = _platform_server_fs__WEBPACK_IMPORTED_MODULE_1__.getBudgetDir(id);
                if (await _platform_server_fs__WEBPACK_IMPORTED_MODULE_1__.exists(_platform_server_fs__WEBPACK_IMPORTED_MODULE_1__.join(budgetDir, LATEST_BACKUP_FILENAME))) {
                    return {
                        id: LATEST_BACKUP_FILENAME,
                        date: null,
                        isLatest: true
                    };
                }
                return null;
            }
            async function getAvailableBackups(id) {
                const backups = await getBackups(id);
                const latestBackup = await getLatestBackup(id);
                if (latestBackup) {
                    backups.unshift(latestBackup);
                }
                return backups.map((backup) => ({
                    ...backup,
                    date: backup.date ? date_fns__WEBPACK_IMPORTED_MODULE_6__["default"](backup.date, 'yyyy-MM-dd H:mm') : null
                }));
            }
            async function updateBackups(backups) {
                const byDay = backups.reduce((groups, backup) => {
                    const day = date_fns__WEBPACK_IMPORTED_MODULE_6__["default"](backup.date, 'yyyy-MM-dd');
                    groups[day] = groups[day] || [];
                    groups[day].push(backup);
                    return groups;
                }, {});
                const removed = [];
                for (const day of Object.keys(byDay)) {
                    const dayBackups = byDay[day];
                    const isToday = day === _shared_months__WEBPACK_IMPORTED_MODULE_3__.currentDay();
                    // Allow 3 backups of the current day (so fine-grained edits are
                    // kept around). Otherwise only keep around one backup per day.
                    // And only keep a total of 10 backups.
                    for (const backup of dayBackups.slice(isToday ? 3 : 1)) {
                        removed.push(backup.id);
                    }
                }
                // Get the list of remaining backups and only keep the latest 10
                const currentBackups = backups.filter((backup) => !removed.includes(backup.id));
                return removed.concat(currentBackups.slice(10).map((backup) => backup.id));
            }
            async function makeBackup(id) {
                const budgetDir = _platform_server_fs__WEBPACK_IMPORTED_MODULE_1__.getBudgetDir(id);
                // When making a backup, we no longer consider the user to be
                // viewing any backups. If there exists a "latest backup" we should
                // delete it and consider whatever is current as the latest
                if (await _platform_server_fs__WEBPACK_IMPORTED_MODULE_1__.exists(_platform_server_fs__WEBPACK_IMPORTED_MODULE_1__.join(budgetDir, LATEST_BACKUP_FILENAME))) {
                    await _platform_server_fs__WEBPACK_IMPORTED_MODULE_1__.removeFile(_platform_server_fs__WEBPACK_IMPORTED_MODULE_1__.join(_platform_server_fs__WEBPACK_IMPORTED_MODULE_1__.getBudgetDir(id), LATEST_BACKUP_FILENAME));
                }
                const backupId = `${(0, uuid__WEBPACK_IMPORTED_MODULE_7__["default"])()}.sqlite`;
                const backupPath = _platform_server_fs__WEBPACK_IMPORTED_MODULE_1__.join(budgetDir, 'backups', backupId);
                if (!await _platform_server_fs__WEBPACK_IMPORTED_MODULE_1__.exists(_platform_server_fs__WEBPACK_IMPORTED_MODULE_1__.join(budgetDir, 'backups'))) {
                    await _platform_server_fs__WEBPACK_IMPORTED_MODULE_1__.mkdir(_platform_server_fs__WEBPACK_IMPORTED_MODULE_1__.join(budgetDir, 'backups'));
                }
                await _platform_server_fs__WEBPACK_IMPORTED_MODULE_1__.copyFile(_platform_server_fs__WEBPACK_IMPORTED_MODULE_1__.join(budgetDir, 'db.sqlite'), backupPath);
                // Remove all the messages from the backup
                const db = _platform_server_sqlite__WEBPACK_IMPORTED_MODULE_2__.openDatabase(backupPath);
                await _platform_server_sqlite__WEBPACK_IMPORTED_MODULE_2__.runQuery(db, 'DELETE FROM messages_crdt');
                await _platform_server_sqlite__WEBPACK_IMPORTED_MODULE_2__.runQuery(db, 'DELETE FROM messages_clock');
                _platform_server_sqlite__WEBPACK_IMPORTED_MODULE_2__.closeDatabase(db);
                const toRemove = await updateBackups(await getBackups(id));
                for (const id of toRemove) {
                    await _platform_server_fs__WEBPACK_IMPORTED_MODULE_1__.removeFile(_platform_server_fs__WEBPACK_IMPORTED_MODULE_1__.join(budgetDir, 'backups', id));
                }
                _platform_server_connection__WEBPACK_IMPORTED_MODULE_0__.send('backups-updated', await getAvailableBackups(id));
            }
            async function loadBackup(id, backupId) {
                const budgetDir = _platform_server_fs__WEBPACK_IMPORTED_MODULE_1__.getBudgetDir(id);
                if (!await _platform_server_fs__WEBPACK_IMPORTED_MODULE_1__.exists(_platform_server_fs__WEBPACK_IMPORTED_MODULE_1__.join(budgetDir, LATEST_BACKUP_FILENAME))) {
                    // If this is the first time we're loading a backup, save the
                    // current version so the user can easily revert back to it
                    await _platform_server_fs__WEBPACK_IMPORTED_MODULE_1__.copyFile(_platform_server_fs__WEBPACK_IMPORTED_MODULE_1__.join(budgetDir, 'db.sqlite'), _platform_server_fs__WEBPACK_IMPORTED_MODULE_1__.join(budgetDir, LATEST_BACKUP_FILENAME));
                    await _platform_server_fs__WEBPACK_IMPORTED_MODULE_1__.copyFile(_platform_server_fs__WEBPACK_IMPORTED_MODULE_1__.join(budgetDir, 'metadata.json'), _platform_server_fs__WEBPACK_IMPORTED_MODULE_1__.join(budgetDir, 'metadata.latest.json'));
                    // Restart the backup service to make sure the user has the full
                    // amount of time to figure out which one they want
                    stopBackupService();
                    startBackupService(id);
                    await _prefs__WEBPACK_IMPORTED_MODULE_5__.loadPrefs(id);
                }
                if (backupId === LATEST_BACKUP_FILENAME) {
                    console.log('Reverting backup');
                    // If reverting back to the latest, copy and delete the latest
                    // backup
                    await _platform_server_fs__WEBPACK_IMPORTED_MODULE_1__.copyFile(_platform_server_fs__WEBPACK_IMPORTED_MODULE_1__.join(budgetDir, LATEST_BACKUP_FILENAME), _platform_server_fs__WEBPACK_IMPORTED_MODULE_1__.join(budgetDir, 'db.sqlite'));
                    await _platform_server_fs__WEBPACK_IMPORTED_MODULE_1__.copyFile(_platform_server_fs__WEBPACK_IMPORTED_MODULE_1__.join(budgetDir, 'metadata.latest.json'), _platform_server_fs__WEBPACK_IMPORTED_MODULE_1__.join(budgetDir, 'metadata.json'));
                    await _platform_server_fs__WEBPACK_IMPORTED_MODULE_1__.removeFile(_platform_server_fs__WEBPACK_IMPORTED_MODULE_1__.join(budgetDir, LATEST_BACKUP_FILENAME));
                    await _platform_server_fs__WEBPACK_IMPORTED_MODULE_1__.removeFile(_platform_server_fs__WEBPACK_IMPORTED_MODULE_1__.join(budgetDir, 'metadata.latest.json'));
                    // Re-upload the new file
                    try {
                        await _cloud_storage__WEBPACK_IMPORTED_MODULE_4__.upload();
                    }
                    catch (e) { }
                    _prefs__WEBPACK_IMPORTED_MODULE_5__.unloadPrefs();
                }
                else {
                    console.log('Loading backup', backupId);
                    // This function is only ever called when a budget isn't loaded,
                    // so it's safe to load our prefs in. We need to forget about any
                    // syncing data if we are loading a backup (the current sync data
                    // will be restored if the user reverts to the original version)
                    await _prefs__WEBPACK_IMPORTED_MODULE_5__.loadPrefs(id);
                    await _prefs__WEBPACK_IMPORTED_MODULE_5__.savePrefs({
                        groupId: null,
                        lastSyncedTimestamp: null,
                        lastUploaded: null
                    });
                    // Re-upload the new file
                    try {
                        await _cloud_storage__WEBPACK_IMPORTED_MODULE_4__.upload();
                    }
                    catch (e) { }
                    _prefs__WEBPACK_IMPORTED_MODULE_5__.unloadPrefs();
                    await _platform_server_fs__WEBPACK_IMPORTED_MODULE_1__.copyFile(_platform_server_fs__WEBPACK_IMPORTED_MODULE_1__.join(budgetDir, 'backups', backupId), _platform_server_fs__WEBPACK_IMPORTED_MODULE_1__.join(budgetDir, 'db.sqlite'));
                }
            }
            function startBackupService(id) {
                if (serviceInterval) {
                    clearInterval(serviceInterval);
                }
                // Make a backup every 15 minutes
                serviceInterval = setInterval(async () => {
                    console.log('Making backup');
                    await makeBackup(id);
                }, 1000 * 60 * 15);
            }
            function stopBackupService() {
                clearInterval(serviceInterval);
                serviceInterval = null;
            }
            /***/ 
        }),
        /***/ "./packages/loot-core/src/server/budget/actions.ts": 
        /*!*********************************************************!*\
          !*** ./packages/loot-core/src/server/budget/actions.ts ***!
          \*********************************************************/
        /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony export */ __webpack_require__.d(__webpack_exports__, {
                /* harmony export */ copyPreviousMonth: () => ( /* binding */copyPreviousMonth),
                /* harmony export */ copySinglePreviousMonth: () => ( /* binding */copySinglePreviousMonth),
                /* harmony export */ coverOverbudgeted: () => ( /* binding */coverOverbudgeted),
                /* harmony export */ coverOverspending: () => ( /* binding */coverOverspending),
                /* harmony export */ getBudget: () => ( /* binding */getBudget),
                /* harmony export */ getSheetValue: () => ( /* binding */getSheetValue),
                /* harmony export */ holdForNextMonth: () => ( /* binding */holdForNextMonth),
                /* harmony export */ isReflectBudget: () => ( /* binding */isReflectBudget),
                /* harmony export */ resetHold: () => ( /* binding */resetHold),
                /* harmony export */ set3MonthAvg: () => ( /* binding */set3MonthAvg),
                /* harmony export */ setBudget: () => ( /* binding */setBudget),
                /* harmony export */ setBuffer: () => ( /* binding */setBuffer),
                /* harmony export */ setCategoryCarryover: () => ( /* binding */setCategoryCarryover),
                /* harmony export */ setGoal: () => ( /* binding */setGoal),
                /* harmony export */ setNMonthAvg: () => ( /* binding */setNMonthAvg),
                /* harmony export */ setZero: () => ( /* binding */setZero),
                /* harmony export */ transferAvailable: () => ( /* binding */transferAvailable),
                /* harmony export */ transferCategory: () => ( /* binding */transferCategory)
                /* harmony export */ 
            });
            /* harmony import */ var _shared_months__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../shared/months */ "./packages/loot-core/src/shared/months.ts");
            /* harmony import */ var _shared_util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../shared/util */ "./packages/loot-core/src/shared/util.ts");
            /* harmony import */ var _db__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../db */ "./packages/loot-core/src/server/db/index.ts");
            /* harmony import */ var _prefs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../prefs */ "./packages/loot-core/src/server/prefs.ts");
            /* harmony import */ var _sheet__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../sheet */ "./packages/loot-core/src/server/sheet.ts");
            /* harmony import */ var _sync__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../sync */ "./packages/loot-core/src/server/sync/index.ts");
            // @ts-strict-ignore
            async function getSheetValue(sheetName, cell) {
                const node = await _sheet__WEBPACK_IMPORTED_MODULE_4__.getCell(sheetName, cell);
                return (0, _shared_util__WEBPACK_IMPORTED_MODULE_1__.safeNumber)(typeof node.value === 'number' ? node.value : 0);
            }
            // We want to only allow the positive movement of money back and
            // forth. buffered should never be allowed to go into the negative,
            // and you shouldn't be allowed to pull non-existent money from
            // leftover.
            function calcBufferedAmount(toBudget, buffered, amount) {
                amount = Math.min(Math.max(amount, -buffered), Math.max(toBudget, 0));
                return buffered + amount;
            }
            function getBudgetTable() {
                const { budgetType } = _prefs__WEBPACK_IMPORTED_MODULE_3__.getPrefs() || {};
                return budgetType === 'report' ? 'reflect_budgets' : 'zero_budgets';
            }
            function isReflectBudget() {
                const { budgetType } = _prefs__WEBPACK_IMPORTED_MODULE_3__.getPrefs();
                return budgetType === 'report';
            }
            function dbMonth(month) {
                return parseInt(month.replace('-', ''));
            }
            function getBudgetData(table, month) {
                return _db__WEBPACK_IMPORTED_MODULE_2__.all(`
    SELECT b.*, c.is_income FROM v_categories c
    LEFT JOIN ${table} b ON b.category = c.id
    WHERE c.tombstone = 0 AND b.month = ?
  `, [
                    month
                ]);
            }
            function getAllMonths(startMonth) {
                const { createdMonths } = _sheet__WEBPACK_IMPORTED_MODULE_4__.get().meta();
                let latest = null;
                for (const month of createdMonths) {
                    if (latest == null || month > latest) {
                        latest = month;
                    }
                }
                return _shared_months__WEBPACK_IMPORTED_MODULE_0__.rangeInclusive(startMonth, latest);
            }
            // TODO: Valid month format in all the functions below
            function getBudget({ category, month }) {
                const table = getBudgetTable();
                const existing = _db__WEBPACK_IMPORTED_MODULE_2__.firstSync(`SELECT * FROM ${table} WHERE month = ? AND category = ?`, [
                    dbMonth(month),
                    category
                ]);
                return existing ? existing.amount || 0 : 0;
            }
            function setBudget({ category, month, amount }) {
                amount = (0, _shared_util__WEBPACK_IMPORTED_MODULE_1__.safeNumber)(typeof amount === 'number' ? amount : 0);
                const table = getBudgetTable();
                const existing = _db__WEBPACK_IMPORTED_MODULE_2__.firstSync(`SELECT id FROM ${table} WHERE month = ? AND category = ?`, [
                    dbMonth(month),
                    category
                ]);
                if (existing) {
                    return _db__WEBPACK_IMPORTED_MODULE_2__.update(table, {
                        id: existing.id,
                        amount
                    });
                }
                return _db__WEBPACK_IMPORTED_MODULE_2__.insert(table, {
                    id: `${dbMonth(month)}-${category}`,
                    month: dbMonth(month),
                    category,
                    amount
                });
            }
            function setGoal({ month, category, goal, long_goal }) {
                const table = getBudgetTable();
                const existing = _db__WEBPACK_IMPORTED_MODULE_2__.firstSync(`SELECT id FROM ${table} WHERE month = ? AND category = ?`, [
                    dbMonth(month),
                    category
                ]);
                if (existing) {
                    return _db__WEBPACK_IMPORTED_MODULE_2__.update(table, {
                        id: existing.id,
                        goal,
                        long_goal
                    });
                }
                return _db__WEBPACK_IMPORTED_MODULE_2__.insert(table, {
                    id: `${dbMonth(month)}-${category}`,
                    month: dbMonth(month),
                    category,
                    goal,
                    long_goal
                });
            }
            function setBuffer(month, amount) {
                const existing = _db__WEBPACK_IMPORTED_MODULE_2__.firstSync(`SELECT id FROM zero_budget_months WHERE id = ?`, [
                    month
                ]);
                if (existing) {
                    return _db__WEBPACK_IMPORTED_MODULE_2__.update('zero_budget_months', {
                        id: existing.id,
                        buffered: amount
                    });
                }
                return _db__WEBPACK_IMPORTED_MODULE_2__.insert('zero_budget_months', {
                    id: month,
                    buffered: amount
                });
            }
            function setCarryover(table, category, month, flag) {
                const existing = _db__WEBPACK_IMPORTED_MODULE_2__.firstSync(`SELECT id FROM ${table} WHERE month = ? AND category = ?`, [
                    month,
                    category
                ]);
                if (existing) {
                    return _db__WEBPACK_IMPORTED_MODULE_2__.update(table, {
                        id: existing.id,
                        carryover: flag ? 1 : 0
                    });
                }
                return _db__WEBPACK_IMPORTED_MODULE_2__.insert(table, {
                    id: `${month}-${category}`,
                    month,
                    category,
                    carryover: flag ? 1 : 0
                });
            }
            // Actions
            async function copyPreviousMonth({ month }) {
                const prevMonth = dbMonth(_shared_months__WEBPACK_IMPORTED_MODULE_0__.prevMonth(month));
                const table = getBudgetTable();
                const budgetData = await getBudgetData(table, prevMonth.toString());
                await (0, _sync__WEBPACK_IMPORTED_MODULE_5__.batchMessages)(async () => {
                    budgetData.forEach((prevBudget) => {
                        if (prevBudget.is_income === 1 && !isReflectBudget()) {
                            return;
                        }
                        setBudget({
                            category: prevBudget.category,
                            month,
                            amount: prevBudget.amount
                        });
                    });
                });
            }
            async function copySinglePreviousMonth({ month, category }) {
                const prevMonth = _shared_months__WEBPACK_IMPORTED_MODULE_0__.prevMonth(month);
                const newAmount = await getSheetValue(_shared_months__WEBPACK_IMPORTED_MODULE_0__.sheetForMonth(prevMonth), 'budget-' + category);
                await (0, _sync__WEBPACK_IMPORTED_MODULE_5__.batchMessages)(async () => {
                    setBudget({
                        category,
                        month,
                        amount: newAmount
                    });
                });
            }
            async function setZero({ month }) {
                const categories = await _db__WEBPACK_IMPORTED_MODULE_2__.all('SELECT * FROM v_categories WHERE tombstone = 0');
                await (0, _sync__WEBPACK_IMPORTED_MODULE_5__.batchMessages)(async () => {
                    categories.forEach((cat) => {
                        if (cat.is_income === 1 && !isReflectBudget()) {
                            return;
                        }
                        setBudget({
                            category: cat.id,
                            month,
                            amount: 0
                        });
                    });
                });
            }
            async function set3MonthAvg({ month }) {
                const categories = await _db__WEBPACK_IMPORTED_MODULE_2__.all('SELECT * FROM v_categories WHERE tombstone = 0');
                const prevMonth1 = _shared_months__WEBPACK_IMPORTED_MODULE_0__.prevMonth(month);
                const prevMonth2 = _shared_months__WEBPACK_IMPORTED_MODULE_0__.prevMonth(prevMonth1);
                const prevMonth3 = _shared_months__WEBPACK_IMPORTED_MODULE_0__.prevMonth(prevMonth2);
                await (0, _sync__WEBPACK_IMPORTED_MODULE_5__.batchMessages)(async () => {
                    for (const cat of categories) {
                        if (cat.is_income === 1 && !isReflectBudget()) {
                            continue;
                        }
                        const spent1 = await getSheetValue(_shared_months__WEBPACK_IMPORTED_MODULE_0__.sheetForMonth(prevMonth1), 'sum-amount-' + cat.id);
                        const spent2 = await getSheetValue(_shared_months__WEBPACK_IMPORTED_MODULE_0__.sheetForMonth(prevMonth2), 'sum-amount-' + cat.id);
                        const spent3 = await getSheetValue(_shared_months__WEBPACK_IMPORTED_MODULE_0__.sheetForMonth(prevMonth3), 'sum-amount-' + cat.id);
                        let avg = Math.round((spent1 + spent2 + spent3) / 3);
                        if (cat.is_income === 0) {
                            avg *= -1;
                        }
                        setBudget({
                            category: cat.id,
                            month,
                            amount: avg
                        });
                    }
                });
            }
            async function setNMonthAvg({ month, N, category }) {
                const categoryFromDb = await _db__WEBPACK_IMPORTED_MODULE_2__.first('SELECT is_income FROM v_categories WHERE id = ?', [
                    category
                ]);
                let prevMonth = _shared_months__WEBPACK_IMPORTED_MODULE_0__.prevMonth(month);
                let sumAmount = 0;
                for (let l = 0; l < N; l++) {
                    sumAmount += await getSheetValue(_shared_months__WEBPACK_IMPORTED_MODULE_0__.sheetForMonth(prevMonth), 'sum-amount-' + category);
                    prevMonth = _shared_months__WEBPACK_IMPORTED_MODULE_0__.prevMonth(prevMonth);
                }
                await (0, _sync__WEBPACK_IMPORTED_MODULE_5__.batchMessages)(async () => {
                    let avg = Math.round(sumAmount / N);
                    if (categoryFromDb.is_income === 0) {
                        avg *= -1;
                    }
                    setBudget({
                        category,
                        month,
                        amount: avg
                    });
                });
            }
            async function holdForNextMonth({ month, amount }) {
                const row = await _db__WEBPACK_IMPORTED_MODULE_2__.first('SELECT buffered FROM zero_budget_months WHERE id = ?', [
                    month
                ]);
                const sheetName = _shared_months__WEBPACK_IMPORTED_MODULE_0__.sheetForMonth(month);
                const toBudget = await getSheetValue(sheetName, 'to-budget');
                if (toBudget > 0) {
                    const bufferedAmount = calcBufferedAmount(toBudget, row && row.buffered || 0, amount);
                    await setBuffer(month, bufferedAmount);
                    return true;
                }
                return false;
            }
            async function resetHold({ month }) {
                await setBuffer(month, 0);
            }
            async function coverOverspending({ month, to, from }) {
                const sheetName = _shared_months__WEBPACK_IMPORTED_MODULE_0__.sheetForMonth(month);
                const toBudgeted = await getSheetValue(sheetName, 'budget-' + to);
                const leftover = await getSheetValue(sheetName, 'leftover-' + to);
                const leftoverFrom = await getSheetValue(sheetName, from === 'to-be-budgeted' ? 'to-budget' : 'leftover-' + from);
                if (leftover >= 0 || leftoverFrom <= 0) {
                    return;
                }
                const amountCovered = Math.min(-leftover, leftoverFrom);
                // If we are covering it from the to be budgeted amount, ignore this
                if (from !== 'to-be-budgeted') {
                    const fromBudgeted = await getSheetValue(sheetName, 'budget-' + from);
                    await setBudget({
                        category: from,
                        month,
                        amount: fromBudgeted - amountCovered
                    });
                }
                await setBudget({
                    category: to,
                    month,
                    amount: toBudgeted + amountCovered
                });
            }
            async function transferAvailable({ month, amount, category }) {
                const sheetName = _shared_months__WEBPACK_IMPORTED_MODULE_0__.sheetForMonth(month);
                const leftover = await getSheetValue(sheetName, 'to-budget');
                amount = Math.max(Math.min(amount, leftover), 0);
                const budgeted = await getSheetValue(sheetName, 'budget-' + category);
                await setBudget({
                    category,
                    month,
                    amount: budgeted + amount
                });
            }
            async function coverOverbudgeted({ month, category }) {
                const sheetName = _shared_months__WEBPACK_IMPORTED_MODULE_0__.sheetForMonth(month);
                const toBudget = await getSheetValue(sheetName, 'to-budget');
                const categoryBudget = await getSheetValue(sheetName, 'budget-' + category);
                await setBudget({
                    category,
                    month,
                    amount: categoryBudget + toBudget
                });
            }
            async function transferCategory({ month, amount, from, to }) {
                const sheetName = _shared_months__WEBPACK_IMPORTED_MODULE_0__.sheetForMonth(month);
                const fromBudgeted = await getSheetValue(sheetName, 'budget-' + from);
                await setBudget({
                    category: from,
                    month,
                    amount: fromBudgeted - amount
                });
                // If we are simply moving it back into available cash to budget,
                // don't do anything else
                if (to !== 'to-be-budgeted') {
                    const toBudgeted = await getSheetValue(sheetName, 'budget-' + to);
                    await setBudget({
                        category: to,
                        month,
                        amount: toBudgeted + amount
                    });
                }
            }
            async function setCategoryCarryover({ startMonth, category, flag }) {
                const table = getBudgetTable();
                const months = getAllMonths(startMonth);
                await (0, _sync__WEBPACK_IMPORTED_MODULE_5__.batchMessages)(async () => {
                    for (const month of months) {
                        setCarryover(table, category, dbMonth(month).toString(), flag);
                    }
                });
            }
            /***/ 
        }),
        /***/ "./packages/loot-core/src/server/budget/app.ts": 
        /*!*****************************************************!*\
          !*** ./packages/loot-core/src/server/budget/app.ts ***!
          \*****************************************************/
        /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony export */ __webpack_require__.d(__webpack_exports__, {
                /* harmony export */ app: () => ( /* binding */app)
                /* harmony export */ 
            });
            /* harmony import */ var _app__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../app */ "./packages/loot-core/src/server/app.ts");
            /* harmony import */ var _mutators__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../mutators */ "./packages/loot-core/src/server/mutators.ts");
            /* harmony import */ var _undo__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../undo */ "./packages/loot-core/src/server/undo.ts");
            /* harmony import */ var _actions__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./actions */ "./packages/loot-core/src/server/budget/actions.ts");
            /* harmony import */ var _cleanup_template__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./cleanup-template */ "./packages/loot-core/src/server/budget/cleanup-template.ts");
            /* harmony import */ var _goaltemplates__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./goaltemplates */ "./packages/loot-core/src/server/budget/goaltemplates.ts");
            const app = (0, _app__WEBPACK_IMPORTED_MODULE_0__.createApp)();
            app.method('budget/budget-amount', (0, _mutators__WEBPACK_IMPORTED_MODULE_1__.mutator)((0, _undo__WEBPACK_IMPORTED_MODULE_2__.undoable)(_actions__WEBPACK_IMPORTED_MODULE_3__.setBudget)));
            app.method('budget/copy-previous-month', (0, _mutators__WEBPACK_IMPORTED_MODULE_1__.mutator)((0, _undo__WEBPACK_IMPORTED_MODULE_2__.undoable)(_actions__WEBPACK_IMPORTED_MODULE_3__.copyPreviousMonth)));
            app.method('budget/copy-single-month', (0, _mutators__WEBPACK_IMPORTED_MODULE_1__.mutator)((0, _undo__WEBPACK_IMPORTED_MODULE_2__.undoable)(_actions__WEBPACK_IMPORTED_MODULE_3__.copySinglePreviousMonth)));
            app.method('budget/set-zero', (0, _mutators__WEBPACK_IMPORTED_MODULE_1__.mutator)((0, _undo__WEBPACK_IMPORTED_MODULE_2__.undoable)(_actions__WEBPACK_IMPORTED_MODULE_3__.setZero)));
            app.method('budget/set-3month-avg', (0, _mutators__WEBPACK_IMPORTED_MODULE_1__.mutator)((0, _undo__WEBPACK_IMPORTED_MODULE_2__.undoable)(_actions__WEBPACK_IMPORTED_MODULE_3__.set3MonthAvg)));
            app.method('budget/set-n-month-avg', (0, _mutators__WEBPACK_IMPORTED_MODULE_1__.mutator)((0, _undo__WEBPACK_IMPORTED_MODULE_2__.undoable)(_actions__WEBPACK_IMPORTED_MODULE_3__.setNMonthAvg)));
            app.method('budget/check-templates', (0, _mutators__WEBPACK_IMPORTED_MODULE_1__.mutator)((0, _undo__WEBPACK_IMPORTED_MODULE_2__.undoable)(_goaltemplates__WEBPACK_IMPORTED_MODULE_5__.runCheckTemplates)));
            app.method('budget/apply-goal-template', (0, _mutators__WEBPACK_IMPORTED_MODULE_1__.mutator)((0, _undo__WEBPACK_IMPORTED_MODULE_2__.undoable)(_goaltemplates__WEBPACK_IMPORTED_MODULE_5__.applyTemplate)));
            app.method('budget/overwrite-goal-template', (0, _mutators__WEBPACK_IMPORTED_MODULE_1__.mutator)((0, _undo__WEBPACK_IMPORTED_MODULE_2__.undoable)(_goaltemplates__WEBPACK_IMPORTED_MODULE_5__.overwriteTemplate)));
            app.method('budget/apply-single-template', (0, _mutators__WEBPACK_IMPORTED_MODULE_1__.mutator)((0, _undo__WEBPACK_IMPORTED_MODULE_2__.undoable)(_goaltemplates__WEBPACK_IMPORTED_MODULE_5__.applySingleCategoryTemplate)));
            app.method('budget/cleanup-goal-template', (0, _mutators__WEBPACK_IMPORTED_MODULE_1__.mutator)((0, _undo__WEBPACK_IMPORTED_MODULE_2__.undoable)(_cleanup_template__WEBPACK_IMPORTED_MODULE_4__.cleanupTemplate)));
            app.method('budget/hold-for-next-month', (0, _mutators__WEBPACK_IMPORTED_MODULE_1__.mutator)((0, _undo__WEBPACK_IMPORTED_MODULE_2__.undoable)(_actions__WEBPACK_IMPORTED_MODULE_3__.holdForNextMonth)));
            app.method('budget/reset-hold', (0, _mutators__WEBPACK_IMPORTED_MODULE_1__.mutator)((0, _undo__WEBPACK_IMPORTED_MODULE_2__.undoable)(_actions__WEBPACK_IMPORTED_MODULE_3__.resetHold)));
            app.method('budget/cover-overspending', (0, _mutators__WEBPACK_IMPORTED_MODULE_1__.mutator)((0, _undo__WEBPACK_IMPORTED_MODULE_2__.undoable)(_actions__WEBPACK_IMPORTED_MODULE_3__.coverOverspending)));
            app.method('budget/transfer-available', (0, _mutators__WEBPACK_IMPORTED_MODULE_1__.mutator)((0, _undo__WEBPACK_IMPORTED_MODULE_2__.undoable)(_actions__WEBPACK_IMPORTED_MODULE_3__.transferAvailable)));
            app.method('budget/cover-overbudgeted', (0, _mutators__WEBPACK_IMPORTED_MODULE_1__.mutator)((0, _undo__WEBPACK_IMPORTED_MODULE_2__.undoable)(_actions__WEBPACK_IMPORTED_MODULE_3__.coverOverbudgeted)));
            app.method('budget/transfer-category', (0, _mutators__WEBPACK_IMPORTED_MODULE_1__.mutator)((0, _undo__WEBPACK_IMPORTED_MODULE_2__.undoable)(_actions__WEBPACK_IMPORTED_MODULE_3__.transferCategory)));
            app.method('budget/set-carryover', (0, _mutators__WEBPACK_IMPORTED_MODULE_1__.mutator)((0, _undo__WEBPACK_IMPORTED_MODULE_2__.undoable)(_actions__WEBPACK_IMPORTED_MODULE_3__.setCategoryCarryover)));
            /***/ 
        }),
        /***/ "./packages/loot-core/src/server/budget/base.ts": 
        /*!******************************************************!*\
          !*** ./packages/loot-core/src/server/budget/base.ts ***!
          \******************************************************/
        /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony export */ __webpack_require__.d(__webpack_exports__, {
                /* harmony export */ createAllBudgets: () => ( /* binding */createAllBudgets),
                /* harmony export */ createBudget: () => ( /* binding */createBudget),
                /* harmony export */ doTransfer: () => ( /* binding */doTransfer),
                /* harmony export */ getBudgetRange: () => ( /* binding */getBudgetRange),
                /* harmony export */ getBudgetType: () => ( /* binding */getBudgetType),
                /* harmony export */ setType: () => ( /* binding */setType),
                /* harmony export */ triggerBudgetChanges: () => ( /* binding */triggerBudgetChanges)
                /* harmony export */ 
            });
            /* harmony import */ var _shared_months__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../shared/months */ "./packages/loot-core/src/shared/months.ts");
            /* harmony import */ var _shared_util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../shared/util */ "./packages/loot-core/src/shared/util.ts");
            /* harmony import */ var _db__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../db */ "./packages/loot-core/src/server/db/index.ts");
            /* harmony import */ var _sheet__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../sheet */ "./packages/loot-core/src/server/sheet.ts");
            /* harmony import */ var _spreadsheet_util__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../spreadsheet/util */ "./packages/loot-core/src/server/spreadsheet/util.ts");
            /* harmony import */ var _actions__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./actions */ "./packages/loot-core/src/server/budget/actions.ts");
            /* harmony import */ var _report__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./report */ "./packages/loot-core/src/server/budget/report.ts");
            /* harmony import */ var _rollover__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./rollover */ "./packages/loot-core/src/server/budget/rollover.ts");
            /* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./util */ "./packages/loot-core/src/server/budget/util.ts");
            // @ts-strict-ignore
            function getBudgetType() {
                const meta = _sheet__WEBPACK_IMPORTED_MODULE_3__.get().meta();
                return meta.budgetType || 'rollover';
            }
            function getBudgetRange(start, end) {
                start = _shared_months__WEBPACK_IMPORTED_MODULE_0__.getMonth(start);
                end = _shared_months__WEBPACK_IMPORTED_MODULE_0__.getMonth(end);
                // The start date should never be after the end date. If that
                // happened, the month range might be a valid range and weird
                // things happen
                if (start > end) {
                    start = end;
                }
                // Budgets should exist 3 months before the earliest needed date
                // (either the oldest transaction or the current month if no
                // transactions yet), and a year from the current date. There's no
                // need to ever have budgets outside that range.
                start = _shared_months__WEBPACK_IMPORTED_MODULE_0__.subMonths(start, 3);
                end = _shared_months__WEBPACK_IMPORTED_MODULE_0__.addMonths(end, 12);
                return {
                    start,
                    end,
                    range: _shared_months__WEBPACK_IMPORTED_MODULE_0__.rangeInclusive(start, end)
                };
            }
            function createCategory(cat, sheetName, prevSheetName, start, end) {
                _sheet__WEBPACK_IMPORTED_MODULE_3__.get().createDynamic(sheetName, 'sum-amount-' + cat.id, {
                    initialValue: 0,
                    run: () => {
                        // Making this sync is faster!
                        const rows = _db__WEBPACK_IMPORTED_MODULE_2__.runQuery(`SELECT SUM(amount) as amount FROM v_transactions_internal_alive t
           LEFT JOIN accounts a ON a.id = t.account
         WHERE t.date >= ${start} AND t.date <= ${end}
           AND category = '${cat.id}' AND a.offbudget = 0`, [], true);
                        const row = rows[0];
                        const amount = row ? row.amount : 0;
                        return amount || 0;
                    }
                });
                if (getBudgetType() === 'rollover') {
                    _rollover__WEBPACK_IMPORTED_MODULE_7__.createCategory(cat, sheetName, prevSheetName);
                }
                else {
                    _report__WEBPACK_IMPORTED_MODULE_6__.createCategory(cat, sheetName, prevSheetName);
                }
            }
            function createCategoryGroup(group, sheetName) {
                _sheet__WEBPACK_IMPORTED_MODULE_3__.get().createDynamic(sheetName, 'group-sum-amount-' + group.id, {
                    initialValue: 0,
                    dependencies: group.categories.map((cat) => `sum-amount-${cat.id}`),
                    run: _util__WEBPACK_IMPORTED_MODULE_8__.sumAmounts
                });
                if (!group.is_income || getBudgetType() !== 'rollover') {
                    _sheet__WEBPACK_IMPORTED_MODULE_3__.get().createDynamic(sheetName, 'group-budget-' + group.id, {
                        initialValue: 0,
                        dependencies: group.categories.map((cat) => `budget-${cat.id}`),
                        run: _util__WEBPACK_IMPORTED_MODULE_8__.sumAmounts
                    });
                    _sheet__WEBPACK_IMPORTED_MODULE_3__.get().createDynamic(sheetName, 'group-leftover-' + group.id, {
                        initialValue: 0,
                        dependencies: group.categories.map((cat) => `leftover-${cat.id}`),
                        run: _util__WEBPACK_IMPORTED_MODULE_8__.sumAmounts
                    });
                }
            }
            function handleAccountChange(months, oldValue, newValue) {
                if (!oldValue || oldValue.offbudget !== newValue.offbudget) {
                    const rows = _db__WEBPACK_IMPORTED_MODULE_2__.runQuery(`
        SELECT DISTINCT(category) as category FROM transactions
        WHERE acct = ?
      `, [
                        newValue.id
                    ], true);
                    months.forEach((month) => {
                        const sheetName = _shared_months__WEBPACK_IMPORTED_MODULE_0__.sheetForMonth(month);
                        rows.forEach((row) => {
                            _sheet__WEBPACK_IMPORTED_MODULE_3__.get().recompute((0, _spreadsheet_util__WEBPACK_IMPORTED_MODULE_4__.resolveName)(sheetName, 'sum-amount-' + row.category));
                        });
                    });
                }
            }
            function handleTransactionChange(transaction, changedFields) {
                if ((changedFields.has('date') || changedFields.has('acct') || changedFields.has('amount') || changedFields.has('category') || changedFields.has('tombstone') || changedFields.has('isParent')) && transaction.date && transaction.category) {
                    const month = _shared_months__WEBPACK_IMPORTED_MODULE_0__.monthFromDate(_db__WEBPACK_IMPORTED_MODULE_2__.fromDateRepr(transaction.date));
                    const sheetName = _shared_months__WEBPACK_IMPORTED_MODULE_0__.sheetForMonth(month);
                    _sheet__WEBPACK_IMPORTED_MODULE_3__.get().recompute((0, _spreadsheet_util__WEBPACK_IMPORTED_MODULE_4__.resolveName)(sheetName, 'sum-amount-' + transaction.category));
                }
            }
            function handleCategoryMappingChange(months, oldValue, newValue) {
                months.forEach((month) => {
                    const sheetName = _shared_months__WEBPACK_IMPORTED_MODULE_0__.sheetForMonth(month);
                    if (oldValue) {
                        _sheet__WEBPACK_IMPORTED_MODULE_3__.get().recompute((0, _spreadsheet_util__WEBPACK_IMPORTED_MODULE_4__.resolveName)(sheetName, 'sum-amount-' + oldValue.transferId));
                    }
                    _sheet__WEBPACK_IMPORTED_MODULE_3__.get().recompute((0, _spreadsheet_util__WEBPACK_IMPORTED_MODULE_4__.resolveName)(sheetName, 'sum-amount-' + newValue.transferId));
                });
            }
            function handleCategoryChange(months, oldValue, newValue) {
                function addDeps(sheetName, groupId, catId) {
                    _sheet__WEBPACK_IMPORTED_MODULE_3__.get().addDependencies(sheetName, `group-sum-amount-${groupId}`, [
                        `sum-amount-${catId}`
                    ]);
                    _sheet__WEBPACK_IMPORTED_MODULE_3__.get().addDependencies(sheetName, `group-budget-${groupId}`, [
                        `budget-${catId}`
                    ]);
                    _sheet__WEBPACK_IMPORTED_MODULE_3__.get().addDependencies(sheetName, `group-leftover-${groupId}`, [
                        `leftover-${catId}`
                    ]);
                }
                function removeDeps(sheetName, groupId, catId) {
                    _sheet__WEBPACK_IMPORTED_MODULE_3__.get().removeDependencies(sheetName, `group-sum-amount-${groupId}`, [
                        `sum-amount-${catId}`
                    ]);
                    _sheet__WEBPACK_IMPORTED_MODULE_3__.get().removeDependencies(sheetName, `group-budget-${groupId}`, [
                        `budget-${catId}`
                    ]);
                    _sheet__WEBPACK_IMPORTED_MODULE_3__.get().removeDependencies(sheetName, `group-leftover-${groupId}`, [
                        `leftover-${catId}`
                    ]);
                }
                const budgetType = getBudgetType();
                if (oldValue && oldValue.tombstone === 0 && newValue.tombstone === 1) {
                    const id = newValue.id;
                    const groupId = newValue.cat_group;
                    months.forEach((month) => {
                        const sheetName = _shared_months__WEBPACK_IMPORTED_MODULE_0__.sheetForMonth(month);
                        removeDeps(sheetName, groupId, id);
                    });
                }
                else if (newValue.tombstone === 0 && (!oldValue || oldValue.tombstone === 1)) {
                    if (budgetType === 'rollover') {
                        _rollover__WEBPACK_IMPORTED_MODULE_7__.createBlankCategory(newValue, months);
                    }
                    months.forEach((month) => {
                        const prevMonth = _shared_months__WEBPACK_IMPORTED_MODULE_0__.prevMonth(month);
                        const prevSheetName = _shared_months__WEBPACK_IMPORTED_MODULE_0__.sheetForMonth(prevMonth);
                        const sheetName = _shared_months__WEBPACK_IMPORTED_MODULE_0__.sheetForMonth(month);
                        const { start, end } = _shared_months__WEBPACK_IMPORTED_MODULE_0__.bounds(month);
                        createCategory(newValue, sheetName, prevSheetName, start, end);
                        const id = newValue.id;
                        const groupId = newValue.cat_group;
                        if (getBudgetType() === 'rollover') {
                            _sheet__WEBPACK_IMPORTED_MODULE_3__.get().addDependencies(sheetName, 'last-month-overspent', [
                                `${prevSheetName}!leftover-${id}`,
                                `${prevSheetName}!carryover-${id}`
                            ]);
                        }
                        addDeps(sheetName, groupId, id);
                    });
                }
                else if (oldValue && oldValue.cat_group !== newValue.cat_group) {
                    // The category moved so we need to update the dependencies
                    const id = newValue.id;
                    months.forEach((month) => {
                        const sheetName = _shared_months__WEBPACK_IMPORTED_MODULE_0__.sheetForMonth(month);
                        removeDeps(sheetName, oldValue.cat_group, id);
                        addDeps(sheetName, newValue.cat_group, id);
                    });
                }
            }
            function handleCategoryGroupChange(months, oldValue, newValue) {
                const budgetType = getBudgetType();
                function addDeps(sheetName, groupId) {
                    _sheet__WEBPACK_IMPORTED_MODULE_3__.get().addDependencies(sheetName, 'total-budgeted', [
                        `group-budget-${groupId}`
                    ]);
                    _sheet__WEBPACK_IMPORTED_MODULE_3__.get().addDependencies(sheetName, 'total-spent', [
                        `group-sum-amount-${groupId}`
                    ]);
                    _sheet__WEBPACK_IMPORTED_MODULE_3__.get().addDependencies(sheetName, 'total-leftover', [
                        `group-leftover-${groupId}`
                    ]);
                }
                function removeDeps(sheetName, groupId) {
                    _sheet__WEBPACK_IMPORTED_MODULE_3__.get().removeDependencies(sheetName, 'total-budgeted', [
                        `group-budget-${groupId}`
                    ]);
                    _sheet__WEBPACK_IMPORTED_MODULE_3__.get().removeDependencies(sheetName, 'total-spent', [
                        `group-sum-amount-${groupId}`
                    ]);
                    _sheet__WEBPACK_IMPORTED_MODULE_3__.get().removeDependencies(sheetName, 'total-leftover', [
                        `group-leftover-${groupId}`
                    ]);
                }
                if (newValue.tombstone === 1 && oldValue && oldValue.tombstone === 0) {
                    const id = newValue.id;
                    months.forEach((month) => {
                        const sheetName = _shared_months__WEBPACK_IMPORTED_MODULE_0__.sheetForMonth(month);
                        removeDeps(sheetName, id);
                    });
                }
                else if (newValue.tombstone === 0 && (!oldValue || oldValue.tombstone === 1)) {
                    const group = newValue;
                    if (!group.is_income || budgetType !== 'rollover') {
                        months.forEach((month) => {
                            const sheetName = _shared_months__WEBPACK_IMPORTED_MODULE_0__.sheetForMonth(month);
                            // Dirty, dirty hack. These functions should not be async, but this is
                            // OK because we're leveraging the sync nature of queries. Ideally we
                            // wouldn't be querying here. But I think we have to. At least for now
                            // we do
                            const categories = _db__WEBPACK_IMPORTED_MODULE_2__.runQuery('SELECT * FROM categories WHERE tombstone = 0 AND cat_group = ?', [
                                group.id
                            ], true);
                            createCategoryGroup({
                                ...group,
                                categories
                            }, sheetName);
                            addDeps(sheetName, group.id);
                        });
                    }
                }
            }
            function handleBudgetMonthChange(budget) {
                const sheetName = _shared_months__WEBPACK_IMPORTED_MODULE_0__.sheetForMonth(budget.id);
                _sheet__WEBPACK_IMPORTED_MODULE_3__.get().set(`${sheetName}!buffered`, budget.buffered);
            }
            function handleBudgetChange(budget) {
                if (budget.category) {
                    const sheetName = _shared_months__WEBPACK_IMPORTED_MODULE_0__.sheetForMonth(budget.month.toString());
                    _sheet__WEBPACK_IMPORTED_MODULE_3__.get().set(`${sheetName}!budget-${budget.category}`, budget.amount || 0);
                    _sheet__WEBPACK_IMPORTED_MODULE_3__.get().set(`${sheetName}!carryover-${budget.category}`, budget.carryover === 1 ? true : false);
                    _sheet__WEBPACK_IMPORTED_MODULE_3__.get().set(`${sheetName}!goal-${budget.category}`, budget.goal);
                    _sheet__WEBPACK_IMPORTED_MODULE_3__.get().set(`${sheetName}!long-goal-${budget.category}`, budget.long_goal);
                }
            }
            function triggerBudgetChanges(oldValues, newValues) {
                const { createdMonths = new Set() } = _sheet__WEBPACK_IMPORTED_MODULE_3__.get().meta();
                _sheet__WEBPACK_IMPORTED_MODULE_3__.startTransaction();
                try {
                    newValues.forEach((items, table) => {
                        const old = oldValues.get(table);
                        items.forEach((newValue) => {
                            const oldValue = old && old.get(newValue.id);
                            if (table === 'zero_budget_months') {
                                handleBudgetMonthChange(newValue);
                            }
                            else if (table === 'zero_budgets' || table === 'reflect_budgets') {
                                handleBudgetChange(newValue);
                            }
                            else if (table === 'transactions') {
                                const changed = new Set(Object.keys((0, _shared_util__WEBPACK_IMPORTED_MODULE_1__.getChangedValues)(oldValue || {}, newValue) || {}));
                                if (oldValue) {
                                    handleTransactionChange(oldValue, changed);
                                }
                                handleTransactionChange(newValue, changed);
                            }
                            else if (table === 'category_mapping') {
                                handleCategoryMappingChange(createdMonths, oldValue, newValue);
                            }
                            else if (table === 'categories') {
                                handleCategoryChange(createdMonths, oldValue, newValue);
                            }
                            else if (table === 'category_groups') {
                                handleCategoryGroupChange(createdMonths, oldValue, newValue);
                            }
                            else if (table === 'accounts') {
                                handleAccountChange(createdMonths, oldValue, newValue);
                            }
                        });
                    });
                }
                finally {
                    _sheet__WEBPACK_IMPORTED_MODULE_3__.endTransaction();
                }
            }
            async function doTransfer(categoryIds, transferId) {
                const { createdMonths: months } = _sheet__WEBPACK_IMPORTED_MODULE_3__.get().meta();
                [
                    ...months
                ].forEach((month) => {
                    const totalValue = categoryIds.map((id) => {
                        return _actions__WEBPACK_IMPORTED_MODULE_5__.getBudget({
                            month,
                            category: id
                        });
                    }).reduce((total, value) => total + value, 0);
                    const transferValue = _actions__WEBPACK_IMPORTED_MODULE_5__.getBudget({
                        month,
                        category: transferId
                    });
                    _actions__WEBPACK_IMPORTED_MODULE_5__.setBudget({
                        month,
                        category: transferId,
                        amount: totalValue + transferValue
                    });
                });
            }
            async function createBudget(months) {
                const categories = await _db__WEBPACK_IMPORTED_MODULE_2__.getCategories();
                const groups = await _db__WEBPACK_IMPORTED_MODULE_2__.getCategoriesGrouped();
                _sheet__WEBPACK_IMPORTED_MODULE_3__.startTransaction();
                const meta = _sheet__WEBPACK_IMPORTED_MODULE_3__.get().meta();
                meta.createdMonths = meta.createdMonths || new Set();
                const budgetType = getBudgetType();
                if (budgetType === 'rollover') {
                    _rollover__WEBPACK_IMPORTED_MODULE_7__.createBudget(meta, categories, months);
                }
                months.forEach((month) => {
                    if (!meta.createdMonths.has(month)) {
                        const prevMonth = _shared_months__WEBPACK_IMPORTED_MODULE_0__.prevMonth(month);
                        const { start, end } = _shared_months__WEBPACK_IMPORTED_MODULE_0__.bounds(month);
                        const sheetName = _shared_months__WEBPACK_IMPORTED_MODULE_0__.sheetForMonth(month);
                        const prevSheetName = _shared_months__WEBPACK_IMPORTED_MODULE_0__.sheetForMonth(prevMonth);
                        categories.forEach((cat) => {
                            createCategory(cat, sheetName, prevSheetName, start, end);
                        });
                        groups.forEach((group) => {
                            createCategoryGroup(group, sheetName);
                        });
                        if (budgetType === 'rollover') {
                            _rollover__WEBPACK_IMPORTED_MODULE_7__.createSummary(groups, categories, prevSheetName, sheetName);
                        }
                        else {
                            _report__WEBPACK_IMPORTED_MODULE_6__.createSummary(groups, categories, sheetName);
                        }
                        meta.createdMonths.add(month);
                    }
                });
                _sheet__WEBPACK_IMPORTED_MODULE_3__.get().setMeta(meta);
                _sheet__WEBPACK_IMPORTED_MODULE_3__.endTransaction();
                // Wait for the spreadsheet to finish computing. Normally this won't
                // do anything (as values are cached) but on first run this need to
                // show the loading screen while it initially sets up.
                await _sheet__WEBPACK_IMPORTED_MODULE_3__.waitOnSpreadsheet();
            }
            async function createAllBudgets() {
                const earliestTransaction = await _db__WEBPACK_IMPORTED_MODULE_2__.first('SELECT * FROM transactions WHERE isChild=0 AND date IS NOT NULL ORDER BY date ASC LIMIT 1');
                const earliestDate = earliestTransaction && _db__WEBPACK_IMPORTED_MODULE_2__.fromDateRepr(earliestTransaction.date);
                const currentMonth = _shared_months__WEBPACK_IMPORTED_MODULE_0__.currentMonth();
                // Get the range based off of the earliest transaction and the
                // current month. If no transactions currently exist the current
                // month is also used as the starting month
                const { start, end, range } = getBudgetRange(earliestDate || currentMonth, currentMonth);
                const meta = _sheet__WEBPACK_IMPORTED_MODULE_3__.get().meta();
                const createdMonths = meta.createdMonths || new Set();
                const newMonths = range.filter((m) => !createdMonths.has(m));
                if (newMonths.length > 0) {
                    await createBudget(range);
                }
                return {
                    start,
                    end
                };
            }
            async function setType(type) {
                const meta = _sheet__WEBPACK_IMPORTED_MODULE_3__.get().meta();
                if (type === meta.budgetType) {
                    return;
                }
                meta.budgetType = type;
                meta.createdMonths = new Set();
                // Go through and force all the cells to be recomputed
                const nodes = _sheet__WEBPACK_IMPORTED_MODULE_3__.get().getNodes();
                _db__WEBPACK_IMPORTED_MODULE_2__.transaction(() => {
                    for (const name of nodes.keys()) {
                        const [sheetName, cellName] = name.split('!');
                        if (sheetName.match(/^budget\d+/)) {
                            _sheet__WEBPACK_IMPORTED_MODULE_3__.get().deleteCell(sheetName, cellName);
                        }
                    }
                });
                _sheet__WEBPACK_IMPORTED_MODULE_3__.get().startCacheBarrier();
                _sheet__WEBPACK_IMPORTED_MODULE_3__.loadUserBudgets(_db__WEBPACK_IMPORTED_MODULE_2__);
                const bounds = await createAllBudgets();
                _sheet__WEBPACK_IMPORTED_MODULE_3__.get().endCacheBarrier();
                return bounds;
            }
            /***/ 
        }),
        /***/ "./packages/loot-core/src/server/budget/cleanup-template.ts": 
        /*!******************************************************************!*\
          !*** ./packages/loot-core/src/server/budget/cleanup-template.ts ***!
          \******************************************************************/
        /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony export */ __webpack_require__.d(__webpack_exports__, {
                /* harmony export */ cleanupTemplate: () => ( /* binding */cleanupTemplate)
                /* harmony export */ 
            });
            /* harmony import */ var _shared_months__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../shared/months */ "./packages/loot-core/src/shared/months.ts");
            /* harmony import */ var _db__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../db */ "./packages/loot-core/src/server/db/index.ts");
            /* harmony import */ var _actions__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./actions */ "./packages/loot-core/src/server/budget/actions.ts");
            /* harmony import */ var _cleanup_template_pegjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./cleanup-template.pegjs */ "./packages/loot-core/src/server/budget/cleanup-template.pegjs");
            /* harmony import */ var _cleanup_template_pegjs__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/ __webpack_require__.n(_cleanup_template_pegjs__WEBPACK_IMPORTED_MODULE_3__);
            // @ts-strict-ignore
            function cleanupTemplate({ month }) {
                return processCleanup(month);
            }
            async function applyGroupCleanups(month, sourceGroups, sinkGroups, generalGroups) {
                const sheetName = _shared_months__WEBPACK_IMPORTED_MODULE_0__.sheetForMonth(month);
                const warnings = [];
                const db_month = parseInt(month.replace('-', ''));
                let groupLength = sourceGroups.length;
                while (groupLength > 0) {
                    //function for each unique group
                    const groupName = sourceGroups[0].group;
                    const tempSourceGroups = sourceGroups.filter((c) => c.group === groupName);
                    const sinkGroup = sinkGroups.filter((c) => c.group === groupName);
                    const generalGroup = generalGroups.filter((c) => c.group === groupName);
                    let total_weight = 0;
                    if (sinkGroup.length > 0 || generalGroup.length > 0) {
                        //only return group source funds to To Budget if there are corresponding sinking groups or underfunded included groups
                        for (let ii = 0; ii < tempSourceGroups.length; ii++) {
                            const balance = await (0, _actions__WEBPACK_IMPORTED_MODULE_2__.getSheetValue)(sheetName, `leftover-${tempSourceGroups[ii].category}`);
                            const budgeted = await (0, _actions__WEBPACK_IMPORTED_MODULE_2__.getSheetValue)(sheetName, `budget-${tempSourceGroups[ii].category}`);
                            await (0, _actions__WEBPACK_IMPORTED_MODULE_2__.setBudget)({
                                category: tempSourceGroups[ii].category,
                                month,
                                amount: budgeted - balance
                            });
                        }
                        //calculate total weight for sinking funds
                        for (let ii = 0; ii < sinkGroup.length; ii++) {
                            total_weight += sinkGroup[ii].weight;
                        }
                        //fill underfunded categories within the group first
                        for (let ii = 0; ii < generalGroup.length; ii++) {
                            const budgetAvailable = await (0, _actions__WEBPACK_IMPORTED_MODULE_2__.getSheetValue)(sheetName, `to-budget`);
                            const balance = await (0, _actions__WEBPACK_IMPORTED_MODULE_2__.getSheetValue)(sheetName, `leftover-${generalGroup[ii].category}`);
                            const budgeted = await (0, _actions__WEBPACK_IMPORTED_MODULE_2__.getSheetValue)(sheetName, `budget-${generalGroup[ii].category}`);
                            const to_budget = budgeted + Math.abs(balance);
                            const categoryId = generalGroup[ii].category;
                            let carryover = await _db__WEBPACK_IMPORTED_MODULE_1__.first(`SELECT carryover FROM zero_budgets WHERE month = ? and category = ?`, [
                                db_month,
                                categoryId
                            ]);
                            if (carryover === null) {
                                carryover = {
                                    carryover: 0
                                };
                            }
                            if (balance < 0 && Math.abs(balance) <= budgetAvailable && !generalGroup[ii].category.is_income && carryover.carryover === 0) {
                                await (0, _actions__WEBPACK_IMPORTED_MODULE_2__.setBudget)({
                                    category: generalGroup[ii].category,
                                    month,
                                    amount: to_budget
                                });
                            }
                            else if (balance < 0 && !generalGroup[ii].category.is_income && carryover.carryover === 0 && Math.abs(balance) > budgetAvailable) {
                                await (0, _actions__WEBPACK_IMPORTED_MODULE_2__.setBudget)({
                                    category: generalGroup[ii].category,
                                    month,
                                    amount: budgeted + budgetAvailable
                                });
                            }
                        }
                        const budgetAvailable = await (0, _actions__WEBPACK_IMPORTED_MODULE_2__.getSheetValue)(sheetName, `to-budget`);
                        for (let ii = 0; ii < sinkGroup.length; ii++) {
                            const budgeted = await (0, _actions__WEBPACK_IMPORTED_MODULE_2__.getSheetValue)(sheetName, `budget-${sinkGroup[ii].category}`);
                            const to_budget = budgeted + Math.round(sinkGroup[ii].weight / total_weight * budgetAvailable);
                            await (0, _actions__WEBPACK_IMPORTED_MODULE_2__.setBudget)({
                                category: sinkGroup[ii].category,
                                month,
                                amount: to_budget
                            });
                        }
                    }
                    else {
                        warnings.push(groupName + ' has no matching sink categories.');
                    }
                    sourceGroups = sourceGroups.filter((c) => c.group !== groupName);
                    groupLength = sourceGroups.length;
                }
                return warnings;
            }
            async function processCleanup(month) {
                let num_sources = 0;
                let num_sinks = 0;
                let total_weight = 0;
                const errors = [];
                const warnings = [];
                const sinkCategory = [];
                const sourceWithRollover = [];
                const db_month = parseInt(month.replace('-', ''));
                const category_templates = await getCategoryTemplates();
                const categories = await _db__WEBPACK_IMPORTED_MODULE_1__.all('SELECT * FROM v_categories WHERE tombstone = 0');
                const sheetName = _shared_months__WEBPACK_IMPORTED_MODULE_0__.sheetForMonth(month);
                const groupSource = [];
                const groupSink = [];
                const groupGeneral = [];
                //filter out category groups
                for (let c = 0; c < categories.length; c++) {
                    const category = categories[c];
                    const template = category_templates[category.id];
                    //filter out source and sink groups for processing
                    if (template) {
                        if (template.filter((t) => t.type === 'source' && t.group !== null).length > 0) {
                            groupSource.push({
                                category: category.id,
                                group: template.filter((t) => t.type === 'source' && t.group !== null)[0].group
                            });
                        }
                        if (template.filter((t) => t.type === 'sink' && t.group !== null).length > 0) {
                            //only supports 1 sink reference per category.  Need more?
                            groupSink.push({
                                category: category.id,
                                group: template.filter((t) => t.type === 'sink' && t.group !== null)[0].group,
                                weight: template.filter((t) => t.type === 'sink' && t.group !== null)[0].weight
                            });
                        }
                        if (template.filter((t) => t.type === null && t.group !== null).length > 0) {
                            groupGeneral.push({
                                category: category.id,
                                group: template[0].group
                            });
                        }
                    }
                }
                //run category groups
                const newWarnings = await applyGroupCleanups(month, groupSource, groupSink, groupGeneral);
                warnings.splice(1, 0, ...newWarnings);
                for (let c = 0; c < categories.length; c++) {
                    const category = categories[c];
                    const template = category_templates[category.id];
                    if (template) {
                        if (template.filter((t) => t.type === 'source' && t.group === null).length > 0) {
                            const balance = await (0, _actions__WEBPACK_IMPORTED_MODULE_2__.getSheetValue)(sheetName, `leftover-${category.id}`);
                            const budgeted = await (0, _actions__WEBPACK_IMPORTED_MODULE_2__.getSheetValue)(sheetName, `budget-${category.id}`);
                            if (balance >= 0) {
                                // const spent = await getSheetValue(
                                //   sheetName,
                                //   `sum-amount-${category.id}`,
                                // );
                                await (0, _actions__WEBPACK_IMPORTED_MODULE_2__.setBudget)({
                                    category: category.id,
                                    month,
                                    amount: budgeted - balance
                                });
                                await (0, _actions__WEBPACK_IMPORTED_MODULE_2__.setGoal)({
                                    category: category.id,
                                    month,
                                    goal: budgeted - balance,
                                    long_goal: 0
                                });
                                num_sources += 1;
                            }
                            else {
                                warnings.push(category.name + ' does not have available funds.');
                            }
                            const carryover = await _db__WEBPACK_IMPORTED_MODULE_1__.first(`SELECT carryover FROM zero_budgets WHERE month = ? and category = ?`, [
                                db_month,
                                category.id
                            ]);
                            if (carryover !== null) {
                                //keep track of source categories with rollover enabled
                                if (carryover.carryover === 1) {
                                    sourceWithRollover.push({
                                        cat: category,
                                        temp: template
                                    });
                                }
                            }
                        }
                        if (template.filter((t) => t.type === 'sink' && t.group === null).length > 0) {
                            sinkCategory.push({
                                cat: category,
                                temp: template
                            });
                            num_sinks += 1;
                            total_weight += template.filter((w) => w.type === 'sink')[0].weight;
                        }
                    }
                }
                //funds all underfunded categories first unless the overspending rollover is checked
                for (let c = 0; c < categories.length; c++) {
                    const category = categories[c];
                    const budgetAvailable = await (0, _actions__WEBPACK_IMPORTED_MODULE_2__.getSheetValue)(sheetName, `to-budget`);
                    const balance = await (0, _actions__WEBPACK_IMPORTED_MODULE_2__.getSheetValue)(sheetName, `leftover-${category.id}`);
                    const budgeted = await (0, _actions__WEBPACK_IMPORTED_MODULE_2__.getSheetValue)(sheetName, `budget-${category.id}`);
                    const to_budget = budgeted + Math.abs(balance);
                    const categoryId = category.id;
                    let carryover = await _db__WEBPACK_IMPORTED_MODULE_1__.first(`SELECT carryover FROM zero_budgets WHERE month = ? and category = ?`, [
                        db_month,
                        categoryId
                    ]);
                    if (carryover === null) {
                        carryover = {
                            carryover: 0
                        };
                    }
                    if (balance < 0 && Math.abs(balance) <= budgetAvailable && !category.is_income && carryover.carryover === 0) {
                        await (0, _actions__WEBPACK_IMPORTED_MODULE_2__.setBudget)({
                            category: category.id,
                            month,
                            amount: to_budget
                        });
                    }
                    else if (balance < 0 && !category.is_income && carryover.carryover === 0 && Math.abs(balance) > budgetAvailable) {
                        await (0, _actions__WEBPACK_IMPORTED_MODULE_2__.setBudget)({
                            category: category.id,
                            month,
                            amount: budgeted + budgetAvailable
                        });
                    }
                }
                const budgetAvailable = await (0, _actions__WEBPACK_IMPORTED_MODULE_2__.getSheetValue)(sheetName, `to-budget`);
                if (budgetAvailable <= 0) {
                    warnings.push('Global: No funds are available to reallocate.');
                }
                //fill sinking categories
                for (let c = 0; c < sinkCategory.length; c++) {
                    const budgeted = await (0, _actions__WEBPACK_IMPORTED_MODULE_2__.getSheetValue)(sheetName, `budget-${sinkCategory[c].cat.id}`);
                    const categoryId = sinkCategory[c].cat.id;
                    const weight = sinkCategory[c].temp.filter((w) => w.type === 'sink')[0].weight;
                    let to_budget = budgeted + Math.round(weight / total_weight * budgetAvailable);
                    if (c === sinkCategory.length - 1) {
                        const currentBudgetAvailable = await (0, _actions__WEBPACK_IMPORTED_MODULE_2__.getSheetValue)(sheetName, `to-budget`);
                        if (to_budget > currentBudgetAvailable) {
                            to_budget = budgeted + currentBudgetAvailable;
                        }
                    }
                    await (0, _actions__WEBPACK_IMPORTED_MODULE_2__.setBudget)({
                        category: categoryId,
                        month,
                        amount: to_budget
                    });
                }
                if (num_sources === 0) {
                    if (errors.length) {
                        return {
                            type: 'error',
                            sticky: true,
                            message: `There were errors interpreting some templates:`,
                            pre: errors.join('\n\n')
                        };
                    }
                    else if (warnings.length) {
                        return {
                            type: 'warning',
                            message: 'Global: Funds not available:',
                            pre: warnings.join('\n\n')
                        };
                    }
                    else {
                        return {
                            type: 'message',
                            message: 'All categories were up to date.'
                        };
                    }
                }
                else {
                    const applied = `Successfully returned funds from ${num_sources} ${num_sources === 1 ? 'source' : 'sources'} and funded ${num_sinks} sinking ${num_sinks === 1 ? 'fund' : 'funds'}.`;
                    if (errors.length) {
                        return {
                            sticky: true,
                            message: `${applied} There were errors interpreting some templates:`,
                            pre: errors.join('\n\n')
                        };
                    }
                    else if (warnings.length) {
                        return {
                            type: 'warning',
                            message: 'Global: Funds not available:',
                            pre: warnings.join('\n\n')
                        };
                    }
                    else {
                        return {
                            type: 'message',
                            message: applied
                        };
                    }
                }
            }
            const TEMPLATE_PREFIX = '#cleanup ';
            async function getCategoryTemplates() {
                const templates = {};
                const notes = await _db__WEBPACK_IMPORTED_MODULE_1__.all(`SELECT * FROM notes WHERE lower(note) like '%${TEMPLATE_PREFIX}%'`);
                for (let n = 0; n < notes.length; n++) {
                    const lines = notes[n].note.split('\n');
                    const template_lines = [];
                    for (let l = 0; l < lines.length; l++) {
                        const line = lines[l].trim();
                        if (!line.toLowerCase().startsWith(TEMPLATE_PREFIX))
                            continue;
                        const expression = line.slice(TEMPLATE_PREFIX.length);
                        try {
                            const parsed = (0, _cleanup_template_pegjs__WEBPACK_IMPORTED_MODULE_3__.parse)(expression);
                            template_lines.push(parsed);
                        }
                        catch (e) {
                            template_lines.push({
                                type: 'error',
                                line,
                                error: e
                            });
                        }
                    }
                    if (template_lines.length) {
                        templates[notes[n].id] = template_lines;
                    }
                }
                return templates;
            }
            /***/ 
        }),
        /***/ "./packages/loot-core/src/server/budget/goals/goalsAverage.ts": 
        /*!********************************************************************!*\
          !*** ./packages/loot-core/src/server/budget/goals/goalsAverage.ts ***!
          \********************************************************************/
        /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony export */ __webpack_require__.d(__webpack_exports__, {
                /* harmony export */ goalsAverage: () => ( /* binding */goalsAverage)
                /* harmony export */ 
            });
            /* harmony import */ var _shared_months__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../shared/months */ "./packages/loot-core/src/shared/months.ts");
            /* harmony import */ var _actions__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../actions */ "./packages/loot-core/src/server/budget/actions.ts");
            // @ts-strict-ignore
            async function goalsAverage(template, month, category, errors, to_budget) {
                // simple has an 'amount' param
                let increment = 0;
                if (template.amount) {
                    let sum = 0;
                    for (let i = 1; i <= template.amount; i++) {
                        // add up other months
                        const sheetName = _shared_months__WEBPACK_IMPORTED_MODULE_0__.sheetForMonth(_shared_months__WEBPACK_IMPORTED_MODULE_0__.subMonths(month, i));
                        sum += await (0, _actions__WEBPACK_IMPORTED_MODULE_1__.getSheetValue)(sheetName, `sum-amount-${category.id}`);
                    }
                    increment = sum / template.amount;
                }
                else {
                    errors.push('Number of months to average is not valid');
                    return {
                        to_budget,
                        errors
                    };
                }
                to_budget += -Math.round(increment);
                return {
                    to_budget,
                    errors
                };
            }
            /***/ 
        }),
        /***/ "./packages/loot-core/src/server/budget/goals/goalsBy.ts": 
        /*!***************************************************************!*\
          !*** ./packages/loot-core/src/server/budget/goals/goalsBy.ts ***!
          \***************************************************************/
        /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony export */ __webpack_require__.d(__webpack_exports__, {
                /* harmony export */ goalsBy: () => ( /* binding */goalsBy)
                /* harmony export */ 
            });
            /* harmony import */ var _shared_months__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../shared/months */ "./packages/loot-core/src/shared/months.ts");
            /* harmony import */ var _shared_util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../shared/util */ "./packages/loot-core/src/shared/util.ts");
            /* harmony import */ var _actions__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../actions */ "./packages/loot-core/src/server/budget/actions.ts");
            // @ts-strict-ignore
            async function goalsBy(template_lines, current_month, template, l, remainder, last_month_balance, to_budget, errors) {
                // by has 'amount' and 'month' params
                if (!(0, _actions__WEBPACK_IMPORTED_MODULE_2__.isReflectBudget)()) {
                    let target = 0;
                    let target_month = `${template_lines[l].month}-01`;
                    let num_months = _shared_months__WEBPACK_IMPORTED_MODULE_0__.differenceInCalendarMonths(target_month, current_month);
                    const repeat = template.type === 'by' ? template.repeat : (template.repeat || 1) * 12;
                    while (num_months < 0 && repeat) {
                        target_month = _shared_months__WEBPACK_IMPORTED_MODULE_0__.addMonths(target_month, repeat);
                        num_months = _shared_months__WEBPACK_IMPORTED_MODULE_0__.differenceInCalendarMonths(template_lines[l].month, current_month);
                    }
                    if (l === 0)
                        remainder = last_month_balance;
                    remainder = (0, _shared_util__WEBPACK_IMPORTED_MODULE_1__.amountToInteger)(template_lines[l].amount) - remainder;
                    if (remainder >= 0) {
                        target = remainder;
                        remainder = 0;
                    }
                    else {
                        target = 0;
                        remainder = Math.abs(remainder);
                    }
                    const increment = num_months >= 0 ? Math.round(target / (num_months + 1)) : 0;
                    to_budget += increment;
                }
                else {
                    errors.push(`by templates are not supported in Report budgets`);
                }
                return {
                    to_budget,
                    errors,
                    remainder
                };
            }
            /***/ 
        }),
        /***/ "./packages/loot-core/src/server/budget/goals/goalsPercentage.ts": 
        /*!***********************************************************************!*\
          !*** ./packages/loot-core/src/server/budget/goals/goalsPercentage.ts ***!
          \***********************************************************************/
        /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony export */ __webpack_require__.d(__webpack_exports__, {
                /* harmony export */ goalsPercentage: () => ( /* binding */goalsPercentage)
                /* harmony export */ 
            });
            /* harmony import */ var _shared_months__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../shared/months */ "./packages/loot-core/src/shared/months.ts");
            /* harmony import */ var _db__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../db */ "./packages/loot-core/src/server/db/index.ts");
            /* harmony import */ var _actions__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../actions */ "./packages/loot-core/src/server/budget/actions.ts");
            // @ts-strict-ignore
            async function goalsPercentage(template, month, available_start, sheetName, to_budget, errors) {
                const percent = template.percent;
                let monthlyIncome = 0;
                if (template.category.toLowerCase() === 'all income') {
                    if (template.previous) {
                        const sheetName_lastmonth = _shared_months__WEBPACK_IMPORTED_MODULE_0__.sheetForMonth(_shared_months__WEBPACK_IMPORTED_MODULE_0__.addMonths(month, -1));
                        monthlyIncome = await (0, _actions__WEBPACK_IMPORTED_MODULE_2__.getSheetValue)(sheetName_lastmonth, 'total-income');
                    }
                    else {
                        monthlyIncome = await (0, _actions__WEBPACK_IMPORTED_MODULE_2__.getSheetValue)(sheetName, `total-income`);
                    }
                }
                else if (template.category.toLowerCase() === 'available funds') {
                    monthlyIncome = available_start;
                }
                else {
                    const income_category = (await _db__WEBPACK_IMPORTED_MODULE_1__.getCategories()).find((c) => c.is_income && c.name.toLowerCase() === template.category.toLowerCase());
                    if (!income_category) {
                        errors.push(`Could not find category ${template.category}`);
                        return {
                            to_budget,
                            errors
                        };
                    }
                    if (template.previous) {
                        const sheetName_lastmonth = _shared_months__WEBPACK_IMPORTED_MODULE_0__.sheetForMonth(_shared_months__WEBPACK_IMPORTED_MODULE_0__.addMonths(month, -1));
                        monthlyIncome = await (0, _actions__WEBPACK_IMPORTED_MODULE_2__.getSheetValue)(sheetName_lastmonth, `sum-amount-${income_category.id}`);
                    }
                    else {
                        monthlyIncome = await (0, _actions__WEBPACK_IMPORTED_MODULE_2__.getSheetValue)(sheetName, `sum-amount-${income_category.id}`);
                    }
                }
                const increment = Math.max(0, Math.round(monthlyIncome * (percent / 100)));
                to_budget += increment;
                return {
                    to_budget,
                    errors
                };
            }
            /***/ 
        }),
        /***/ "./packages/loot-core/src/server/budget/goals/goalsRemainder.ts": 
        /*!**********************************************************************!*\
          !*** ./packages/loot-core/src/server/budget/goals/goalsRemainder.ts ***!
          \**********************************************************************/
        /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony export */ __webpack_require__.d(__webpack_exports__, {
                /* harmony export */ findRemainder: () => ( /* binding */findRemainder),
                /* harmony export */ goalsRemainder: () => ( /* binding */goalsRemainder)
                /* harmony export */ 
            });
            // @ts-strict-ignore
            async function goalsRemainder(template, budgetAvailable, remainder_scale, to_budget) {
                if (remainder_scale >= 0) {
                    to_budget += remainder_scale === 0 ? Math.round(template.weight) : Math.round(remainder_scale * template.weight);
                    // can over budget with the rounding, so checking that
                    if (to_budget >= budgetAvailable) {
                        to_budget = budgetAvailable;
                        // check if there is 1 cent leftover from rounding
                    }
                    else if (budgetAvailable - to_budget === 1) {
                        to_budget = to_budget + 1;
                    }
                }
                return {
                    to_budget
                };
            }
            function findRemainder(priority_list, categories, category_templates) {
                // find all remainder templates, place them at highest priority
                let remainder_found;
                let remainder_weight_total = 0;
                const remainder_priority = priority_list[priority_list.length - 1] + 1;
                for (let c = 0; c < categories.length; c++) {
                    const category = categories[c];
                    const templates = category_templates[category.id];
                    if (templates) {
                        for (let i = 0; i < templates.length; i++) {
                            if (templates[i].type === 'remainder') {
                                templates[i].priority = remainder_priority;
                                remainder_weight_total += templates[i].weight;
                                remainder_found = true;
                            }
                        }
                    }
                }
                return {
                    remainder_found,
                    remainder_priority,
                    remainder_weight_total
                };
            }
            /***/ 
        }),
        /***/ "./packages/loot-core/src/server/budget/goals/goalsSchedule.ts": 
        /*!*********************************************************************!*\
          !*** ./packages/loot-core/src/server/budget/goals/goalsSchedule.ts ***!
          \*********************************************************************/
        /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony export */ __webpack_require__.d(__webpack_exports__, {
                /* harmony export */ goalsSchedule: () => ( /* binding */goalsSchedule)
                /* harmony export */ 
            });
            /* harmony import */ var _shared_months__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../shared/months */ "./packages/loot-core/src/shared/months.ts");
            /* harmony import */ var _shared_schedules__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../shared/schedules */ "./packages/loot-core/src/shared/schedules.ts");
            /* harmony import */ var _db__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../db */ "./packages/loot-core/src/server/db/index.ts");
            /* harmony import */ var _schedules_app__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../schedules/app */ "./packages/loot-core/src/server/schedules/app.ts");
            /* harmony import */ var _actions__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../actions */ "./packages/loot-core/src/server/budget/actions.ts");
            // @ts-strict-ignore
            async function createScheduleList(template, current_month, category) {
                const t = [];
                const errors = [];
                for (let ll = 0; ll < template.length; ll++) {
                    const { id: sid, completed: complete } = await _db__WEBPACK_IMPORTED_MODULE_2__.first('SELECT * FROM schedules WHERE name = ? AND tombstone = 0', [
                        template[ll].name
                    ]);
                    const rule = await (0, _schedules_app__WEBPACK_IMPORTED_MODULE_3__.getRuleForSchedule)(sid);
                    const conditions = rule.serialize().conditions;
                    const { date: dateConditions, amount: amountCondition } = (0, _shared_schedules__WEBPACK_IMPORTED_MODULE_1__.extractScheduleConds)(conditions);
                    const scheduleAmount = amountCondition.op === 'isbetween' ? Math.round(amountCondition.value.num1 + amountCondition.value.num2) / 2 : amountCondition.value;
                    const { amount: postRuleAmount, subtransactions } = rule.execActions({
                        amount: scheduleAmount,
                        category: category.id,
                        subtransactions: []
                    });
                    const categorySubtransactions = subtransactions?.filter((t) => t.category === category.id);
                    // Unless the current category is relevant to the schedule, target the post-rule amount.
                    const sign = category.is_income ? 1 : -1;
                    const target = sign * (categorySubtransactions?.length ? categorySubtransactions.reduce((acc, t) => acc + t.amount, 0) : postRuleAmount ?? scheduleAmount);
                    const next_date_string = (0, _schedules_app__WEBPACK_IMPORTED_MODULE_3__.getNextDate)(dateConditions, _shared_months__WEBPACK_IMPORTED_MODULE_0__._parse(current_month));
                    const target_interval = dateConditions.value.interval ? dateConditions.value.interval : 1;
                    const target_frequency = dateConditions.value.frequency;
                    const isRepeating = Object(dateConditions.value) === dateConditions.value && 'frequency' in dateConditions.value;
                    const num_months = _shared_months__WEBPACK_IMPORTED_MODULE_0__.differenceInCalendarMonths(next_date_string, current_month);
                    if (num_months < 0) {
                        //non-repeating schedules could be negative
                        errors.push(`Schedule ${template[ll].name} is in the Past.`);
                    }
                    else {
                        t.push({
                            target,
                            next_date_string,
                            target_interval,
                            target_frequency,
                            num_months,
                            completed: complete,
                            //started,
                            full: template[ll].full === null ? false : template[ll].full,
                            repeat: isRepeating,
                            name: template[ll].name
                        });
                        if (!complete) {
                            if (isRepeating) {
                                let monthlyTarget = 0;
                                const nextMonth = _shared_months__WEBPACK_IMPORTED_MODULE_0__.addMonths(current_month, t[t.length - 1].num_months + 1);
                                let nextBaseDate = (0, _schedules_app__WEBPACK_IMPORTED_MODULE_3__.getNextDate)(dateConditions, _shared_months__WEBPACK_IMPORTED_MODULE_0__._parse(current_month), true);
                                let nextDate = dateConditions.value.skipWeekend ? _shared_months__WEBPACK_IMPORTED_MODULE_0__.dayFromDate((0, _schedules_app__WEBPACK_IMPORTED_MODULE_3__.getDateWithSkippedWeekend)(_shared_months__WEBPACK_IMPORTED_MODULE_0__._parse(nextBaseDate), dateConditions.value.weekendSolveMode)) : nextBaseDate;
                                while (nextDate < nextMonth) {
                                    monthlyTarget += -target;
                                    const currentDate = nextBaseDate;
                                    const oneDayLater = _shared_months__WEBPACK_IMPORTED_MODULE_0__.addDays(nextBaseDate, 1);
                                    nextBaseDate = (0, _schedules_app__WEBPACK_IMPORTED_MODULE_3__.getNextDate)(dateConditions, _shared_months__WEBPACK_IMPORTED_MODULE_0__._parse(oneDayLater), true);
                                    nextDate = dateConditions.value.skipWeekend ? _shared_months__WEBPACK_IMPORTED_MODULE_0__.dayFromDate((0, _schedules_app__WEBPACK_IMPORTED_MODULE_3__.getDateWithSkippedWeekend)(_shared_months__WEBPACK_IMPORTED_MODULE_0__._parse(nextBaseDate), dateConditions.value.weekendSolveMode)) : nextBaseDate;
                                    const diffDays = _shared_months__WEBPACK_IMPORTED_MODULE_0__.differenceInCalendarDays(nextBaseDate, currentDate);
                                    if (!diffDays) {
                                        break;
                                    }
                                }
                                t[t.length - 1].target = -monthlyTarget;
                            }
                        }
                        else {
                            errors.push(`Schedule ${t[ll].name} is not active during the month in question.`);
                        }
                    }
                }
                return {
                    t: t.filter((c) => c.completed === 0),
                    errors
                };
            }
            async function getPayMonthOfTotal(t) {
                //return the contribution amounts of full or every month type schedules
                let total = 0;
                const schedules = t.filter((c) => c.num_months === 0);
                for (let ll = 0; ll < schedules.length; ll++) {
                    total += schedules[ll].target;
                }
                return total;
            }
            async function getSinkingContributionTotal(t, remainder, last_month_balance) {
                //return the contribution amount if there is a balance carried in the category
                let total = 0;
                for (let ll = 0; ll < t.length; ll++) {
                    remainder = ll === 0 ? t[ll].target - last_month_balance : t[ll].target - remainder;
                    let tg = 0;
                    if (remainder >= 0) {
                        tg = remainder;
                        remainder = 0;
                    }
                    else {
                        tg = 0;
                        remainder = Math.abs(remainder);
                    }
                    total += tg / (t[ll].num_months + 1);
                }
                return total;
            }
            async function getSinkingBaseContributionTotal(t) {
                //return only the base contribution of each schedule
                let total = 0;
                for (let ll = 0; ll < t.length; ll++) {
                    total += t[ll].target / t[ll].target_interval;
                }
                return total;
            }
            async function getSinkingTotal(t) {
                //sum the total of all upcoming schedules
                let total = 0;
                for (let ll = 0; ll < t.length; ll++) {
                    total += t[ll].target;
                }
                return total;
            }
            async function goalsSchedule(scheduleFlag, template_lines, current_month, balance, remainder, last_month_balance, to_budget, errors, category) {
                if (!scheduleFlag) {
                    scheduleFlag = true;
                    const template = template_lines.filter((t) => t.type === 'schedule');
                    //in the case of multiple templates per category, schedules may have wrong priority level
                    const t = await createScheduleList(template, current_month, category);
                    errors = errors.concat(t.errors);
                    const isPayMonthOf = (c) => c.full || c.target_frequency === 'monthly' && c.target_interval === 1 && c.num_months === 0 || c.target_frequency === 'weekly' && c.target_interval >= 0 && c.num_months === 0 || c.target_frequency === 'daily' || (0, _actions__WEBPACK_IMPORTED_MODULE_4__.isReflectBudget)();
                    const t_payMonthOf = t.t.filter(isPayMonthOf);
                    const t_sinking = t.t.filter((c) => !isPayMonthOf(c)).sort((a, b) => a.next_date_string.localeCompare(b.next_date_string));
                    const totalPayMonthOf = await getPayMonthOfTotal(t_payMonthOf);
                    const totalSinking = await getSinkingTotal(t_sinking);
                    const totalSinkingBaseContribution = await getSinkingBaseContributionTotal(t_sinking);
                    if (balance >= totalSinking + totalPayMonthOf) {
                        to_budget += Math.round(totalPayMonthOf + totalSinkingBaseContribution);
                    }
                    else {
                        const totalSinkingContribution = await getSinkingContributionTotal(t_sinking, remainder, last_month_balance);
                        if (t_sinking.length === 0) {
                            to_budget += Math.round(totalPayMonthOf + totalSinkingContribution) - last_month_balance;
                        }
                        else {
                            to_budget += Math.round(totalPayMonthOf + totalSinkingContribution);
                        }
                    }
                }
                return {
                    to_budget,
                    errors,
                    remainder,
                    scheduleFlag
                };
            }
            /***/ 
        }),
        /***/ "./packages/loot-core/src/server/budget/goals/goalsSimple.ts": 
        /*!*******************************************************************!*\
          !*** ./packages/loot-core/src/server/budget/goals/goalsSimple.ts ***!
          \*******************************************************************/
        /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony export */ __webpack_require__.d(__webpack_exports__, {
                /* harmony export */ goalsSimple: () => ( /* binding */goalsSimple)
                /* harmony export */ 
            });
            /* harmony import */ var _shared_util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../shared/util */ "./packages/loot-core/src/shared/util.ts");
            // @ts-strict-ignore
            async function goalsSimple(template, limitCheck, errors, limit, hold, to_budget, last_month_balance) {
                // simple has 'monthly' and/or 'limit' params
                if (template.limit != null) {
                    if (limitCheck) {
                        errors.push(`More than one up to limit found.`);
                        return {
                            to_budget,
                            errors,
                            limit,
                            limitCheck,
                            hold
                        };
                    }
                    else {
                        limitCheck = true;
                        limit = (0, _shared_util__WEBPACK_IMPORTED_MODULE_0__.amountToInteger)(template.limit.amount);
                        hold = template.limit.hold;
                    }
                }
                let increment = 0;
                if (template.monthly != null) {
                    const monthly = (0, _shared_util__WEBPACK_IMPORTED_MODULE_0__.amountToInteger)(template.monthly);
                    increment = monthly;
                }
                else {
                    increment = limit - last_month_balance;
                }
                to_budget += increment;
                return {
                    to_budget,
                    errors,
                    limit,
                    limitCheck,
                    hold
                };
            }
            /***/ 
        }),
        /***/ "./packages/loot-core/src/server/budget/goals/goalsSpend.ts": 
        /*!******************************************************************!*\
          !*** ./packages/loot-core/src/server/budget/goals/goalsSpend.ts ***!
          \******************************************************************/
        /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony export */ __webpack_require__.d(__webpack_exports__, {
                /* harmony export */ goalsSpend: () => ( /* binding */goalsSpend)
                /* harmony export */ 
            });
            /* harmony import */ var _shared_months__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../shared/months */ "./packages/loot-core/src/shared/months.ts");
            /* harmony import */ var _shared_util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../shared/util */ "./packages/loot-core/src/shared/util.ts");
            /* harmony import */ var _actions__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../actions */ "./packages/loot-core/src/server/budget/actions.ts");
            // @ts-strict-ignore
            async function goalsSpend(template, last_month_balance, current_month, to_budget, errors, category) {
                // spend has 'amount' and 'from' and 'month' params
                const from_month = `${template.from}-01`;
                const to_month = `${template.month}-01`;
                let already_budgeted = last_month_balance;
                let first_month = true;
                for (let m = from_month; _shared_months__WEBPACK_IMPORTED_MODULE_0__.differenceInCalendarMonths(current_month, m) > 0; m = _shared_months__WEBPACK_IMPORTED_MODULE_0__.addMonths(m, 1)) {
                    const sheetName = _shared_months__WEBPACK_IMPORTED_MODULE_0__.sheetForMonth(_shared_months__WEBPACK_IMPORTED_MODULE_0__.format(m, 'yyyy-MM'));
                    if (first_month) {
                        const spent = await (0, _actions__WEBPACK_IMPORTED_MODULE_2__.getSheetValue)(sheetName, `sum-amount-${category.id}`);
                        const balance = await (0, _actions__WEBPACK_IMPORTED_MODULE_2__.getSheetValue)(sheetName, `leftover-${category.id}`);
                        already_budgeted = balance - spent;
                        first_month = false;
                    }
                    else {
                        const budgeted = await (0, _actions__WEBPACK_IMPORTED_MODULE_2__.getSheetValue)(sheetName, `budget-${category.id}`);
                        already_budgeted += budgeted;
                    }
                }
                const num_months = _shared_months__WEBPACK_IMPORTED_MODULE_0__.differenceInCalendarMonths(to_month, _shared_months__WEBPACK_IMPORTED_MODULE_0__._parse(current_month));
                const target = (0, _shared_util__WEBPACK_IMPORTED_MODULE_1__.amountToInteger)(template.amount);
                let increment = 0;
                if (num_months < 0) {
                    errors.push(`${template.month} is in the past.`);
                    return {
                        to_budget,
                        errors
                    };
                }
                else if (num_months === 0) {
                    increment = target - already_budgeted;
                }
                else {
                    increment = Math.round((target - already_budgeted) / (num_months + 1));
                }
                to_budget = increment;
                return {
                    to_budget,
                    errors
                };
            }
            /***/ 
        }),
        /***/ "./packages/loot-core/src/server/budget/goals/goalsWeek.ts": 
        /*!*****************************************************************!*\
          !*** ./packages/loot-core/src/server/budget/goals/goalsWeek.ts ***!
          \*****************************************************************/
        /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony export */ __webpack_require__.d(__webpack_exports__, {
                /* harmony export */ goalsWeek: () => ( /* binding */goalsWeek)
                /* harmony export */ 
            });
            /* harmony import */ var _shared_months__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../shared/months */ "./packages/loot-core/src/shared/months.ts");
            /* harmony import */ var _shared_util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../shared/util */ "./packages/loot-core/src/shared/util.ts");
            // @ts-strict-ignore
            async function goalsWeek(template, limit, limitCheck, hold, current_month, to_budget, errors) {
                // week has 'amount', 'starting', 'weeks' and optional 'limit' params
                const amount = (0, _shared_util__WEBPACK_IMPORTED_MODULE_1__.amountToInteger)(template.amount);
                const weeks = template.weeks != null ? Math.round(template.weeks) : 1;
                if (template.limit != null) {
                    if (limit > 0) {
                        errors.push(`More than one up to limit found.`);
                        return {
                            to_budget,
                            errors,
                            limit,
                            limitCheck,
                            hold
                        };
                    }
                    else {
                        limitCheck = true;
                        limit = (0, _shared_util__WEBPACK_IMPORTED_MODULE_1__.amountToInteger)(template.limit.amount);
                        hold = template.limit.hold;
                    }
                }
                let w = template.starting;
                const next_month = _shared_months__WEBPACK_IMPORTED_MODULE_0__.addMonths(current_month, 1);
                while (w < next_month) {
                    if (w >= current_month) {
                        to_budget += amount;
                    }
                    w = _shared_months__WEBPACK_IMPORTED_MODULE_0__.addWeeks(w, weeks);
                }
                return {
                    to_budget,
                    errors,
                    limit,
                    limitCheck,
                    hold
                };
            }
            /***/ 
        }),
        /***/ "./packages/loot-core/src/server/budget/goaltemplates.ts": 
        /*!***************************************************************!*\
          !*** ./packages/loot-core/src/server/budget/goaltemplates.ts ***!
          \***************************************************************/
        /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony export */ __webpack_require__.d(__webpack_exports__, {
                /* harmony export */ applySingleCategoryTemplate: () => ( /* binding */applySingleCategoryTemplate),
                /* harmony export */ applyTemplate: () => ( /* binding */applyTemplate),
                /* harmony export */ overwriteTemplate: () => ( /* binding */overwriteTemplate),
                /* harmony export */ runCheckTemplates: () => ( /* binding */runCheckTemplates)
                /* harmony export */ 
            });
            /* harmony import */ var _shared_months__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../shared/months */ "./packages/loot-core/src/shared/months.ts");
            /* harmony import */ var _shared_util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../shared/util */ "./packages/loot-core/src/shared/util.ts");
            /* harmony import */ var _db__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../db */ "./packages/loot-core/src/server/db/index.ts");
            /* harmony import */ var _sync__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../sync */ "./packages/loot-core/src/server/sync/index.ts");
            /* harmony import */ var _actions__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./actions */ "./packages/loot-core/src/server/budget/actions.ts");
            /* harmony import */ var _goal_template_pegjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./goal-template.pegjs */ "./packages/loot-core/src/server/budget/goal-template.pegjs");
            /* harmony import */ var _goal_template_pegjs__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/ __webpack_require__.n(_goal_template_pegjs__WEBPACK_IMPORTED_MODULE_5__);
            /* harmony import */ var _goals_goalsAverage__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./goals/goalsAverage */ "./packages/loot-core/src/server/budget/goals/goalsAverage.ts");
            /* harmony import */ var _goals_goalsBy__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./goals/goalsBy */ "./packages/loot-core/src/server/budget/goals/goalsBy.ts");
            /* harmony import */ var _goals_goalsPercentage__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./goals/goalsPercentage */ "./packages/loot-core/src/server/budget/goals/goalsPercentage.ts");
            /* harmony import */ var _goals_goalsRemainder__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./goals/goalsRemainder */ "./packages/loot-core/src/server/budget/goals/goalsRemainder.ts");
            /* harmony import */ var _goals_goalsSchedule__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./goals/goalsSchedule */ "./packages/loot-core/src/server/budget/goals/goalsSchedule.ts");
            /* harmony import */ var _goals_goalsSimple__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./goals/goalsSimple */ "./packages/loot-core/src/server/budget/goals/goalsSimple.ts");
            /* harmony import */ var _goals_goalsSpend__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./goals/goalsSpend */ "./packages/loot-core/src/server/budget/goals/goalsSpend.ts");
            /* harmony import */ var _goals_goalsWeek__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./goals/goalsWeek */ "./packages/loot-core/src/server/budget/goals/goalsWeek.ts");
            // @ts-strict-ignore
            const TEMPLATE_PREFIX = '#template';
            const GOAL_PREFIX = '#goal';
            async function applyTemplate({ month }) {
                await storeTemplates();
                const category_templates = await getTemplates(null, 'template');
                const category_goals = await getTemplates(null, 'goal');
                const ret = await processTemplate(month, false, category_templates);
                await processGoals(category_goals, month);
                return ret;
            }
            async function overwriteTemplate({ month }) {
                await storeTemplates();
                const category_templates = await getTemplates(null, 'template');
                const category_goals = await getTemplates(null, 'goal');
                const ret = await processTemplate(month, true, category_templates);
                await processGoals(category_goals, month);
                return ret;
            }
            async function applySingleCategoryTemplate({ month, category }) {
                const categories = await _db__WEBPACK_IMPORTED_MODULE_2__.all(`SELECT * FROM v_categories WHERE id = ?`, [
                    category
                ]);
                await storeTemplates();
                const category_templates = await getTemplates(categories[0], 'template');
                const category_goals = await getTemplates(categories[0], 'goal');
                const ret = await processTemplate(month, true, category_templates, categories[0]);
                await processGoals(category_goals, month, categories[0]);
                return ret;
            }
            function runCheckTemplates() {
                return checkTemplates();
            }
            async function getCategories() {
                return await _db__WEBPACK_IMPORTED_MODULE_2__.all(`
    SELECT categories.* FROM categories 
    INNER JOIN category_groups on categories.cat_group = category_groups.id 
    WHERE categories.tombstone = 0 AND categories.hidden = 0 
    AND category_groups.hidden = 0
    `);
            }
            function checkScheduleTemplates(template) {
                let lowPriority = template[0].priority;
                let errorNotice = false;
                for (let l = 1; l < template.length; l++) {
                    if (template[l].priority !== lowPriority) {
                        lowPriority = Math.min(lowPriority, template[l].priority);
                        errorNotice = true;
                    }
                }
                return {
                    lowPriority,
                    errorNotice
                };
            }
            async function setGoalBudget({ month, templateBudget }) {
                await (0, _sync__WEBPACK_IMPORTED_MODULE_3__.batchMessages)(async () => {
                    templateBudget.forEach((element) => {
                        (0, _actions__WEBPACK_IMPORTED_MODULE_4__.setBudget)({
                            category: element.category,
                            month,
                            amount: element.amount
                        });
                    });
                });
            }
            async function setCategoryTargets({ month, idealTemplate }) {
                await (0, _sync__WEBPACK_IMPORTED_MODULE_3__.batchMessages)(async () => {
                    idealTemplate.forEach((element) => {
                        (0, _actions__WEBPACK_IMPORTED_MODULE_4__.setGoal)({
                            category: element.category,
                            goal: element.amount,
                            month,
                            long_goal: 0
                        });
                    });
                });
            }
            async function resetCategoryTargets(month, category) {
                let categories = [];
                if (category === null) {
                    categories = await getCategories();
                }
                else {
                    categories = category;
                }
                await (0, _sync__WEBPACK_IMPORTED_MODULE_3__.batchMessages)(async () => {
                    for (let i = 0; i < categories.length; i++) {
                        (0, _actions__WEBPACK_IMPORTED_MODULE_4__.setGoal)({
                            category: categories[i].id,
                            goal: null,
                            month,
                            long_goal: null
                        });
                    }
                });
            }
            async function storeTemplates() {
                //stores the template definitions to the database
                const templates = await getCategoryTemplates(null);
                const categories = await getCategories();
                for (let c = 0; c < categories.length; c++) {
                    const template = templates[categories[c].id];
                    if (template) {
                        await _db__WEBPACK_IMPORTED_MODULE_2__.update('categories', {
                            id: categories[c].id,
                            goal_def: JSON.stringify(template)
                        });
                    }
                    else {
                        await _db__WEBPACK_IMPORTED_MODULE_2__.update('categories', {
                            id: categories[c].id,
                            goal_def: null
                        });
                    }
                }
            }
            async function getTemplates(category, directive) {
                //retrieves template definitions from the database
                const goal_def = await _db__WEBPACK_IMPORTED_MODULE_2__.all('SELECT * FROM categories WHERE goal_def IS NOT NULL');
                const templates = [];
                for (let ll = 0; ll < goal_def.length; ll++) {
                    templates[goal_def[ll].id] = JSON.parse(goal_def[ll].goal_def);
                }
                if (category) {
                    const singleCategoryTemplate = [];
                    if (templates[category.id] !== undefined) {
                        singleCategoryTemplate[category.id] = templates[category.id].filter((t) => t.directive === directive);
                        return singleCategoryTemplate;
                    }
                    singleCategoryTemplate[category.id] = undefined;
                    return singleCategoryTemplate;
                }
                else {
                    const categories = await getCategories();
                    const ret = [];
                    for (let cc = 0; cc < categories.length; cc++) {
                        const id = categories[cc].id;
                        if (templates[id]) {
                            ret[id] = templates[id];
                            ret[id] = ret[id].filter((t) => t.directive === directive);
                        }
                    }
                    return ret;
                }
            }
            async function processTemplate(month, force, category_templates, category) {
                let num_applied = 0;
                let errors = [];
                const idealTemplate = [];
                const setToZero = [];
                let priority_list = [];
                let categories = [];
                const categories_remove = [];
                if (category) {
                    categories[0] = category;
                }
                else {
                    categories = await getCategories();
                }
                //clears templated categories
                for (let c = 0; c < categories.length; c++) {
                    const category = categories[c];
                    const budgeted = await (0, _actions__WEBPACK_IMPORTED_MODULE_4__.getSheetValue)(_shared_months__WEBPACK_IMPORTED_MODULE_0__.sheetForMonth(month), `budget-${category.id}`);
                    const template = category_templates[category.id];
                    if (template) {
                        for (let l = 0; l < template.length; l++) {
                            //add each priority we need to a list.  Will sort later
                            if (template[l].priority == null) {
                                continue;
                            }
                            priority_list.push(template[l].priority);
                        }
                    }
                    if (budgeted) {
                        if (!force) {
                            // save index of category to remove
                            categories_remove.push(c);
                        }
                        else {
                            // add all categories with a template to the list to unset budget
                            if (template?.length > 0) {
                                setToZero.push({
                                    category: category.id
                                });
                            }
                        }
                    }
                }
                // remove the categories we are skipping
                // Go backwards through the list so the indexes don't change
                // on the categories we need
                for (let i = categories_remove.length - 1; i >= 0; i--) {
                    categories.splice(categories_remove[i], 1);
                }
                // zero out budget and goal from categories that need it
                await setGoalBudget({
                    month,
                    templateBudget: setToZero
                });
                await resetCategoryTargets(month, categories);
                // sort and filter down to just the requested priorities
                priority_list = priority_list.sort(function (a, b) {
                    return a - b;
                }).filter((item, index, curr) => curr.indexOf(item) === index);
                const { remainder_found, remainder_priority, remainder_weight_total } = (0, _goals_goalsRemainder__WEBPACK_IMPORTED_MODULE_9__.findRemainder)(priority_list, categories, category_templates);
                if (remainder_found)
                    priority_list.push(remainder_priority);
                const sheetName = _shared_months__WEBPACK_IMPORTED_MODULE_0__.sheetForMonth(month);
                const available_start = await (0, _actions__WEBPACK_IMPORTED_MODULE_4__.getSheetValue)(sheetName, `to-budget`);
                let budgetAvailable = (0, _actions__WEBPACK_IMPORTED_MODULE_4__.isReflectBudget)() ? await (0, _actions__WEBPACK_IMPORTED_MODULE_4__.getSheetValue)(sheetName, `total-saved`) : await (0, _actions__WEBPACK_IMPORTED_MODULE_4__.getSheetValue)(sheetName, `to-budget`);
                for (let ii = 0; ii < priority_list.length; ii++) {
                    const priority = priority_list[ii];
                    const templateBudget = [];
                    // setup scaling for remainder
                    let remainder_scale = 1;
                    if (priority === remainder_priority && remainder_found) {
                        const available_now = await (0, _actions__WEBPACK_IMPORTED_MODULE_4__.getSheetValue)(sheetName, `to-budget`);
                        remainder_scale = available_now / remainder_weight_total;
                    }
                    for (let c = 0; c < categories.length; c++) {
                        const category = categories[c];
                        let template_lines = category_templates[category.id];
                        if (template_lines) {
                            //check that all schedule and by lines have the same priority level
                            let skipSchedule = false;
                            let isScheduleOrBy = false;
                            let priorityCheck = 0;
                            if (template_lines.filter((t) => (t.type === 'schedule' || t.type === 'by') && t.priority === priority).length > 0) {
                                template_lines = template_lines.filter((t) => t.priority === priority && (t.type !== 'schedule' || t.type !== 'by') || t.type === 'schedule' || t.type === 'by');
                                const { lowPriority, errorNotice } = await checkScheduleTemplates(template_lines);
                                priorityCheck = lowPriority;
                                skipSchedule = priorityCheck !== priority ? true : false;
                                isScheduleOrBy = true;
                                if (!skipSchedule && errorNotice) {
                                    errors.push(category.name + ': Schedules and By templates should all have the same priority.  Using priority ' + priorityCheck);
                                }
                            }
                            if (!skipSchedule) {
                                if (!isScheduleOrBy) {
                                    template_lines = template_lines.filter((t) => t.priority === priority);
                                }
                                if (template_lines.length > 0) {
                                    errors = errors.concat(template_lines.filter((t) => t.type === 'error').map(({ line, error }) => [
                                        category.name + ': ' + error.message,
                                        line,
                                        ' '.repeat(TEMPLATE_PREFIX.length + error.location.start.offset) + '^'
                                    ].join('\n')));
                                    const prev_budgeted = await (0, _actions__WEBPACK_IMPORTED_MODULE_4__.getSheetValue)(sheetName, `budget-${category.id}`);
                                    const { amount: originalToBudget, errors: applyErrors } = await applyCategoryTemplate(category, template_lines, month, remainder_scale, available_start, budgetAvailable, prev_budgeted);
                                    let to_budget = originalToBudget;
                                    if (to_budget != null) {
                                        num_applied++;
                                        //only store goals from non remainder templates
                                        if (priority !== remainder_priority) {
                                            if (idealTemplate.filter((c) => c.category === category.id).length > 0) {
                                                idealTemplate.filter((c) => c.category === category.id)[0].amount += to_budget;
                                            }
                                            else {
                                                idealTemplate.push({
                                                    category: category.id,
                                                    amount: to_budget
                                                });
                                            }
                                        }
                                        if (to_budget <= budgetAvailable || !priority) {
                                            templateBudget.push({
                                                category: category.id,
                                                amount: to_budget + prev_budgeted
                                            });
                                        }
                                        else if (to_budget > budgetAvailable && budgetAvailable >= 0) {
                                            to_budget = budgetAvailable;
                                            errors.push(`Insufficient funds.`);
                                            templateBudget.push({
                                                category: category.id,
                                                amount: to_budget + prev_budgeted
                                            });
                                        }
                                        budgetAvailable -= to_budget;
                                    }
                                    if (applyErrors != null) {
                                        errors = errors.concat(applyErrors.map((error) => `${category.name}: ${error}`));
                                    }
                                }
                            }
                        }
                    }
                    await setGoalBudget({
                        month,
                        templateBudget
                    });
                }
                await setCategoryTargets({
                    month,
                    idealTemplate
                });
                if (num_applied === 0) {
                    if (errors.length) {
                        return {
                            type: 'error',
                            sticky: true,
                            message: `There were errors interpreting some templates:`,
                            pre: errors.join('\n\n')
                        };
                    }
                    else {
                        return {
                            type: 'message',
                            message: 'All categories were up to date.'
                        };
                    }
                }
                else {
                    const applied = `Successfully applied ${num_applied} templates.`;
                    if (errors.length) {
                        return {
                            sticky: true,
                            message: `${applied} There were errors interpreting some templates:`,
                            pre: errors.join('\n\n')
                        };
                    }
                    else {
                        return {
                            type: 'message',
                            message: applied
                        };
                    }
                }
            }
            async function processGoals(goals, month, category) {
                let categories = [];
                if (category) {
                    categories[0] = category;
                }
                else {
                    categories = await getCategories();
                }
                for (let c = 0; c < categories.length; c++) {
                    const cat_id = categories[c].id;
                    const goal_lines = goals[cat_id];
                    if (goal_lines?.length > 0) {
                        await (0, _actions__WEBPACK_IMPORTED_MODULE_4__.setGoal)({
                            month,
                            category: cat_id,
                            goal: (0, _shared_util__WEBPACK_IMPORTED_MODULE_1__.amountToInteger)(goal_lines[0].amount),
                            long_goal: 1
                        });
                    }
                }
            }
            async function getCategoryTemplates(category) {
                const templates = {};
                let notes = await _db__WEBPACK_IMPORTED_MODULE_2__.all(`
    SELECT * FROM notes 
    WHERE lower(note) like '%${TEMPLATE_PREFIX}%' 
    OR lower(note) like '%${GOAL_PREFIX}%'
     `);
                if (category)
                    notes = notes.filter((n) => n.id === category.id);
                for (let n = 0; n < notes.length; n++) {
                    const lines = notes[n].note.split('\n');
                    const template_lines = [];
                    for (let l = 0; l < lines.length; l++) {
                        const line = lines[l].trim();
                        if (!line.toLowerCase().startsWith(TEMPLATE_PREFIX) && !line.toLowerCase().startsWith(GOAL_PREFIX)) {
                            continue;
                        }
                        try {
                            const parsed = (0, _goal_template_pegjs__WEBPACK_IMPORTED_MODULE_5__.parse)(line);
                            template_lines.push(parsed);
                        }
                        catch (e) {
                            template_lines.push({
                                type: 'error',
                                line,
                                error: e
                            });
                        }
                    }
                    if (template_lines.length) {
                        templates[notes[n].id] = template_lines;
                    }
                }
                return templates;
            }
            async function applyCategoryTemplate(category, template_lines, month, remainder_scale, available_start, budgetAvailable, prev_budgeted) {
                const current_month = `${month}-01`;
                let errors = [];
                let all_schedule_names = await _db__WEBPACK_IMPORTED_MODULE_2__.all('SELECT name from schedules WHERE name NOT NULL AND tombstone = 0');
                all_schedule_names = all_schedule_names.map((v) => v.name);
                let scheduleFlag = false; //only run schedules portion once
                // remove lines for past dates, calculate repeating dates
                template_lines = template_lines.filter((template) => {
                    switch (template.type) {
                        case 'by':
                        case 'spend':
                            let target_month = `${template.month}-01`;
                            let num_months = _shared_months__WEBPACK_IMPORTED_MODULE_0__.differenceInCalendarMonths(target_month, current_month);
                            const repeat = template.annual ? (template.repeat || 1) * 12 : template.repeat;
                            let spend_from;
                            if (template.type === 'spend') {
                                spend_from = `${template.from}-01`;
                            }
                            while (num_months < 0 && repeat) {
                                target_month = _shared_months__WEBPACK_IMPORTED_MODULE_0__.addMonths(target_month, repeat);
                                if (spend_from) {
                                    spend_from = _shared_months__WEBPACK_IMPORTED_MODULE_0__.addMonths(spend_from, repeat);
                                }
                                num_months = _shared_months__WEBPACK_IMPORTED_MODULE_0__.differenceInCalendarMonths(target_month, current_month);
                            }
                            if (num_months < 0) {
                                errors.push(`${template.month} is in the past.`);
                                return false;
                            }
                            template.month = _shared_months__WEBPACK_IMPORTED_MODULE_0__.format(target_month, 'yyyy-MM');
                            if (spend_from) {
                                template.from = _shared_months__WEBPACK_IMPORTED_MODULE_0__.format(spend_from, 'yyyy-MM');
                            }
                            break;
                        case 'schedule':
                            if (!all_schedule_names.includes(template.name)) {
                                errors.push(`Schedule ${template.name} does not exist`);
                                return null;
                            }
                            break;
                        default:
                    }
                    return true;
                });
                if (template_lines.length > 1) {
                    template_lines = template_lines.sort((a, b) => {
                        if (a.type === 'by' && !a.annual) {
                            return _shared_months__WEBPACK_IMPORTED_MODULE_0__.differenceInCalendarMonths(`${a.month}-01`, `${b.month}-01`);
                        }
                        else if (a.type === 'schedule' || b.type === 'schedule') {
                            return a.priority - b.priority;
                        }
                        else {
                            return a.type.localeCompare(b.type);
                        }
                    });
                }
                const sheetName = _shared_months__WEBPACK_IMPORTED_MODULE_0__.sheetForMonth(month);
                const spent = await (0, _actions__WEBPACK_IMPORTED_MODULE_4__.getSheetValue)(sheetName, `sum-amount-${category.id}`);
                const balance = await (0, _actions__WEBPACK_IMPORTED_MODULE_4__.getSheetValue)(sheetName, `leftover-${category.id}`);
                const last_month_balance = balance - spent - prev_budgeted;
                let to_budget = 0;
                let limit = 0;
                let hold = false;
                let limitCheck = false;
                let remainder = 0;
                for (let l = 0; l < template_lines.length; l++) {
                    const template = template_lines[l];
                    switch (template.type) {
                        case 'simple':
                            {
                                const goalsReturn = await (0, _goals_goalsSimple__WEBPACK_IMPORTED_MODULE_11__.goalsSimple)(template, limitCheck, errors, limit, hold, to_budget, last_month_balance);
                                to_budget = goalsReturn.to_budget;
                                errors = goalsReturn.errors;
                                limit = goalsReturn.limit;
                                limitCheck = goalsReturn.limitCheck;
                                hold = goalsReturn.hold;
                                break;
                            }
                        case 'by':
                            {
                                const goalsReturn = await (0, _goals_goalsBy__WEBPACK_IMPORTED_MODULE_7__.goalsBy)(template_lines, current_month, template, l, remainder, last_month_balance, to_budget, errors);
                                to_budget = goalsReturn.to_budget;
                                errors = goalsReturn.errors;
                                remainder = goalsReturn.remainder;
                                break;
                            }
                        case 'week':
                            {
                                const goalsReturn = await (0, _goals_goalsWeek__WEBPACK_IMPORTED_MODULE_13__.goalsWeek)(template, limit, limitCheck, hold, current_month, to_budget, errors);
                                to_budget = goalsReturn.to_budget;
                                errors = goalsReturn.errors;
                                limit = goalsReturn.limit;
                                limitCheck = goalsReturn.limitCheck;
                                hold = goalsReturn.hold;
                                break;
                            }
                        case 'spend':
                            {
                                const goalsReturn = await (0, _goals_goalsSpend__WEBPACK_IMPORTED_MODULE_12__.goalsSpend)(template, last_month_balance, current_month, to_budget, errors, category);
                                to_budget = goalsReturn.to_budget;
                                errors = goalsReturn.errors;
                                break;
                            }
                        case 'percentage':
                            {
                                const goalsReturn = await (0, _goals_goalsPercentage__WEBPACK_IMPORTED_MODULE_8__.goalsPercentage)(template, month, available_start, sheetName, to_budget, errors);
                                to_budget = goalsReturn.to_budget;
                                errors = goalsReturn.errors;
                                break;
                            }
                        case 'schedule':
                            {
                                const goalsReturn = await (0, _goals_goalsSchedule__WEBPACK_IMPORTED_MODULE_10__.goalsSchedule)(scheduleFlag, template_lines, current_month, balance, remainder, last_month_balance, to_budget, errors, category);
                                to_budget = goalsReturn.to_budget;
                                errors = goalsReturn.errors;
                                remainder = goalsReturn.remainder;
                                scheduleFlag = goalsReturn.scheduleFlag;
                                break;
                            }
                        case 'remainder':
                            {
                                const goalsReturn = await (0, _goals_goalsRemainder__WEBPACK_IMPORTED_MODULE_9__.goalsRemainder)(template, budgetAvailable, remainder_scale, to_budget);
                                to_budget = goalsReturn.to_budget;
                                break;
                            }
                        case 'average':
                            {
                                const goalsReturn = await (0, _goals_goalsAverage__WEBPACK_IMPORTED_MODULE_6__.goalsAverage)(template, current_month, category, errors, to_budget);
                                to_budget = goalsReturn.to_budget;
                                errors = goalsReturn.errors;
                                break;
                            }
                        case 'error':
                            return {
                                errors
                            };
                        default:
                    }
                }
                if (limitCheck) {
                    if (hold && balance > limit) {
                        to_budget = 0;
                    }
                    else if (to_budget + balance > limit) {
                        to_budget = limit - balance;
                    }
                }
                // setup notifications
                let str = category.name + ': ' + (0, _shared_util__WEBPACK_IMPORTED_MODULE_1__.integerToAmount)(last_month_balance);
                str += ' + ' + (0, _shared_util__WEBPACK_IMPORTED_MODULE_1__.integerToAmount)(to_budget) + ' = ' + (0, _shared_util__WEBPACK_IMPORTED_MODULE_1__.integerToAmount)(last_month_balance + to_budget);
                str += ' ' + template_lines.map((x) => x.line).join('\n');
                console.log(str);
                return {
                    amount: to_budget,
                    errors
                };
            }
            async function checkTemplates() {
                const category_templates = await getCategoryTemplates(null);
                const errors = [];
                const categories = await _db__WEBPACK_IMPORTED_MODULE_2__.all('SELECT * FROM v_categories WHERE tombstone = 0');
                let all_schedule_names = await _db__WEBPACK_IMPORTED_MODULE_2__.all('SELECT name from schedules WHERE name NOT NULL AND tombstone = 0');
                all_schedule_names = all_schedule_names.map((v) => v.name);
                // run through each line and see if its an error
                for (let c = 0; c < categories.length; c++) {
                    const category = categories[c];
                    const template = category_templates[category.id];
                    if (template) {
                        for (let l = 0; l < template.length; l++) {
                            //check for basic error
                            if (template[l].type === 'error') {
                                errors.push(category.name + ': ' + template[l].line);
                            }
                            // check schedule name error
                            if (template[l].type === 'schedule') {
                                if (!all_schedule_names.includes(template[l].name)) {
                                    errors.push(category.name + ': Schedule ' + template[l].name + ' does not exist');
                                }
                            }
                        }
                    }
                }
                if (errors.length) {
                    return {
                        sticky: true,
                        message: `There were errors interpreting some templates:`,
                        pre: errors.join('\n\n')
                    };
                }
                else {
                    return {
                        type: 'message',
                        message: 'All templates passed! '
                    };
                }
            }
            /***/ 
        }),
        /***/ "./packages/loot-core/src/server/budget/report.ts": 
        /*!********************************************************!*\
          !*** ./packages/loot-core/src/server/budget/report.ts ***!
          \********************************************************/
        /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony export */ __webpack_require__.d(__webpack_exports__, {
                /* harmony export */ createCategory: () => ( /* binding */createCategory),
                /* harmony export */ createSummary: () => ( /* binding */createSummary)
                /* harmony export */ 
            });
            /* harmony import */ var _shared_util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../shared/util */ "./packages/loot-core/src/shared/util.ts");
            /* harmony import */ var _sheet__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../sheet */ "./packages/loot-core/src/server/sheet.ts");
            /* harmony import */ var _spreadsheet_util__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../spreadsheet/util */ "./packages/loot-core/src/server/spreadsheet/util.ts");
            /* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./util */ "./packages/loot-core/src/server/budget/util.ts");
            // @ts-strict-ignore
            async function createCategory(cat, sheetName, prevSheetName) {
                _sheet__WEBPACK_IMPORTED_MODULE_1__.get().createStatic(sheetName, `budget-${cat.id}`, 0);
                // This makes the app more robust by "fixing up" null budget values.
                // Those should not be allowed, but in case somehow a null value
                // ends up there, we are resilient to it. Preferrably the
                // spreadsheet would have types and be more strict about what is
                // allowed to be set.
                if (_sheet__WEBPACK_IMPORTED_MODULE_1__.get().getCellValue(sheetName, `budget-${cat.id}`) == null) {
                    _sheet__WEBPACK_IMPORTED_MODULE_1__.get().set((0, _spreadsheet_util__WEBPACK_IMPORTED_MODULE_2__.resolveName)(sheetName, `budget-${cat.id}`), 0);
                }
                _sheet__WEBPACK_IMPORTED_MODULE_1__.get().createDynamic(sheetName, `leftover-${cat.id}`, {
                    initialValue: 0,
                    dependencies: [
                        `budget-${cat.id}`,
                        `sum-amount-${cat.id}`,
                        `${prevSheetName}!carryover-${cat.id}`,
                        `${prevSheetName}!leftover-${cat.id}`
                    ],
                    run: (budgeted, sumAmount, prevCarryover, prevLeftover) => {
                        if (cat.is_income) {
                            return (0, _shared_util__WEBPACK_IMPORTED_MODULE_0__.safeNumber)((0, _util__WEBPACK_IMPORTED_MODULE_3__.number)(budgeted) - (0, _util__WEBPACK_IMPORTED_MODULE_3__.number)(sumAmount) + (prevCarryover ? (0, _util__WEBPACK_IMPORTED_MODULE_3__.number)(prevLeftover) : 0));
                        }
                        return (0, _shared_util__WEBPACK_IMPORTED_MODULE_0__.safeNumber)((0, _util__WEBPACK_IMPORTED_MODULE_3__.number)(budgeted) + (0, _util__WEBPACK_IMPORTED_MODULE_3__.number)(sumAmount) + (prevCarryover ? (0, _util__WEBPACK_IMPORTED_MODULE_3__.number)(prevLeftover) : 0));
                    }
                });
                _sheet__WEBPACK_IMPORTED_MODULE_1__.get().createDynamic(sheetName, `spent-with-carryover-${cat.id}`, {
                    initialValue: 0,
                    dependencies: [
                        `budget-${cat.id}`,
                        `sum-amount-${cat.id}`,
                        `carryover-${cat.id}`
                    ],
                    // TODO: Why refresh??
                    refresh: true,
                    run: (budgeted, sumAmount, carryover) => {
                        return carryover ? Math.max(0, (0, _shared_util__WEBPACK_IMPORTED_MODULE_0__.safeNumber)((0, _util__WEBPACK_IMPORTED_MODULE_3__.number)(budgeted) + (0, _util__WEBPACK_IMPORTED_MODULE_3__.number)(sumAmount))) : sumAmount;
                    }
                });
                _sheet__WEBPACK_IMPORTED_MODULE_1__.get().createStatic(sheetName, `carryover-${cat.id}`, false);
            }
            function createSummary(groups, categories, sheetName) {
                const incomeGroup = groups.filter((group) => group.is_income)[0];
                const expenseCategories = categories.filter((cat) => !cat.is_income);
                _sheet__WEBPACK_IMPORTED_MODULE_1__.get().createDynamic(sheetName, 'total-budgeted', {
                    initialValue: 0,
                    dependencies: groups.filter((group) => !group.is_income).map((group) => `group-budget-${group.id}`),
                    run: _util__WEBPACK_IMPORTED_MODULE_3__.sumAmounts
                });
                _sheet__WEBPACK_IMPORTED_MODULE_1__.get().createDynamic(sheetName, 'total-spent', {
                    initialValue: 0,
                    refresh: true,
                    dependencies: expenseCategories.map((cat) => `${sheetName}!spent-with-carryover-${cat.id}`),
                    run: _util__WEBPACK_IMPORTED_MODULE_3__.sumAmounts
                });
                _sheet__WEBPACK_IMPORTED_MODULE_1__.get().createDynamic(sheetName, 'total-income', {
                    initialValue: 0,
                    dependencies: [
                        `group-sum-amount-${incomeGroup.id}`
                    ],
                    run: (amount) => amount
                });
                _sheet__WEBPACK_IMPORTED_MODULE_1__.get().createDynamic(sheetName, 'total-leftover', {
                    initialValue: 0,
                    dependencies: [
                        'total-budgeted',
                        'total-spent'
                    ],
                    run: _util__WEBPACK_IMPORTED_MODULE_3__.sumAmounts
                });
                _sheet__WEBPACK_IMPORTED_MODULE_1__.get().createDynamic(sheetName, 'total-budget-income', {
                    initialValue: 0,
                    dependencies: [
                        `group-budget-${incomeGroup.id}`
                    ],
                    run: (amount) => amount
                });
                _sheet__WEBPACK_IMPORTED_MODULE_1__.get().createDynamic(sheetName, 'total-saved', {
                    initialValue: 0,
                    dependencies: [
                        'total-budget-income',
                        'total-budgeted'
                    ],
                    run: (income, budgeted) => {
                        return income - budgeted;
                    }
                });
                _sheet__WEBPACK_IMPORTED_MODULE_1__.get().createDynamic(sheetName, 'real-saved', {
                    initialValue: 0,
                    dependencies: [
                        'total-income',
                        'total-spent'
                    ],
                    run: (income, spent) => {
                        return (0, _shared_util__WEBPACK_IMPORTED_MODULE_0__.safeNumber)(income - -spent);
                    }
                });
            }
            /***/ 
        }),
        /***/ "./packages/loot-core/src/server/budget/rollover.ts": 
        /*!**********************************************************!*\
          !*** ./packages/loot-core/src/server/budget/rollover.ts ***!
          \**********************************************************/
        /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony export */ __webpack_require__.d(__webpack_exports__, {
                /* harmony export */ createBlankCategory: () => ( /* binding */createBlankCategory),
                /* harmony export */ createBudget: () => ( /* binding */createBudget),
                /* harmony export */ createCategory: () => ( /* binding */createCategory),
                /* harmony export */ createSummary: () => ( /* binding */createSummary)
                /* harmony export */ 
            });
            /* harmony import */ var _shared_months__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../shared/months */ "./packages/loot-core/src/shared/months.ts");
            /* harmony import */ var _shared_util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../shared/util */ "./packages/loot-core/src/shared/util.ts");
            /* harmony import */ var _sheet__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../sheet */ "./packages/loot-core/src/server/sheet.ts");
            /* harmony import */ var _spreadsheet_util__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../spreadsheet/util */ "./packages/loot-core/src/server/spreadsheet/util.ts");
            /* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./util */ "./packages/loot-core/src/server/budget/util.ts");
            // @ts-strict-ignore
            function getBlankSheet(months) {
                const blankMonth = _shared_months__WEBPACK_IMPORTED_MODULE_0__.prevMonth(months[0]);
                return _shared_months__WEBPACK_IMPORTED_MODULE_0__.sheetForMonth(blankMonth);
            }
            function createBlankCategory(cat, months) {
                if (months.length > 0) {
                    const sheetName = getBlankSheet(months);
                    _sheet__WEBPACK_IMPORTED_MODULE_2__.get().createStatic(sheetName, `carryover-${cat.id}`, false);
                    _sheet__WEBPACK_IMPORTED_MODULE_2__.get().createStatic(sheetName, `leftover-${cat.id}`, 0);
                    _sheet__WEBPACK_IMPORTED_MODULE_2__.get().createStatic(sheetName, `leftover-pos-${cat.id}`, 0);
                }
            }
            function createBlankMonth(categories, sheetName, months) {
                _sheet__WEBPACK_IMPORTED_MODULE_2__.get().createStatic(sheetName, 'is-blank', true);
                _sheet__WEBPACK_IMPORTED_MODULE_2__.get().createStatic(sheetName, 'to-budget', 0);
                _sheet__WEBPACK_IMPORTED_MODULE_2__.get().createStatic(sheetName, 'buffered', 0);
                categories.forEach((cat) => createBlankCategory(cat, months));
            }
            function createCategory(cat, sheetName, prevSheetName) {
                if (!cat.is_income) {
                    _sheet__WEBPACK_IMPORTED_MODULE_2__.get().createStatic(sheetName, `budget-${cat.id}`, 0);
                    // This makes the app more robust by "fixing up" null budget values.
                    // Those should not be allowed, but in case somehow a null value
                    // ends up there, we are resilient to it. Preferrably the
                    // spreadsheet would have types and be more strict about what is
                    // allowed to be set.
                    if (_sheet__WEBPACK_IMPORTED_MODULE_2__.get().getCellValue(sheetName, `budget-${cat.id}`) == null) {
                        _sheet__WEBPACK_IMPORTED_MODULE_2__.get().set((0, _spreadsheet_util__WEBPACK_IMPORTED_MODULE_3__.resolveName)(sheetName, `budget-${cat.id}`), 0);
                    }
                    _sheet__WEBPACK_IMPORTED_MODULE_2__.get().createStatic(sheetName, `carryover-${cat.id}`, false);
                    _sheet__WEBPACK_IMPORTED_MODULE_2__.get().createDynamic(sheetName, `leftover-${cat.id}`, {
                        initialValue: 0,
                        dependencies: [
                            `budget-${cat.id}`,
                            `sum-amount-${cat.id}`,
                            `${prevSheetName}!carryover-${cat.id}`,
                            `${prevSheetName}!leftover-${cat.id}`,
                            `${prevSheetName}!leftover-pos-${cat.id}`
                        ],
                        run: (budgeted, spent, prevCarryover, prevLeftover, prevLeftoverPos) => {
                            return (0, _shared_util__WEBPACK_IMPORTED_MODULE_1__.safeNumber)((0, _util__WEBPACK_IMPORTED_MODULE_4__.number)(budgeted) + (0, _util__WEBPACK_IMPORTED_MODULE_4__.number)(spent) + (prevCarryover ? (0, _util__WEBPACK_IMPORTED_MODULE_4__.number)(prevLeftover) : (0, _util__WEBPACK_IMPORTED_MODULE_4__.number)(prevLeftoverPos)));
                        }
                    });
                    _sheet__WEBPACK_IMPORTED_MODULE_2__.get().createDynamic(sheetName, 'leftover-pos-' + cat.id, {
                        initialValue: 0,
                        dependencies: [
                            `leftover-${cat.id}`
                        ],
                        run: (leftover) => {
                            return leftover < 0 ? 0 : leftover;
                        }
                    });
                }
            }
            function createSummary(groups, categories, prevSheetName, sheetName) {
                const incomeGroup = groups.filter((group) => group.is_income)[0];
                const expenseCategories = categories.filter((cat) => !cat.is_income);
                _sheet__WEBPACK_IMPORTED_MODULE_2__.get().createStatic(sheetName, 'buffered', 0);
                _sheet__WEBPACK_IMPORTED_MODULE_2__.get().createDynamic(sheetName, 'from-last-month', {
                    initialValue: 0,
                    dependencies: [
                        `${prevSheetName}!to-budget`,
                        `${prevSheetName}!buffered`
                    ],
                    run: (toBudget, buffered) => (0, _shared_util__WEBPACK_IMPORTED_MODULE_1__.safeNumber)((0, _util__WEBPACK_IMPORTED_MODULE_4__.number)(toBudget) + (0, _util__WEBPACK_IMPORTED_MODULE_4__.number)(buffered))
                });
                // Alias the group income total to `total-income`
                _sheet__WEBPACK_IMPORTED_MODULE_2__.get().createDynamic(sheetName, 'total-income', {
                    initialValue: 0,
                    dependencies: [
                        `group-sum-amount-${incomeGroup.id}`
                    ],
                    run: (amount) => amount
                });
                _sheet__WEBPACK_IMPORTED_MODULE_2__.get().createDynamic(sheetName, 'available-funds', {
                    initialValue: 0,
                    dependencies: [
                        'total-income',
                        'from-last-month'
                    ],
                    run: (income, fromLastMonth) => (0, _shared_util__WEBPACK_IMPORTED_MODULE_1__.safeNumber)((0, _util__WEBPACK_IMPORTED_MODULE_4__.number)(income) + (0, _util__WEBPACK_IMPORTED_MODULE_4__.number)(fromLastMonth))
                });
                _sheet__WEBPACK_IMPORTED_MODULE_2__.get().createDynamic(sheetName, 'last-month-overspent', {
                    initialValue: 0,
                    dependencies: (0, _util__WEBPACK_IMPORTED_MODULE_4__.flatten2)(expenseCategories.map((cat) => [
                        `${prevSheetName}!leftover-${cat.id}`,
                        `${prevSheetName}!carryover-${cat.id}`
                    ])),
                    run: (...data) => {
                        data = (0, _util__WEBPACK_IMPORTED_MODULE_4__.unflatten2)(data);
                        return (0, _shared_util__WEBPACK_IMPORTED_MODULE_1__.safeNumber)(data.reduce((total, [leftover, carryover]) => {
                            if (carryover) {
                                return total;
                            }
                            return total + Math.min(0, (0, _util__WEBPACK_IMPORTED_MODULE_4__.number)(leftover));
                        }, 0));
                    }
                });
                _sheet__WEBPACK_IMPORTED_MODULE_2__.get().createDynamic(sheetName, 'total-budgeted', {
                    initialValue: 0,
                    dependencies: groups.filter((group) => !group.is_income).map((group) => `group-budget-${group.id}`),
                    run: (...amounts) => {
                        // Negate budgeted amount
                        return -(0, _util__WEBPACK_IMPORTED_MODULE_4__.sumAmounts)(...amounts);
                    }
                });
                _sheet__WEBPACK_IMPORTED_MODULE_2__.get().createDynamic(sheetName, 'buffered', {
                    initialValue: 0
                });
                _sheet__WEBPACK_IMPORTED_MODULE_2__.get().createDynamic(sheetName, 'to-budget', {
                    initialValue: 0,
                    dependencies: [
                        'available-funds',
                        'last-month-overspent',
                        'total-budgeted',
                        'buffered'
                    ],
                    run: (available, lastOverspent, totalBudgeted, buffered) => {
                        return (0, _shared_util__WEBPACK_IMPORTED_MODULE_1__.safeNumber)((0, _util__WEBPACK_IMPORTED_MODULE_4__.number)(available) + (0, _util__WEBPACK_IMPORTED_MODULE_4__.number)(lastOverspent) + (0, _util__WEBPACK_IMPORTED_MODULE_4__.number)(totalBudgeted) - (0, _util__WEBPACK_IMPORTED_MODULE_4__.number)(buffered));
                    }
                });
                _sheet__WEBPACK_IMPORTED_MODULE_2__.get().createDynamic(sheetName, 'total-spent', {
                    initialValue: 0,
                    dependencies: groups.filter((group) => !group.is_income).map((group) => `group-sum-amount-${group.id}`),
                    run: _util__WEBPACK_IMPORTED_MODULE_4__.sumAmounts
                });
                _sheet__WEBPACK_IMPORTED_MODULE_2__.get().createDynamic(sheetName, 'total-leftover', {
                    initialValue: 0,
                    dependencies: groups.filter((group) => !group.is_income).map((group) => `group-leftover-${group.id}`),
                    run: _util__WEBPACK_IMPORTED_MODULE_4__.sumAmounts
                });
            }
            function createBudget(meta, categories, months) {
                // The spreadsheet is now strict - so we need to fill in some
                // default values for the month before the first month. Only do this
                // if it doesn't already exist
                const blankSheet = getBlankSheet(months);
                if (meta.blankSheet !== blankSheet) {
                    _sheet__WEBPACK_IMPORTED_MODULE_2__.get().clearSheet(meta.blankSheet);
                    createBlankMonth(categories, blankSheet, months);
                    meta.blankSheet = blankSheet;
                }
            }
            /***/ 
        }),
        /***/ "./packages/loot-core/src/server/budget/util.ts": 
        /*!******************************************************!*\
          !*** ./packages/loot-core/src/server/budget/util.ts ***!
          \******************************************************/
        /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony export */ __webpack_require__.d(__webpack_exports__, {
                /* harmony export */ flatten2: () => ( /* binding */flatten2),
                /* harmony export */ number: () => ( /* reexport safe */_spreadsheet_globals__WEBPACK_IMPORTED_MODULE_1__.number),
                /* harmony export */ sumAmounts: () => ( /* binding */sumAmounts),
                /* harmony export */ unflatten2: () => ( /* binding */unflatten2)
                /* harmony export */ 
            });
            /* harmony import */ var _shared_util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../shared/util */ "./packages/loot-core/src/shared/util.ts");
            /* harmony import */ var _spreadsheet_globals__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../spreadsheet/globals */ "./packages/loot-core/src/server/spreadsheet/globals.ts");
            // @ts-strict-ignore
            function sumAmounts(...amounts) {
                return (0, _shared_util__WEBPACK_IMPORTED_MODULE_0__.safeNumber)(amounts.reduce((total, amount) => {
                    return total + (0, _spreadsheet_globals__WEBPACK_IMPORTED_MODULE_1__.number)(amount);
                }, 0));
            }
            function flatten2(arr) {
                return Array.prototype.concat.apply([], arr);
            }
            function unflatten2(arr) {
                const res = [];
                for (let i = 0; i < arr.length; i += 2) {
                    res.push([
                        arr[i],
                        arr[i + 1]
                    ]);
                }
                return res;
            }
            /***/ 
        }),
        /***/ "./packages/loot-core/src/server/cloud-storage.ts": 
        /*!********************************************************!*\
          !*** ./packages/loot-core/src/server/cloud-storage.ts ***!
          \********************************************************/
        /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony export */ __webpack_require__.d(__webpack_exports__, {
                /* harmony export */ checkKey: () => ( /* binding */checkKey),
                /* harmony export */ download: () => ( /* binding */download),
                /* harmony export */ exportBuffer: () => ( /* binding */exportBuffer),
                /* harmony export */ importBuffer: () => ( /* binding */importBuffer),
                /* harmony export */ listRemoteFiles: () => ( /* binding */listRemoteFiles),
                /* harmony export */ possiblyUpload: () => ( /* binding */possiblyUpload),
                /* harmony export */ removeFile: () => ( /* binding */removeFile),
                /* harmony export */ resetSyncState: () => ( /* binding */resetSyncState),
                /* harmony export */ upload: () => ( /* binding */upload)
                /* harmony export */ 
            });
            /* harmony import */ var adm_zip__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! adm-zip */ "./node_modules/adm-zip/adm-zip.js");
            /* harmony import */ var adm_zip__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/ __webpack_require__.n(adm_zip__WEBPACK_IMPORTED_MODULE_0__);
            /* harmony import */ var uuid__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! uuid */ "./node_modules/uuid/dist/esm-node/v4.js");
            /* harmony import */ var _platform_server_asyncStorage__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../platform/server/asyncStorage */ "./packages/loot-core/src/platform/server/asyncStorage/index.electron.ts");
            /* harmony import */ var _platform_server_fetch__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../platform/server/fetch */ "./packages/loot-core/src/platform/server/fetch/index.api.ts");
            /* harmony import */ var _platform_server_fs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../platform/server/fs */ "./packages/loot-core/src/platform/server/fs/index.electron.ts");
            /* harmony import */ var _platform_server_sqlite__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../platform/server/sqlite */ "./packages/loot-core/src/platform/server/sqlite/index.electron.ts");
            /* harmony import */ var _shared_months__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../shared/months */ "./packages/loot-core/src/shared/months.ts");
            /* harmony import */ var _encryption__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./encryption */ "./packages/loot-core/src/server/encryption.ts");
            /* harmony import */ var _errors__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./errors */ "./packages/loot-core/src/server/errors.ts");
            /* harmony import */ var _mutators__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./mutators */ "./packages/loot-core/src/server/mutators.ts");
            /* harmony import */ var _post__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./post */ "./packages/loot-core/src/server/post.ts");
            /* harmony import */ var _prefs__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./prefs */ "./packages/loot-core/src/server/prefs.ts");
            /* harmony import */ var _server_config__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./server-config */ "./packages/loot-core/src/server/server-config.ts");
            // @ts-strict-ignore
            const UPLOAD_FREQUENCY_IN_DAYS = 7;
            async function checkHTTPStatus(res) {
                if (res.status !== 200) {
                    return res.text().then((str) => {
                        throw new _errors__WEBPACK_IMPORTED_MODULE_7__.HTTPError(res.status, str);
                    });
                }
                else {
                    return res;
                }
            }
            async function fetchJSON(...args) {
                let res = await (0, _platform_server_fetch__WEBPACK_IMPORTED_MODULE_2__.fetch)(...args);
                res = await checkHTTPStatus(res);
                return res.json();
            }
            async function checkKey() {
                const userToken = await _platform_server_asyncStorage__WEBPACK_IMPORTED_MODULE_1__.getItem('user-token');
                const { cloudFileId, encryptKeyId } = _prefs__WEBPACK_IMPORTED_MODULE_10__.getPrefs();
                let res;
                try {
                    res = await (0, _post__WEBPACK_IMPORTED_MODULE_9__.post)((0, _server_config__WEBPACK_IMPORTED_MODULE_11__.getServer)().SYNC_SERVER + '/user-get-key', {
                        token: userToken,
                        fileId: cloudFileId
                    });
                }
                catch (e) {
                    console.log(e);
                    return {
                        valid: false,
                        error: {
                            reason: 'network'
                        }
                    };
                }
                return {
                    valid: // This == comparison is important, they could be null or undefined
                    // eslint-disable-next-line eqeqeq
                    res.id == encryptKeyId && (encryptKeyId == null || _encryption__WEBPACK_IMPORTED_MODULE_6__.hasKey(encryptKeyId))
                };
            }
            async function resetSyncState(newKeyState) {
                const userToken = await _platform_server_asyncStorage__WEBPACK_IMPORTED_MODULE_1__.getItem('user-token');
                const { cloudFileId } = _prefs__WEBPACK_IMPORTED_MODULE_10__.getPrefs();
                try {
                    await (0, _post__WEBPACK_IMPORTED_MODULE_9__.post)((0, _server_config__WEBPACK_IMPORTED_MODULE_11__.getServer)().SYNC_SERVER + '/reset-user-file', {
                        token: userToken,
                        fileId: cloudFileId
                    });
                }
                catch (e) {
                    if (e instanceof _errors__WEBPACK_IMPORTED_MODULE_7__.PostError) {
                        return {
                            error: {
                                reason: e.reason === 'unauthorized' ? 'unauthorized' : 'network'
                            }
                        };
                    }
                    return {
                        error: {
                            reason: 'internal'
                        }
                    };
                }
                if (newKeyState) {
                    try {
                        await (0, _post__WEBPACK_IMPORTED_MODULE_9__.post)((0, _server_config__WEBPACK_IMPORTED_MODULE_11__.getServer)().SYNC_SERVER + '/user-create-key', {
                            token: userToken,
                            fileId: cloudFileId,
                            keyId: newKeyState.key.getId(),
                            keySalt: newKeyState.salt,
                            testContent: newKeyState.testContent
                        });
                    }
                    catch (e) {
                        if (e instanceof _errors__WEBPACK_IMPORTED_MODULE_7__.PostError) {
                            return {
                                error: {
                                    reason: 'network'
                                }
                            };
                        }
                        return {
                            error: {
                                reason: 'internal'
                            }
                        };
                    }
                }
                return {};
            }
            async function exportBuffer() {
                const { id, budgetName } = _prefs__WEBPACK_IMPORTED_MODULE_10__.getPrefs();
                if (!budgetName) {
                    return null;
                }
                const budgetDir = _platform_server_fs__WEBPACK_IMPORTED_MODULE_3__.getBudgetDir(id);
                // create zip
                const zipped = new (adm_zip__WEBPACK_IMPORTED_MODULE_0___default())();
                // We run this in a mutator even though its not mutating anything
                // because we are reading the sqlite file from disk. We want to make
                // sure that we get a valid snapshot of it so we want this to be
                // serialized with all other mutations.
                await (0, _mutators__WEBPACK_IMPORTED_MODULE_8__.runMutator)(async () => {
                    const rawDbContent = await _platform_server_fs__WEBPACK_IMPORTED_MODULE_3__.readFile(_platform_server_fs__WEBPACK_IMPORTED_MODULE_3__.join(budgetDir, 'db.sqlite'), 'binary');
                    // Do some post-processing of the database. We NEVER upload the cache with
                    // the database; this forces new downloads to always recompute everything
                    // which is not only safer, but reduces the filesize a lot.
                    const memDb = await _platform_server_sqlite__WEBPACK_IMPORTED_MODULE_4__.openDatabase(rawDbContent);
                    _platform_server_sqlite__WEBPACK_IMPORTED_MODULE_4__.execQuery(memDb, `
        DELETE FROM kvcache;
        DELETE FROM kvcache_key;
      `);
                    const dbContent = await _platform_server_sqlite__WEBPACK_IMPORTED_MODULE_4__.exportDatabase(memDb);
                    _platform_server_sqlite__WEBPACK_IMPORTED_MODULE_4__.closeDatabase(memDb);
                    // mark it as a file that needs a new clock so when a new client
                    // downloads it, it'll get set to a unique node
                    const meta = JSON.parse(await _platform_server_fs__WEBPACK_IMPORTED_MODULE_3__.readFile(_platform_server_fs__WEBPACK_IMPORTED_MODULE_3__.join(budgetDir, 'metadata.json')));
                    meta.resetClock = true;
                    const metaContent = Buffer.from(JSON.stringify(meta), 'utf8');
                    zipped.addFile('db.sqlite', Buffer.from(dbContent));
                    zipped.addFile('metadata.json', metaContent);
                });
                return Buffer.from(zipped.toBuffer());
            }
            async function importBuffer(fileData, buffer) {
                let zipped, entries;
                try {
                    zipped = new (adm_zip__WEBPACK_IMPORTED_MODULE_0___default())(buffer);
                    entries = zipped.getEntries();
                }
                catch (err) {
                    throw (0, _errors__WEBPACK_IMPORTED_MODULE_7__.FileDownloadError)('not-zip-file');
                }
                const dbEntry = entries.find((e) => e.entryName.includes('db.sqlite'));
                const metaEntry = entries.find((e) => e.entryName.includes('metadata.json'));
                if (!dbEntry || !metaEntry) {
                    throw (0, _errors__WEBPACK_IMPORTED_MODULE_7__.FileDownloadError)('invalid-zip-file');
                }
                const dbContent = zipped.readFile(dbEntry);
                const metaContent = zipped.readFile(metaEntry);
                let meta;
                try {
                    meta = JSON.parse(metaContent.toString('utf8'));
                }
                catch (err) {
                    throw (0, _errors__WEBPACK_IMPORTED_MODULE_7__.FileDownloadError)('invalid-meta-file');
                }
                // Update the metadata. The stored file on the server might be
                // out-of-date with a few keys
                meta = {
                    ...meta,
                    cloudFileId: fileData.fileId,
                    groupId: fileData.groupId,
                    lastUploaded: _shared_months__WEBPACK_IMPORTED_MODULE_5__.currentDay(),
                    encryptKeyId: fileData.encryptMeta ? fileData.encryptMeta.keyId : null
                };
                const budgetDir = _platform_server_fs__WEBPACK_IMPORTED_MODULE_3__.getBudgetDir(meta.id);
                if (await _platform_server_fs__WEBPACK_IMPORTED_MODULE_3__.exists(budgetDir)) {
                    // Don't remove the directory so that backups are retained
                    const dbFile = _platform_server_fs__WEBPACK_IMPORTED_MODULE_3__.join(budgetDir, 'db.sqlite');
                    const metaFile = _platform_server_fs__WEBPACK_IMPORTED_MODULE_3__.join(budgetDir, 'metadata.json');
                    if (await _platform_server_fs__WEBPACK_IMPORTED_MODULE_3__.exists(dbFile)) {
                        await _platform_server_fs__WEBPACK_IMPORTED_MODULE_3__.removeFile(dbFile);
                    }
                    if (await _platform_server_fs__WEBPACK_IMPORTED_MODULE_3__.exists(metaFile)) {
                        await _platform_server_fs__WEBPACK_IMPORTED_MODULE_3__.removeFile(metaFile);
                    }
                }
                else {
                    await _platform_server_fs__WEBPACK_IMPORTED_MODULE_3__.mkdir(budgetDir);
                }
                await _platform_server_fs__WEBPACK_IMPORTED_MODULE_3__.writeFile(_platform_server_fs__WEBPACK_IMPORTED_MODULE_3__.join(budgetDir, 'db.sqlite'), dbContent);
                await _platform_server_fs__WEBPACK_IMPORTED_MODULE_3__.writeFile(_platform_server_fs__WEBPACK_IMPORTED_MODULE_3__.join(budgetDir, 'metadata.json'), JSON.stringify(meta));
                return {
                    id: meta.id
                };
            }
            async function upload() {
                const userToken = await _platform_server_asyncStorage__WEBPACK_IMPORTED_MODULE_1__.getItem('user-token');
                if (!userToken) {
                    throw (0, _errors__WEBPACK_IMPORTED_MODULE_7__.FileUploadError)('unauthorized');
                }
                const zipContent = await exportBuffer();
                if (zipContent == null) {
                    return;
                }
                const { id, groupId, budgetName, cloudFileId: originalCloudFileId, encryptKeyId } = _prefs__WEBPACK_IMPORTED_MODULE_10__.getPrefs();
                let cloudFileId = originalCloudFileId;
                let uploadContent = zipContent;
                let uploadMeta = null;
                // The upload process encrypts with the key tagged in the prefs for
                // the file. It will upload the file and the server is responsible
                // for checking that the key is up-to-date and rejecting it if not
                if (encryptKeyId) {
                    let encrypted;
                    try {
                        encrypted = await _encryption__WEBPACK_IMPORTED_MODULE_6__.encrypt(zipContent, encryptKeyId);
                    }
                    catch (e) {
                        throw (0, _errors__WEBPACK_IMPORTED_MODULE_7__.FileUploadError)('encrypt-failure', {
                            isMissingKey: e.message === 'missing-key'
                        });
                    }
                    uploadContent = encrypted.value;
                    uploadMeta = encrypted.meta;
                }
                if (!cloudFileId) {
                    cloudFileId = (0, uuid__WEBPACK_IMPORTED_MODULE_12__["default"])();
                }
                let res;
                try {
                    res = await fetchJSON((0, _server_config__WEBPACK_IMPORTED_MODULE_11__.getServer)().SYNC_SERVER + '/upload-user-file', {
                        method: 'POST',
                        headers: {
                            'Content-Length': uploadContent.length,
                            'Content-Type': 'application/encrypted-file',
                            'X-ACTUAL-TOKEN': userToken,
                            'X-ACTUAL-FILE-ID': cloudFileId,
                            'X-ACTUAL-NAME': encodeURIComponent(budgetName),
                            'X-ACTUAL-FORMAT': 2,
                            ...uploadMeta ? {
                                'X-ACTUAL-ENCRYPT-META': JSON.stringify(uploadMeta)
                            } : null,
                            ...groupId ? {
                                'X-ACTUAL-GROUP-ID': groupId
                            } : null
                        },
                        body: uploadContent
                    });
                }
                catch (err) {
                    console.log('Upload failure', err);
                    if (err instanceof _errors__WEBPACK_IMPORTED_MODULE_7__.PostError) {
                        throw (0, _errors__WEBPACK_IMPORTED_MODULE_7__.FileUploadError)(err.reason === 'unauthorized' ? 'unauthorized' : err.reason || 'network');
                    }
                    throw (0, _errors__WEBPACK_IMPORTED_MODULE_7__.FileUploadError)('internal');
                }
                if (res.status === 'ok') {
                    // Only save it if we are still working on the same file
                    if (_prefs__WEBPACK_IMPORTED_MODULE_10__.getPrefs() && _prefs__WEBPACK_IMPORTED_MODULE_10__.getPrefs().id === id) {
                        await _prefs__WEBPACK_IMPORTED_MODULE_10__.savePrefs({
                            lastUploaded: _shared_months__WEBPACK_IMPORTED_MODULE_5__.currentDay(),
                            cloudFileId,
                            groupId: res.groupId
                        });
                    }
                }
                else {
                    throw (0, _errors__WEBPACK_IMPORTED_MODULE_7__.FileUploadError)('internal');
                }
            }
            async function possiblyUpload() {
                const { cloudFileId, groupId, lastUploaded } = _prefs__WEBPACK_IMPORTED_MODULE_10__.getPrefs();
                const threshold = lastUploaded && _shared_months__WEBPACK_IMPORTED_MODULE_5__.addDays(lastUploaded, UPLOAD_FREQUENCY_IN_DAYS);
                const currentDay = _shared_months__WEBPACK_IMPORTED_MODULE_5__.currentDay();
                // We only want to try to upload every UPLOAD_FREQUENCY_IN_DAYS days
                if (lastUploaded && currentDay < threshold) {
                    return;
                }
                // We only want to upload existing cloud files that are part of a
                // valid group
                if (!cloudFileId || !groupId) {
                    return;
                }
                // Don't block on uploading
                upload().catch(() => { });
            }
            async function removeFile(fileId) {
                const userToken = await _platform_server_asyncStorage__WEBPACK_IMPORTED_MODULE_1__.getItem('user-token');
                await (0, _post__WEBPACK_IMPORTED_MODULE_9__.post)((0, _server_config__WEBPACK_IMPORTED_MODULE_11__.getServer)().SYNC_SERVER + '/delete-user-file', {
                    token: userToken,
                    fileId
                });
            }
            async function listRemoteFiles() {
                const userToken = await _platform_server_asyncStorage__WEBPACK_IMPORTED_MODULE_1__.getItem('user-token');
                if (!userToken) {
                    return null;
                }
                let res;
                try {
                    res = await fetchJSON((0, _server_config__WEBPACK_IMPORTED_MODULE_11__.getServer)().SYNC_SERVER + '/list-user-files', {
                        headers: {
                            'X-ACTUAL-TOKEN': userToken
                        }
                    });
                }
                catch (e) {
                    console.log('Unexpected error fetching file list from server', e);
                    return null;
                }
                if (res.status === 'error') {
                    console.log('Error fetching file list from server', res);
                    return null;
                }
                return res.data.map((file) => ({
                    ...file,
                    hasKey: _encryption__WEBPACK_IMPORTED_MODULE_6__.hasKey(file.encryptKeyId)
                }));
            }
            async function download(fileId) {
                const userToken = await _platform_server_asyncStorage__WEBPACK_IMPORTED_MODULE_1__.getItem('user-token');
                const syncServer = (0, _server_config__WEBPACK_IMPORTED_MODULE_11__.getServer)().SYNC_SERVER;
                const userFileFetch = (0, _platform_server_fetch__WEBPACK_IMPORTED_MODULE_2__.fetch)(`${syncServer}/download-user-file`, {
                    headers: {
                        'X-ACTUAL-TOKEN': userToken,
                        'X-ACTUAL-FILE-ID': fileId
                    }
                }).then(checkHTTPStatus).then((res) => {
                    if (res.arrayBuffer) {
                        return res.arrayBuffer().then((ab) => Buffer.from(ab));
                    }
                    return res.buffer();
                }).catch((err) => {
                    console.log('Download failure', err);
                    throw (0, _errors__WEBPACK_IMPORTED_MODULE_7__.FileDownloadError)('download-failure');
                });
                const userFileInfoFetch = fetchJSON(`${syncServer}/get-user-file-info`, {
                    headers: {
                        'X-ACTUAL-TOKEN': userToken,
                        'X-ACTUAL-FILE-ID': fileId
                    }
                }).catch((err) => {
                    console.log('Error fetching file info', err);
                    throw (0, _errors__WEBPACK_IMPORTED_MODULE_7__.FileDownloadError)('internal', {
                        fileId
                    });
                });
                const [userFileInfoRes, userFileRes] = await Promise.all([
                    userFileInfoFetch,
                    userFileFetch
                ]);
                if (userFileInfoRes.status !== 'ok') {
                    console.log('Could not download file from the server. Are you sure you have the right file ID?', userFileInfoRes);
                    throw (0, _errors__WEBPACK_IMPORTED_MODULE_7__.FileDownloadError)('internal', {
                        fileId
                    });
                }
                const fileData = userFileInfoRes.data;
                let buffer = userFileRes;
                // The download process checks if the server gave us decrypt
                // information. It is assumed that this key has already been loaded
                // in, which is done in a previous step
                if (fileData.encryptMeta) {
                    try {
                        buffer = await _encryption__WEBPACK_IMPORTED_MODULE_6__.decrypt(buffer, fileData.encryptMeta);
                    }
                    catch (e) {
                        throw (0, _errors__WEBPACK_IMPORTED_MODULE_7__.FileDownloadError)('decrypt-failure', {
                            isMissingKey: e.message === 'missing-key'
                        });
                    }
                }
                return importBuffer(fileData, buffer);
            }
            /***/ 
        }),
        /***/ "./packages/loot-core/src/server/db/index.ts": 
        /*!***************************************************!*\
          !*** ./packages/loot-core/src/server/db/index.ts ***!
          \***************************************************/
        /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony export */ __webpack_require__.d(__webpack_exports__, {
                /* harmony export */ all: () => ( /* binding */all),
                /* harmony export */ asyncTransaction: () => ( /* binding */asyncTransaction),
                /* harmony export */ cache: () => ( /* binding */cache),
                /* harmony export */ closeDatabase: () => ( /* binding */closeDatabase),
                /* harmony export */ deleteAccount: () => ( /* binding */deleteAccount),
                /* harmony export */ deleteCategory: () => ( /* binding */deleteCategory),
                /* harmony export */ deleteCategoryGroup: () => ( /* binding */deleteCategoryGroup),
                /* harmony export */ deletePayee: () => ( /* binding */deletePayee),
                /* harmony export */ deleteTransaction: () => ( /* binding */deleteTransaction),
                /* harmony export */ deleteTransferPayee: () => ( /* binding */deleteTransferPayee),
                /* harmony export */ delete_: () => ( /* binding */delete_),
                /* harmony export */ execQuery: () => ( /* binding */execQuery),
                /* harmony export */ first: () => ( /* binding */first),
                /* harmony export */ firstSync: () => ( /* binding */firstSync),
                /* harmony export */ fromDateRepr: () => ( /* reexport safe */_models__WEBPACK_IMPORTED_MODULE_6__.fromDateRepr),
                /* harmony export */ getAccounts: () => ( /* binding */getAccounts),
                /* harmony export */ getCategories: () => ( /* binding */getCategories),
                /* harmony export */ getCategoriesGrouped: () => ( /* binding */getCategoriesGrouped),
                /* harmony export */ getCommonPayees: () => ( /* binding */getCommonPayees),
                /* harmony export */ getDatabase: () => ( /* binding */getDatabase),
                /* harmony export */ getDatabasePath: () => ( /* binding */getDatabasePath),
                /* harmony export */ getOrphanedPayees: () => ( /* binding */getOrphanedPayees),
                /* harmony export */ getPayee: () => ( /* binding */getPayee),
                /* harmony export */ getPayeeByName: () => ( /* binding */getPayeeByName),
                /* harmony export */ getPayees: () => ( /* binding */getPayees),
                /* harmony export */ getTransaction: () => ( /* binding */getTransaction),
                /* harmony export */ getTransactions: () => ( /* binding */getTransactions),
                /* harmony export */ insert: () => ( /* binding */insert),
                /* harmony export */ insertAccount: () => ( /* binding */insertAccount),
                /* harmony export */ insertCategory: () => ( /* binding */insertCategory),
                /* harmony export */ insertCategoryGroup: () => ( /* binding */insertCategoryGroup),
                /* harmony export */ insertPayee: () => ( /* binding */insertPayee),
                /* harmony export */ insertTransaction: () => ( /* binding */insertTransaction),
                /* harmony export */ insertWithSchema: () => ( /* binding */insertWithSchema),
                /* harmony export */ insertWithUUID: () => ( /* binding */insertWithUUID),
                /* harmony export */ loadClock: () => ( /* binding */loadClock),
                /* harmony export */ mergePayees: () => ( /* binding */mergePayees),
                /* harmony export */ moveAccount: () => ( /* binding */moveAccount),
                /* harmony export */ moveCategory: () => ( /* binding */moveCategory),
                /* harmony export */ moveCategoryGroup: () => ( /* binding */moveCategoryGroup),
                /* harmony export */ openDatabase: () => ( /* binding */openDatabase),
                /* harmony export */ run: () => ( /* binding */run),
                /* harmony export */ runQuery: () => ( /* binding */runQuery),
                /* harmony export */ select: () => ( /* binding */select),
                /* harmony export */ selectFirstWithSchema: () => ( /* binding */selectFirstWithSchema),
                /* harmony export */ selectWithSchema: () => ( /* binding */selectWithSchema),
                /* harmony export */ setDatabase: () => ( /* binding */setDatabase),
                /* harmony export */ syncGetOrphanedPayees: () => ( /* binding */syncGetOrphanedPayees),
                /* harmony export */ toDateRepr: () => ( /* reexport safe */_models__WEBPACK_IMPORTED_MODULE_6__.toDateRepr),
                /* harmony export */ transaction: () => ( /* binding */transaction),
                /* harmony export */ update: () => ( /* binding */update),
                /* harmony export */ updateAccount: () => ( /* binding */updateAccount),
                /* harmony export */ updateCategory: () => ( /* binding */updateCategory),
                /* harmony export */ updateCategoryGroup: () => ( /* binding */updateCategoryGroup),
                /* harmony export */ updatePayee: () => ( /* binding */updatePayee),
                /* harmony export */ updateTransaction: () => ( /* binding */updateTransaction),
                /* harmony export */ updateWithSchema: () => ( /* binding */updateWithSchema)
                /* harmony export */ 
            });
            /* harmony import */ var _actual_app_crdt__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @actual-app/crdt */ "@actual-app/crdt");
            /* harmony import */ var _actual_app_crdt__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/ __webpack_require__.n(_actual_app_crdt__WEBPACK_IMPORTED_MODULE_0__);
            /* harmony import */ var lru_cache__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! lru-cache */ "./node_modules/lru-cache/index.js");
            /* harmony import */ var lru_cache__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/ __webpack_require__.n(lru_cache__WEBPACK_IMPORTED_MODULE_1__);
            /* harmony import */ var uuid__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! uuid */ "./node_modules/uuid/dist/esm-node/v4.js");
            /* harmony import */ var _platform_server_fs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../platform/server/fs */ "./packages/loot-core/src/platform/server/fs/index.electron.ts");
            /* harmony import */ var _platform_server_sqlite__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../platform/server/sqlite */ "./packages/loot-core/src/platform/server/sqlite/index.electron.ts");
            /* harmony import */ var _shared_util__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../shared/util */ "./packages/loot-core/src/shared/util.ts");
            /* harmony import */ var _aql__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../aql */ "./packages/loot-core/src/server/aql/index.ts");
            /* harmony import */ var _models__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../models */ "./packages/loot-core/src/server/models.ts");
            /* harmony import */ var _sync__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../sync */ "./packages/loot-core/src/server/sync/index.ts");
            /* harmony import */ var _sort__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./sort */ "./packages/loot-core/src/server/db/sort.ts");
            // @ts-strict-ignore
            let dbPath = null;
            let db = null;
            // Util
            function getDatabasePath() {
                return dbPath;
            }
            async function openDatabase(id) {
                if (db) {
                    await _platform_server_sqlite__WEBPACK_IMPORTED_MODULE_3__.closeDatabase(db);
                }
                dbPath = _platform_server_fs__WEBPACK_IMPORTED_MODULE_2__.join(_platform_server_fs__WEBPACK_IMPORTED_MODULE_2__.getBudgetDir(id), 'db.sqlite');
                setDatabase(await _platform_server_sqlite__WEBPACK_IMPORTED_MODULE_3__.openDatabase(dbPath));
                // await execQuery('PRAGMA journal_mode = WAL');
            }
            async function closeDatabase() {
                if (db) {
                    await _platform_server_sqlite__WEBPACK_IMPORTED_MODULE_3__.closeDatabase(db);
                    setDatabase(null);
                }
            }
            function setDatabase(db_) {
                db = db_;
                resetQueryCache();
            }
            function getDatabase() {
                return db;
            }
            async function loadClock() {
                const row = await first('SELECT * FROM messages_clock');
                if (row) {
                    const clock = (0, _actual_app_crdt__WEBPACK_IMPORTED_MODULE_0__.deserializeClock)(row.clock);
                    (0, _actual_app_crdt__WEBPACK_IMPORTED_MODULE_0__.setClock)(clock);
                }
                else {
                    // No clock exists yet (first run of the app), so create a default
                    // one.
                    const timestamp = new _actual_app_crdt__WEBPACK_IMPORTED_MODULE_0__.Timestamp(0, 0, (0, _actual_app_crdt__WEBPACK_IMPORTED_MODULE_0__.makeClientId)());
                    const clock = (0, _actual_app_crdt__WEBPACK_IMPORTED_MODULE_0__.makeClock)(timestamp);
                    (0, _actual_app_crdt__WEBPACK_IMPORTED_MODULE_0__.setClock)(clock);
                    await runQuery('INSERT INTO messages_clock (id, clock) VALUES (?, ?)', [
                        1,
                        (0, _actual_app_crdt__WEBPACK_IMPORTED_MODULE_0__.serializeClock)(clock)
                    ]);
                }
            }
            function runQuery(sql, params, fetchAll) {
                // const unrecord = perf.record('sqlite');
                const result = _platform_server_sqlite__WEBPACK_IMPORTED_MODULE_3__.runQuery(db, sql, params, fetchAll);
                // unrecord();
                return result;
            }
            function execQuery(sql) {
                _platform_server_sqlite__WEBPACK_IMPORTED_MODULE_3__.execQuery(db, sql);
            }
            // This manages an LRU cache of prepared query statements. This is
            // only needed in hot spots when you are running lots of queries.
            let _queryCache = new (lru_cache__WEBPACK_IMPORTED_MODULE_1___default())({
                max: 100
            });
            function cache(sql) {
                const cached = _queryCache.get(sql);
                if (cached) {
                    return cached;
                }
                const prepared = _platform_server_sqlite__WEBPACK_IMPORTED_MODULE_3__.prepare(db, sql);
                _queryCache.set(sql, prepared);
                return prepared;
            }
            function resetQueryCache() {
                _queryCache = new (lru_cache__WEBPACK_IMPORTED_MODULE_1___default())({
                    max: 100
                });
            }
            function transaction(fn) {
                return _platform_server_sqlite__WEBPACK_IMPORTED_MODULE_3__.transaction(db, fn);
            }
            function asyncTransaction(fn) {
                return _platform_server_sqlite__WEBPACK_IMPORTED_MODULE_3__.asyncTransaction(db, fn);
            }
            // This function is marked as async because `runQuery` is no longer
            // async. We return a promise here until we've audited all the code to
            // make sure nothing calls `.then` on this.
            async function all(sql, params) {
                return runQuery(sql, params, true);
            }
            async function first(sql, params) {
                const arr = await runQuery(sql, params, true);
                return arr.length === 0 ? null : arr[0];
            }
            // The underlying sql system is now sync, but we can't update `first` yet
            // without auditing all uses of it
            function firstSync(sql, params) {
                const arr = runQuery(sql, params, true);
                return arr.length === 0 ? null : arr[0];
            }
            // This function is marked as async because `runQuery` is no longer
            // async. We return a promise here until we've audited all the code to
            // make sure nothing calls `.then` on this.
            async function run(sql, params) {
                return runQuery(sql, params);
            }
            async function select(table, id) {
                const rows = await runQuery('SELECT * FROM ' + table + ' WHERE id = ?', [
                    id
                ], true);
                return rows[0];
            }
            async function update(table, params) {
                const fields = Object.keys(params).filter((k) => k !== 'id');
                if (params.id == null) {
                    throw new Error('update: id is required');
                }
                await (0, _sync__WEBPACK_IMPORTED_MODULE_7__.sendMessages)(fields.map((k) => {
                    return {
                        dataset: table,
                        row: params.id,
                        column: k,
                        value: params[k],
                        timestamp: _actual_app_crdt__WEBPACK_IMPORTED_MODULE_0__.Timestamp.send()
                    };
                }));
            }
            async function insertWithUUID(table, row) {
                if (!row.id) {
                    row = {
                        ...row,
                        id: (0, uuid__WEBPACK_IMPORTED_MODULE_9__["default"])()
                    };
                }
                await insert(table, row);
                // We can't rely on the return value of insert because if the
                // primary key is text, sqlite returns the internal row id which we
                // don't care about. We want to return the generated UUID.
                return row.id;
            }
            async function insert(table, row) {
                const fields = Object.keys(row).filter((k) => k !== 'id');
                if (row.id == null) {
                    throw new Error('insert: id is required');
                }
                await (0, _sync__WEBPACK_IMPORTED_MODULE_7__.sendMessages)(fields.map((k) => {
                    return {
                        dataset: table,
                        row: row.id,
                        column: k,
                        value: row[k],
                        timestamp: _actual_app_crdt__WEBPACK_IMPORTED_MODULE_0__.Timestamp.send()
                    };
                }));
            }
            async function delete_(table, id) {
                await (0, _sync__WEBPACK_IMPORTED_MODULE_7__.sendMessages)([
                    {
                        dataset: table,
                        row: id,
                        column: 'tombstone',
                        value: 1,
                        timestamp: _actual_app_crdt__WEBPACK_IMPORTED_MODULE_0__.Timestamp.send()
                    }
                ]);
            }
            async function selectWithSchema(table, sql, params) {
                const rows = await runQuery(sql, params, true);
                return rows.map((row) => (0, _aql__WEBPACK_IMPORTED_MODULE_5__.convertFromSelect)(_aql__WEBPACK_IMPORTED_MODULE_5__.schema, _aql__WEBPACK_IMPORTED_MODULE_5__.schemaConfig, table, row)).filter(Boolean);
            }
            async function selectFirstWithSchema(table, sql, params) {
                const rows = await selectWithSchema(table, sql, params);
                return rows.length > 0 ? rows[0] : null;
            }
            function insertWithSchema(table, row) {
                // Even though `insertWithUUID` does this, we need to do it here so
                // the schema validation passes
                if (!row.id) {
                    row = {
                        ...row,
                        id: (0, uuid__WEBPACK_IMPORTED_MODULE_9__["default"])()
                    };
                }
                return insertWithUUID(table, (0, _aql__WEBPACK_IMPORTED_MODULE_5__.convertForInsert)(_aql__WEBPACK_IMPORTED_MODULE_5__.schema, _aql__WEBPACK_IMPORTED_MODULE_5__.schemaConfig, table, row));
            }
            function updateWithSchema(table, fields) {
                return update(table, (0, _aql__WEBPACK_IMPORTED_MODULE_5__.convertForUpdate)(_aql__WEBPACK_IMPORTED_MODULE_5__.schema, _aql__WEBPACK_IMPORTED_MODULE_5__.schemaConfig, table, fields));
            }
            // Data-specific functions. Ideally this would be split up into
            // different files
            async function getCategories() {
                return await all(`
    SELECT c.* FROM categories c WHERE c.tombstone = 0
      ORDER BY c.sort_order, c.id
  `);
            }
            async function getCategoriesGrouped() {
                const groups = await all(`
    SELECT cg.* FROM category_groups cg WHERE cg.tombstone = 0 ORDER BY cg.is_income, cg.sort_order, cg.id
  `);
                const categories = await all(`
    SELECT c.* FROM categories c WHERE c.tombstone = 0
      ORDER BY c.sort_order, c.id
  `);
                return groups.map((group) => {
                    return {
                        ...group,
                        categories: categories.filter((c) => c.cat_group === group.id)
                    };
                });
            }
            async function insertCategoryGroup(group) {
                // Don't allow duplicate group
                const existingGroup = await first(`SELECT id, name, hidden FROM category_groups WHERE UPPER(name) = ? and tombstone = 0 LIMIT 1`, [
                    group.name.toUpperCase()
                ]);
                if (existingGroup) {
                    throw new Error(`A ${existingGroup.hidden ? 'hidden ' : ''}${existingGroup.name} category group already exists.`);
                }
                const lastGroup = await first(`
    SELECT sort_order FROM category_groups WHERE tombstone = 0 ORDER BY sort_order DESC, id DESC LIMIT 1
  `);
                const sort_order = (lastGroup ? lastGroup.sort_order : 0) + _sort__WEBPACK_IMPORTED_MODULE_8__.SORT_INCREMENT;
                group = {
                    ..._models__WEBPACK_IMPORTED_MODULE_6__.categoryGroupModel.validate(group),
                    sort_order
                };
                return insertWithUUID('category_groups', group);
            }
            function updateCategoryGroup(group) {
                group = _models__WEBPACK_IMPORTED_MODULE_6__.categoryGroupModel.validate(group, {
                    update: true
                });
                return update('category_groups', group);
            }
            async function moveCategoryGroup(id, targetId) {
                const groups = await all(`SELECT id, sort_order FROM category_groups WHERE tombstone = 0 ORDER BY sort_order, id`);
                const { updates, sort_order } = (0, _sort__WEBPACK_IMPORTED_MODULE_8__.shoveSortOrders)(groups, targetId);
                for (const info of updates) {
                    await update('category_groups', info);
                }
                await update('category_groups', {
                    id,
                    sort_order
                });
            }
            async function deleteCategoryGroup(group, transferId) {
                const categories = await all('SELECT * FROM categories WHERE cat_group = ?', [
                    group.id
                ]);
                // Delete all the categories within a group
                await Promise.all(categories.map((cat) => deleteCategory(cat, transferId)));
                await delete_('category_groups', group.id);
            }
            async function insertCategory(category, { atEnd } = {
                atEnd: undefined
            }) {
                let sort_order;
                let id_;
                await (0, _sync__WEBPACK_IMPORTED_MODULE_7__.batchMessages)(async () => {
                    // Dont allow duplicated names in groups
                    const existingCatInGroup = await first(`SELECT id FROM categories WHERE cat_group = ? and UPPER(name) = ? and tombstone = 0 LIMIT 1`, [
                        category.cat_group,
                        category.name.toUpperCase()
                    ]);
                    if (existingCatInGroup) {
                        throw new Error(`Category ${category.name} already exists in group ${category.cat_group}`);
                    }
                    if (atEnd) {
                        const lastCat = await first(`
        SELECT sort_order FROM categories WHERE tombstone = 0 ORDER BY sort_order DESC, id DESC LIMIT 1
      `);
                        sort_order = (lastCat ? lastCat.sort_order : 0) + _sort__WEBPACK_IMPORTED_MODULE_8__.SORT_INCREMENT;
                    }
                    else {
                        // Unfortunately since we insert at the beginning, we need to shove
                        // the sort orders to make sure there's room for it
                        const categories = await all(`SELECT id, sort_order FROM categories WHERE cat_group = ? AND tombstone = 0 ORDER BY sort_order, id`, [
                            category.cat_group
                        ]);
                        const { updates, sort_order: order } = (0, _sort__WEBPACK_IMPORTED_MODULE_8__.shoveSortOrders)(categories, categories.length > 0 ? categories[0].id : null);
                        for (const info of updates) {
                            await update('categories', info);
                        }
                        sort_order = order;
                    }
                    category = {
                        ..._models__WEBPACK_IMPORTED_MODULE_6__.categoryModel.validate(category),
                        sort_order
                    };
                    const id = await insertWithUUID('categories', category);
                    // Create an entry in the mapping table that points it to itself
                    await insert('category_mapping', {
                        id,
                        transferId: id
                    });
                    id_ = id;
                });
                return id_;
            }
            function updateCategory(category) {
                category = _models__WEBPACK_IMPORTED_MODULE_6__.categoryModel.validate(category, {
                    update: true
                });
                return update('categories', category);
            }
            async function moveCategory(id, groupId, targetId) {
                if (!groupId) {
                    throw new Error('moveCategory: groupId is required');
                }
                const categories = await all(`SELECT id, sort_order FROM categories WHERE cat_group = ? AND tombstone = 0 ORDER BY sort_order, id`, [
                    groupId
                ]);
                const { updates, sort_order } = (0, _sort__WEBPACK_IMPORTED_MODULE_8__.shoveSortOrders)(categories, targetId);
                for (const info of updates) {
                    await update('categories', info);
                }
                await update('categories', {
                    id,
                    sort_order,
                    cat_group: groupId
                });
            }
            async function deleteCategory(category, transferId) {
                if (transferId) {
                    // We need to update all the deleted categories that currently
                    // point to the one we're about to delete so they all are
                    // "forwarded" to the new transferred category.
                    const existingTransfers = await all('SELECT * FROM category_mapping WHERE transferId = ?', [
                        category.id
                    ]);
                    for (const mapping of existingTransfers) {
                        await update('category_mapping', {
                            id: mapping.id,
                            transferId
                        });
                    }
                    // Finally, map the category we're about to delete to the new one
                    await update('category_mapping', {
                        id: category.id,
                        transferId
                    });
                }
                return delete_('categories', category.id);
            }
            async function getPayee(id) {
                return first(`SELECT * FROM payees WHERE id = ?`, [
                    id
                ]);
            }
            async function insertPayee(payee) {
                payee = _models__WEBPACK_IMPORTED_MODULE_6__.payeeModel.validate(payee);
                let id;
                await (0, _sync__WEBPACK_IMPORTED_MODULE_7__.batchMessages)(async () => {
                    id = await insertWithUUID('payees', payee);
                    await insert('payee_mapping', {
                        id,
                        targetId: id
                    });
                });
                return id;
            }
            async function deletePayee(payee) {
                const { transfer_acct } = await first('SELECT * FROM payees WHERE id = ?', [
                    payee.id
                ]);
                if (transfer_acct) {
                    // You should never be able to delete transfer payees
                    return;
                }
                // let mappings = await all('SELECT id FROM payee_mapping WHERE targetId = ?', [
                //   payee.id
                // ]);
                // await Promise.all(
                //   mappings.map(m => update('payee_mapping', { id: m.id, targetId: null }))
                // );
                return delete_('payees', payee.id);
            }
            async function deleteTransferPayee(payee) {
                // This allows deleting transfer payees
                return delete_('payees', payee.id);
            }
            function updatePayee(payee) {
                payee = _models__WEBPACK_IMPORTED_MODULE_6__.payeeModel.validate(payee, {
                    update: true
                });
                return update('payees', payee);
            }
            async function mergePayees(target, ids) {
                // Load in payees so we can check some stuff
                const dbPayees = await all('SELECT * FROM payees');
                const payees = (0, _shared_util__WEBPACK_IMPORTED_MODULE_4__.groupById)(dbPayees);
                // Filter out any transfer payees
                if (payees[target].transfer_acct != null) {
                    return;
                }
                ids = ids.filter((id) => payees[id].transfer_acct == null);
                await (0, _sync__WEBPACK_IMPORTED_MODULE_7__.batchMessages)(async () => {
                    await Promise.all(ids.map(async (id) => {
                        const mappings = await all('SELECT id FROM payee_mapping WHERE targetId = ?', [
                            id
                        ]);
                        await Promise.all(mappings.map((m) => update('payee_mapping', {
                            id: m.id,
                            targetId: target
                        })));
                    }));
                    await Promise.all(ids.map((id) => Promise.all([
                        update('payee_mapping', {
                            id,
                            targetId: target
                        }),
                        delete_('payees', id)
                    ])));
                });
            }
            function getPayees() {
                return all(`
    SELECT p.*, COALESCE(a.name, p.name) AS name FROM payees p
    LEFT JOIN accounts a ON (p.transfer_acct = a.id AND a.tombstone = 0)
    WHERE p.tombstone = 0 AND (p.transfer_acct IS NULL OR a.id IS NOT NULL)
    ORDER BY p.transfer_acct IS NULL DESC, p.name COLLATE NOCASE, a.offbudget, a.sort_order
  `);
            }
            function getCommonPayees() {
                const threeMonthsAgo = '20240201';
                const limit = 10;
                return all(`
    SELECT 	p.id as id, p.name as name, p.favorite as favorite, 
      p.category as category, TRUE as common, NULL as transfer_acct,
    count(*) as c, 
    max(t.date) as latest
    FROM payees p
    LEFT JOIN v_transactions t on t.payee == p.id
    WHERE LENGTH(p.name) > 0
    GROUP BY p.id
    HAVING latest > ${threeMonthsAgo}
    ORDER BY c DESC ,p.transfer_acct IS NULL DESC, p.name 
    COLLATE NOCASE
    LIMIT ${limit}
  `);
            }
            function syncGetOrphanedPayees() {
                return all(`
  SELECT p.id FROM payees p
  LEFT JOIN payee_mapping pm ON pm.id = p.id
  LEFT JOIN v_transactions_internal_alive t ON t.payee = pm.targetId
  WHERE p.tombstone = 0 AND p.transfer_acct IS NULL AND t.id IS NULL
`);
            }
            async function getOrphanedPayees() {
                const rows = await all(`
    SELECT p.id FROM payees p
    LEFT JOIN payee_mapping pm ON pm.id = p.id
    LEFT JOIN v_transactions_internal_alive t ON t.payee = pm.targetId
    WHERE p.tombstone = 0 AND p.transfer_acct IS NULL AND t.id IS NULL
  `);
                return rows.map((row) => row.id);
            }
            async function getPayeeByName(name) {
                return first(`SELECT * FROM payees WHERE UNICODE_LOWER(name) = ? AND tombstone = 0`, [
                    name.toLowerCase()
                ]);
            }
            function getAccounts() {
                return all(`SELECT a.*, b.name as bankName, b.id as bankId FROM accounts a
       LEFT JOIN banks b ON a.bank = b.id
       WHERE a.tombstone = 0
       ORDER BY sort_order, name`);
            }
            async function insertAccount(account) {
                const accounts = await all('SELECT * FROM accounts WHERE offbudget = ? ORDER BY sort_order, name', [
                    account.offbudget != null ? account.offbudget : 0
                ]);
                // Don't pass a target in, it will default to appending at the end
                const { sort_order } = (0, _sort__WEBPACK_IMPORTED_MODULE_8__.shoveSortOrders)(accounts);
                account = _models__WEBPACK_IMPORTED_MODULE_6__.accountModel.validate({
                    ...account,
                    sort_order
                });
                return insertWithUUID('accounts', account);
            }
            function updateAccount(account) {
                account = _models__WEBPACK_IMPORTED_MODULE_6__.accountModel.validate(account, {
                    update: true
                });
                return update('accounts', account);
            }
            function deleteAccount(account) {
                return delete_('accounts', account.id);
            }
            async function moveAccount(id, targetId) {
                const account = await first('SELECT * FROM accounts WHERE id = ?', [
                    id
                ]);
                let accounts;
                if (account.closed) {
                    accounts = await all(`SELECT id, sort_order FROM accounts WHERE closed = 1 ORDER BY sort_order, name`);
                }
                else {
                    accounts = await all(`SELECT id, sort_order FROM accounts WHERE tombstone = 0 AND offbudget = ? ORDER BY sort_order, name`, [
                        account.offbudget
                    ]);
                }
                const { updates, sort_order } = (0, _sort__WEBPACK_IMPORTED_MODULE_8__.shoveSortOrders)(accounts, targetId);
                await (0, _sync__WEBPACK_IMPORTED_MODULE_7__.batchMessages)(async () => {
                    for (const info of updates) {
                        update('accounts', info);
                    }
                    update('accounts', {
                        id,
                        sort_order
                    });
                });
            }
            async function getTransaction(id) {
                const rows = await selectWithSchema('transactions', 'SELECT * FROM v_transactions WHERE id = ?', [
                    id
                ]);
                return rows[0];
            }
            async function getTransactions(accountId) {
                if (arguments.length > 1) {
                    throw new Error('`getTransactions` was given a second argument, it now only takes a single argument `accountId`');
                }
                return selectWithSchema('transactions', 'SELECT * FROM v_transactions WHERE account = ?', [
                    accountId
                ]);
            }
            function insertTransaction(transaction) {
                return insertWithSchema('transactions', transaction);
            }
            function updateTransaction(transaction) {
                return updateWithSchema('transactions', transaction);
            }
            async function deleteTransaction(transaction) {
                return delete_('transactions', transaction.id);
            }
            /***/ 
        }),
        /***/ "./packages/loot-core/src/server/db/mappings.ts": 
        /*!******************************************************!*\
          !*** ./packages/loot-core/src/server/db/mappings.ts ***!
          \******************************************************/
        /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony export */ __webpack_require__.d(__webpack_exports__, {
                /* harmony export */ getMapping: () => ( /* binding */getMapping),
                /* harmony export */ getMappings: () => ( /* binding */getMappings),
                /* harmony export */ loadMappings: () => ( /* binding */loadMappings)
                /* harmony export */ 
            });
            /* harmony import */ var _sync_index__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../sync/index */ "./packages/loot-core/src/server/sync/index.ts");
            /* harmony import */ var _index__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./index */ "./packages/loot-core/src/server/db/index.ts");
            // @ts-strict-ignore
            // This file keeps all the mappings in memory so we can access it
            // synchronously. This is primarily used in the rules system, but
            // there may be other uses in the future. You don't need to worry
            // about this generally; if you are querying transactions, ids are
            // transparently mapped for you. But if you are building something
            // that stores ids and later uses them, you need to remember to map
            // the ids.
            //
            // IMPORTANT: `loadMappings` must be called first before other modules
            // that listen for sync changes. This must be the first sync listener
            // to run in case other listeners use this mapping table; otherwise
            // they might see stale mappings.
            let allMappings;
            let unlistenSync;
            async function loadMappings() {
                // The mappings are separated into tables specific to the type of
                // data. But you know, we really could keep a global mapping table.
                const categories = (await _index__WEBPACK_IMPORTED_MODULE_1__.all('SELECT * FROM category_mapping')).map((r) => [
                    r.id,
                    r.transferId
                ]);
                const payees = (await _index__WEBPACK_IMPORTED_MODULE_1__.all('SELECT * FROM payee_mapping')).map((r) => [
                    r.id,
                    r.targetId
                ]);
                // All ids are unique, so we can just keep a global table of mappings
                allMappings = new Map(categories.concat(payees));
                if (unlistenSync) {
                    unlistenSync();
                }
                unlistenSync = (0, _sync_index__WEBPACK_IMPORTED_MODULE_0__.addSyncListener)(onApplySync);
            }
            function onApplySync(oldValues, newValues) {
                newValues.forEach((items, table) => {
                    if (table.indexOf('mapping') !== -1) {
                        const field = table === 'category_mapping' ? 'transferId' : 'targetId';
                        items.forEach((newValue) => {
                            allMappings.set(newValue.id, newValue[field]);
                        });
                    }
                });
            }
            function getMappings() {
                return allMappings;
            }
            function getMapping(id) {
                return allMappings.get(id) || null;
            }
            /***/ 
        }),
        /***/ "./packages/loot-core/src/server/db/sort.ts": 
        /*!**************************************************!*\
          !*** ./packages/loot-core/src/server/db/sort.ts ***!
          \**************************************************/
        /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony export */ __webpack_require__.d(__webpack_exports__, {
                /* harmony export */ SORT_INCREMENT: () => ( /* binding */SORT_INCREMENT),
                /* harmony export */ shoveSortOrders: () => ( /* binding */shoveSortOrders)
                /* harmony export */ 
            });
            const SORT_INCREMENT = 16384;
            function midpoint(items, to) {
                const below = items[to - 1];
                const above = items[to];
                if (!below) {
                    return above.sort_order / 2;
                }
                else if (!above) {
                    return below.sort_order + SORT_INCREMENT;
                }
                else {
                    return (below.sort_order + above.sort_order) / 2;
                }
            }
            function shoveSortOrders(items, targetId) {
                const to = items.findIndex((item) => item.id === targetId);
                const target = items[to];
                const before = items[to - 1];
                const updates = [];
                // If no target is specified, append at the end
                if (!targetId || to === -1) {
                    let order;
                    if (items.length > 0) {
                        // Add a new increment to whatever is the latest sort order
                        order = items[items.length - 1].sort_order + SORT_INCREMENT;
                    }
                    else {
                        // If no items exist, the default is to use the first increment
                        order = SORT_INCREMENT;
                    }
                    return {
                        updates,
                        sort_order: order
                    };
                }
                else {
                    if (target.sort_order - (before ? before.sort_order : 0) <= 2) {
                        let next = to;
                        let order = Math.floor(items[next].sort_order) + SORT_INCREMENT;
                        while (next < items.length) {
                            // No need to update it if it's already greater than the current
                            // order. This can happen because there may already be large
                            // gaps
                            if (order <= items[next].sort_order) {
                                break;
                            }
                            updates.push({
                                id: items[next].id,
                                sort_order: order
                            });
                            next++;
                            order += SORT_INCREMENT;
                        }
                    }
                    return {
                        updates,
                        sort_order: midpoint(items, to)
                    };
                }
            }
            /***/ 
        }),
        /***/ "./packages/loot-core/src/server/db/util.ts": 
        /*!**************************************************!*\
          !*** ./packages/loot-core/src/server/db/util.ts ***!
          \**************************************************/
        /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony export */ __webpack_require__.d(__webpack_exports__, {
                /* harmony export */ incrFetch: () => ( /* binding */incrFetch),
                /* harmony export */ whereIn: () => ( /* binding */whereIn)
                /* harmony export */ 
            });
            // @ts-strict-ignore
            async function incrFetch(runQuery, terms, compare, makeQuery, params = []) {
                const pageCount = 500;
                let results = [];
                let fetchedIds = new Set();
                for (let i = 0; i < terms.length; i += pageCount) {
                    const slice = terms.slice(i, i + pageCount).filter((id) => !fetchedIds.has(id));
                    if (slice.length > 0) {
                        const filter = slice.map((id) => compare(id)).join(' OR ');
                        const query = makeQuery('(' + filter + ')');
                        const rows = await runQuery(query, params, true);
                        fetchedIds = new Set([
                            ...fetchedIds,
                            ...slice
                        ]);
                        results = results.concat(rows);
                    }
                }
                return results;
            }
            function whereIn(ids, field) {
                const ids2 = [
                    ...new Set(ids)
                ];
                // eslint-disable-next-line rulesdir/typography
                const filter = `${field} IN (` + ids2.map((id) => `'${id}'`).join(',') + ')';
                return filter;
            }
            /***/ 
        }),
        /***/ "./packages/loot-core/src/server/encryption-internals.ts": 
        /*!***************************************************************!*\
          !*** ./packages/loot-core/src/server/encryption-internals.ts ***!
          \***************************************************************/
        /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony export */ __webpack_require__.d(__webpack_exports__, {
                /* harmony export */ createKey: () => ( /* binding */createKey),
                /* harmony export */ decrypt: () => ( /* binding */decrypt),
                /* harmony export */ encrypt: () => ( /* binding */encrypt),
                /* harmony export */ importKey: () => ( /* binding */importKey),
                /* harmony export */ randomBytes: () => ( /* binding */randomBytes),
                /* harmony export */ sha256String: () => ( /* binding */sha256String)
                /* harmony export */ 
            });
            /* harmony import */ var crypto__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! crypto */ "crypto");
            /* harmony import */ var crypto__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/ __webpack_require__.n(crypto__WEBPACK_IMPORTED_MODULE_0__);
            // @ts-strict-ignore
            const ENCRYPTION_ALGORITHM = 'aes-256-gcm';
            async function sha256String(str) {
                return crypto__WEBPACK_IMPORTED_MODULE_0___default().createHash('sha256').update(str).digest('base64');
            }
            function randomBytes(n) {
                return crypto__WEBPACK_IMPORTED_MODULE_0___default().randomBytes(n);
            }
            function encrypt(masterKey, value) {
                const masterKeyBuffer = masterKey.getValue().raw;
                // let iv = createKeyBuffer({ numBytes: 12, secret: masterKeyBuffer });
                const iv = crypto__WEBPACK_IMPORTED_MODULE_0___default().randomBytes(12);
                const cipher = crypto__WEBPACK_IMPORTED_MODULE_0___default().createCipheriv(ENCRYPTION_ALGORITHM, masterKeyBuffer, iv);
                let encrypted = cipher.update(value);
                encrypted = Buffer.concat([
                    encrypted,
                    cipher.final()
                ]);
                const authTag = cipher.getAuthTag();
                return {
                    value: encrypted,
                    meta: {
                        keyId: masterKey.getId(),
                        algorithm: ENCRYPTION_ALGORITHM,
                        iv: iv.toString('base64'),
                        authTag: authTag.toString('base64')
                    }
                };
            }
            function decrypt(masterKey, encrypted, meta) {
                const masterKeyBuffer = masterKey.getValue().raw;
                const { algorithm, iv: originalIv, authTag: originalAuthTag } = meta;
                const iv = Buffer.from(originalIv, 'base64');
                const authTag = Buffer.from(originalAuthTag, 'base64');
                const decipher = crypto__WEBPACK_IMPORTED_MODULE_0___default().createDecipheriv(algorithm, masterKeyBuffer, iv);
                decipher.setAuthTag(authTag);
                let decrypted = decipher.update(encrypted);
                decrypted = Buffer.concat([
                    decrypted,
                    decipher.final()
                ]);
                return decrypted;
            }
            function createKey({ secret, salt }) {
                const buffer = createKeyBuffer({
                    secret,
                    salt
                });
                return {
                    raw: buffer,
                    base64: buffer.toString('base64')
                };
            }
            function importKey(str) {
                return {
                    raw: Buffer.from(str, 'base64'),
                    base64: str
                };
            }
            /**
             * Generates a Buffer of a desired byte length to be used as either an encryption key or an initialization vector.
             *
             * @private
             */ function createKeyBuffer({ numBytes, secret, salt }) {
                return crypto__WEBPACK_IMPORTED_MODULE_0___default().pbkdf2Sync(secret || crypto__WEBPACK_IMPORTED_MODULE_0___default().randomBytes(128).toString('base64'), salt || crypto__WEBPACK_IMPORTED_MODULE_0___default().randomBytes(32).toString('base64'), 10000, numBytes || 32, 'sha512');
            }
            /***/ 
        }),
        /***/ "./packages/loot-core/src/server/encryption.ts": 
        /*!*****************************************************!*\
          !*** ./packages/loot-core/src/server/encryption.ts ***!
          \*****************************************************/
        /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony export */ __webpack_require__.d(__webpack_exports__, {
                /* harmony export */ createKey: () => ( /* binding */createKey),
                /* harmony export */ decrypt: () => ( /* binding */decrypt),
                /* harmony export */ encrypt: () => ( /* binding */encrypt),
                /* harmony export */ getKey: () => ( /* binding */getKey),
                /* harmony export */ hasKey: () => ( /* binding */hasKey),
                /* harmony export */ loadKey: () => ( /* binding */loadKey),
                /* harmony export */ randomBytes: () => ( /* binding */randomBytes),
                /* harmony export */ unloadAllKeys: () => ( /* binding */unloadAllKeys),
                /* harmony export */ unloadKey: () => ( /* binding */unloadKey)
                /* harmony export */ 
            });
            /* harmony import */ var uuid__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! uuid */ "./node_modules/uuid/dist/esm-node/v4.js");
            /* harmony import */ var _encryption_internals__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./encryption-internals */ "./packages/loot-core/src/server/encryption-internals.ts");
            // @ts-strict-ignore
            // A map of all possible master encryption keys to use, keyed by
            // unique id
            let keys = {};
            class Key {
                constructor({ id }) {
                    this.id = id || (0, uuid__WEBPACK_IMPORTED_MODULE_1__["default"])();
                }
                async createFromPassword({ password, salt }) {
                    this.value = await _encryption_internals__WEBPACK_IMPORTED_MODULE_0__.createKey({
                        secret: password,
                        salt
                    });
                }
                async createFromBase64(str) {
                    this.value = await _encryption_internals__WEBPACK_IMPORTED_MODULE_0__.importKey(str);
                }
                getId() {
                    return this.id;
                }
                getValue() {
                    return this.value;
                }
                serialize() {
                    return {
                        id: this.id,
                        base64: this.value.base64
                    };
                }
            }
            function getKey(keyId) {
                if (keyId == null || keys[keyId] == null) {
                    throw new Error('missing-key');
                }
                return keys[keyId];
            }
            function hasKey(keyId) {
                return keyId in keys;
            }
            function encrypt(value, keyId) {
                return _encryption_internals__WEBPACK_IMPORTED_MODULE_0__.encrypt(getKey(keyId), value);
            }
            function decrypt(encrypted, meta) {
                return _encryption_internals__WEBPACK_IMPORTED_MODULE_0__.decrypt(getKey(meta.keyId), encrypted, meta);
            }
            function randomBytes(n) {
                return _encryption_internals__WEBPACK_IMPORTED_MODULE_0__.randomBytes(n);
            }
            async function loadKey(key) {
                let keyInstance;
                if (!(key instanceof Key)) {
                    keyInstance = new Key({
                        id: key.id
                    });
                    await keyInstance.createFromBase64(key.base64);
                }
                else {
                    keyInstance = key;
                }
                keys[keyInstance.getId()] = keyInstance;
            }
            function unloadKey(key) {
                delete keys[key.getId()];
            }
            function unloadAllKeys() {
                keys = {};
            }
            async function createKey({ id, password, salt }) {
                const key = new Key({
                    id
                });
                await key.createFromPassword({
                    password,
                    salt
                });
                return key;
            }
            /***/ 
        }),
        /***/ "./packages/loot-core/src/server/errors.ts": 
        /*!*************************************************!*\
          !*** ./packages/loot-core/src/server/errors.ts ***!
          \*************************************************/
        /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony export */ __webpack_require__.d(__webpack_exports__, {
                /* harmony export */ APIError: () => ( /* binding */APIError),
                /* harmony export */ FileDownloadError: () => ( /* binding */FileDownloadError),
                /* harmony export */ FileUploadError: () => ( /* binding */FileUploadError),
                /* harmony export */ HTTPError: () => ( /* binding */HTTPError),
                /* harmony export */ PostError: () => ( /* binding */PostError),
                /* harmony export */ RuleError: () => ( /* binding */RuleError),
                /* harmony export */ SyncError: () => ( /* binding */SyncError),
                /* harmony export */ TransactionError: () => ( /* binding */TransactionError)
                /* harmony export */ 
            });
            // TODO: normalize error types
            class PostError extends Error {
                constructor(reason, meta) {
                    super('PostError: ' + reason);
                    this.type = 'PostError';
                    this.reason = reason;
                    this.meta = meta;
                }
            }
            class HTTPError extends Error {
                constructor(code, body) {
                    super(`HTTPError: unsuccessful status code (${code}): ${body}`);
                    this.statusCode = code;
                    this.responseBody = body;
                }
            }
            class SyncError extends Error {
                constructor(reason, meta) {
                    super('SyncError: ' + reason);
                    this.reason = reason;
                    this.meta = meta;
                }
            }
            class TransactionError extends Error {
            }
            class RuleError extends Error {
                constructor(name, message) {
                    super('RuleError: ' + message);
                    this.type = name;
                }
            }
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            function APIError(msg, meta) {
                return {
                    type: 'APIError',
                    message: msg,
                    meta
                };
            }
            function FileDownloadError(reason, meta) {
                return {
                    type: 'FileDownloadError',
                    reason,
                    meta
                };
            }
            function FileUploadError(reason, meta) {
                return {
                    type: 'FileUploadError',
                    reason,
                    meta
                };
            }
            /***/ 
        }),
        /***/ "./packages/loot-core/src/server/filters/app.ts": 
        /*!******************************************************!*\
          !*** ./packages/loot-core/src/server/filters/app.ts ***!
          \******************************************************/
        /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony export */ __webpack_require__.d(__webpack_exports__, {
                /* harmony export */ app: () => ( /* binding */app)
                /* harmony export */ 
            });
            /* harmony import */ var uuid__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! uuid */ "./node_modules/uuid/dist/esm-node/v4.js");
            /* harmony import */ var _accounts_transaction_rules__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../accounts/transaction-rules */ "./packages/loot-core/src/server/accounts/transaction-rules.ts");
            /* harmony import */ var _app__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../app */ "./packages/loot-core/src/server/app.ts");
            /* harmony import */ var _db__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../db */ "./packages/loot-core/src/server/db/index.ts");
            /* harmony import */ var _models__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../models */ "./packages/loot-core/src/server/models.ts");
            /* harmony import */ var _mutators__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../mutators */ "./packages/loot-core/src/server/mutators.ts");
            /* harmony import */ var _undo__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../undo */ "./packages/loot-core/src/server/undo.ts");
            // @ts-strict-ignore
            const filterModel = {
                validate(filter, { update } = {}) {
                    (0, _models__WEBPACK_IMPORTED_MODULE_3__.requiredFields)('transaction_filters', filter, [
                        'conditions'
                    ], update);
                    if (!update || 'conditionsOp' in filter) {
                        if (![
                            'and',
                            'or'
                        ].includes(filter.conditionsOp)) {
                            throw new Error('Invalid filter conditionsOp: ' + filter.conditionsOp);
                        }
                    }
                    return filter;
                },
                toJS(row) {
                    const { conditions, conditions_op, ...fields } = row;
                    return {
                        ...fields,
                        conditionsOp: conditions_op,
                        conditions: (0, _accounts_transaction_rules__WEBPACK_IMPORTED_MODULE_0__.parseConditionsOrActions)(conditions)
                    };
                },
                fromJS(filter) {
                    const { conditionsOp, ...row } = filter;
                    if (conditionsOp) {
                        row.conditions_op = conditionsOp;
                    }
                    return row;
                }
            };
            async function filterNameExists(name, filterId, newItem) {
                const idForName = await _db__WEBPACK_IMPORTED_MODULE_2__.first('SELECT id from transaction_filters WHERE tombstone = 0 AND name = ?', [
                    name
                ]);
                if (idForName === null) {
                    return false;
                }
                if (!newItem) {
                    return idForName.id !== filterId;
                }
                return true;
            }
            //TODO: Possible to simplify this?
            //use filters and maps
            function conditionExists(item, filters, newItem) {
                const { conditions, conditionsOp } = item;
                let condCheck = [];
                let fCondCheck = false;
                let fCondFound;
                filters.map((filter) => {
                    if (!fCondCheck && //If conditions.length equals 1 then ignore conditionsOp
                        (conditions.length === 1 ? true : filter.conditionsOp === conditionsOp) && !filter.tombstone && filter.conditions.length === conditions.length) {
                        fCondCheck = false;
                        conditions.map((cond, i) => {
                            condCheck[i] = filter.conditions.filter((fcond) => {
                                return cond.value === fcond.value && cond.op === fcond.op && cond.field === fcond.field;
                            }).length > 0;
                            fCondCheck = (i === 0 ? true : fCondCheck) && condCheck[i];
                            return true;
                        });
                        fCondFound = fCondCheck && condCheck[conditions.length - 1] && filter;
                    }
                    return true;
                });
                condCheck = [];
                if (!newItem) {
                    return fCondFound ? fCondFound.id !== item.id ? fCondFound.name : false : false;
                }
                return fCondFound ? fCondFound.name : false;
            }
            async function createFilter(filter) {
                const filterId = (0, uuid__WEBPACK_IMPORTED_MODULE_6__["default"])();
                const item = {
                    id: filterId,
                    conditions: filter.state.conditions,
                    conditionsOp: filter.state.conditionsOp,
                    name: filter.state.name
                };
                if (item.name) {
                    if (await filterNameExists(item.name, item.id, true)) {
                        throw new Error('There is already a filter named ' + item.name);
                    }
                }
                else {
                    throw new Error('Filter name is required');
                }
                if (item.conditions.length > 0) {
                    const condExists = conditionExists(item, filter.filters, true);
                    if (condExists) {
                        throw new Error('Duplicate filter warning: conditions already exist. Filter name: ' + condExists);
                    }
                }
                else {
                    throw new Error('Conditions are required');
                }
                // Create the filter here based on the info
                await _db__WEBPACK_IMPORTED_MODULE_2__.insertWithSchema('transaction_filters', filterModel.fromJS(item));
                return filterId;
            }
            async function updateFilter(filter) {
                const item = {
                    id: filter.state.id,
                    conditions: filter.state.conditions,
                    conditionsOp: filter.state.conditionsOp,
                    name: filter.state.name
                };
                if (item.name) {
                    if (await filterNameExists(item.name, item.id, false)) {
                        throw new Error('There is already a filter named ' + item.name);
                    }
                }
                else {
                    throw new Error('Filter name is required');
                }
                if (item.conditions.length > 0) {
                    const condExists = conditionExists(item, filter.filters, false);
                    if (condExists) {
                        throw new Error('Duplicate filter warning: conditions already exist. Filter name: ' + condExists);
                    }
                }
                else {
                    throw new Error('Conditions are required');
                }
                await _db__WEBPACK_IMPORTED_MODULE_2__.updateWithSchema('transaction_filters', filterModel.fromJS(item));
            }
            async function deleteFilter(id) {
                await _db__WEBPACK_IMPORTED_MODULE_2__.delete_('transaction_filters', id);
            }
            const app = (0, _app__WEBPACK_IMPORTED_MODULE_1__.createApp)();
            app.method('filter-create', (0, _mutators__WEBPACK_IMPORTED_MODULE_4__.mutator)(createFilter));
            app.method('filter-update', (0, _mutators__WEBPACK_IMPORTED_MODULE_4__.mutator)(updateFilter));
            app.method('filter-delete', (0, _mutators__WEBPACK_IMPORTED_MODULE_4__.mutator)((0, _undo__WEBPACK_IMPORTED_MODULE_5__.undoable)(deleteFilter)));
            /***/ 
        }),
        /***/ "./packages/loot-core/src/server/importers/actual.ts": 
        /*!***********************************************************!*\
          !*** ./packages/loot-core/src/server/importers/actual.ts ***!
          \***********************************************************/
        /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony export */ __webpack_require__.d(__webpack_exports__, {
                /* harmony export */ importActual: () => ( /* binding */importActual)
                /* harmony export */ 
            });
            /* harmony import */ var _platform_server_fs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../platform/server/fs */ "./packages/loot-core/src/platform/server/fs/index.electron.ts");
            /* harmony import */ var _platform_server_sqlite__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../platform/server/sqlite */ "./packages/loot-core/src/platform/server/sqlite/index.electron.ts");
            /* harmony import */ var _cloud_storage__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../cloud-storage */ "./packages/loot-core/src/server/cloud-storage.ts");
            /* harmony import */ var _main__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../main */ "./packages/loot-core/src/server/main.ts");
            /* harmony import */ var _sheet__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../sheet */ "./packages/loot-core/src/server/sheet.ts");
            // @ts-strict-ignore
            async function importActual(_filepath, buffer) {
                // Importing Actual files is a special case because we can directly
                // write down the files, but because it doesn't go through the API
                // layer we need to duplicate some of the workflow
                await _main__WEBPACK_IMPORTED_MODULE_3__.handlers['close-budget']();
                let id;
                try {
                    ({ id } = await _cloud_storage__WEBPACK_IMPORTED_MODULE_2__.importBuffer({
                        cloudFileId: null,
                        groupId: null
                    }, buffer));
                }
                catch (e) {
                    if (e.type === 'FileDownloadError') {
                        return {
                            error: e.reason
                        };
                    }
                    throw e;
                }
                // We never want to load cached data from imported files, so
                // delete the cache
                const sqliteDb = await _platform_server_sqlite__WEBPACK_IMPORTED_MODULE_1__.openDatabase(_platform_server_fs__WEBPACK_IMPORTED_MODULE_0__.join(_platform_server_fs__WEBPACK_IMPORTED_MODULE_0__.getBudgetDir(id), 'db.sqlite'));
                _platform_server_sqlite__WEBPACK_IMPORTED_MODULE_1__.execQuery(sqliteDb, `
          DELETE FROM kvcache;
          DELETE FROM kvcache_key;
        `);
                _platform_server_sqlite__WEBPACK_IMPORTED_MODULE_1__.closeDatabase(sqliteDb);
                // Load the budget, force everything to be computed, and try
                // to upload it as a cloud file
                await _main__WEBPACK_IMPORTED_MODULE_3__.handlers['load-budget']({
                    id
                });
                await _main__WEBPACK_IMPORTED_MODULE_3__.handlers['get-budget-bounds']();
                await (0, _sheet__WEBPACK_IMPORTED_MODULE_4__.waitOnSpreadsheet)();
                await _cloud_storage__WEBPACK_IMPORTED_MODULE_2__.upload().catch(() => { });
            }
            /***/ 
        }),
        /***/ "./packages/loot-core/src/server/importers/index.ts": 
        /*!**********************************************************!*\
          !*** ./packages/loot-core/src/server/importers/index.ts ***!
          \**********************************************************/
        /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony export */ __webpack_require__.d(__webpack_exports__, {
                /* harmony export */ handleBudgetImport: () => ( /* binding */handleBudgetImport)
                /* harmony export */ 
            });
            /* harmony import */ var _main__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../main */ "./packages/loot-core/src/server/main.ts");
            /* harmony import */ var _actual__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./actual */ "./packages/loot-core/src/server/importers/actual.ts");
            /* harmony import */ var _ynab4__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ynab4 */ "./packages/loot-core/src/server/importers/ynab4.ts");
            /* harmony import */ var _ynab5__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./ynab5 */ "./packages/loot-core/src/server/importers/ynab5.ts");
            // @ts-strict-ignore
            const importers = {
                ynab4: _ynab4__WEBPACK_IMPORTED_MODULE_2__,
                ynab5: _ynab5__WEBPACK_IMPORTED_MODULE_3__
            };
            async function handleBudgetImport(type, filepath, buffer) {
                if (type === 'actual') {
                    return (0, _actual__WEBPACK_IMPORTED_MODULE_1__.importActual)(filepath, buffer);
                }
                const importer = importers[type];
                try {
                    let data;
                    let budgetName;
                    try {
                        data = importer.parseFile(buffer);
                        budgetName = importer.getBudgetName(filepath, data);
                    }
                    catch (e) {
                        console.error('failed to parse file', e);
                    }
                    if (!budgetName) {
                        return {
                            error: 'not-' + type
                        };
                    }
                    try {
                        await _main__WEBPACK_IMPORTED_MODULE_0__.handlers['api/start-import']({
                            budgetName
                        });
                    }
                    catch (e) {
                        console.error('failed to start import', e);
                        return {
                            error: 'unknown'
                        };
                    }
                    await importer.doImport(data);
                }
                catch (e) {
                    await _main__WEBPACK_IMPORTED_MODULE_0__.handlers['api/abort-import']();
                    console.error('failed to run import', e);
                    return {
                        error: 'unknown'
                    };
                }
                await _main__WEBPACK_IMPORTED_MODULE_0__.handlers['api/finish-import']();
            }
            /***/ 
        }),
        /***/ "./packages/loot-core/src/server/importers/ynab4.ts": 
        /*!**********************************************************!*\
          !*** ./packages/loot-core/src/server/importers/ynab4.ts ***!
          \**********************************************************/
        /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony export */ __webpack_require__.d(__webpack_exports__, {
                /* harmony export */ doImport: () => ( /* binding */doImport),
                /* harmony export */ getBudgetName: () => ( /* binding */getBudgetName),
                /* harmony export */ parseFile: () => ( /* binding */parseFile)
                /* harmony export */ 
            });
            /* harmony import */ var _actual_app_api_injected__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @actual-app/api/injected */ "./packages/api/injected.js");
            /* harmony import */ var _actual_app_api_methods__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @actual-app/api/methods */ "./packages/api/methods.ts");
            /* harmony import */ var _actual_app_api_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @actual-app/api/utils */ "./packages/api/utils.js");
            /* harmony import */ var adm_zip__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! adm-zip */ "./node_modules/adm-zip/adm-zip.js");
            /* harmony import */ var adm_zip__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/ __webpack_require__.n(adm_zip__WEBPACK_IMPORTED_MODULE_3__);
            /* harmony import */ var slash__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! slash */ "./node_modules/slash/index.js");
            /* harmony import */ var slash__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/ __webpack_require__.n(slash__WEBPACK_IMPORTED_MODULE_4__);
            /* harmony import */ var uuid__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! uuid */ "./node_modules/uuid/dist/esm-node/v4.js");
            /* harmony import */ var _shared_months__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../shared/months */ "./packages/loot-core/src/shared/months.ts");
            /* harmony import */ var _shared_util__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../shared/util */ "./packages/loot-core/src/shared/util.ts");
            // @ts-strict-ignore
            // This is a special usage of the API because this package is embedded
            // into Actual itself. We only want to pull in the methods in that
            // case and ignore everything else; otherwise we'd be pulling in the
            // entire backend bundle from the API
            // Importer
            async function importAccounts(data, entityIdMap) {
                const accounts = (0, _shared_util__WEBPACK_IMPORTED_MODULE_6__.sortByKey)(data.accounts, 'sortableIndex');
                return Promise.all(accounts.map(async (account) => {
                    if (!account.isTombstone) {
                        const id = await _actual_app_api_methods__WEBPACK_IMPORTED_MODULE_1__.createAccount({
                            name: account.accountName,
                            offbudget: account.onBudget ? false : true,
                            closed: account.hidden ? true : false
                        });
                        entityIdMap.set(account.entityId, id);
                    }
                }));
            }
            async function importCategories(data, entityIdMap) {
                const masterCategories = (0, _shared_util__WEBPACK_IMPORTED_MODULE_6__.sortByKey)(data.masterCategories, 'sortableIndex');
                await Promise.all(masterCategories.map(async (masterCategory) => {
                    if (masterCategory.type === 'OUTFLOW' && !masterCategory.isTombstone && masterCategory.subCategories && masterCategory.subCategories.some((cat) => !cat.isTombstone)) {
                        const id = await _actual_app_api_methods__WEBPACK_IMPORTED_MODULE_1__.createCategoryGroup({
                            name: masterCategory.name,
                            is_income: false
                        });
                        entityIdMap.set(masterCategory.entityId, id);
                        if (masterCategory.note) {
                            (0, _actual_app_api_injected__WEBPACK_IMPORTED_MODULE_0__.send)('notes-save', {
                                id,
                                note: masterCategory.note
                            });
                        }
                        if (masterCategory.subCategories) {
                            const subCategories = (0, _shared_util__WEBPACK_IMPORTED_MODULE_6__.sortByKey)(masterCategory.subCategories, 'sortableIndex');
                            subCategories.reverse();
                            // This can't be done in parallel because sort order depends
                            // on insertion order
                            for (const category of subCategories) {
                                if (!category.isTombstone) {
                                    const id = await _actual_app_api_methods__WEBPACK_IMPORTED_MODULE_1__.createCategory({
                                        name: category.name,
                                        group_id: entityIdMap.get(category.masterCategoryId)
                                    });
                                    entityIdMap.set(category.entityId, id);
                                    if (category.note) {
                                        (0, _actual_app_api_injected__WEBPACK_IMPORTED_MODULE_0__.send)('notes-save', {
                                            id,
                                            note: category.note
                                        });
                                    }
                                }
                            }
                        }
                    }
                }));
            }
            async function importPayees(data, entityIdMap) {
                for (const payee of data.payees) {
                    if (!payee.isTombstone) {
                        const id = await _actual_app_api_methods__WEBPACK_IMPORTED_MODULE_1__.createPayee({
                            name: payee.name,
                            category: entityIdMap.get(payee.autoFillCategoryId) || null,
                            transfer_acct: entityIdMap.get(payee.targetAccountId) || null
                        });
                        // TODO: import payee rules
                        entityIdMap.set(payee.entityId, id);
                    }
                }
            }
            async function importTransactions(data, entityIdMap) {
                const categories = await _actual_app_api_methods__WEBPACK_IMPORTED_MODULE_1__.getCategories();
                const incomeCategoryId = categories.find((cat) => cat.name === 'Income').id;
                const accounts = await _actual_app_api_methods__WEBPACK_IMPORTED_MODULE_1__.getAccounts();
                const payees = await _actual_app_api_methods__WEBPACK_IMPORTED_MODULE_1__.getPayees();
                function getCategory(id) {
                    if (id == null || id === 'Category/__Split__') {
                        return null;
                    }
                    else if (id === 'Category/__ImmediateIncome__' || id === 'Category/__DeferredIncome__') {
                        return incomeCategoryId;
                    }
                    return entityIdMap.get(id);
                }
                function isOffBudget(acctId) {
                    const acct = accounts.find((acct) => acct.id === acctId);
                    if (!acct) {
                        throw new Error('Could not find account for transaction when importing');
                    }
                    return acct.offbudget;
                }
                // Go ahead and generate ids for all of the transactions so we can
                // reliably resolve transfers
                for (const transaction of data.transactions) {
                    entityIdMap.set(transaction.entityId, (0, uuid__WEBPACK_IMPORTED_MODULE_7__["default"])());
                    if (transaction.subTransactions) {
                        for (const subTransaction of transaction.subTransactions) {
                            entityIdMap.set(subTransaction.entityId, (0, uuid__WEBPACK_IMPORTED_MODULE_7__["default"])());
                        }
                    }
                }
                const transactionsGrouped = (0, _shared_util__WEBPACK_IMPORTED_MODULE_6__.groupBy)(data.transactions, 'accountId');
                await Promise.all([
                    ...transactionsGrouped.keys()
                ].map(async (accountId) => {
                    const transactions = transactionsGrouped.get(accountId);
                    const toImport = transactions.map((transaction) => {
                        if (transaction.isTombstone) {
                            return null;
                        }
                        const id = entityIdMap.get(transaction.entityId);
                        function transferProperties(t) {
                            const transferId = entityIdMap.get(t.transferTransactionId) || null;
                            let payee = null;
                            let imported_payee = null;
                            if (transferId) {
                                payee = payees.find((p) => p.transfer_acct === entityIdMap.get(t.targetAccountId)).id;
                            }
                            else {
                                payee = entityIdMap.get(t.payeeId);
                                imported_payee = data.payees.find((p) => p.entityId === t.payeeId)?.name;
                            }
                            return {
                                transfer_id: transferId,
                                payee,
                                imported_payee
                            };
                        }
                        const newTransaction = {
                            id,
                            amount: (0, _actual_app_api_utils__WEBPACK_IMPORTED_MODULE_2__.amountToInteger)(transaction.amount),
                            category: isOffBudget(entityIdMap.get(accountId)) ? null : getCategory(transaction.categoryId),
                            date: transaction.date,
                            notes: transaction.memo || null,
                            cleared: transaction.cleared === 'Cleared' || transaction.cleared === 'Reconciled',
                            reconciled: transaction.cleared === 'Reconciled',
                            ...transferProperties(transaction),
                            subtransactions: transaction.subTransactions && transaction.subTransactions.map((t) => {
                                return {
                                    id: entityIdMap.get(t.entityId),
                                    amount: (0, _actual_app_api_utils__WEBPACK_IMPORTED_MODULE_2__.amountToInteger)(t.amount),
                                    category: getCategory(t.categoryId),
                                    notes: t.memo || null,
                                    ...transferProperties(t)
                                };
                            })
                        };
                        return newTransaction;
                    }).filter((x) => x);
                    await _actual_app_api_methods__WEBPACK_IMPORTED_MODULE_1__.addTransactions(entityIdMap.get(accountId), toImport, {
                        learnCategories: true
                    });
                }));
            }
            function fillInBudgets(data, categoryBudgets) {
                // YNAB only contains entries for categories that have been actually
                // budgeted. That would be fine except that we need to set the
                // "carryover" flag on each month when carrying debt across months.
                // To make sure our system has a chance to set this flag on each
                // category, make sure a budget exists for every category of every
                // month.
                const budgets = [
                    ...categoryBudgets
                ];
                data.masterCategories.forEach((masterCategory) => {
                    if (masterCategory.subCategories) {
                        masterCategory.subCategories.forEach((category) => {
                            if (!budgets.find((b) => b.categoryId === category.entityId)) {
                                budgets.push({
                                    budgeted: 0,
                                    categoryId: category.entityId
                                });
                            }
                        });
                    }
                });
                return budgets;
            }
            async function importBudgets(data, entityIdMap) {
                const budgets = (0, _shared_util__WEBPACK_IMPORTED_MODULE_6__.sortByKey)(data.monthlyBudgets, 'month');
                await _actual_app_api_methods__WEBPACK_IMPORTED_MODULE_1__.batchBudgetUpdates(async () => {
                    for (const budget of budgets) {
                        const filled = fillInBudgets(data, budget.monthlySubCategoryBudgets.filter((b) => !b.isTombstone));
                        await Promise.all(filled.map(async (catBudget) => {
                            const amount = (0, _actual_app_api_utils__WEBPACK_IMPORTED_MODULE_2__.amountToInteger)(catBudget.budgeted);
                            const catId = entityIdMap.get(catBudget.categoryId);
                            const month = _shared_months__WEBPACK_IMPORTED_MODULE_5__.monthFromDate(budget.month);
                            if (!catId) {
                                return;
                            }
                            await _actual_app_api_methods__WEBPACK_IMPORTED_MODULE_1__.setBudgetAmount(month, catId, amount);
                            if (catBudget.overspendingHandling === 'AffectsBuffer') {
                                await _actual_app_api_methods__WEBPACK_IMPORTED_MODULE_1__.setBudgetCarryover(month, catId, false);
                            }
                            else if (catBudget.overspendingHandling === 'Confined') {
                                await _actual_app_api_methods__WEBPACK_IMPORTED_MODULE_1__.setBudgetCarryover(month, catId, true);
                            }
                        }));
                    }
                });
            }
            function estimateRecentness(str) {
                // The "recentness" is the total amount of changes that this device
                // is aware of, which is estimated by summing up all of the version
                // numbers that its aware of. This works because version numbers are
                // increasing integers.
                return str.split(',').reduce((total, version) => {
                    const [_, number] = version.split('-');
                    return total + parseInt(number);
                }, 0);
            }
            function findLatestDevice(zipped, entries) {
                let devices = entries.map((entry) => {
                    const contents = zipped.readFile(entry).toString('utf8');
                    let data;
                    try {
                        data = JSON.parse(contents);
                    }
                    catch (e) {
                        return null;
                    }
                    if (data.hasFullKnowledge) {
                        return {
                            deviceGUID: data.deviceGUID,
                            shortName: data.shortDeviceId,
                            recentness: estimateRecentness(data.knowledge)
                        };
                    }
                    return null;
                }).filter((x) => x);
                devices = (0, _shared_util__WEBPACK_IMPORTED_MODULE_6__.sortByKey)(devices, 'recentness');
                return devices[devices.length - 1].deviceGUID;
            }
            async function doImport(data) {
                const entityIdMap = new Map();
                console.log('Importing Accounts...');
                await importAccounts(data, entityIdMap);
                console.log('Importing Categories...');
                await importCategories(data, entityIdMap);
                console.log('Importing Payees...');
                await importPayees(data, entityIdMap);
                console.log('Importing Transactions...');
                await importTransactions(data, entityIdMap);
                console.log('Importing Budgets...');
                await importBudgets(data, entityIdMap);
                console.log('Setting up...');
            }
            function getBudgetName(filepath) {
                let unixFilepath = slash__WEBPACK_IMPORTED_MODULE_4___default()(filepath);
                if (!/\.zip/.test(unixFilepath)) {
                    return null;
                }
                unixFilepath = unixFilepath.replace(/\.zip$/, '').replace(/.ynab4$/, '');
                // Most budgets are named like "Budget~51938D82.ynab4" but sometimes
                // they are only "Budget.ynab4". We only want to grab the name
                // before the ~ if it exists.
                const m = unixFilepath.match(/([^/~]+)[^/]*$/);
                if (!m) {
                    return null;
                }
                return m[1];
            }
            function getFile(entries, path) {
                const files = entries.filter((e) => e.entryName === path);
                if (files.length === 0) {
                    throw new Error('Could not find file: ' + path);
                }
                if (files.length >= 2) {
                    throw new Error('File name matches multiple files: ' + path);
                }
                return files[0];
            }
            function join(...paths) {
                return paths.slice(1).reduce((full, path) => {
                    return full + '/' + path.replace(/^\//, '');
                }, paths[0].replace(/\/$/, ''));
            }
            function parseFile(buffer) {
                const zipped = new (adm_zip__WEBPACK_IMPORTED_MODULE_3___default())(buffer);
                const entries = zipped.getEntries();
                let root = '';
                const dirMatch = entries[0].entryName.match(/([^/]*\.ynab4)/);
                if (dirMatch) {
                    root = dirMatch[1] + '/';
                }
                const metaStr = zipped.readFile(getFile(entries, root + 'Budget.ymeta'));
                const meta = JSON.parse(metaStr.toString('utf8'));
                const budgetPath = join(root, meta.relativeDataFolderName);
                const deviceFiles = entries.filter((e) => e.entryName.startsWith(join(budgetPath, 'devices')));
                const deviceGUID = findLatestDevice(zipped, deviceFiles);
                const yfullPath = join(budgetPath, deviceGUID, 'Budget.yfull');
                let contents;
                try {
                    contents = zipped.readFile(getFile(entries, yfullPath)).toString('utf8');
                }
                catch (e) {
                    console.log(e);
                    throw new Error('Error reading Budget.yfull file');
                }
                try {
                    return JSON.parse(contents);
                }
                catch (e) {
                    throw new Error('Error parsing Budget.yfull file');
                }
            }
            /***/ 
        }),
        /***/ "./packages/loot-core/src/server/importers/ynab5.ts": 
        /*!**********************************************************!*\
          !*** ./packages/loot-core/src/server/importers/ynab5.ts ***!
          \**********************************************************/
        /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony export */ __webpack_require__.d(__webpack_exports__, {
                /* harmony export */ doImport: () => ( /* binding */doImport),
                /* harmony export */ getBudgetName: () => ( /* binding */getBudgetName),
                /* harmony export */ parseFile: () => ( /* binding */parseFile)
                /* harmony export */ 
            });
            /* harmony import */ var _actual_app_api_methods__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @actual-app/api/methods */ "./packages/api/methods.ts");
            /* harmony import */ var uuid__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! uuid */ "./node_modules/uuid/dist/esm-node/v4.js");
            /* harmony import */ var _shared_months__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../shared/months */ "./packages/loot-core/src/shared/months.ts");
            /* harmony import */ var _shared_util__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../shared/util */ "./packages/loot-core/src/shared/util.ts");
            // @ts-strict-ignore
            // This is a special usage of the API because this package is embedded
            // into Actual itself. We only want to pull in the methods in that
            // case and ignore everything else; otherwise we'd be pulling in the
            // entire backend bundle from the API
            function amountFromYnab(amount) {
                // ynabs multiplies amount by 1000 and actual by 100
                // so, this function divides by 10
                return Math.round(amount / 10);
            }
            function importAccounts(data, entityIdMap) {
                return Promise.all(data.accounts.map(async (account) => {
                    if (!account.deleted) {
                        const id = await _actual_app_api_methods__WEBPACK_IMPORTED_MODULE_0__.createAccount({
                            name: account.name,
                            offbudget: account.on_budget ? false : true,
                            closed: account.closed
                        });
                        entityIdMap.set(account.id, id);
                    }
                }));
            }
            async function importCategories(data, entityIdMap) {
                // Hidden categories are put in its own group by YNAB,
                // so it's already handled.
                const categories = await _actual_app_api_methods__WEBPACK_IMPORTED_MODULE_0__.getCategories();
                const incomeCatId = findIdByName(categories, 'Income');
                const ynabIncomeCategories = [
                    'To be Budgeted',
                    'Inflow: Ready to Assign'
                ];
                function checkSpecialCat(cat) {
                    if (cat.category_group_id === findIdByName(data.category_groups, 'Internal Master Category')) {
                        if (ynabIncomeCategories.some((ynabIncomeCategory) => equalsIgnoreCase(cat.name, ynabIncomeCategory))) {
                            return 'income';
                        }
                        else {
                            return 'internal';
                        }
                    }
                    else if (cat.category_group_id === findIdByName(data.category_groups, 'Credit Card Payments')) {
                        return 'creditCard';
                    }
                    else if (cat.category_group_id === findIdByName(data.category_groups, 'Income')) {
                        return 'income';
                    }
                }
                // Can't be done in parallel to have
                // correct sort order.
                for (const group of data.category_groups) {
                    if (!group.deleted) {
                        let groupId;
                        // Ignores internal category and credit cards
                        if (!equalsIgnoreCase(group.name, 'Internal Master Category') && !equalsIgnoreCase(group.name, 'Credit Card Payments') && !equalsIgnoreCase(group.name, 'Income')) {
                            groupId = await _actual_app_api_methods__WEBPACK_IMPORTED_MODULE_0__.createCategoryGroup({
                                name: group.name,
                                is_income: false
                            });
                            entityIdMap.set(group.id, groupId);
                        }
                        if (equalsIgnoreCase(group.name, 'Income')) {
                            groupId = incomeCatId;
                            entityIdMap.set(group.id, groupId);
                        }
                        const cats = data.categories.filter((cat) => cat.category_group_id === group.id);
                        for (const cat of cats.reverse()) {
                            if (!cat.deleted) {
                                // Handles special categories. Starting balance is a payee
                                // in YNAB so it's handled in importTransactions
                                switch (checkSpecialCat(cat)) {
                                    case 'income':
                                        {
                                            // doesn't create new category, only assigns id
                                            const id = incomeCatId;
                                            entityIdMap.set(cat.id, id);
                                            break;
                                        }
                                    case 'creditCard':
                                    case 'internal':
                                        break;
                                    default:
                                        {
                                            const id = await _actual_app_api_methods__WEBPACK_IMPORTED_MODULE_0__.createCategory({
                                                name: cat.name,
                                                group_id: groupId
                                            });
                                            entityIdMap.set(cat.id, id);
                                            break;
                                        }
                                }
                            }
                        }
                    }
                }
            }
            function importPayees(data, entityIdMap) {
                return Promise.all(data.payees.map(async (payee) => {
                    if (!payee.deleted) {
                        const id = await _actual_app_api_methods__WEBPACK_IMPORTED_MODULE_0__.createPayee({
                            name: payee.name
                        });
                        entityIdMap.set(payee.id, id);
                    }
                }));
            }
            async function importTransactions(data, entityIdMap) {
                const payees = await _actual_app_api_methods__WEBPACK_IMPORTED_MODULE_0__.getPayees();
                const categories = await _actual_app_api_methods__WEBPACK_IMPORTED_MODULE_0__.getCategories();
                const incomeCatId = findIdByName(categories, 'Income');
                const startingBalanceCatId = findIdByName(categories, 'Starting Balances'); //better way to do it?
                const startingPayeeYNAB = findIdByName(data.payees, 'Starting Balance');
                const transactionsGrouped = (0, _shared_util__WEBPACK_IMPORTED_MODULE_2__.groupBy)(data.transactions, 'account_id');
                const subtransactionsGrouped = (0, _shared_util__WEBPACK_IMPORTED_MODULE_2__.groupBy)(data.subtransactions, 'transaction_id');
                const payeesByTransferAcct = payees.filter((payee) => payee?.transfer_acct).map((payee) => [
                    payee.transfer_acct,
                    payee
                ]);
                const payeeTransferAcctHashMap = new Map(payeesByTransferAcct);
                const orphanTransferMap = new Map();
                const orphanSubtransfer = [];
                const orphanSubtransferTrxId = [];
                const orphanSubtransferAcctIdByTrxIdMap = new Map();
                const orphanSubtransferDateByTrxIdMap = new Map();
                // Go ahead and generate ids for all of the transactions so we can
                // reliably resolve transfers
                // Also identify orphan transfer transactions and subtransactions.
                for (const transaction of data.subtransactions) {
                    entityIdMap.set(transaction.id, (0, uuid__WEBPACK_IMPORTED_MODULE_3__["default"])());
                    if (transaction.transfer_account_id) {
                        orphanSubtransfer.push(transaction);
                        orphanSubtransferTrxId.push(transaction.transaction_id);
                    }
                }
                for (const transaction of data.transactions) {
                    entityIdMap.set(transaction.id, (0, uuid__WEBPACK_IMPORTED_MODULE_3__["default"])());
                    if (transaction.transfer_account_id && !transaction.transfer_transaction_id) {
                        const key = transaction.account_id + '#' + transaction.transfer_account_id;
                        if (!orphanTransferMap.has(key)) {
                            orphanTransferMap.set(key, [
                                transaction
                            ]);
                        }
                        else {
                            orphanTransferMap.get(key).push(transaction);
                        }
                    }
                    if (orphanSubtransferTrxId.includes(transaction.id)) {
                        orphanSubtransferAcctIdByTrxIdMap.set(transaction.id, transaction.account_id);
                        orphanSubtransferDateByTrxIdMap.set(transaction.id, transaction.date);
                    }
                }
                // Compute link between subtransaction transfers and orphaned transaction
                // transfers. The goal is to match each transfer subtransaction to the related
                // transfer transaction according to the accounts, date, amount and memo.
                const orphanSubtransferMap = orphanSubtransfer.reduce((map, subtransaction) => {
                    const key = subtransaction.transfer_account_id + '#' + orphanSubtransferAcctIdByTrxIdMap.get(subtransaction.transaction_id);
                    if (!map.has(key)) {
                        map.set(key, [
                            subtransaction
                        ]);
                    }
                    else {
                        map.get(key).push(subtransaction);
                    }
                    return map;
                }, new Map());
                // The comparator will be used to order transfer transactions and their
                // corresponding tranfer subtransaction in two aligned list. Hopefully
                // for every list index in the transactions list, the related subtransaction
                // will be at the same index.
                const orphanTransferComparator = (a, b) => {
                    // a and b can be a YNAB5.Transaction (having a date attribute) or a
                    // YNAB5.Subtransaction (missing that date attribute)
                    const date_a = 'date' in a ? a.date : orphanSubtransferDateByTrxIdMap.get(a.transaction_id);
                    const date_b = 'date' in b ? b.date : orphanSubtransferDateByTrxIdMap.get(b.transaction_id);
                    // A transaction and the related subtransaction have inverted amounts.
                    // To have those in the same order, the subtransaction has to be reversed
                    // to have the same amount.
                    const amount_a = 'date' in a ? a.amount : -a.amount;
                    const amount_b = 'date' in b ? b.amount : -b.amount;
                    // Transaction are ordered first by date, then by amount, and lastly by memo
                    if (date_a > date_b)
                        return 1;
                    if (date_a < date_b)
                        return -1;
                    if (amount_a > amount_b)
                        return 1;
                    if (amount_a < amount_b)
                        return -1;
                    if (a.memo > b.memo)
                        return 1;
                    if (a.memo < b.memo)
                        return -1;
                    return 0;
                };
                const orphanTrxIdSubtrxIdMap = new Map();
                orphanTransferMap.forEach((transactions, key) => {
                    const subtransactions = orphanSubtransferMap.get(key);
                    if (subtransactions) {
                        transactions.sort(orphanTransferComparator);
                        subtransactions.sort(orphanTransferComparator);
                        // Iterate on the two sorted lists transactions and subtransactions and
                        // find matching data to identify the related transaction ids.
                        let transactionIdx = 0;
                        let subtransactionIdx = 0;
                        do {
                            switch (orphanTransferComparator(transactions[transactionIdx], subtransactions[subtransactionIdx])) {
                                case 0:
                                    // The current list indexes are matching: the transaction and
                                    // subtransaction are related (same date, amount and memo)
                                    orphanTrxIdSubtrxIdMap.set(transactions[transactionIdx].id, entityIdMap.get(subtransactions[subtransactionIdx].id));
                                    orphanTrxIdSubtrxIdMap.set(subtransactions[subtransactionIdx].id, entityIdMap.get(transactions[transactionIdx].id));
                                    transactionIdx++;
                                    subtransactionIdx++;
                                    break;
                                case -1:
                                    // The current list indexes are not matching:
                                    // The current transaction is "smaller" than the current subtransaction
                                    // (earlier date, smaller amount, memo value sorted before)
                                    // So we advance to the next transaction and see if it match with
                                    // the current subtransaction
                                    transactionIdx++;
                                    break;
                                case 1:
                                    // Inverse of the previous case:
                                    // The current subtransaction is "smaller" than the current transaction
                                    // So we advance to the next subtransaction
                                    subtransactionIdx++;
                                    break;
                            }
                        } while (transactionIdx < transactions.length && subtransactionIdx < subtransactions.length);
                    }
                });
                await Promise.all([
                    ...transactionsGrouped.keys()
                ].map(async (accountId) => {
                    const transactions = transactionsGrouped.get(accountId);
                    const toImport = transactions.map((transaction) => {
                        if (transaction.deleted) {
                            return null;
                        }
                        const subtransactions = subtransactionsGrouped.get(transaction.id);
                        // Add transaction
                        const newTransaction = {
                            id: entityIdMap.get(transaction.id),
                            account: entityIdMap.get(transaction.account_id),
                            date: transaction.date,
                            amount: amountFromYnab(transaction.amount),
                            category: entityIdMap.get(transaction.category_id) || null,
                            cleared: [
                                'cleared',
                                'reconciled'
                            ].includes(transaction.cleared),
                            reconciled: transaction.cleared === 'reconciled',
                            notes: transaction.memo || null,
                            imported_id: transaction.import_id || null,
                            transfer_id: entityIdMap.get(transaction.transfer_transaction_id) || orphanTrxIdSubtrxIdMap.get(transaction.id) || null,
                            subtransactions: subtransactions ? subtransactions.map((subtrans) => {
                                return {
                                    id: entityIdMap.get(subtrans.id),
                                    amount: amountFromYnab(subtrans.amount),
                                    category: entityIdMap.get(subtrans.category_id) || null,
                                    notes: subtrans.memo,
                                    transfer_id: orphanTrxIdSubtrxIdMap.get(subtrans.id) || null,
                                    payee: null,
                                    imported_payee: null
                                };
                            }) : null,
                            payee: null,
                            imported_payee: null
                        };
                        // Handle transactions and subtransactions payee
                        const transactionPayeeUpdate = (trx, newTrx) => {
                            if (trx.transfer_account_id) {
                                const mappedTransferAccountId = entityIdMap.get(trx.transfer_account_id);
                                newTrx.payee = payeeTransferAcctHashMap.get(mappedTransferAccountId)?.id;
                            }
                            else {
                                newTrx.payee = entityIdMap.get(trx.payee_id);
                                newTrx.imported_payee = data.payees.find((p) => !p.deleted && p.id === trx.payee_id)?.name;
                            }
                        };
                        transactionPayeeUpdate(transaction, newTransaction);
                        if (newTransaction.subtransactions) {
                            subtransactions.forEach((subtrans) => {
                                const newSubtransaction = newTransaction.subtransactions.find((newSubtrans) => newSubtrans.id === entityIdMap.get(subtrans.id));
                                transactionPayeeUpdate(subtrans, newSubtransaction);
                            });
                        }
                        // Handle starting balances
                        if (transaction.payee_id === startingPayeeYNAB && entityIdMap.get(transaction.category_id) === incomeCatId) {
                            newTransaction.category = startingBalanceCatId;
                            newTransaction.payee = null;
                        }
                        return newTransaction;
                    }).filter((x) => x);
                    await _actual_app_api_methods__WEBPACK_IMPORTED_MODULE_0__.addTransactions(entityIdMap.get(accountId), toImport, {
                        learnCategories: true
                    });
                }));
            }
            async function importBudgets(data, entityIdMap) {
                // There should be info in the docs to deal with
                // no credit card category and how YNAB and Actual
                // handle differently the amount To be Budgeted
                // i.e. Actual considers the cc debt while YNAB doesn't
                //
                // Also, there could be a way to set rollover using
                // Deferred Income Subcat and Immediate Income Subcat
                const budgets = (0, _shared_util__WEBPACK_IMPORTED_MODULE_2__.sortByKey)(data.months, 'month');
                const internalCatIdYnab = findIdByName(data.category_groups, 'Internal Master Category');
                const creditcardCatIdYnab = findIdByName(data.category_groups, 'Credit Card Payments');
                await _actual_app_api_methods__WEBPACK_IMPORTED_MODULE_0__.batchBudgetUpdates(async () => {
                    for (const budget of budgets) {
                        const month = _shared_months__WEBPACK_IMPORTED_MODULE_1__.monthFromDate(budget.month);
                        await Promise.all(budget.categories.map(async (catBudget) => {
                            const catId = entityIdMap.get(catBudget.id);
                            const amount = Math.round(catBudget.budgeted / 10);
                            if (!catId || catBudget.category_group_id === internalCatIdYnab || catBudget.category_group_id === creditcardCatIdYnab) {
                                return;
                            }
                            await _actual_app_api_methods__WEBPACK_IMPORTED_MODULE_0__.setBudgetAmount(month, catId, amount);
                        }));
                    }
                });
            }
            // Utils
            async function doImport(data) {
                const entityIdMap = new Map();
                console.log('Importing Accounts...');
                await importAccounts(data, entityIdMap);
                console.log('Importing Categories...');
                await importCategories(data, entityIdMap);
                console.log('Importing Payees...');
                await importPayees(data, entityIdMap);
                console.log('Importing Transactions...');
                await importTransactions(data, entityIdMap);
                console.log('Importing Budgets...');
                await importBudgets(data, entityIdMap);
                console.log('Setting up...');
            }
            function parseFile(buffer) {
                let data = JSON.parse(buffer.toString());
                if (data.data) {
                    data = data.data;
                }
                if (data.budget) {
                    data = data.budget;
                }
                return data;
            }
            function getBudgetName(_filepath, data) {
                return data.budget_name || data.name;
            }
            function equalsIgnoreCase(stringa, stringb) {
                return stringa.localeCompare(stringb, undefined, {
                    sensitivity: 'base'
                }) === 0;
            }
            function findByNameIgnoreCase(categories, name) {
                return categories.find((cat) => equalsIgnoreCase(cat.name, name));
            }
            function findIdByName(categories, name) {
                return findByNameIgnoreCase(categories, name)?.id;
            }
            /***/ 
        }),
        /***/ "./packages/loot-core/src/server/main-app.ts": 
        /*!***************************************************!*\
          !*** ./packages/loot-core/src/server/main-app.ts ***!
          \***************************************************/
        /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony export */ __webpack_require__.d(__webpack_exports__, {
                /* harmony export */ app: () => ( /* binding */app)
                /* harmony export */ 
            });
            /* harmony import */ var _platform_server_connection__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../platform/server/connection */ "./packages/loot-core/src/platform/server/connection/index.api.ts");
            /* harmony import */ var _app__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./app */ "./packages/loot-core/src/server/app.ts");
            // Main app
            const app = (0, _app__WEBPACK_IMPORTED_MODULE_1__.createApp)();
            app.events.on('sync', (info) => {
                _platform_server_connection__WEBPACK_IMPORTED_MODULE_0__.send('sync-event', info);
            });
            /***/ 
        }),
        /***/ "./packages/loot-core/src/server/main.ts": 
        /*!***********************************************!*\
          !*** ./packages/loot-core/src/server/main.ts ***!
          \***********************************************/
        /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony export */ __webpack_require__.d(__webpack_exports__, {
                /* harmony export */ handlers: () => ( /* binding */handlers),
                /* harmony export */ init: () => ( /* binding */init),
                /* harmony export */ initApp: () => ( /* binding */initApp),
                /* harmony export */ lib: () => ( /* binding */lib)
                /* harmony export */ 
            });
            /* harmony import */ var _polyfills__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./polyfills */ "./packages/loot-core/src/server/polyfills.ts");
            /* harmony import */ var _polyfills__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/ __webpack_require__.n(_polyfills__WEBPACK_IMPORTED_MODULE_0__);
            /* harmony import */ var _actual_app_api_injected__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @actual-app/api/injected */ "./packages/api/injected.js");
            /* harmony import */ var _actual_app_crdt__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @actual-app/crdt */ "@actual-app/crdt");
            /* harmony import */ var _actual_app_crdt__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/ __webpack_require__.n(_actual_app_crdt__WEBPACK_IMPORTED_MODULE_2__);
            /* harmony import */ var uuid__WEBPACK_IMPORTED_MODULE_51__ = __webpack_require__(/*! uuid */ "./node_modules/uuid/dist/esm-node/v4.js");
            /* harmony import */ var _mocks_budget__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../mocks/budget */ "./packages/loot-core/src/mocks/budget.ts");
            /* harmony import */ var _platform_exceptions__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../platform/exceptions */ "./packages/loot-core/src/platform/exceptions/index.electron.ts");
            /* harmony import */ var _platform_server_asyncStorage__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../platform/server/asyncStorage */ "./packages/loot-core/src/platform/server/asyncStorage/index.electron.ts");
            /* harmony import */ var _platform_server_connection__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../platform/server/connection */ "./packages/loot-core/src/platform/server/connection/index.api.ts");
            /* harmony import */ var _platform_server_fs__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../platform/server/fs */ "./packages/loot-core/src/platform/server/fs/index.electron.ts");
            /* harmony import */ var _platform_server_log__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../platform/server/log */ "./packages/loot-core/src/platform/server/log/index.api.ts");
            /* harmony import */ var _platform_server_sqlite__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../platform/server/sqlite */ "./packages/loot-core/src/platform/server/sqlite/index.electron.ts");
            /* harmony import */ var _shared_environment__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../shared/environment */ "./packages/loot-core/src/shared/environment.ts");
            /* harmony import */ var _shared_months__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../shared/months */ "./packages/loot-core/src/shared/months.ts");
            /* harmony import */ var _shared_query__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../shared/query */ "./packages/loot-core/src/shared/query.ts");
            /* harmony import */ var _shared_util__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../shared/util */ "./packages/loot-core/src/shared/util.ts");
            /* harmony import */ var _accounts_export_to_csv__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./accounts/export-to-csv */ "./packages/loot-core/src/server/accounts/export-to-csv.ts");
            /* harmony import */ var _accounts_link__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./accounts/link */ "./packages/loot-core/src/server/accounts/link.ts");
            /* harmony import */ var _accounts_parse_file__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./accounts/parse-file */ "./packages/loot-core/src/server/accounts/parse-file.ts");
            /* harmony import */ var _accounts_payees__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./accounts/payees */ "./packages/loot-core/src/server/accounts/payees.ts");
            /* harmony import */ var _accounts_sync__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./accounts/sync */ "./packages/loot-core/src/server/accounts/sync.ts");
            /* harmony import */ var _accounts_transaction_rules__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./accounts/transaction-rules */ "./packages/loot-core/src/server/accounts/transaction-rules.ts");
            /* harmony import */ var _accounts_transactions__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./accounts/transactions */ "./packages/loot-core/src/server/accounts/transactions.ts");
            /* harmony import */ var _api__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ./api */ "./packages/loot-core/src/server/api.ts");
            /* harmony import */ var _aql__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ./aql */ "./packages/loot-core/src/server/aql/index.ts");
            /* harmony import */ var _backups__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! ./backups */ "./packages/loot-core/src/server/backups.ts");
            /* harmony import */ var _budget_app__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! ./budget/app */ "./packages/loot-core/src/server/budget/app.ts");
            /* harmony import */ var _budget_base__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! ./budget/base */ "./packages/loot-core/src/server/budget/base.ts");
            /* harmony import */ var _cloud_storage__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(/*! ./cloud-storage */ "./packages/loot-core/src/server/cloud-storage.ts");
            /* harmony import */ var _db__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__(/*! ./db */ "./packages/loot-core/src/server/db/index.ts");
            /* harmony import */ var _db_mappings__WEBPACK_IMPORTED_MODULE_28__ = __webpack_require__(/*! ./db/mappings */ "./packages/loot-core/src/server/db/mappings.ts");
            /* harmony import */ var _encryption__WEBPACK_IMPORTED_MODULE_29__ = __webpack_require__(/*! ./encryption */ "./packages/loot-core/src/server/encryption.ts");
            /* harmony import */ var _errors__WEBPACK_IMPORTED_MODULE_30__ = __webpack_require__(/*! ./errors */ "./packages/loot-core/src/server/errors.ts");
            /* harmony import */ var _filters_app__WEBPACK_IMPORTED_MODULE_31__ = __webpack_require__(/*! ./filters/app */ "./packages/loot-core/src/server/filters/app.ts");
            /* harmony import */ var _importers__WEBPACK_IMPORTED_MODULE_32__ = __webpack_require__(/*! ./importers */ "./packages/loot-core/src/server/importers/index.ts");
            /* harmony import */ var _main_app__WEBPACK_IMPORTED_MODULE_33__ = __webpack_require__(/*! ./main-app */ "./packages/loot-core/src/server/main-app.ts");
            /* harmony import */ var _mutators__WEBPACK_IMPORTED_MODULE_34__ = __webpack_require__(/*! ./mutators */ "./packages/loot-core/src/server/mutators.ts");
            /* harmony import */ var _notes_app__WEBPACK_IMPORTED_MODULE_35__ = __webpack_require__(/*! ./notes/app */ "./packages/loot-core/src/server/notes/app.ts");
            /* harmony import */ var _platform__WEBPACK_IMPORTED_MODULE_36__ = __webpack_require__(/*! ./platform */ "./packages/loot-core/src/server/platform.ts");
            /* harmony import */ var _post__WEBPACK_IMPORTED_MODULE_37__ = __webpack_require__(/*! ./post */ "./packages/loot-core/src/server/post.ts");
            /* harmony import */ var _prefs__WEBPACK_IMPORTED_MODULE_38__ = __webpack_require__(/*! ./prefs */ "./packages/loot-core/src/server/prefs.ts");
            /* harmony import */ var _reports_app__WEBPACK_IMPORTED_MODULE_39__ = __webpack_require__(/*! ./reports/app */ "./packages/loot-core/src/server/reports/app.ts");
            /* harmony import */ var _rules_app__WEBPACK_IMPORTED_MODULE_40__ = __webpack_require__(/*! ./rules/app */ "./packages/loot-core/src/server/rules/app.ts");
            /* harmony import */ var _schedules_app__WEBPACK_IMPORTED_MODULE_41__ = __webpack_require__(/*! ./schedules/app */ "./packages/loot-core/src/server/schedules/app.ts");
            /* harmony import */ var _server_config__WEBPACK_IMPORTED_MODULE_42__ = __webpack_require__(/*! ./server-config */ "./packages/loot-core/src/server/server-config.ts");
            /* harmony import */ var _sheet__WEBPACK_IMPORTED_MODULE_43__ = __webpack_require__(/*! ./sheet */ "./packages/loot-core/src/server/sheet.ts");
            /* harmony import */ var _spreadsheet_util__WEBPACK_IMPORTED_MODULE_44__ = __webpack_require__(/*! ./spreadsheet/util */ "./packages/loot-core/src/server/spreadsheet/util.ts");
            /* harmony import */ var _sync__WEBPACK_IMPORTED_MODULE_45__ = __webpack_require__(/*! ./sync */ "./packages/loot-core/src/server/sync/index.ts");
            /* harmony import */ var _sync_migrate__WEBPACK_IMPORTED_MODULE_46__ = __webpack_require__(/*! ./sync/migrate */ "./packages/loot-core/src/server/sync/migrate.ts");
            /* harmony import */ var _tools_app__WEBPACK_IMPORTED_MODULE_47__ = __webpack_require__(/*! ./tools/app */ "./packages/loot-core/src/server/tools/app.ts");
            /* harmony import */ var _undo__WEBPACK_IMPORTED_MODULE_48__ = __webpack_require__(/*! ./undo */ "./packages/loot-core/src/server/undo.ts");
            /* harmony import */ var _update__WEBPACK_IMPORTED_MODULE_49__ = __webpack_require__(/*! ./update */ "./packages/loot-core/src/server/update.ts");
            /* harmony import */ var _util_budget_name__WEBPACK_IMPORTED_MODULE_50__ = __webpack_require__(/*! ./util/budget-name */ "./packages/loot-core/src/server/util/budget-name.ts");
            // @ts-strict-ignore
            const DEMO_BUDGET_ID = '_demo-budget';
            const TEST_BUDGET_ID = '_test-budget';
            // util
            function onSheetChange({ names }) {
                const nodes = names.map((name) => {
                    const node = _sheet__WEBPACK_IMPORTED_MODULE_43__.get()._getNode(name);
                    return {
                        name: node.name,
                        value: node.value
                    };
                });
                _platform_server_connection__WEBPACK_IMPORTED_MODULE_6__.send('cells-changed', nodes);
            }
            // handlers
            // need to work around the type system here because the object
            // is /currently/ empty but we promise to fill it in later
            let handlers = {};
            handlers['undo'] = (0, _mutators__WEBPACK_IMPORTED_MODULE_34__.mutator)(async function () {
                return (0, _undo__WEBPACK_IMPORTED_MODULE_48__.undo)();
            });
            handlers['redo'] = (0, _mutators__WEBPACK_IMPORTED_MODULE_34__.mutator)(function () {
                return (0, _undo__WEBPACK_IMPORTED_MODULE_48__.redo)();
            });
            handlers['transactions-batch-update'] = (0, _mutators__WEBPACK_IMPORTED_MODULE_34__.mutator)(async function ({ added, deleted, updated, learnCategories }) {
                return (0, _undo__WEBPACK_IMPORTED_MODULE_48__.withUndo)(async () => {
                    const result = await (0, _accounts_transactions__WEBPACK_IMPORTED_MODULE_20__.batchUpdateTransactions)({
                        added,
                        updated,
                        deleted,
                        learnCategories
                    });
                    return result;
                });
            });
            handlers['transaction-add'] = (0, _mutators__WEBPACK_IMPORTED_MODULE_34__.mutator)(async function (transaction) {
                await handlers['transactions-batch-update']({
                    added: [
                        transaction
                    ]
                });
                return {};
            });
            handlers['transaction-update'] = (0, _mutators__WEBPACK_IMPORTED_MODULE_34__.mutator)(async function (transaction) {
                await handlers['transactions-batch-update']({
                    updated: [
                        transaction
                    ]
                });
                return {};
            });
            handlers['transaction-delete'] = (0, _mutators__WEBPACK_IMPORTED_MODULE_34__.mutator)(async function (transaction) {
                await handlers['transactions-batch-update']({
                    deleted: [
                        transaction
                    ]
                });
                return {};
            });
            handlers['transactions-parse-file'] = async function ({ filepath, options }) {
                return (0, _accounts_parse_file__WEBPACK_IMPORTED_MODULE_16__.parseFile)(filepath, options);
            };
            handlers['transactions-export'] = async function ({ transactions, accounts, categoryGroups, payees }) {
                return (0, _accounts_export_to_csv__WEBPACK_IMPORTED_MODULE_14__.exportToCSV)(transactions, accounts, categoryGroups, payees);
            };
            handlers['transactions-export-query'] = async function ({ query: queryState }) {
                return (0, _accounts_export_to_csv__WEBPACK_IMPORTED_MODULE_14__.exportQueryToCSV)(new _shared_query__WEBPACK_IMPORTED_MODULE_12__.Query(queryState));
            };
            handlers['get-categories'] = async function () {
                return {
                    grouped: await _db__WEBPACK_IMPORTED_MODULE_27__.getCategoriesGrouped(),
                    list: await _db__WEBPACK_IMPORTED_MODULE_27__.getCategories()
                };
            };
            handlers['get-earliest-transaction'] = async function () {
                const { data } = await (0, _aql__WEBPACK_IMPORTED_MODULE_22__.runQuery)((0, _shared_query__WEBPACK_IMPORTED_MODULE_12__.q)('transactions').options({
                    splits: 'none'
                }).orderBy({
                    date: 'asc'
                }).select('*').limit(1));
                return data[0] || null;
            };
            handlers['get-budget-bounds'] = async function () {
                return _budget_base__WEBPACK_IMPORTED_MODULE_25__.createAllBudgets();
            };
            handlers['rollover-budget-month'] = async function ({ month }) {
                const groups = await _db__WEBPACK_IMPORTED_MODULE_27__.getCategoriesGrouped();
                const sheetName = _shared_months__WEBPACK_IMPORTED_MODULE_11__.sheetForMonth(month);
                function value(name) {
                    const v = _sheet__WEBPACK_IMPORTED_MODULE_43__.getCellValue(sheetName, name);
                    return {
                        value: v === '' ? 0 : v,
                        name: (0, _spreadsheet_util__WEBPACK_IMPORTED_MODULE_44__.resolveName)(sheetName, name)
                    };
                }
                let values = [
                    value('available-funds'),
                    value('last-month-overspent'),
                    value('buffered'),
                    value('total-budgeted'),
                    value('to-budget'),
                    value('from-last-month'),
                    value('total-income'),
                    value('total-spent'),
                    value('total-leftover')
                ];
                for (const group of groups) {
                    if (group.is_income) {
                        values.push(value('total-income'));
                        for (const cat of group.categories) {
                            values.push(value(`sum-amount-${cat.id}`));
                        }
                    }
                    else {
                        values = values.concat([
                            value(`group-budget-${group.id}`),
                            value(`group-sum-amount-${group.id}`),
                            value(`group-leftover-${group.id}`)
                        ]);
                        for (const cat of group.categories) {
                            values = values.concat([
                                value(`budget-${cat.id}`),
                                value(`sum-amount-${cat.id}`),
                                value(`leftover-${cat.id}`),
                                value(`carryover-${cat.id}`)
                            ]);
                        }
                    }
                }
                return values;
            };
            handlers['report-budget-month'] = async function ({ month }) {
                const groups = await _db__WEBPACK_IMPORTED_MODULE_27__.getCategoriesGrouped();
                const sheetName = _shared_months__WEBPACK_IMPORTED_MODULE_11__.sheetForMonth(month);
                function value(name) {
                    const v = _sheet__WEBPACK_IMPORTED_MODULE_43__.getCellValue(sheetName, name);
                    return {
                        value: v === '' ? 0 : v,
                        name: (0, _spreadsheet_util__WEBPACK_IMPORTED_MODULE_44__.resolveName)(sheetName, name)
                    };
                }
                let values = [
                    value('total-budgeted'),
                    value('total-budget-income'),
                    value('total-saved'),
                    value('total-income'),
                    value('total-spent'),
                    value('real-saved'),
                    value('total-leftover')
                ];
                for (const group of groups) {
                    values = values.concat([
                        value(`group-budget-${group.id}`),
                        value(`group-sum-amount-${group.id}`),
                        value(`group-leftover-${group.id}`)
                    ]);
                    for (const cat of group.categories) {
                        values = values.concat([
                            value(`budget-${cat.id}`),
                            value(`sum-amount-${cat.id}`),
                            value(`leftover-${cat.id}`)
                        ]);
                        if (!group.is_income) {
                            values.push(value(`carryover-${cat.id}`));
                        }
                    }
                }
                return values;
            };
            handlers['budget-set-type'] = async function ({ type }) {
                if (!_prefs__WEBPACK_IMPORTED_MODULE_38__.BUDGET_TYPES.includes(type)) {
                    throw new Error('Invalid budget type: ' + type);
                }
                // It's already the same; don't do anything
                if (type === _prefs__WEBPACK_IMPORTED_MODULE_38__.getPrefs().budgetType) {
                    return;
                }
                // Save prefs
                return _prefs__WEBPACK_IMPORTED_MODULE_38__.savePrefs({
                    budgetType: type
                });
            };
            handlers['category-create'] = (0, _mutators__WEBPACK_IMPORTED_MODULE_34__.mutator)(async function ({ name, groupId, isIncome, hidden }) {
                return (0, _undo__WEBPACK_IMPORTED_MODULE_48__.withUndo)(async () => {
                    if (!groupId) {
                        throw (0, _errors__WEBPACK_IMPORTED_MODULE_30__.APIError)('Creating a category: groupId is required');
                    }
                    return _db__WEBPACK_IMPORTED_MODULE_27__.insertCategory({
                        name,
                        cat_group: groupId,
                        is_income: isIncome ? 1 : 0,
                        hidden: hidden ? 1 : 0
                    });
                });
            });
            handlers['category-update'] = (0, _mutators__WEBPACK_IMPORTED_MODULE_34__.mutator)(async function (category) {
                return (0, _undo__WEBPACK_IMPORTED_MODULE_48__.withUndo)(async () => {
                    try {
                        await _db__WEBPACK_IMPORTED_MODULE_27__.updateCategory(category);
                    }
                    catch (e) {
                        if (e.message.toLowerCase().includes('unique constraint')) {
                            return {
                                error: {
                                    type: 'category-exists'
                                }
                            };
                        }
                        throw e;
                    }
                    return {};
                });
            });
            handlers['category-move'] = (0, _mutators__WEBPACK_IMPORTED_MODULE_34__.mutator)(async function ({ id, groupId, targetId }) {
                return (0, _undo__WEBPACK_IMPORTED_MODULE_48__.withUndo)(async () => {
                    await (0, _sync__WEBPACK_IMPORTED_MODULE_45__.batchMessages)(async () => {
                        await _db__WEBPACK_IMPORTED_MODULE_27__.moveCategory(id, groupId, targetId);
                    });
                    return 'ok';
                });
            });
            handlers['category-delete'] = (0, _mutators__WEBPACK_IMPORTED_MODULE_34__.mutator)(async function ({ id, transferId }) {
                return (0, _undo__WEBPACK_IMPORTED_MODULE_48__.withUndo)(async () => {
                    let result = {};
                    await (0, _sync__WEBPACK_IMPORTED_MODULE_45__.batchMessages)(async () => {
                        const row = await _db__WEBPACK_IMPORTED_MODULE_27__.first('SELECT is_income FROM categories WHERE id = ?', [
                            id
                        ]);
                        if (!row) {
                            result = {
                                error: 'no-categories'
                            };
                            return;
                        }
                        const transfer = transferId && await _db__WEBPACK_IMPORTED_MODULE_27__.first('SELECT is_income FROM categories WHERE id = ?', [
                            transferId
                        ]);
                        if (!row || transferId && !transfer) {
                            result = {
                                error: 'no-categories'
                            };
                            return;
                        }
                        else if (transferId && row.is_income !== transfer.is_income) {
                            result = {
                                error: 'category-type'
                            };
                            return;
                        }
                        // Update spreadsheet values if it's an expense category
                        // TODO: We should do this for income too if it's a reflect budget
                        if (row.is_income === 0) {
                            if (transferId) {
                                await _budget_base__WEBPACK_IMPORTED_MODULE_25__.doTransfer([
                                    id
                                ], transferId);
                            }
                        }
                        await _db__WEBPACK_IMPORTED_MODULE_27__.deleteCategory({
                            id
                        }, transferId);
                    });
                    return result;
                });
            });
            handlers['get-category-groups'] = async function () {
                return await _db__WEBPACK_IMPORTED_MODULE_27__.getCategoriesGrouped();
            };
            handlers['category-group-create'] = (0, _mutators__WEBPACK_IMPORTED_MODULE_34__.mutator)(async function ({ name, isIncome }) {
                return (0, _undo__WEBPACK_IMPORTED_MODULE_48__.withUndo)(async () => {
                    return _db__WEBPACK_IMPORTED_MODULE_27__.insertCategoryGroup({
                        name,
                        is_income: isIncome ? 1 : 0
                    });
                });
            });
            handlers['category-group-update'] = (0, _mutators__WEBPACK_IMPORTED_MODULE_34__.mutator)(async function (group) {
                return (0, _undo__WEBPACK_IMPORTED_MODULE_48__.withUndo)(async () => {
                    return _db__WEBPACK_IMPORTED_MODULE_27__.updateCategoryGroup(group);
                });
            });
            handlers['category-group-move'] = (0, _mutators__WEBPACK_IMPORTED_MODULE_34__.mutator)(async function ({ id, targetId }) {
                return (0, _undo__WEBPACK_IMPORTED_MODULE_48__.withUndo)(async () => {
                    await (0, _sync__WEBPACK_IMPORTED_MODULE_45__.batchMessages)(async () => {
                        await _db__WEBPACK_IMPORTED_MODULE_27__.moveCategoryGroup(id, targetId);
                    });
                    return 'ok';
                });
            });
            handlers['category-group-delete'] = (0, _mutators__WEBPACK_IMPORTED_MODULE_34__.mutator)(async function ({ id, transferId }) {
                return (0, _undo__WEBPACK_IMPORTED_MODULE_48__.withUndo)(async () => {
                    const groupCategories = await _db__WEBPACK_IMPORTED_MODULE_27__.all('SELECT id FROM categories WHERE cat_group = ? AND tombstone = 0', [
                        id
                    ]);
                    return (0, _sync__WEBPACK_IMPORTED_MODULE_45__.batchMessages)(async () => {
                        if (transferId) {
                            await _budget_base__WEBPACK_IMPORTED_MODULE_25__.doTransfer(groupCategories.map((c) => c.id), transferId);
                        }
                        await _db__WEBPACK_IMPORTED_MODULE_27__.deleteCategoryGroup({
                            id
                        }, transferId);
                    });
                });
            });
            handlers['must-category-transfer'] = async function ({ id }) {
                const res = await _db__WEBPACK_IMPORTED_MODULE_27__.runQuery(`SELECT count(t.id) as count FROM transactions t
       LEFT JOIN category_mapping cm ON cm.id = t.category
       WHERE cm.transferId = ? AND t.tombstone = 0`, [
                    id
                ], true);
                // If there are transactions with this category, return early since
                // we already know it needs to be tranferred
                if (res[0].count !== 0) {
                    return true;
                }
                // If there are any non-zero budget values, also force the user to
                // transfer the category.
                return [
                    ..._sheet__WEBPACK_IMPORTED_MODULE_43__.get().meta().createdMonths
                ].some((month) => {
                    const sheetName = _shared_months__WEBPACK_IMPORTED_MODULE_11__.sheetForMonth(month);
                    const value = _sheet__WEBPACK_IMPORTED_MODULE_43__.get().getCellValue(sheetName, 'budget-' + id);
                    return value != null && value !== 0;
                });
            };
            handlers['payee-create'] = (0, _mutators__WEBPACK_IMPORTED_MODULE_34__.mutator)(async function ({ name }) {
                return (0, _undo__WEBPACK_IMPORTED_MODULE_48__.withUndo)(async () => {
                    return _db__WEBPACK_IMPORTED_MODULE_27__.insertPayee({
                        name
                    });
                });
            });
            handlers['common-payees-get'] = async function () {
                return _db__WEBPACK_IMPORTED_MODULE_27__.getCommonPayees();
            };
            handlers['payees-get'] = async function () {
                return _db__WEBPACK_IMPORTED_MODULE_27__.getPayees();
            };
            handlers['payees-get-orphaned'] = async function () {
                return _db__WEBPACK_IMPORTED_MODULE_27__.syncGetOrphanedPayees();
            };
            handlers['payees-get-rule-counts'] = async function () {
                const payeeCounts = {};
                _accounts_transaction_rules__WEBPACK_IMPORTED_MODULE_19__.iterateIds(_accounts_transaction_rules__WEBPACK_IMPORTED_MODULE_19__.getRules(), 'payee', (rule, id) => {
                    if (payeeCounts[id] == null) {
                        payeeCounts[id] = 0;
                    }
                    payeeCounts[id]++;
                });
                return payeeCounts;
            };
            handlers['payees-merge'] = (0, _mutators__WEBPACK_IMPORTED_MODULE_34__.mutator)(async function ({ targetId, mergeIds }) {
                return (0, _undo__WEBPACK_IMPORTED_MODULE_48__.withUndo)(async () => {
                    return _db__WEBPACK_IMPORTED_MODULE_27__.mergePayees(targetId, mergeIds);
                }, {
                    targetId,
                    mergeIds
                });
            });
            handlers['payees-batch-change'] = (0, _mutators__WEBPACK_IMPORTED_MODULE_34__.mutator)(async function ({ added, deleted, updated }) {
                return (0, _undo__WEBPACK_IMPORTED_MODULE_48__.withUndo)(async () => {
                    return (0, _sync__WEBPACK_IMPORTED_MODULE_45__.batchMessages)(async () => {
                        if (deleted) {
                            await Promise.all(deleted.map((p) => _db__WEBPACK_IMPORTED_MODULE_27__.deletePayee(p)));
                        }
                        if (added) {
                            await Promise.all(added.map((p) => _db__WEBPACK_IMPORTED_MODULE_27__.insertPayee(p)));
                        }
                        if (updated) {
                            await Promise.all(updated.map((p) => _db__WEBPACK_IMPORTED_MODULE_27__.updatePayee(p)));
                        }
                    });
                });
            });
            handlers['payees-check-orphaned'] = async function ({ ids }) {
                const orphaned = new Set(await _db__WEBPACK_IMPORTED_MODULE_27__.getOrphanedPayees());
                return ids.filter((id) => orphaned.has(id));
            };
            handlers['payees-get-rules'] = async function ({ id }) {
                return _accounts_transaction_rules__WEBPACK_IMPORTED_MODULE_19__.getRulesForPayee(id).map((rule) => rule.serialize());
            };
            handlers['make-filters-from-conditions'] = async function ({ conditions }) {
                return _accounts_transaction_rules__WEBPACK_IMPORTED_MODULE_19__.conditionsToAQL(conditions);
            };
            handlers['getCell'] = async function ({ sheetName, name }) {
                // Fields is no longer used - hardcode
                const fields = [
                    'name',
                    'value'
                ];
                const node = _sheet__WEBPACK_IMPORTED_MODULE_43__.get()._getNode((0, _spreadsheet_util__WEBPACK_IMPORTED_MODULE_44__.resolveName)(sheetName, name));
                if (fields) {
                    const res = {};
                    fields.forEach((field) => {
                        if (field === 'run') {
                            res[field] = node._run ? node._run.toString() : null;
                        }
                        else {
                            res[field] = node[field];
                        }
                    });
                    return res;
                }
                else {
                    return node;
                }
            };
            handlers['getCells'] = async function ({ names }) {
                return names.map((name) => ({
                    value: _sheet__WEBPACK_IMPORTED_MODULE_43__.get()._getNode(name).value
                }));
            };
            handlers['getCellNamesInSheet'] = async function ({ sheetName }) {
                const names = [];
                for (const name of _sheet__WEBPACK_IMPORTED_MODULE_43__.get().getNodes().keys()) {
                    const { sheet: nodeSheet, name: nodeName } = (0, _spreadsheet_util__WEBPACK_IMPORTED_MODULE_44__.unresolveName)(name);
                    if (nodeSheet === sheetName) {
                        names.push(nodeName);
                    }
                }
                return names;
            };
            handlers['debugCell'] = async function ({ sheetName, name }) {
                const node = _sheet__WEBPACK_IMPORTED_MODULE_43__.get().getNode((0, _spreadsheet_util__WEBPACK_IMPORTED_MODULE_44__.resolveName)(sheetName, name));
                return {
                    ...node,
                    _run: node._run && node._run.toString()
                };
            };
            handlers['create-query'] = async function ({ sheetName, name, query }) {
                // Always run it regardless of cache. We don't know anything has changed
                // between the cache value being saved and now
                _sheet__WEBPACK_IMPORTED_MODULE_43__.get().createQuery(sheetName, name, query);
                return 'ok';
            };
            handlers['query'] = async function (query) {
                if (query.table == null) {
                    throw new Error('query has no table, did you forgot to call `.serialize`?');
                }
                return (0, _aql__WEBPACK_IMPORTED_MODULE_22__.runQuery)(query);
            };
            handlers['account-update'] = (0, _mutators__WEBPACK_IMPORTED_MODULE_34__.mutator)(async function ({ id, name }) {
                return (0, _undo__WEBPACK_IMPORTED_MODULE_48__.withUndo)(async () => {
                    await _db__WEBPACK_IMPORTED_MODULE_27__.update('accounts', {
                        id,
                        name
                    });
                    return {};
                });
            });
            handlers['accounts-get'] = async function () {
                return _db__WEBPACK_IMPORTED_MODULE_27__.getAccounts();
            };
            handlers['account-balance'] = async function ({ id, cutoff }) {
                const { balance } = await _db__WEBPACK_IMPORTED_MODULE_27__.first('SELECT sum(amount) as balance FROM transactions WHERE acct = ? AND isParent = 0 AND tombstone = 0 AND date <= ?', [
                    id,
                    _db__WEBPACK_IMPORTED_MODULE_27__.toDateRepr((0, _shared_months__WEBPACK_IMPORTED_MODULE_11__.dayFromDate)(cutoff))
                ]);
                return balance ? balance : 0;
            };
            handlers['account-properties'] = async function ({ id }) {
                const { balance } = await _db__WEBPACK_IMPORTED_MODULE_27__.first('SELECT sum(amount) as balance FROM transactions WHERE acct = ? AND isParent = 0 AND tombstone = 0', [
                    id
                ]);
                const { count } = await _db__WEBPACK_IMPORTED_MODULE_27__.first('SELECT count(id) as count FROM transactions WHERE acct = ? AND tombstone = 0', [
                    id
                ]);
                return {
                    balance: balance || 0,
                    numTransactions: count
                };
            };
            handlers['gocardless-accounts-link'] = async function ({ requisitionId, account, upgradingId, offBudget }) {
                let id;
                const bank = await _accounts_link__WEBPACK_IMPORTED_MODULE_15__.findOrCreateBank(account.institution, requisitionId);
                if (upgradingId) {
                    const accRow = await _db__WEBPACK_IMPORTED_MODULE_27__.first('SELECT * FROM accounts WHERE id = ?', [
                        upgradingId
                    ]);
                    id = accRow.id;
                    await _db__WEBPACK_IMPORTED_MODULE_27__.update('accounts', {
                        id,
                        account_id: account.account_id,
                        bank: bank.id,
                        account_sync_source: 'goCardless'
                    });
                }
                else {
                    id = (0, uuid__WEBPACK_IMPORTED_MODULE_51__["default"])();
                    await _db__WEBPACK_IMPORTED_MODULE_27__.insertWithUUID('accounts', {
                        id,
                        account_id: account.account_id,
                        mask: account.mask,
                        name: account.name,
                        official_name: account.official_name,
                        bank: bank.id,
                        offbudget: offBudget ? 1 : 0,
                        account_sync_source: 'goCardless'
                    });
                    await _db__WEBPACK_IMPORTED_MODULE_27__.insertPayee({
                        name: '',
                        transfer_acct: id
                    });
                }
                await _accounts_sync__WEBPACK_IMPORTED_MODULE_18__.syncAccount(undefined, undefined, id, account.account_id, bank.bank_id);
                _platform_server_connection__WEBPACK_IMPORTED_MODULE_6__.send('sync-event', {
                    type: 'success',
                    tables: [
                        'transactions'
                    ]
                });
                return 'ok';
            };
            handlers['simplefin-accounts-link'] = async function ({ externalAccount, upgradingId, offBudget }) {
                let id;
                const institution = {
                    name: externalAccount.institution ?? 'Unknown'
                };
                const bank = await _accounts_link__WEBPACK_IMPORTED_MODULE_15__.findOrCreateBank(institution, externalAccount.orgDomain ?? externalAccount.orgId);
                if (upgradingId) {
                    const accRow = await _db__WEBPACK_IMPORTED_MODULE_27__.first('SELECT * FROM accounts WHERE id = ?', [
                        upgradingId
                    ]);
                    id = accRow.id;
                    await _db__WEBPACK_IMPORTED_MODULE_27__.update('accounts', {
                        id,
                        account_id: externalAccount.account_id,
                        bank: bank.id,
                        account_sync_source: 'simpleFin'
                    });
                }
                else {
                    id = (0, uuid__WEBPACK_IMPORTED_MODULE_51__["default"])();
                    await _db__WEBPACK_IMPORTED_MODULE_27__.insertWithUUID('accounts', {
                        id,
                        account_id: externalAccount.account_id,
                        name: externalAccount.name,
                        official_name: externalAccount.name,
                        bank: bank.id,
                        offbudget: offBudget ? 1 : 0,
                        account_sync_source: 'simpleFin'
                    });
                    await _db__WEBPACK_IMPORTED_MODULE_27__.insertPayee({
                        name: '',
                        transfer_acct: id
                    });
                }
                await _accounts_sync__WEBPACK_IMPORTED_MODULE_18__.syncAccount(undefined, undefined, id, externalAccount.account_id, bank.bank_id);
                await _platform_server_connection__WEBPACK_IMPORTED_MODULE_6__.send('sync-event', {
                    type: 'success',
                    tables: [
                        'transactions'
                    ]
                });
                return 'ok';
            };
            handlers['account-create'] = (0, _mutators__WEBPACK_IMPORTED_MODULE_34__.mutator)(async function ({ name, balance, offBudget, closed }) {
                return (0, _undo__WEBPACK_IMPORTED_MODULE_48__.withUndo)(async () => {
                    const id = await _db__WEBPACK_IMPORTED_MODULE_27__.insertAccount({
                        name,
                        offbudget: offBudget ? 1 : 0,
                        closed: closed ? 1 : 0
                    });
                    await _db__WEBPACK_IMPORTED_MODULE_27__.insertPayee({
                        name: '',
                        transfer_acct: id
                    });
                    if (balance != null && balance !== 0) {
                        const payee = await (0, _accounts_payees__WEBPACK_IMPORTED_MODULE_17__.getStartingBalancePayee)();
                        await _db__WEBPACK_IMPORTED_MODULE_27__.insertTransaction({
                            account: id,
                            amount: (0, _shared_util__WEBPACK_IMPORTED_MODULE_13__.amountToInteger)(balance),
                            category: offBudget ? null : payee.category,
                            payee: payee.id,
                            date: _shared_months__WEBPACK_IMPORTED_MODULE_11__.currentDay(),
                            cleared: true,
                            starting_balance_flag: true
                        });
                    }
                    return id;
                });
            });
            handlers['account-close'] = (0, _mutators__WEBPACK_IMPORTED_MODULE_34__.mutator)(async function ({ id, transferAccountId, categoryId, forced }) {
                // Unlink the account if it's linked. This makes sure to remove it from
                // bank-sync providers. (This should not be undo-able, as it mutates the
                // remote server and the user will have to link the account again)
                await handlers['account-unlink']({
                    id
                });
                return (0, _undo__WEBPACK_IMPORTED_MODULE_48__.withUndo)(async () => {
                    const account = await _db__WEBPACK_IMPORTED_MODULE_27__.first('SELECT * FROM accounts WHERE id = ? AND tombstone = 0', [
                        id
                    ]);
                    // Do nothing if the account doesn't exist or it's already been
                    // closed
                    if (!account || account.closed === 1) {
                        return;
                    }
                    const { balance, numTransactions } = await handlers['account-properties']({
                        id
                    });
                    // If there are no transactions, we can simply delete the account
                    if (numTransactions === 0) {
                        await _db__WEBPACK_IMPORTED_MODULE_27__.deleteAccount({
                            id
                        });
                    }
                    else if (forced) {
                        const rows = await _db__WEBPACK_IMPORTED_MODULE_27__.runQuery('SELECT id, transfer_id FROM v_transactions WHERE account = ?', [
                            id
                        ], true);
                        const { id: payeeId } = await _db__WEBPACK_IMPORTED_MODULE_27__.first('SELECT id FROM payees WHERE transfer_acct = ?', [
                            id
                        ]);
                        await (0, _sync__WEBPACK_IMPORTED_MODULE_45__.batchMessages)(async () => {
                            // TODO: what this should really do is send a special message that
                            // automatically marks the tombstone value for all transactions
                            // within an account... or something? This is problematic
                            // because another client could easily add new data that
                            // should be marked as deleted.
                            rows.forEach((row) => {
                                if (row.transfer_id) {
                                    _db__WEBPACK_IMPORTED_MODULE_27__.updateTransaction({
                                        id: row.transfer_id,
                                        payee: null,
                                        transfer_id: null
                                    });
                                }
                                _db__WEBPACK_IMPORTED_MODULE_27__.deleteTransaction({
                                    id: row.id
                                });
                            });
                            _db__WEBPACK_IMPORTED_MODULE_27__.deleteAccount({
                                id
                            });
                            _db__WEBPACK_IMPORTED_MODULE_27__.deleteTransferPayee({
                                id: payeeId
                            });
                        });
                    }
                    else {
                        if (balance !== 0 && transferAccountId == null) {
                            throw (0, _errors__WEBPACK_IMPORTED_MODULE_30__.APIError)('balance is non-zero: transferAccountId is required');
                        }
                        await _db__WEBPACK_IMPORTED_MODULE_27__.update('accounts', {
                            id,
                            closed: 1
                        });
                        // If there is a balance we need to transfer it to the specified
                        // account (and possibly categorize it)
                        if (balance !== 0) {
                            const { id: payeeId } = await _db__WEBPACK_IMPORTED_MODULE_27__.first('SELECT id FROM payees WHERE transfer_acct = ?', [
                                transferAccountId
                            ]);
                            await handlers['transaction-add']({
                                id: (0, uuid__WEBPACK_IMPORTED_MODULE_51__["default"])(),
                                payee: payeeId,
                                amount: -balance,
                                account: id,
                                date: _shared_months__WEBPACK_IMPORTED_MODULE_11__.currentDay(),
                                notes: 'Closing account',
                                category: categoryId || null
                            });
                        }
                    }
                });
            });
            handlers['account-reopen'] = (0, _mutators__WEBPACK_IMPORTED_MODULE_34__.mutator)(async function ({ id }) {
                return (0, _undo__WEBPACK_IMPORTED_MODULE_48__.withUndo)(async () => {
                    await _db__WEBPACK_IMPORTED_MODULE_27__.update('accounts', {
                        id,
                        closed: 0
                    });
                });
            });
            handlers['account-move'] = (0, _mutators__WEBPACK_IMPORTED_MODULE_34__.mutator)(async function ({ id, targetId }) {
                return (0, _undo__WEBPACK_IMPORTED_MODULE_48__.withUndo)(async () => {
                    await _db__WEBPACK_IMPORTED_MODULE_27__.moveAccount(id, targetId);
                });
            });
            let stopPolling = false;
            handlers['secret-set'] = async function ({ name, value }) {
                const userToken = await _platform_server_asyncStorage__WEBPACK_IMPORTED_MODULE_5__.getItem('user-token');
                if (!userToken) {
                    return {
                        error: 'unauthorized'
                    };
                }
                try {
                    return await (0, _post__WEBPACK_IMPORTED_MODULE_37__.post)((0, _server_config__WEBPACK_IMPORTED_MODULE_42__.getServer)().BASE_SERVER + '/secret', {
                        name,
                        value
                    }, {
                        'X-ACTUAL-TOKEN': userToken
                    });
                }
                catch (error) {
                    console.error(error);
                    return {
                        error: 'failed'
                    };
                }
            };
            handlers['secret-check'] = async function (name) {
                const userToken = await _platform_server_asyncStorage__WEBPACK_IMPORTED_MODULE_5__.getItem('user-token');
                if (!userToken) {
                    return {
                        error: 'unauthorized'
                    };
                }
                try {
                    return await (0, _post__WEBPACK_IMPORTED_MODULE_37__.get)((0, _server_config__WEBPACK_IMPORTED_MODULE_42__.getServer)().BASE_SERVER + '/secret/' + name, {
                        'X-ACTUAL-TOKEN': userToken
                    });
                }
                catch (error) {
                    console.error(error);
                    return {
                        error: 'failed'
                    };
                }
            };
            handlers['gocardless-poll-web-token'] = async function ({ upgradingAccountId, requisitionId }) {
                const userToken = await _platform_server_asyncStorage__WEBPACK_IMPORTED_MODULE_5__.getItem('user-token');
                if (!userToken)
                    return {
                        error: 'unknown'
                    };
                const startTime = Date.now();
                stopPolling = false;
                async function getData(cb) {
                    if (stopPolling) {
                        return;
                    }
                    if (Date.now() - startTime >= 1000 * 60 * 10) {
                        cb('timeout');
                        return;
                    }
                    const data = await (0, _post__WEBPACK_IMPORTED_MODULE_37__.post)((0, _server_config__WEBPACK_IMPORTED_MODULE_42__.getServer)().GOCARDLESS_SERVER + '/get-accounts', {
                        upgradingAccountId,
                        requisitionId
                    }, {
                        'X-ACTUAL-TOKEN': userToken
                    });
                    if (data) {
                        if (data.error) {
                            cb('unknown');
                        }
                        else {
                            cb(null, data);
                        }
                    }
                    else {
                        setTimeout(() => getData(cb), 3000);
                    }
                }
                return new Promise((resolve) => {
                    getData((error, data) => {
                        if (error) {
                            resolve({
                                error
                            });
                        }
                        else {
                            resolve({
                                data
                            });
                        }
                    });
                });
            };
            handlers['gocardless-status'] = async function () {
                const userToken = await _platform_server_asyncStorage__WEBPACK_IMPORTED_MODULE_5__.getItem('user-token');
                if (!userToken) {
                    return {
                        error: 'unauthorized'
                    };
                }
                return (0, _post__WEBPACK_IMPORTED_MODULE_37__.post)((0, _server_config__WEBPACK_IMPORTED_MODULE_42__.getServer)().GOCARDLESS_SERVER + '/status', {}, {
                    'X-ACTUAL-TOKEN': userToken
                });
            };
            handlers['simplefin-status'] = async function () {
                const userToken = await _platform_server_asyncStorage__WEBPACK_IMPORTED_MODULE_5__.getItem('user-token');
                if (!userToken) {
                    return {
                        error: 'unauthorized'
                    };
                }
                return (0, _post__WEBPACK_IMPORTED_MODULE_37__.post)((0, _server_config__WEBPACK_IMPORTED_MODULE_42__.getServer)().SIMPLEFIN_SERVER + '/status', {}, {
                    'X-ACTUAL-TOKEN': userToken
                });
            };
            handlers['simplefin-accounts'] = async function () {
                const userToken = await _platform_server_asyncStorage__WEBPACK_IMPORTED_MODULE_5__.getItem('user-token');
                if (!userToken) {
                    return {
                        error: 'unauthorized'
                    };
                }
                try {
                    return await (0, _post__WEBPACK_IMPORTED_MODULE_37__.post)((0, _server_config__WEBPACK_IMPORTED_MODULE_42__.getServer)().SIMPLEFIN_SERVER + '/accounts', {}, {
                        'X-ACTUAL-TOKEN': userToken
                    }, 60000);
                }
                catch (error) {
                    return {
                        error_code: 'TIMED_OUT'
                    };
                }
            };
            handlers['gocardless-get-banks'] = async function (country) {
                const userToken = await _platform_server_asyncStorage__WEBPACK_IMPORTED_MODULE_5__.getItem('user-token');
                if (!userToken) {
                    return {
                        error: 'unauthorized'
                    };
                }
                return (0, _post__WEBPACK_IMPORTED_MODULE_37__.post)((0, _server_config__WEBPACK_IMPORTED_MODULE_42__.getServer)().GOCARDLESS_SERVER + '/get-banks', {
                    country,
                    showDemo: (0, _shared_environment__WEBPACK_IMPORTED_MODULE_10__.isNonProductionEnvironment)()
                }, {
                    'X-ACTUAL-TOKEN': userToken
                });
            };
            handlers['gocardless-poll-web-token-stop'] = async function () {
                stopPolling = true;
                return 'ok';
            };
            handlers['gocardless-create-web-token'] = async function ({ upgradingAccountId, institutionId, accessValidForDays }) {
                const userToken = await _platform_server_asyncStorage__WEBPACK_IMPORTED_MODULE_5__.getItem('user-token');
                if (!userToken) {
                    return {
                        error: 'unauthorized'
                    };
                }
                try {
                    return await (0, _post__WEBPACK_IMPORTED_MODULE_37__.post)((0, _server_config__WEBPACK_IMPORTED_MODULE_42__.getServer)().GOCARDLESS_SERVER + '/create-web-token', {
                        upgradingAccountId,
                        institutionId,
                        accessValidForDays
                    }, {
                        'X-ACTUAL-TOKEN': userToken
                    });
                }
                catch (error) {
                    console.error(error);
                    return {
                        error: 'failed'
                    };
                }
            };
            handlers['accounts-bank-sync'] = async function ({ id }) {
                const [[, userId], [, userKey]] = await _platform_server_asyncStorage__WEBPACK_IMPORTED_MODULE_5__.multiGet([
                    'user-id',
                    'user-key'
                ]);
                const accounts = await _db__WEBPACK_IMPORTED_MODULE_27__.runQuery(`SELECT a.*, b.bank_id as bankId FROM accounts a
         LEFT JOIN banks b ON a.bank = b.id
         WHERE a.tombstone = 0 AND a.closed = 0 ${id ? 'AND a.id = ?' : ''}
         ORDER BY a.offbudget, a.sort_order`, id ? [
                    id
                ] : [], true);
                const errors = [];
                let newTransactions = [];
                let matchedTransactions = [];
                let updatedAccounts = [];
                for (let i = 0; i < accounts.length; i++) {
                    const acct = accounts[i];
                    if (acct.bankId) {
                        try {
                            console.group('Bank Sync operation for account:', acct.name);
                            const res = await _accounts_sync__WEBPACK_IMPORTED_MODULE_18__.syncAccount(userId, userKey, acct.id, acct.account_id, acct.bankId);
                            const { added, updated } = res;
                            newTransactions = newTransactions.concat(added);
                            matchedTransactions = matchedTransactions.concat(updated);
                            if (added.length > 0 || updated.length > 0) {
                                updatedAccounts = updatedAccounts.concat(acct.id);
                            }
                        }
                        catch (err) {
                            if (err.type === 'BankSyncError') {
                                errors.push({
                                    type: 'SyncError',
                                    accountId: acct.id,
                                    message: 'Failed syncing account ' + acct.name + '.',
                                    category: err.category,
                                    code: err.code
                                });
                            }
                            else if (err instanceof _errors__WEBPACK_IMPORTED_MODULE_30__.PostError && err.reason !== 'internal') {
                                errors.push({
                                    accountId: acct.id,
                                    message: err.reason ? err.reason : `Account ${acct.name} is not linked properly. Please link it again.`
                                });
                            }
                            else {
                                errors.push({
                                    accountId: acct.id,
                                    message: 'There was an internal error. Please get in touch https://actualbudget.org/contact for support.',
                                    internal: err.stack
                                });
                                err.message = 'Failed syncing account: ' + err.message;
                                (0, _platform_exceptions__WEBPACK_IMPORTED_MODULE_4__.captureException)(err);
                            }
                        }
                        finally {
                            console.groupEnd();
                        }
                    }
                }
                if (updatedAccounts.length > 0) {
                    _platform_server_connection__WEBPACK_IMPORTED_MODULE_6__.send('sync-event', {
                        type: 'success',
                        tables: [
                            'transactions'
                        ]
                    });
                }
                return {
                    errors,
                    newTransactions,
                    matchedTransactions,
                    updatedAccounts
                };
            };
            handlers['transactions-import'] = (0, _mutators__WEBPACK_IMPORTED_MODULE_34__.mutator)(function ({ accountId, transactions, isPreview }) {
                return (0, _undo__WEBPACK_IMPORTED_MODULE_48__.withUndo)(async () => {
                    if (typeof accountId !== 'string') {
                        throw (0, _errors__WEBPACK_IMPORTED_MODULE_30__.APIError)('transactions-import: accountId must be an id');
                    }
                    try {
                        return await _accounts_sync__WEBPACK_IMPORTED_MODULE_18__.reconcileTransactions(accountId, transactions, false, isPreview);
                    }
                    catch (err) {
                        if (err instanceof _errors__WEBPACK_IMPORTED_MODULE_30__.TransactionError) {
                            return {
                                errors: [
                                    {
                                        message: err.message
                                    }
                                ],
                                added: [],
                                updated: [],
                                updatedPreview: []
                            };
                        }
                        throw err;
                    }
                });
            });
            handlers['account-unlink'] = (0, _mutators__WEBPACK_IMPORTED_MODULE_34__.mutator)(async function ({ id }) {
                const { bank: bankId } = await _db__WEBPACK_IMPORTED_MODULE_27__.first('SELECT bank FROM accounts WHERE id = ?', [
                    id
                ]);
                if (!bankId) {
                    return 'ok';
                }
                const accRow = await _db__WEBPACK_IMPORTED_MODULE_27__.first('SELECT * FROM accounts WHERE id = ?', [
                    id
                ]);
                const isGoCardless = accRow.account_sync_source === 'goCardless';
                await _db__WEBPACK_IMPORTED_MODULE_27__.updateAccount({
                    id,
                    account_id: null,
                    bank: null,
                    balance_current: null,
                    balance_available: null,
                    balance_limit: null,
                    account_sync_source: null
                });
                if (isGoCardless === false) {
                    return;
                }
                const { count } = await _db__WEBPACK_IMPORTED_MODULE_27__.first('SELECT COUNT(*) as count FROM accounts WHERE bank = ?', [
                    bankId
                ]);
                // No more accounts are associated with this bank. We can remove
                // it from GoCardless.
                const userToken = await _platform_server_asyncStorage__WEBPACK_IMPORTED_MODULE_5__.getItem('user-token');
                if (!userToken) {
                    return 'ok';
                }
                if (count === 0) {
                    const { bank_id: requisitionId } = await _db__WEBPACK_IMPORTED_MODULE_27__.first('SELECT bank_id FROM banks WHERE id = ?', [
                        bankId
                    ]);
                    try {
                        await (0, _post__WEBPACK_IMPORTED_MODULE_37__.post)((0, _server_config__WEBPACK_IMPORTED_MODULE_42__.getServer)().GOCARDLESS_SERVER + '/remove-account', {
                            requisitionId
                        }, {
                            'X-ACTUAL-TOKEN': userToken
                        });
                    }
                    catch (error) {
                        console.log({
                            error
                        });
                    }
                }
                return 'ok';
            });
            handlers['save-global-prefs'] = async function (prefs) {
                if ('maxMonths' in prefs) {
                    await _platform_server_asyncStorage__WEBPACK_IMPORTED_MODULE_5__.setItem('max-months', '' + prefs.maxMonths);
                }
                if ('documentDir' in prefs) {
                    if (await _platform_server_fs__WEBPACK_IMPORTED_MODULE_7__.exists(prefs.documentDir)) {
                        await _platform_server_asyncStorage__WEBPACK_IMPORTED_MODULE_5__.setItem('document-dir', prefs.documentDir);
                    }
                }
                if ('floatingSidebar' in prefs) {
                    await _platform_server_asyncStorage__WEBPACK_IMPORTED_MODULE_5__.setItem('floating-sidebar', '' + prefs.floatingSidebar);
                }
                if ('theme' in prefs) {
                    await _platform_server_asyncStorage__WEBPACK_IMPORTED_MODULE_5__.setItem('theme', prefs.theme);
                }
                return 'ok';
            };
            handlers['load-global-prefs'] = async function () {
                const [[, floatingSidebar], [, maxMonths], [, documentDir], [, encryptKey], [, theme]] = await _platform_server_asyncStorage__WEBPACK_IMPORTED_MODULE_5__.multiGet([
                    'floating-sidebar',
                    'max-months',
                    'document-dir',
                    'encrypt-key',
                    'theme'
                ]);
                return {
                    floatingSidebar: floatingSidebar === 'true' ? true : false,
                    maxMonths: (0, _shared_util__WEBPACK_IMPORTED_MODULE_13__.stringToInteger)(maxMonths || ''),
                    documentDir: documentDir || getDefaultDocumentDir(),
                    keyId: encryptKey && JSON.parse(encryptKey).id,
                    theme: theme === 'light' || theme === 'dark' || theme === 'auto' || theme === 'development' || theme === 'midnight' ? theme : 'auto'
                };
            };
            handlers['save-prefs'] = async function (prefsToSet) {
                const { cloudFileId } = _prefs__WEBPACK_IMPORTED_MODULE_38__.getPrefs();
                // Need to sync the budget name on the server as well
                if (prefsToSet.budgetName && cloudFileId) {
                    const userToken = await _platform_server_asyncStorage__WEBPACK_IMPORTED_MODULE_5__.getItem('user-token');
                    await (0, _post__WEBPACK_IMPORTED_MODULE_37__.post)((0, _server_config__WEBPACK_IMPORTED_MODULE_42__.getServer)().SYNC_SERVER + '/update-user-filename', {
                        token: userToken,
                        fileId: cloudFileId,
                        name: prefsToSet.budgetName
                    });
                }
                await _prefs__WEBPACK_IMPORTED_MODULE_38__.savePrefs(prefsToSet);
                return 'ok';
            };
            handlers['load-prefs'] = async function () {
                return _prefs__WEBPACK_IMPORTED_MODULE_38__.getPrefs();
            };
            handlers['sync-reset'] = async function () {
                return await (0, _sync__WEBPACK_IMPORTED_MODULE_45__.resetSync)();
            };
            handlers['sync-repair'] = async function () {
                await (0, _sync__WEBPACK_IMPORTED_MODULE_45__.repairSync)();
            };
            // A user can only enable/change their key with the file loaded. This
            // will change in the future: during onboarding the user should be
            // able to enable encryption. (Imagine if they are importing data from
            // another source, they should be able to encrypt first)
            handlers['key-make'] = async function ({ password }) {
                if (!_prefs__WEBPACK_IMPORTED_MODULE_38__.getPrefs()) {
                    throw new Error('user-set-key must be called with file loaded');
                }
                const salt = _encryption__WEBPACK_IMPORTED_MODULE_29__.randomBytes(32).toString('base64');
                const id = (0, uuid__WEBPACK_IMPORTED_MODULE_51__["default"])();
                const key = await _encryption__WEBPACK_IMPORTED_MODULE_29__.createKey({
                    id,
                    password,
                    salt
                });
                // Load the key
                await _encryption__WEBPACK_IMPORTED_MODULE_29__.loadKey(key);
                // Make some test data to use if the key is valid or not
                const testContent = await (0, _sync__WEBPACK_IMPORTED_MODULE_45__.makeTestMessage)(key.getId());
                // Changing your key necessitates a sync reset as well. This will
                // clear all existing encrypted data from the server so you won't
                // have a mix of data encrypted with different keys.
                return await (0, _sync__WEBPACK_IMPORTED_MODULE_45__.resetSync)({
                    key,
                    salt,
                    testContent: JSON.stringify({
                        ...testContent,
                        value: testContent.value.toString('base64')
                    })
                });
            };
            // This can be called both while a file is already loaded or not. This
            // will see if a key is valid and if so save it off.
            handlers['key-test'] = async function ({ fileId, password }) {
                const userToken = await _platform_server_asyncStorage__WEBPACK_IMPORTED_MODULE_5__.getItem('user-token');
                if (fileId == null) {
                    fileId = _prefs__WEBPACK_IMPORTED_MODULE_38__.getPrefs().cloudFileId;
                }
                let res;
                try {
                    res = await (0, _post__WEBPACK_IMPORTED_MODULE_37__.post)((0, _server_config__WEBPACK_IMPORTED_MODULE_42__.getServer)().SYNC_SERVER + '/user-get-key', {
                        token: userToken,
                        fileId
                    });
                }
                catch (e) {
                    console.log(e);
                    return {
                        error: {
                            reason: 'network'
                        }
                    };
                }
                const { id, salt, test: originalTest } = res;
                let test = originalTest;
                if (test == null) {
                    return {
                        error: {
                            reason: 'old-key-style'
                        }
                    };
                }
                test = JSON.parse(test);
                const key = await _encryption__WEBPACK_IMPORTED_MODULE_29__.createKey({
                    id,
                    password,
                    salt
                });
                _encryption__WEBPACK_IMPORTED_MODULE_29__.loadKey(key);
                try {
                    await _encryption__WEBPACK_IMPORTED_MODULE_29__.decrypt(Buffer.from(test.value, 'base64'), test.meta);
                }
                catch (e) {
                    console.log(e);
                    // Unload the key, it's invalid
                    _encryption__WEBPACK_IMPORTED_MODULE_29__.unloadKey(key);
                    return {
                        error: {
                            reason: 'decrypt-failure'
                        }
                    };
                }
                // Persist key in async storage
                const keys = JSON.parse(await _platform_server_asyncStorage__WEBPACK_IMPORTED_MODULE_5__.getItem(`encrypt-keys`) || '{}');
                keys[fileId] = key.serialize();
                await _platform_server_asyncStorage__WEBPACK_IMPORTED_MODULE_5__.setItem('encrypt-keys', JSON.stringify(keys));
                // Save the key id in prefs if the are loaded. If they aren't, we
                // are testing a key to download a file and when the file is
                // actually downloaded it will update the prefs with the latest key id
                if (_prefs__WEBPACK_IMPORTED_MODULE_38__.getPrefs()) {
                    await _prefs__WEBPACK_IMPORTED_MODULE_38__.savePrefs({
                        encryptKeyId: key.getId()
                    });
                }
                return {};
            };
            handlers['get-did-bootstrap'] = async function () {
                return Boolean(await _platform_server_asyncStorage__WEBPACK_IMPORTED_MODULE_5__.getItem('did-bootstrap'));
            };
            handlers['subscribe-needs-bootstrap'] = async function ({ url } = {}) {
                try {
                    if (!(0, _server_config__WEBPACK_IMPORTED_MODULE_42__.getServer)(url)) {
                        return {
                            bootstrapped: true,
                            hasServer: false
                        };
                    }
                }
                catch (err) {
                    return {
                        error: 'get-server-failure'
                    };
                }
                let res;
                try {
                    res = await (0, _post__WEBPACK_IMPORTED_MODULE_37__.get)((0, _server_config__WEBPACK_IMPORTED_MODULE_42__.getServer)(url).SIGNUP_SERVER + '/needs-bootstrap');
                }
                catch (err) {
                    return {
                        error: 'network-failure'
                    };
                }
                try {
                    res = JSON.parse(res);
                }
                catch (err) {
                    return {
                        error: 'parse-failure'
                    };
                }
                if (res.status === 'error') {
                    return {
                        error: res.reason
                    };
                }
                return {
                    bootstrapped: res.data.bootstrapped,
                    loginMethod: res.data.loginMethod || 'password',
                    hasServer: true
                };
            };
            handlers['subscribe-bootstrap'] = async function ({ password }) {
                let res;
                try {
                    res = await (0, _post__WEBPACK_IMPORTED_MODULE_37__.post)((0, _server_config__WEBPACK_IMPORTED_MODULE_42__.getServer)().SIGNUP_SERVER + '/bootstrap', {
                        password
                    });
                }
                catch (err) {
                    return {
                        error: err.reason || 'network-failure'
                    };
                }
                if (res.token) {
                    await _platform_server_asyncStorage__WEBPACK_IMPORTED_MODULE_5__.setItem('user-token', res.token);
                    return {};
                }
                return {
                    error: 'internal'
                };
            };
            handlers['subscribe-get-user'] = async function () {
                if (!(0, _server_config__WEBPACK_IMPORTED_MODULE_42__.getServer)()) {
                    if (!await _platform_server_asyncStorage__WEBPACK_IMPORTED_MODULE_5__.getItem('did-bootstrap')) {
                        return null;
                    }
                    return {
                        offline: false
                    };
                }
                const userToken = await _platform_server_asyncStorage__WEBPACK_IMPORTED_MODULE_5__.getItem('user-token');
                if (!userToken) {
                    return null;
                }
                try {
                    const res = await (0, _post__WEBPACK_IMPORTED_MODULE_37__.get)((0, _server_config__WEBPACK_IMPORTED_MODULE_42__.getServer)().SIGNUP_SERVER + '/validate', {
                        headers: {
                            'X-ACTUAL-TOKEN': userToken
                        }
                    });
                    const { status, reason } = JSON.parse(res);
                    if (status === 'error') {
                        if (reason === 'unauthorized') {
                            return null;
                        }
                        return {
                            offline: true
                        };
                    }
                    return {
                        offline: false
                    };
                }
                catch (e) {
                    console.log(e);
                    return {
                        offline: true
                    };
                }
            };
            handlers['subscribe-change-password'] = async function ({ password }) {
                const userToken = await _platform_server_asyncStorage__WEBPACK_IMPORTED_MODULE_5__.getItem('user-token');
                if (!userToken) {
                    return {
                        error: 'not-logged-in'
                    };
                }
                try {
                    await (0, _post__WEBPACK_IMPORTED_MODULE_37__.post)((0, _server_config__WEBPACK_IMPORTED_MODULE_42__.getServer)().SIGNUP_SERVER + '/change-password', {
                        token: userToken,
                        password
                    });
                }
                catch (err) {
                    return {
                        error: err.reason || 'network-failure'
                    };
                }
                return {};
            };
            handlers['subscribe-sign-in'] = async function ({ password, loginMethod }) {
                if (typeof loginMethod !== 'string' || loginMethod == null) {
                    loginMethod = 'password';
                }
                let res;
                try {
                    res = await (0, _post__WEBPACK_IMPORTED_MODULE_37__.post)((0, _server_config__WEBPACK_IMPORTED_MODULE_42__.getServer)().SIGNUP_SERVER + '/login', {
                        loginMethod,
                        password
                    });
                }
                catch (err) {
                    return {
                        error: err.reason || 'network-failure'
                    };
                }
                if (!res.token) {
                    throw new Error('login: User token not set');
                }
                await _platform_server_asyncStorage__WEBPACK_IMPORTED_MODULE_5__.setItem('user-token', res.token);
                return {};
            };
            handlers['subscribe-sign-out'] = async function () {
                _encryption__WEBPACK_IMPORTED_MODULE_29__.unloadAllKeys();
                await _platform_server_asyncStorage__WEBPACK_IMPORTED_MODULE_5__.multiRemove([
                    'user-token',
                    'encrypt-keys',
                    'lastBudget',
                    'readOnly'
                ]);
                return 'ok';
            };
            handlers['get-server-version'] = async function () {
                if (!(0, _server_config__WEBPACK_IMPORTED_MODULE_42__.getServer)()) {
                    return {
                        error: 'no-server'
                    };
                }
                let version;
                try {
                    const res = await (0, _post__WEBPACK_IMPORTED_MODULE_37__.get)((0, _server_config__WEBPACK_IMPORTED_MODULE_42__.getServer)().BASE_SERVER + '/info');
                    const info = JSON.parse(res);
                    version = info.build.version;
                }
                catch (err) {
                    return {
                        error: 'network-failure'
                    };
                }
                return {
                    version
                };
            };
            handlers['get-server-url'] = async function () {
                return (0, _server_config__WEBPACK_IMPORTED_MODULE_42__.getServer)() && (0, _server_config__WEBPACK_IMPORTED_MODULE_42__.getServer)().BASE_SERVER;
            };
            handlers['set-server-url'] = async function ({ url, validate = true }) {
                if (url == null) {
                    await _platform_server_asyncStorage__WEBPACK_IMPORTED_MODULE_5__.removeItem('user-token');
                }
                else {
                    url = url.replace(/\/+$/, '');
                    if (validate) {
                        // Validate the server is running
                        const result = await (0, _mutators__WEBPACK_IMPORTED_MODULE_34__.runHandler)(handlers['subscribe-needs-bootstrap'], {
                            url
                        });
                        if ('error' in result) {
                            return {
                                error: result.error
                            };
                        }
                    }
                }
                await _platform_server_asyncStorage__WEBPACK_IMPORTED_MODULE_5__.setItem('server-url', url);
                await _platform_server_asyncStorage__WEBPACK_IMPORTED_MODULE_5__.setItem('did-bootstrap', true);
                (0, _server_config__WEBPACK_IMPORTED_MODULE_42__.setServer)(url);
                return {};
            };
            handlers['sync'] = async function () {
                return (0, _sync__WEBPACK_IMPORTED_MODULE_45__.fullSync)();
            };
            handlers['get-budgets'] = async function () {
                const paths = await _platform_server_fs__WEBPACK_IMPORTED_MODULE_7__.listDir(_platform_server_fs__WEBPACK_IMPORTED_MODULE_7__.getDocumentDir());
                const budgets = (await Promise.all(paths.map(async (name) => {
                    const prefsPath = _platform_server_fs__WEBPACK_IMPORTED_MODULE_7__.join(_platform_server_fs__WEBPACK_IMPORTED_MODULE_7__.getDocumentDir(), name, 'metadata.json');
                    if (await _platform_server_fs__WEBPACK_IMPORTED_MODULE_7__.exists(prefsPath)) {
                        let prefs;
                        try {
                            prefs = JSON.parse(await _platform_server_fs__WEBPACK_IMPORTED_MODULE_7__.readFile(prefsPath));
                        }
                        catch (e) {
                            console.log('Error parsing metadata:', e.stack);
                            return;
                        }
                        // We treat the directory name as the canonical id so that if
                        // the user moves it around/renames/etc, nothing breaks. The
                        // id is stored in prefs just for convenience (and the prefs
                        // will always update to the latest given id)
                        if (name !== DEMO_BUDGET_ID) {
                            return {
                                id: name,
                                ...prefs.cloudFileId ? {
                                    cloudFileId: prefs.cloudFileId
                                } : {},
                                ...prefs.encryptKeyId ? {
                                    encryptKeyId: prefs.encryptKeyId
                                } : {},
                                ...prefs.groupId ? {
                                    groupId: prefs.groupId
                                } : {},
                                name: prefs.budgetName || '(no name)'
                            };
                        }
                    }
                    return null;
                }))).filter((x) => x);
                return budgets;
            };
            handlers['get-remote-files'] = async function () {
                return _cloud_storage__WEBPACK_IMPORTED_MODULE_26__.listRemoteFiles();
            };
            handlers['reset-budget-cache'] = (0, _mutators__WEBPACK_IMPORTED_MODULE_34__.mutator)(async function () {
                // Recomputing everything will update the cache
                await _sheet__WEBPACK_IMPORTED_MODULE_43__.loadUserBudgets(_db__WEBPACK_IMPORTED_MODULE_27__);
                _sheet__WEBPACK_IMPORTED_MODULE_43__.get().recomputeAll();
                await _sheet__WEBPACK_IMPORTED_MODULE_43__.waitOnSpreadsheet();
            });
            handlers['upload-budget'] = async function ({ id } = {}) {
                if (id) {
                    if (_prefs__WEBPACK_IMPORTED_MODULE_38__.getPrefs()) {
                        throw new Error('upload-budget: id given but prefs already loaded');
                    }
                    await _prefs__WEBPACK_IMPORTED_MODULE_38__.loadPrefs(id);
                }
                try {
                    await _cloud_storage__WEBPACK_IMPORTED_MODULE_26__.upload();
                }
                catch (e) {
                    console.log(e);
                    if (e.type === 'FileUploadError') {
                        return {
                            error: e
                        };
                    }
                    (0, _platform_exceptions__WEBPACK_IMPORTED_MODULE_4__.captureException)(e);
                    return {
                        error: {
                            reason: 'internal'
                        }
                    };
                }
                finally {
                    if (id) {
                        _prefs__WEBPACK_IMPORTED_MODULE_38__.unloadPrefs();
                    }
                }
                return {};
            };
            handlers['download-budget'] = async function ({ fileId }) {
                let result;
                try {
                    result = await _cloud_storage__WEBPACK_IMPORTED_MODULE_26__.download(fileId);
                }
                catch (e) {
                    if (e.type === 'FileDownloadError') {
                        if (e.reason === 'file-exists' && e.meta.id) {
                            await _prefs__WEBPACK_IMPORTED_MODULE_38__.loadPrefs(e.meta.id);
                            const name = _prefs__WEBPACK_IMPORTED_MODULE_38__.getPrefs().budgetName;
                            _prefs__WEBPACK_IMPORTED_MODULE_38__.unloadPrefs();
                            e.meta = {
                                ...e.meta,
                                name
                            };
                        }
                        return {
                            error: e
                        };
                    }
                    else {
                        (0, _platform_exceptions__WEBPACK_IMPORTED_MODULE_4__.captureException)(e);
                        return {
                            error: {
                                reason: 'internal'
                            }
                        };
                    }
                }
                const id = result.id;
                await handlers['load-budget']({
                    id
                });
                result = await handlers['sync-budget']();
                await handlers['close-budget']();
                if (result.error) {
                    return result;
                }
                return {
                    id
                };
            };
            // open and sync, but dont close
            handlers['sync-budget'] = async function () {
                (0, _sync__WEBPACK_IMPORTED_MODULE_45__.setSyncingMode)('enabled');
                const result = await (0, _sync__WEBPACK_IMPORTED_MODULE_45__.initialFullSync)();
                return result;
            };
            handlers['load-budget'] = async function ({ id }) {
                const currentPrefs = _prefs__WEBPACK_IMPORTED_MODULE_38__.getPrefs();
                if (currentPrefs) {
                    if (currentPrefs.id === id) {
                        // If it's already loaded, do nothing
                        return {};
                    }
                    else {
                        // Otherwise, close the currently loaded budget
                        await handlers['close-budget']();
                    }
                }
                const res = await loadBudget(id);
                return res;
            };
            handlers['create-demo-budget'] = async function () {
                // Make sure the read only flag isn't leftover (normally it's
                // reset when signing in, but you don't have to sign in for the
                // demo budget)
                await _platform_server_asyncStorage__WEBPACK_IMPORTED_MODULE_5__.setItem('readOnly', '');
                return handlers['create-budget']({
                    budgetName: 'Demo Budget',
                    testMode: true,
                    testBudgetId: DEMO_BUDGET_ID
                });
            };
            handlers['close-budget'] = async function () {
                (0, _platform_exceptions__WEBPACK_IMPORTED_MODULE_4__.captureBreadcrumb)({
                    message: 'Closing budget'
                });
                // The spreadsheet may be running, wait for it to complete
                await _sheet__WEBPACK_IMPORTED_MODULE_43__.waitOnSpreadsheet();
                _sheet__WEBPACK_IMPORTED_MODULE_43__.unloadSpreadsheet();
                (0, _sync__WEBPACK_IMPORTED_MODULE_45__.clearFullSyncTimeout)();
                await _main_app__WEBPACK_IMPORTED_MODULE_33__.app.stopServices();
                await _db__WEBPACK_IMPORTED_MODULE_27__.closeDatabase();
                try {
                    await _platform_server_asyncStorage__WEBPACK_IMPORTED_MODULE_5__.setItem('lastBudget', '');
                }
                catch (e) {
                    // This might fail if we are shutting down after failing to load a
                    // budget. We want to unload whatever has already been loaded but
                    // be resilient to anything failing
                }
                _prefs__WEBPACK_IMPORTED_MODULE_38__.unloadPrefs();
                (0, _backups__WEBPACK_IMPORTED_MODULE_23__.stopBackupService)();
                return 'ok';
            };
            handlers['delete-budget'] = async function ({ id, cloudFileId }) {
                // If it's a cloud file, you can delete it from the server by
                // passing its cloud id
                if (cloudFileId) {
                    await _cloud_storage__WEBPACK_IMPORTED_MODULE_26__.removeFile(cloudFileId).catch(() => { });
                }
                // If a local file exists, you can delete it by passing its local id
                if (id) {
                    const budgetDir = _platform_server_fs__WEBPACK_IMPORTED_MODULE_7__.getBudgetDir(id);
                    await _platform_server_fs__WEBPACK_IMPORTED_MODULE_7__.removeDirRecursively(budgetDir);
                }
                return 'ok';
            };
            handlers['create-budget'] = async function ({ budgetName, avoidUpload, testMode, testBudgetId } = {}) {
                let id;
                if (testMode) {
                    budgetName = budgetName || 'Test Budget';
                    id = testBudgetId || TEST_BUDGET_ID;
                    if (await _platform_server_fs__WEBPACK_IMPORTED_MODULE_7__.exists(_platform_server_fs__WEBPACK_IMPORTED_MODULE_7__.getBudgetDir(id))) {
                        await _platform_server_fs__WEBPACK_IMPORTED_MODULE_7__.removeDirRecursively(_platform_server_fs__WEBPACK_IMPORTED_MODULE_7__.getBudgetDir(id));
                    }
                }
                else {
                    // Generate budget name if not given
                    if (!budgetName) {
                        // Unfortunately we need to load all of the existing files first
                        // so we can detect conflicting names.
                        const files = await handlers['get-budgets']();
                        budgetName = await (0, _util_budget_name__WEBPACK_IMPORTED_MODULE_50__.uniqueFileName)(files);
                    }
                    id = await (0, _util_budget_name__WEBPACK_IMPORTED_MODULE_50__.idFromFileName)(budgetName);
                }
                const budgetDir = _platform_server_fs__WEBPACK_IMPORTED_MODULE_7__.getBudgetDir(id);
                await _platform_server_fs__WEBPACK_IMPORTED_MODULE_7__.mkdir(budgetDir);
                // Create the initial database
                await _platform_server_fs__WEBPACK_IMPORTED_MODULE_7__.copyFile(_platform_server_fs__WEBPACK_IMPORTED_MODULE_7__.bundledDatabasePath, _platform_server_fs__WEBPACK_IMPORTED_MODULE_7__.join(budgetDir, 'db.sqlite'));
                // Create the initial prefs file
                await _platform_server_fs__WEBPACK_IMPORTED_MODULE_7__.writeFile(_platform_server_fs__WEBPACK_IMPORTED_MODULE_7__.join(budgetDir, 'metadata.json'), JSON.stringify(_prefs__WEBPACK_IMPORTED_MODULE_38__.getDefaultPrefs(id, budgetName)));
                // Load it in
                const { error } = await loadBudget(id);
                if (error) {
                    console.log('Error creating budget: ' + error);
                    return {
                        error
                    };
                }
                if (!avoidUpload && !testMode) {
                    try {
                        await _cloud_storage__WEBPACK_IMPORTED_MODULE_26__.upload();
                    }
                    catch (e) {
                        // Ignore any errors uploading. If they are offline they should
                        // still be able to create files.
                    }
                }
                if (testMode) {
                    await (0, _mocks_budget__WEBPACK_IMPORTED_MODULE_3__.createTestBudget)(handlers);
                }
                return {};
            };
            handlers['import-budget'] = async function ({ filepath, type }) {
                try {
                    if (!await _platform_server_fs__WEBPACK_IMPORTED_MODULE_7__.exists(filepath)) {
                        throw new Error(`File not found at the provided path: ${filepath}`);
                    }
                    const buffer = Buffer.from(await _platform_server_fs__WEBPACK_IMPORTED_MODULE_7__.readFile(filepath, 'binary'));
                    const results = await (0, _importers__WEBPACK_IMPORTED_MODULE_32__.handleBudgetImport)(type, filepath, buffer);
                    return results || {};
                }
                catch (err) {
                    err.message = 'Error importing budget: ' + err.message;
                    (0, _platform_exceptions__WEBPACK_IMPORTED_MODULE_4__.captureException)(err);
                    return {
                        error: 'internal-error'
                    };
                }
            };
            handlers['export-budget'] = async function () {
                try {
                    return {
                        data: await _cloud_storage__WEBPACK_IMPORTED_MODULE_26__.exportBuffer()
                    };
                }
                catch (err) {
                    err.message = 'Error exporting budget: ' + err.message;
                    (0, _platform_exceptions__WEBPACK_IMPORTED_MODULE_4__.captureException)(err);
                    return {
                        error: 'internal-error'
                    };
                }
            };
            async function loadBudget(id) {
                let dir;
                try {
                    dir = _platform_server_fs__WEBPACK_IMPORTED_MODULE_7__.getBudgetDir(id);
                }
                catch (e) {
                    (0, _platform_exceptions__WEBPACK_IMPORTED_MODULE_4__.captureException)(new Error('`getBudgetDir` failed in `loadBudget`: ' + e.message));
                    return {
                        error: 'budget-not-found'
                    };
                }
                (0, _platform_exceptions__WEBPACK_IMPORTED_MODULE_4__.captureBreadcrumb)({
                    message: 'Loading budget ' + dir
                });
                if (!await _platform_server_fs__WEBPACK_IMPORTED_MODULE_7__.exists(dir)) {
                    (0, _platform_exceptions__WEBPACK_IMPORTED_MODULE_4__.captureException)(new Error('budget directory does not exist'));
                    return {
                        error: 'budget-not-found'
                    };
                }
                try {
                    await _prefs__WEBPACK_IMPORTED_MODULE_38__.loadPrefs(id);
                    await _db__WEBPACK_IMPORTED_MODULE_27__.openDatabase(id);
                }
                catch (e) {
                    (0, _platform_exceptions__WEBPACK_IMPORTED_MODULE_4__.captureBreadcrumb)({
                        message: 'Error loading budget ' + id
                    });
                    (0, _platform_exceptions__WEBPACK_IMPORTED_MODULE_4__.captureException)(e);
                    await handlers['close-budget']();
                    return {
                        error: 'opening-budget'
                    };
                }
                // Older versions didn't tag the file with the current user, so do
                // so now
                if (!_prefs__WEBPACK_IMPORTED_MODULE_38__.getPrefs().userId) {
                    const userId = await _platform_server_asyncStorage__WEBPACK_IMPORTED_MODULE_5__.getItem('user-token');
                    _prefs__WEBPACK_IMPORTED_MODULE_38__.savePrefs({
                        userId
                    });
                }
                try {
                    await (0, _update__WEBPACK_IMPORTED_MODULE_49__.updateVersion)();
                }
                catch (e) {
                    console.warn('Error updating', e);
                    let result;
                    if (e.message.includes('out-of-sync-migrations')) {
                        result = {
                            error: 'out-of-sync-migrations'
                        };
                    }
                    else if (e.message.includes('out-of-sync-data')) {
                        result = {
                            error: 'out-of-sync-data'
                        };
                    }
                    else {
                        (0, _platform_exceptions__WEBPACK_IMPORTED_MODULE_4__.captureException)(e);
                        _platform_server_log__WEBPACK_IMPORTED_MODULE_8__.logger.info('Error updating budget ' + id, e);
                        console.log('Error updating budget', e);
                        result = {
                            error: 'loading-budget'
                        };
                    }
                    await handlers['close-budget']();
                    return result;
                }
                await _db__WEBPACK_IMPORTED_MODULE_27__.loadClock();
                if (_prefs__WEBPACK_IMPORTED_MODULE_38__.getPrefs().resetClock) {
                    // If we need to generate a fresh clock, we need to generate a new
                    // client id. This happens when the database is transferred to a
                    // new device.
                    //
                    // TODO: The client id should be stored elsewhere. It shouldn't
                    // work this way, but it's fine for now.
                    _actual_app_crdt__WEBPACK_IMPORTED_MODULE_2__.getClock().timestamp.setNode(_actual_app_crdt__WEBPACK_IMPORTED_MODULE_2__.makeClientId());
                    await _db__WEBPACK_IMPORTED_MODULE_27__.runQuery('INSERT OR REPLACE INTO messages_clock (id, clock) VALUES (1, ?)', [
                        _actual_app_crdt__WEBPACK_IMPORTED_MODULE_2__.serializeClock(_actual_app_crdt__WEBPACK_IMPORTED_MODULE_2__.getClock())
                    ]);
                    await _prefs__WEBPACK_IMPORTED_MODULE_38__.savePrefs({
                        resetClock: false
                    });
                }
                if (!_platform__WEBPACK_IMPORTED_MODULE_36__.isWeb && !_platform__WEBPACK_IMPORTED_MODULE_36__.isMobile && "development" !== 'test') {
                    (0, _backups__WEBPACK_IMPORTED_MODULE_23__.startBackupService)(id);
                }
                try {
                    await _sheet__WEBPACK_IMPORTED_MODULE_43__.loadSpreadsheet(_db__WEBPACK_IMPORTED_MODULE_27__, onSheetChange);
                }
                catch (e) {
                    (0, _platform_exceptions__WEBPACK_IMPORTED_MODULE_4__.captureException)(e);
                    await handlers['close-budget']();
                    return {
                        error: 'opening-budget'
                    };
                }
                // This is a bit leaky, but we need to set the initial budget type
                _sheet__WEBPACK_IMPORTED_MODULE_43__.get().meta().budgetType = _prefs__WEBPACK_IMPORTED_MODULE_38__.getPrefs().budgetType;
                await _budget_base__WEBPACK_IMPORTED_MODULE_25__.createAllBudgets();
                // Load all the in-memory state
                await _db_mappings__WEBPACK_IMPORTED_MODULE_28__.loadMappings();
                await _accounts_transaction_rules__WEBPACK_IMPORTED_MODULE_19__.loadRules();
                await _sync_migrate__WEBPACK_IMPORTED_MODULE_46__.listen();
                await _main_app__WEBPACK_IMPORTED_MODULE_33__.app.startServices();
                (0, _undo__WEBPACK_IMPORTED_MODULE_48__.clearUndo)();
                // Ensure that syncing is enabled
                if (true) {
                    if (id === DEMO_BUDGET_ID) {
                        (0, _sync__WEBPACK_IMPORTED_MODULE_45__.setSyncingMode)('disabled');
                    }
                    else {
                        if ((0, _server_config__WEBPACK_IMPORTED_MODULE_42__.getServer)()) {
                            (0, _sync__WEBPACK_IMPORTED_MODULE_45__.setSyncingMode)('enabled');
                        }
                        else {
                            (0, _sync__WEBPACK_IMPORTED_MODULE_45__.setSyncingMode)('disabled');
                        }
                        await _platform_server_asyncStorage__WEBPACK_IMPORTED_MODULE_5__.setItem('lastBudget', id);
                        // Only upload periodically on desktop
                        if (!_platform__WEBPACK_IMPORTED_MODULE_36__.isMobile) {
                            await _cloud_storage__WEBPACK_IMPORTED_MODULE_26__.possiblyUpload();
                        }
                    }
                }
                _main_app__WEBPACK_IMPORTED_MODULE_33__.app.events.emit('load-budget', {
                    id
                });
                return {};
            }
            handlers['upload-file-web'] = async function ({ filename, contents }) {
                if (!_platform__WEBPACK_IMPORTED_MODULE_36__.isWeb) {
                    return null;
                }
                await _platform_server_fs__WEBPACK_IMPORTED_MODULE_7__.writeFile('/uploads/' + filename, contents);
                return {};
            };
            handlers['backups-get'] = async function ({ id }) {
                return (0, _backups__WEBPACK_IMPORTED_MODULE_23__.getAvailableBackups)(id);
            };
            handlers['backup-load'] = async function ({ id, backupId }) {
                await (0, _backups__WEBPACK_IMPORTED_MODULE_23__.loadBackup)(id, backupId);
            };
            handlers['backup-make'] = async function ({ id }) {
                await (0, _backups__WEBPACK_IMPORTED_MODULE_23__.makeBackup)(id);
            };
            handlers['get-last-opened-backup'] = async function () {
                const id = await _platform_server_asyncStorage__WEBPACK_IMPORTED_MODULE_5__.getItem('lastBudget');
                if (id && id !== '') {
                    const budgetDir = _platform_server_fs__WEBPACK_IMPORTED_MODULE_7__.getBudgetDir(id);
                    // We never want to give back a budget that does not exist on the
                    // filesystem anymore, so first check that it exists
                    if (await _platform_server_fs__WEBPACK_IMPORTED_MODULE_7__.exists(budgetDir)) {
                        return id;
                    }
                }
                return null;
            };
            handlers['app-focused'] = async function () {
                if (_prefs__WEBPACK_IMPORTED_MODULE_38__.getPrefs() && _prefs__WEBPACK_IMPORTED_MODULE_38__.getPrefs().id) {
                    // First we sync
                    (0, _sync__WEBPACK_IMPORTED_MODULE_45__.fullSync)();
                }
            };
            handlers = (0, _api__WEBPACK_IMPORTED_MODULE_21__.installAPI)(handlers);
            _actual_app_api_injected__WEBPACK_IMPORTED_MODULE_1__.override((name, args) => (0, _mutators__WEBPACK_IMPORTED_MODULE_34__.runHandler)(_main_app__WEBPACK_IMPORTED_MODULE_33__.app.handlers[name], args));
            // A hack for now until we clean up everything
            _main_app__WEBPACK_IMPORTED_MODULE_33__.app.handlers = handlers;
            _main_app__WEBPACK_IMPORTED_MODULE_33__.app.combine(_schedules_app__WEBPACK_IMPORTED_MODULE_41__.app, _budget_app__WEBPACK_IMPORTED_MODULE_24__.app, _notes_app__WEBPACK_IMPORTED_MODULE_35__.app, _tools_app__WEBPACK_IMPORTED_MODULE_47__.app, _filters_app__WEBPACK_IMPORTED_MODULE_31__.app, _reports_app__WEBPACK_IMPORTED_MODULE_39__.app, _rules_app__WEBPACK_IMPORTED_MODULE_40__.app);
            function getDefaultDocumentDir() {
                if (_platform__WEBPACK_IMPORTED_MODULE_36__.isMobile) {
                    // On mobile, unfortunately we need to be backwards compatible
                    // with the old folder structure which does not store files inside
                    // of an `Actual` directory. In the future, if we really care, we
                    // can migrate them, but for now just return the documents dir
                    return process.env.ACTUAL_DOCUMENT_DIR;
                }
                return _platform_server_fs__WEBPACK_IMPORTED_MODULE_7__.join(process.env.ACTUAL_DOCUMENT_DIR, 'Actual');
            }
            async function setupDocumentsDir() {
                async function ensureExists(dir) {
                    // Make sure the document folder exists
                    if (!await _platform_server_fs__WEBPACK_IMPORTED_MODULE_7__.exists(dir)) {
                        await _platform_server_fs__WEBPACK_IMPORTED_MODULE_7__.mkdir(dir);
                    }
                }
                let documentDir = await _platform_server_asyncStorage__WEBPACK_IMPORTED_MODULE_5__.getItem('document-dir');
                // Test the existing documents directory to make sure it's a valid
                // path that exists, and if it errors fallback to the default one
                if (documentDir) {
                    try {
                        await ensureExists(documentDir);
                    }
                    catch (e) {
                        documentDir = null;
                    }
                }
                if (!documentDir) {
                    documentDir = getDefaultDocumentDir();
                }
                await ensureExists(documentDir);
                _platform_server_fs__WEBPACK_IMPORTED_MODULE_7__._setDocumentDir(documentDir);
            }
            // eslint-disable-next-line import/no-unused-modules
            async function initApp(isDev, socketName) {
                await _platform_server_sqlite__WEBPACK_IMPORTED_MODULE_9__.init();
                await Promise.all([
                    _platform_server_asyncStorage__WEBPACK_IMPORTED_MODULE_5__.init(),
                    _platform_server_fs__WEBPACK_IMPORTED_MODULE_7__.init()
                ]);
                await setupDocumentsDir();
                const keysStr = await _platform_server_asyncStorage__WEBPACK_IMPORTED_MODULE_5__.getItem('encrypt-keys');
                if (keysStr) {
                    try {
                        const keys = JSON.parse(keysStr);
                        // Load all the keys
                        await Promise.all(Object.keys(keys).map((fileId) => {
                            return _encryption__WEBPACK_IMPORTED_MODULE_29__.loadKey(keys[fileId]);
                        }));
                    }
                    catch (e) {
                        console.log('Error loading key', e);
                        throw new Error('load-key-error');
                    }
                }
                const url = await _platform_server_asyncStorage__WEBPACK_IMPORTED_MODULE_5__.getItem('server-url');
                if (!url) {
                    await _platform_server_asyncStorage__WEBPACK_IMPORTED_MODULE_5__.removeItem('user-token');
                }
                (0, _server_config__WEBPACK_IMPORTED_MODULE_42__.setServer)(url);
                _platform_server_connection__WEBPACK_IMPORTED_MODULE_6__.init(socketName, _main_app__WEBPACK_IMPORTED_MODULE_33__.app.handlers);
                // Allow running DB queries locally
                global.$query = _aql__WEBPACK_IMPORTED_MODULE_22__.runQuery;
                global.$q = _shared_query__WEBPACK_IMPORTED_MODULE_12__.q;
                if (isDev) {
                    global.$send = (name, args) => (0, _mutators__WEBPACK_IMPORTED_MODULE_34__.runHandler)(_main_app__WEBPACK_IMPORTED_MODULE_33__.app.handlers[name], args);
                    global.$db = _db__WEBPACK_IMPORTED_MODULE_27__;
                    global.$setSyncingMode = _sync__WEBPACK_IMPORTED_MODULE_45__.setSyncingMode;
                }
            }
            // eslint-disable-next-line import/no-unused-modules
            async function init(config) {
                // Get from build
                let dataDir, serverURL;
                if (config) {
                    dataDir = config.dataDir;
                    serverURL = config.serverURL;
                }
                else {
                    dataDir = process.env.ACTUAL_DATA_DIR;
                    serverURL = process.env.ACTUAL_SERVER_URL;
                }
                await _platform_server_sqlite__WEBPACK_IMPORTED_MODULE_9__.init();
                await Promise.all([
                    _platform_server_asyncStorage__WEBPACK_IMPORTED_MODULE_5__.init({
                        persist: false
                    }),
                    _platform_server_fs__WEBPACK_IMPORTED_MODULE_7__.init()
                ]);
                _platform_server_fs__WEBPACK_IMPORTED_MODULE_7__._setDocumentDir(dataDir || process.cwd());
                if (serverURL) {
                    (0, _server_config__WEBPACK_IMPORTED_MODULE_42__.setServer)(serverURL);
                    if (config.password) {
                        await (0, _mutators__WEBPACK_IMPORTED_MODULE_34__.runHandler)(handlers['subscribe-sign-in'], {
                            password: config.password
                        });
                    }
                }
                else {
                    // This turns off all server URLs. In this mode we don't want any
                    // access to the server, we are doing things locally
                    (0, _server_config__WEBPACK_IMPORTED_MODULE_42__.setServer)(null);
                    _main_app__WEBPACK_IMPORTED_MODULE_33__.app.events.on('load-budget', () => {
                        (0, _sync__WEBPACK_IMPORTED_MODULE_45__.setSyncingMode)('offline');
                    });
                }
                return lib;
            }
            // Export a few things required for the platform
            // eslint-disable-next-line import/no-unused-modules
            const lib = {
                getDataDir: _platform_server_fs__WEBPACK_IMPORTED_MODULE_7__.getDataDir,
                sendMessage: (msg, args) => _platform_server_connection__WEBPACK_IMPORTED_MODULE_6__.send(msg, args),
                send: async (name, args) => {
                    const res = await (0, _mutators__WEBPACK_IMPORTED_MODULE_34__.runHandler)(_main_app__WEBPACK_IMPORTED_MODULE_33__.app.handlers[name], args);
                    return res;
                },
                on: (name, func) => _main_app__WEBPACK_IMPORTED_MODULE_33__.app.events.on(name, func),
                q: _shared_query__WEBPACK_IMPORTED_MODULE_12__.q,
                db: _db__WEBPACK_IMPORTED_MODULE_27__
            };
            /***/ 
        }),
        /***/ "./packages/loot-core/src/server/migrate/migrations.ts": 
        /*!*************************************************************!*\
          !*** ./packages/loot-core/src/server/migrate/migrations.ts ***!
          \*************************************************************/
        /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony export */ __webpack_require__.d(__webpack_exports__, {
                /* harmony export */ applyMigration: () => ( /* binding */applyMigration),
                /* harmony export */ getAppliedMigrations: () => ( /* binding */getAppliedMigrations),
                /* harmony export */ getMigrationList: () => ( /* binding */getMigrationList),
                /* harmony export */ getMigrationsDir: () => ( /* binding */getMigrationsDir),
                /* harmony export */ getPending: () => ( /* binding */getPending),
                /* harmony export */ getUpMigration: () => ( /* binding */getUpMigration),
                /* harmony export */ migrate: () => ( /* binding */migrate),
                /* harmony export */ withMigrationsDir: () => ( /* binding */withMigrationsDir)
                /* harmony export */ 
            });
            /* harmony import */ var uuid__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! uuid */ "./node_modules/uuid/dist/esm-node/v4.js");
            /* harmony import */ var _migrations_1632571489012_remove_cache__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../migrations/1632571489012_remove_cache */ "./packages/loot-core/migrations/1632571489012_remove_cache.js");
            /* harmony import */ var _platform_server_fs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../platform/server/fs */ "./packages/loot-core/src/platform/server/fs/index.electron.ts");
            /* harmony import */ var _platform_server_sqlite__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../platform/server/sqlite */ "./packages/loot-core/src/platform/server/sqlite/index.electron.ts");
            // @ts-strict-ignore
            // We have to bundle in JS migrations manually to avoid having to `eval`
            // them which doesn't play well with CSP. There isn't great, and eventually
            // we can remove this migration.
            let MIGRATIONS_DIR = _platform_server_fs__WEBPACK_IMPORTED_MODULE_1__.migrationsPath;
            const javascriptMigrations = {
                1632571489012: _migrations_1632571489012_remove_cache__WEBPACK_IMPORTED_MODULE_0__["default"]
            };
            async function withMigrationsDir(dir, func) {
                const oldDir = MIGRATIONS_DIR;
                MIGRATIONS_DIR = dir;
                await func();
                MIGRATIONS_DIR = oldDir;
            }
            function getMigrationsDir() {
                return MIGRATIONS_DIR;
            }
            function getMigrationId(name) {
                return parseInt(name.match(/^(\d)+/)[0]);
            }
            function getUpMigration(id, names) {
                for (const m of names) {
                    if (getMigrationId(m) === id) {
                        return m;
                    }
                }
            }
            async function patchBadMigrations(db) {
                const badFiltersMigration = 1685375406832;
                const newFiltersMigration = 1688749527273;
                const appliedIds = await getAppliedMigrations(db);
                if (appliedIds.includes(badFiltersMigration)) {
                    await _platform_server_sqlite__WEBPACK_IMPORTED_MODULE_2__.runQuery(db, 'DELETE FROM __migrations__ WHERE id = ?', [
                        badFiltersMigration
                    ]);
                    await _platform_server_sqlite__WEBPACK_IMPORTED_MODULE_2__.runQuery(db, 'INSERT INTO __migrations__ (id) VALUES (?)', [
                        newFiltersMigration
                    ]);
                }
            }
            async function getAppliedMigrations(db) {
                const rows = await _platform_server_sqlite__WEBPACK_IMPORTED_MODULE_2__.runQuery(db, 'SELECT * FROM __migrations__ ORDER BY id ASC', [], true);
                return rows.map((row) => row.id);
            }
            async function getMigrationList(migrationsDir) {
                const files = await _platform_server_fs__WEBPACK_IMPORTED_MODULE_1__.listDir(migrationsDir);
                return files.filter((name) => name.match(/(\.sql|\.js)$/)).sort((m1, m2) => {
                    const id1 = getMigrationId(m1);
                    const id2 = getMigrationId(m2);
                    if (id1 < id2) {
                        return -1;
                    }
                    else if (id1 > id2) {
                        return 1;
                    }
                    return 0;
                });
            }
            function getPending(appliedIds, all) {
                return all.filter((name) => {
                    const id = getMigrationId(name);
                    return appliedIds.indexOf(id) === -1;
                });
            }
            async function applyJavaScript(db, id) {
                const dbInterface = {
                    runQuery: (query, params, fetchAll) => _platform_server_sqlite__WEBPACK_IMPORTED_MODULE_2__.runQuery(db, query, params, fetchAll),
                    execQuery: (query) => _platform_server_sqlite__WEBPACK_IMPORTED_MODULE_2__.execQuery(db, query),
                    transaction: (func) => _platform_server_sqlite__WEBPACK_IMPORTED_MODULE_2__.transaction(db, func)
                };
                if (javascriptMigrations[id] == null) {
                    throw new Error('Could not find JS migration code to run for ' + id);
                }
                const run = javascriptMigrations[id];
                return run(dbInterface, () => (0, uuid__WEBPACK_IMPORTED_MODULE_3__["default"])());
            }
            async function applySql(db, sql) {
                try {
                    await _platform_server_sqlite__WEBPACK_IMPORTED_MODULE_2__.execQuery(db, sql);
                }
                catch (e) {
                    console.log('Error applying sql:', sql);
                    throw e;
                }
            }
            async function applyMigration(db, name, migrationsDir) {
                const code = await _platform_server_fs__WEBPACK_IMPORTED_MODULE_1__.readFile(_platform_server_fs__WEBPACK_IMPORTED_MODULE_1__.join(migrationsDir, name));
                if (name.match(/\.js$/)) {
                    await applyJavaScript(db, getMigrationId(name));
                }
                else {
                    await applySql(db, code);
                }
                await _platform_server_sqlite__WEBPACK_IMPORTED_MODULE_2__.runQuery(db, 'INSERT INTO __migrations__ (id) VALUES (?)', [
                    getMigrationId(name)
                ]);
            }
            function checkDatabaseValidity(appliedIds, available) {
                for (let i = 0; i < appliedIds.length; i++) {
                    if (i >= available.length || appliedIds[i] !== getMigrationId(available[i])) {
                        console.error('Database is out of sync with migrations:', {
                            appliedIds,
                            available
                        });
                        throw new Error('out-of-sync-migrations');
                    }
                }
            }
            async function migrate(db) {
                await patchBadMigrations(db);
                const appliedIds = await getAppliedMigrations(db);
                const available = await getMigrationList(MIGRATIONS_DIR);
                checkDatabaseValidity(appliedIds, available);
                const pending = getPending(appliedIds, available);
                for (const migration of pending) {
                    await applyMigration(db, migration, MIGRATIONS_DIR);
                }
                return pending;
            }
            /***/ 
        }),
        /***/ "./packages/loot-core/src/server/models.ts": 
        /*!*************************************************!*\
          !*** ./packages/loot-core/src/server/models.ts ***!
          \*************************************************/
        /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony export */ __webpack_require__.d(__webpack_exports__, {
                /* harmony export */ accountModel: () => ( /* binding */accountModel),
                /* harmony export */ categoryGroupModel: () => ( /* binding */categoryGroupModel),
                /* harmony export */ categoryModel: () => ( /* binding */categoryModel),
                /* harmony export */ fromDateRepr: () => ( /* binding */fromDateRepr),
                /* harmony export */ payeeModel: () => ( /* binding */payeeModel),
                /* harmony export */ requiredFields: () => ( /* binding */requiredFields),
                /* harmony export */ toDateRepr: () => ( /* binding */toDateRepr)
                /* harmony export */ 
            });
            function requiredFields(name, row, fields, update) {
                fields.forEach((field) => {
                    if (update) {
                        if (row.hasOwnProperty(field) && row[field] == null) {
                            throw new Error(`${name} is missing field ${String(field)}`);
                        }
                    }
                    else {
                        if (!row.hasOwnProperty(field) || row[field] == null) {
                            throw new Error(`${name} is missing field ${String(field)}`);
                        }
                    }
                });
            }
            function toDateRepr(str) {
                if (typeof str !== 'string') {
                    throw new Error('toDateRepr not passed a string: ' + str);
                }
                return parseInt(str.replace(/-/g, ''));
            }
            function fromDateRepr(number) {
                if (typeof number !== 'number') {
                    throw new Error('fromDateRepr not passed a number: ' + number);
                }
                const dateString = number.toString();
                return dateString.slice(0, 4) + '-' + dateString.slice(4, 6) + '-' + dateString.slice(6);
            }
            const accountModel = {
                validate(account, { update } = {}) {
                    requiredFields('account', account, update ? [
                        'name',
                        'offbudget',
                        'closed'
                    ] : [
                        'name'
                    ], update);
                    return account;
                }
            };
            const categoryModel = {
                validate(category, { update } = {}) {
                    requiredFields('category', category, update ? [
                        'name',
                        'is_income',
                        'cat_group'
                    ] : [
                        'name',
                        'cat_group'
                    ], update);
                    const { sort_order, ...rest } = category;
                    return {
                        ...rest,
                        hidden: rest.hidden ? 1 : 0
                    };
                }
            };
            const categoryGroupModel = {
                validate(categoryGroup, { update } = {}) {
                    requiredFields('categoryGroup', categoryGroup, update ? [
                        'name',
                        'is_income'
                    ] : [
                        'name'
                    ], update);
                    const { sort_order, ...rest } = categoryGroup;
                    return {
                        ...rest,
                        hidden: rest.hidden ? 1 : 0
                    };
                }
            };
            const payeeModel = {
                validate(payee, { update } = {}) {
                    requiredFields('payee', payee, [
                        'name'
                    ], update);
                    return payee;
                }
            };
            /***/ 
        }),
        /***/ "./packages/loot-core/src/server/mutators.ts": 
        /*!***************************************************!*\
          !*** ./packages/loot-core/src/server/mutators.ts ***!
          \***************************************************/
        /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony export */ __webpack_require__.d(__webpack_exports__, {
                /* harmony export */ disableGlobalMutations: () => ( /* binding */disableGlobalMutations),
                /* harmony export */ enableGlobalMutations: () => ( /* binding */enableGlobalMutations),
                /* harmony export */ getMutatorContext: () => ( /* binding */getMutatorContext),
                /* harmony export */ isMutating: () => ( /* binding */isMutating),
                /* harmony export */ mutator: () => ( /* binding */mutator),
                /* harmony export */ runHandler: () => ( /* binding */runHandler),
                /* harmony export */ runMutator: () => ( /* binding */runMutator),
                /* harmony export */ withMutatorContext: () => ( /* binding */withMutatorContext)
                /* harmony export */ 
            });
            /* harmony import */ var _platform_exceptions__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../platform/exceptions */ "./packages/loot-core/src/platform/exceptions/index.electron.ts");
            /* harmony import */ var _shared_async__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../shared/async */ "./packages/loot-core/src/shared/async.ts");
            // @ts-strict-ignore
            const runningMethods = new Set();
            let currentContext = null;
            const mutatingMethods = new WeakMap();
            let globalMutationsEnabled = false;
            let _latestHandlerNames = [];
            function mutator(handler) {
                mutatingMethods.set(handler, true);
                return handler;
            }
            function isMutating(handler) {
                return mutatingMethods.has(handler);
            }
            async function flushRunningMethods() {
                // Give the client some time to invoke new requests
                await wait(200);
                while (runningMethods.size > 0) {
                    // Wait for all of them
                    await Promise.all([
                        ...runningMethods.values()
                    ]);
                    // We give clients more time to make other requests. This lets them continue
                    // to do an async workflow
                    await wait(100);
                }
            }
            function wait(time) {
                return new Promise((resolve) => setTimeout(resolve, time));
            }
            async function runHandler(handler, args, { undoTag, name } = {}) {
                // For debug reasons, track the latest handlers that have been
                // called
                _latestHandlerNames.push(name);
                if (_latestHandlerNames.length > 5) {
                    _latestHandlerNames = _latestHandlerNames.slice(-5);
                }
                if (mutatingMethods.has(handler)) {
                    return runMutator(() => handler(args), {
                        undoTag
                    });
                }
                // When closing a file, it clears out all global state for the file. That
                // means any async workflows currently executed would be cut off. We handle
                // this by letting all async workflows finish executing before closing the
                // file
                if (name === 'close-budget') {
                    await flushRunningMethods();
                }
                const promise = handler(args);
                runningMethods.add(promise);
                promise.then(() => {
                    runningMethods.delete(promise);
                });
                return promise;
            }
            // These are useful for tests. Only use them in tests.
            function enableGlobalMutations() {
                if (false) { }
            }
            function disableGlobalMutations() {
                if (false) { }
            }
            function _runMutator(func, initialContext = {}) {
                currentContext = initialContext;
                return func().finally(() => {
                    currentContext = null;
                });
            }
            // Type cast needed as TS looses types over nested generic returns
            const runMutator = (0, _shared_async__WEBPACK_IMPORTED_MODULE_1__.sequential)(_runMutator);
            function withMutatorContext(context, func) {
                if (currentContext == null && !globalMutationsEnabled) {
                    (0, _platform_exceptions__WEBPACK_IMPORTED_MODULE_0__.captureBreadcrumb)('Recent methods: ' + _latestHandlerNames.join(', '));
                    (0, _platform_exceptions__WEBPACK_IMPORTED_MODULE_0__.captureException)(new Error('withMutatorContext: mutator not running'));
                    // See comment below. This is not an error right now, but it will
                    // be in the future.
                    return func();
                }
                const prevContext = currentContext;
                currentContext = {
                    ...currentContext,
                    ...context
                };
                return func().finally(() => {
                    currentContext = prevContext;
                });
            }
            function getMutatorContext() {
                if (currentContext == null) {
                    (0, _platform_exceptions__WEBPACK_IMPORTED_MODULE_0__.captureBreadcrumb)({
                        category: 'server',
                        message: 'Recent methods: ' + _latestHandlerNames.join(', ')
                    });
                    // captureException(new Error('getMutatorContext: mutator not running'));
                    // For now, this is a non-fatal error. It will be in the future,
                    // but this is relatively non-critical (undo just won't work) so
                    // return an empty context. When we have more confidence that
                    // everything is running inside a mutator, throw an error.
                    return {};
                }
                if (currentContext == null && globalMutationsEnabled) {
                    return {};
                }
                return currentContext;
            }
            /***/ 
        }),
        /***/ "./packages/loot-core/src/server/notes/app.ts": 
        /*!****************************************************!*\
          !*** ./packages/loot-core/src/server/notes/app.ts ***!
          \****************************************************/
        /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony export */ __webpack_require__.d(__webpack_exports__, {
                /* harmony export */ app: () => ( /* binding */app)
                /* harmony export */ 
            });
            /* harmony import */ var _app__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../app */ "./packages/loot-core/src/server/app.ts");
            /* harmony import */ var _db__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../db */ "./packages/loot-core/src/server/db/index.ts");
            const app = (0, _app__WEBPACK_IMPORTED_MODULE_0__.createApp)();
            app.method('notes-save', async ({ id, note }) => {
                await _db__WEBPACK_IMPORTED_MODULE_1__.update('notes', {
                    id,
                    note
                });
            });
            /***/ 
        }),
        /***/ "./packages/loot-core/src/server/platform.ts": 
        /*!***************************************************!*\
          !*** ./packages/loot-core/src/server/platform.ts ***!
          \***************************************************/
        /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony export */ __webpack_require__.d(__webpack_exports__, {
                /* harmony export */ isDesktop: () => ( /* binding */isDesktop),
                /* harmony export */ isMobile: () => ( /* binding */isMobile),
                /* harmony export */ isWeb: () => ( /* binding */isWeb)
                /* harmony export */ 
            });
            const isMobile = false;
            const isWeb = false;
            const isDesktop = true;
            /***/ 
        }),
        /***/ "./packages/loot-core/src/server/polyfills.ts": 
        /*!****************************************************!*\
          !*** ./packages/loot-core/src/server/polyfills.ts ***!
          \****************************************************/
        /***/ (() => {
            // By default, no polyfills are installed
            /***/ 
        }),
        /***/ "./packages/loot-core/src/server/post.ts": 
        /*!***********************************************!*\
          !*** ./packages/loot-core/src/server/post.ts ***!
          \***********************************************/
        /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony export */ __webpack_require__.d(__webpack_exports__, {
                /* harmony export */ get: () => ( /* binding */get),
                /* harmony export */ post: () => ( /* binding */post),
                /* harmony export */ postBinary: () => ( /* binding */postBinary)
                /* harmony export */ 
            });
            /* harmony import */ var _platform_server_fetch__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../platform/server/fetch */ "./packages/loot-core/src/platform/server/fetch/index.api.ts");
            /* harmony import */ var _errors__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./errors */ "./packages/loot-core/src/server/errors.ts");
            /* harmony import */ var _platform__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./platform */ "./packages/loot-core/src/server/platform.ts");
            // @ts-strict-ignore
            function throwIfNot200(res, text) {
                if (res.status !== 200) {
                    if (res.status === 500) {
                        throw new _errors__WEBPACK_IMPORTED_MODULE_1__.PostError(res.status === 500 ? 'internal' : text);
                    }
                    const contentType = res.headers.get('Content-Type');
                    if (contentType.toLowerCase().indexOf('application/json') !== -1) {
                        const json = JSON.parse(text);
                        throw new _errors__WEBPACK_IMPORTED_MODULE_1__.PostError(json.reason);
                    }
                    throw new _errors__WEBPACK_IMPORTED_MODULE_1__.PostError(text);
                }
            }
            async function post(url, data, headers = {}, timeout = null) {
                let text;
                let res;
                try {
                    const controller = new AbortController();
                    const timeoutId = setTimeout(() => controller.abort(), timeout);
                    const signal = timeout ? controller.signal : null;
                    res = await (0, _platform_server_fetch__WEBPACK_IMPORTED_MODULE_0__.fetch)(url, {
                        method: 'POST',
                        body: JSON.stringify(data),
                        signal,
                        headers: {
                            ...headers,
                            'Content-Type': 'application/json'
                        }
                    });
                    clearTimeout(timeoutId);
                    text = await res.text();
                }
                catch (err) {
                    throw new _errors__WEBPACK_IMPORTED_MODULE_1__.PostError('network-failure');
                }
                throwIfNot200(res, text);
                try {
                    res = JSON.parse(text);
                }
                catch (err) {
                    // Something seriously went wrong. TODO handle errors
                    throw new _errors__WEBPACK_IMPORTED_MODULE_1__.PostError('parse-json', {
                        meta: text
                    });
                }
                if (res.status !== 'ok') {
                    console.log('API call failed: ' + url + '\nData: ' + JSON.stringify(data, null, 2) + '\nResponse: ' + JSON.stringify(res, null, 2));
                    throw new _errors__WEBPACK_IMPORTED_MODULE_1__.PostError(res.description || res.reason || 'unknown');
                }
                return res.data;
            }
            async function postBinary(url, data, headers) {
                let res;
                try {
                    res = await (0, _platform_server_fetch__WEBPACK_IMPORTED_MODULE_0__.fetch)(url, {
                        method: 'POST',
                        body: _platform__WEBPACK_IMPORTED_MODULE_2__.isWeb ? data : Buffer.from(data),
                        headers: {
                            'Content-Length': data.length,
                            'Content-Type': 'application/actual-sync',
                            ...headers
                        }
                    });
                }
                catch (err) {
                    throw new _errors__WEBPACK_IMPORTED_MODULE_1__.PostError('network-failure');
                }
                let buffer;
                if (res.arrayBuffer) {
                    buffer = Buffer.from(await res.arrayBuffer());
                }
                else {
                    buffer = await res.buffer();
                }
                throwIfNot200(res, buffer.toString());
                return buffer;
            }
            function get(url, opts) {
                return (0, _platform_server_fetch__WEBPACK_IMPORTED_MODULE_0__.fetch)(url, opts).then((res) => res.text());
            }
            /***/ 
        }),
        /***/ "./packages/loot-core/src/server/prefs.ts": 
        /*!************************************************!*\
          !*** ./packages/loot-core/src/server/prefs.ts ***!
          \************************************************/
        /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony export */ __webpack_require__.d(__webpack_exports__, {
                /* harmony export */ BUDGET_TYPES: () => ( /* binding */BUDGET_TYPES),
                /* harmony export */ getDefaultPrefs: () => ( /* binding */getDefaultPrefs),
                /* harmony export */ getPrefs: () => ( /* binding */getPrefs),
                /* harmony export */ loadPrefs: () => ( /* binding */loadPrefs),
                /* harmony export */ savePrefs: () => ( /* binding */savePrefs),
                /* harmony export */ unloadPrefs: () => ( /* binding */unloadPrefs)
                /* harmony export */ 
            });
            /* harmony import */ var _actual_app_crdt__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @actual-app/crdt */ "@actual-app/crdt");
            /* harmony import */ var _actual_app_crdt__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/ __webpack_require__.n(_actual_app_crdt__WEBPACK_IMPORTED_MODULE_0__);
            /* harmony import */ var _platform_server_fs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../platform/server/fs */ "./packages/loot-core/src/platform/server/fs/index.electron.ts");
            /* harmony import */ var _sync__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./sync */ "./packages/loot-core/src/server/sync/index.ts");
            // @ts-strict-ignore
            const BUDGET_TYPES = [
                'report',
                'rollover'
            ];
            let prefs = null;
            async function loadPrefs(id) {
                if (false) { }
                const fullpath = _platform_server_fs__WEBPACK_IMPORTED_MODULE_1__.join(_platform_server_fs__WEBPACK_IMPORTED_MODULE_1__.getBudgetDir(id), 'metadata.json');
                try {
                    prefs = JSON.parse(await _platform_server_fs__WEBPACK_IMPORTED_MODULE_1__.readFile(fullpath));
                }
                catch (e) {
                    // If the user messed something up, be flexible and allow them to
                    // still load the budget database. Default the budget name to the
                    // id.
                    prefs = {
                        id,
                        budgetName: id
                    };
                }
                // delete released feature flags
                const releasedFeatures = [
                    'syncAccount'
                ];
                for (const feature of releasedFeatures) {
                    delete prefs[`flags.${feature}`];
                }
                // delete legacy notifications
                for (const key of Object.keys(prefs)) {
                    if (key.startsWith('notifications.')) {
                        delete prefs[key];
                    }
                }
                // No matter what is in `id` field, force it to be the current id.
                // This makes it resilient to users moving around folders, etc
                prefs.id = id;
                return prefs;
            }
            async function savePrefs(prefsToSet, { avoidSync = false } = {}) {
                Object.assign(prefs, prefsToSet);
                if (!avoidSync) {
                    // Sync whitelisted prefs
                    const messages = Object.keys(prefsToSet).map((key) => {
                        if (key === 'budgetType' || key === 'budgetName') {
                            return {
                                dataset: 'prefs',
                                row: key,
                                column: 'value',
                                value: prefsToSet[key],
                                timestamp: _actual_app_crdt__WEBPACK_IMPORTED_MODULE_0__.Timestamp.send()
                            };
                        }
                        return null;
                    }).filter((x) => x);
                    if (messages.length > 0) {
                        await (0, _sync__WEBPACK_IMPORTED_MODULE_2__.sendMessages)(messages);
                    }
                }
                if (true) {
                    const prefsPath = _platform_server_fs__WEBPACK_IMPORTED_MODULE_1__.join(_platform_server_fs__WEBPACK_IMPORTED_MODULE_1__.getBudgetDir(prefs.id), 'metadata.json');
                    await _platform_server_fs__WEBPACK_IMPORTED_MODULE_1__.writeFile(prefsPath, JSON.stringify(prefs));
                }
            }
            function unloadPrefs() {
                prefs = null;
            }
            function getPrefs() {
                return prefs;
            }
            function getDefaultPrefs(id, budgetName) {
                return {
                    id,
                    budgetName
                };
            }
            /***/ 
        }),
        /***/ "./packages/loot-core/src/server/reports/app.ts": 
        /*!******************************************************!*\
          !*** ./packages/loot-core/src/server/reports/app.ts ***!
          \******************************************************/
        /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony export */ __webpack_require__.d(__webpack_exports__, {
                /* harmony export */ app: () => ( /* binding */app)
                /* harmony export */ 
            });
            /* harmony import */ var uuid__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! uuid */ "./node_modules/uuid/dist/esm-node/v4.js");
            /* harmony import */ var _app__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../app */ "./packages/loot-core/src/server/app.ts");
            /* harmony import */ var _db__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../db */ "./packages/loot-core/src/server/db/index.ts");
            /* harmony import */ var _models__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../models */ "./packages/loot-core/src/server/models.ts");
            /* harmony import */ var _mutators__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../mutators */ "./packages/loot-core/src/server/mutators.ts");
            /* harmony import */ var _undo__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../undo */ "./packages/loot-core/src/server/undo.ts");
            const reportModel = {
                validate(report, { update } = {}) {
                    (0, _models__WEBPACK_IMPORTED_MODULE_2__.requiredFields)('Report', report, [
                        'conditionsOp'
                    ], update);
                    if (!update || 'conditionsOp' in report) {
                        if (![
                            'and',
                            'or'
                        ].includes(report.conditionsOp)) {
                            throw new Error('Invalid filter conditionsOp: ' + report.conditionsOp);
                        }
                    }
                    return report;
                },
                toJS(row) {
                    return {
                        id: row.id,
                        name: row.name,
                        startDate: row.start_date,
                        endDate: row.end_date,
                        isDateStatic: row.date_static === 1,
                        dateRange: row.date_range,
                        mode: row.mode,
                        groupBy: row.group_by,
                        interval: row.interval,
                        balanceType: row.balance_type,
                        showEmpty: row.show_empty === 1,
                        showOffBudget: row.show_offbudget === 1,
                        showHiddenCategories: row.show_hidden === 1,
                        showUncategorized: row.show_uncategorized === 1,
                        includeCurrentInterval: row.include_current === 1,
                        selectedCategories: row.selected_categories,
                        graphType: row.graph_type,
                        conditions: row.conditions,
                        conditionsOp: row.conditions_op
                    };
                },
                fromJS(report) {
                    return {
                        id: report.id,
                        name: report.name,
                        start_date: report.startDate,
                        end_date: report.endDate,
                        date_static: report.isDateStatic ? 1 : 0,
                        date_range: report.dateRange,
                        mode: report.mode,
                        group_by: report.groupBy,
                        interval: report.interval,
                        balance_type: report.balanceType,
                        show_empty: report.showEmpty ? 1 : 0,
                        show_offbudget: report.showOffBudget ? 1 : 0,
                        show_hidden: report.showHiddenCategories ? 1 : 0,
                        show_uncategorized: report.showUncategorized ? 1 : 0,
                        include_current: report.includeCurrentInterval ? 1 : 0,
                        selected_categories: report.selectedCategories,
                        graph_type: report.graphType,
                        conditions: report.conditions,
                        conditions_op: report.conditionsOp
                    };
                }
            };
            async function reportNameExists(name, reportId, newItem) {
                const idForName = await _db__WEBPACK_IMPORTED_MODULE_1__.first('SELECT id from custom_reports WHERE tombstone = 0 AND name = ?', [
                    name
                ]);
                //no existing name found
                if (idForName === null) {
                    return false;
                }
                //for update/rename
                if (!newItem) {
                    /*
                -if the found item is the same as the existing item
                then no name change was made.
                -if they are not the same then there is another
                item with that name already.
                */ return idForName.id !== reportId;
                }
                //default return: item was found but does not match current name
                return true;
            }
            async function createReport(report) {
                const reportId = (0, uuid__WEBPACK_IMPORTED_MODULE_5__["default"])();
                const item = {
                    ...report,
                    id: reportId
                };
                if (!item.name) {
                    throw new Error('Report name is required');
                }
                const nameExists = await reportNameExists(item.name, item.id ?? '', true);
                if (nameExists) {
                    throw new Error('There is already a filter named ' + item.name);
                }
                // Create the report here based on the info
                await _db__WEBPACK_IMPORTED_MODULE_1__.insertWithSchema('custom_reports', reportModel.fromJS(item));
                return reportId;
            }
            async function updateReport(item) {
                if (!item.name) {
                    throw new Error('Report name is required');
                }
                if (!item.id) {
                    throw new Error('Report recall error');
                }
                const nameExists = await reportNameExists(item.name, item.id, false);
                if (nameExists) {
                    throw new Error('There is already a filter named ' + item.name);
                }
                await _db__WEBPACK_IMPORTED_MODULE_1__.updateWithSchema('custom_reports', reportModel.fromJS(item));
            }
            async function deleteReport(id) {
                await _db__WEBPACK_IMPORTED_MODULE_1__.delete_('custom_reports', id);
            }
            // Expose functions to the client
            const app = (0, _app__WEBPACK_IMPORTED_MODULE_0__.createApp)();
            app.method('report/create', (0, _mutators__WEBPACK_IMPORTED_MODULE_3__.mutator)((0, _undo__WEBPACK_IMPORTED_MODULE_4__.undoable)(createReport)));
            app.method('report/update', (0, _mutators__WEBPACK_IMPORTED_MODULE_3__.mutator)((0, _undo__WEBPACK_IMPORTED_MODULE_4__.undoable)(updateReport)));
            app.method('report/delete', (0, _mutators__WEBPACK_IMPORTED_MODULE_3__.mutator)((0, _undo__WEBPACK_IMPORTED_MODULE_4__.undoable)(deleteReport)));
            /***/ 
        }),
        /***/ "./packages/loot-core/src/server/rules/app.ts": 
        /*!****************************************************!*\
          !*** ./packages/loot-core/src/server/rules/app.ts ***!
          \****************************************************/
        /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony export */ __webpack_require__.d(__webpack_exports__, {
                /* harmony export */ app: () => ( /* binding */app)
                /* harmony export */ 
            });
            /* harmony import */ var _shared_rules__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../shared/rules */ "./packages/loot-core/src/shared/rules.ts");
            /* harmony import */ var _accounts_rules__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../accounts/rules */ "./packages/loot-core/src/server/accounts/rules.ts");
            /* harmony import */ var _accounts_transaction_rules__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../accounts/transaction-rules */ "./packages/loot-core/src/server/accounts/transaction-rules.ts");
            /* harmony import */ var _app__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../app */ "./packages/loot-core/src/server/app.ts");
            /* harmony import */ var _errors__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../errors */ "./packages/loot-core/src/server/errors.ts");
            /* harmony import */ var _mutators__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../mutators */ "./packages/loot-core/src/server/mutators.ts");
            /* harmony import */ var _sync__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../sync */ "./packages/loot-core/src/server/sync/index.ts");
            /* harmony import */ var _undo__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../undo */ "./packages/loot-core/src/server/undo.ts");
            // @ts-strict-ignore
            function validateRule(rule) {
                // Returns an array of errors, the array is the same link as the
                // passed-in `array`, or null if there are no errors
                function runValidation(array, validate) {
                    const result = array.map((item) => {
                        try {
                            validate(item);
                        }
                        catch (e) {
                            if (e instanceof _errors__WEBPACK_IMPORTED_MODULE_4__.RuleError) {
                                console.warn('Invalid rule', e);
                                return e.type;
                            }
                            throw e;
                        }
                        return null;
                    });
                    return result.filter((res) => typeof res === 'string').length ? result : null;
                }
                const conditionErrors = runValidation(rule.conditions, (cond) => new _accounts_rules__WEBPACK_IMPORTED_MODULE_1__.Condition(cond.op, cond.field, cond.value, cond.options, _shared_rules__WEBPACK_IMPORTED_MODULE_0__.FIELD_TYPES));
                const actionErrors = runValidation(rule.actions, (action) => action.op === 'set-split-amount' ? new _accounts_rules__WEBPACK_IMPORTED_MODULE_1__.Action(action.op, null, action.value, action.options, _shared_rules__WEBPACK_IMPORTED_MODULE_0__.FIELD_TYPES) : action.op === 'link-schedule' ? new _accounts_rules__WEBPACK_IMPORTED_MODULE_1__.Action(action.op, null, action.value, null, _shared_rules__WEBPACK_IMPORTED_MODULE_0__.FIELD_TYPES) : new _accounts_rules__WEBPACK_IMPORTED_MODULE_1__.Action(action.op, action.field, action.value, action.options, _shared_rules__WEBPACK_IMPORTED_MODULE_0__.FIELD_TYPES));
                if (conditionErrors || actionErrors) {
                    return {
                        conditionErrors,
                        actionErrors
                    };
                }
                return null;
            }
            // Expose functions to the client
            const app = (0, _app__WEBPACK_IMPORTED_MODULE_3__.createApp)();
            app.method('rule-validate', async function (rule) {
                const error = validateRule(rule);
                return {
                    error
                };
            });
            app.method('rule-add', (0, _mutators__WEBPACK_IMPORTED_MODULE_5__.mutator)(async function (rule) {
                const error = validateRule(rule);
                if (error) {
                    return {
                        error
                    };
                }
                const id = await _accounts_transaction_rules__WEBPACK_IMPORTED_MODULE_2__.insertRule(rule);
                return {
                    id,
                    ...rule
                };
            }));
            app.method('rule-update', (0, _mutators__WEBPACK_IMPORTED_MODULE_5__.mutator)(async function (rule) {
                const error = validateRule(rule);
                if (error) {
                    return {
                        error
                    };
                }
                await _accounts_transaction_rules__WEBPACK_IMPORTED_MODULE_2__.updateRule(rule);
                return rule;
            }));
            app.method('rule-delete', (0, _mutators__WEBPACK_IMPORTED_MODULE_5__.mutator)(async function (rule) {
                return _accounts_transaction_rules__WEBPACK_IMPORTED_MODULE_2__.deleteRule(rule);
            }));
            app.method('rule-delete-all', (0, _mutators__WEBPACK_IMPORTED_MODULE_5__.mutator)(async function (ids) {
                let someDeletionsFailed = false;
                await (0, _sync__WEBPACK_IMPORTED_MODULE_6__.batchMessages)(async () => {
                    for (const id of ids) {
                        const res = await _accounts_transaction_rules__WEBPACK_IMPORTED_MODULE_2__.deleteRule({
                            id
                        });
                        if (res === false) {
                            someDeletionsFailed = true;
                        }
                    }
                });
                return {
                    someDeletionsFailed
                };
            }));
            app.method('rule-apply-actions', (0, _mutators__WEBPACK_IMPORTED_MODULE_5__.mutator)((0, _undo__WEBPACK_IMPORTED_MODULE_7__.undoable)(async function ({ transactions, actions }) {
                return _accounts_transaction_rules__WEBPACK_IMPORTED_MODULE_2__.applyActions(transactions, actions);
            })));
            app.method('rule-add-payee-rename', (0, _mutators__WEBPACK_IMPORTED_MODULE_5__.mutator)(async function ({ fromNames, to }) {
                return _accounts_transaction_rules__WEBPACK_IMPORTED_MODULE_2__.updatePayeeRenameRule(fromNames, to);
            }));
            app.method('rules-get', async function () {
                return (0, _accounts_rules__WEBPACK_IMPORTED_MODULE_1__.rankRules)(_accounts_transaction_rules__WEBPACK_IMPORTED_MODULE_2__.getRules()).map((rule) => rule.serialize());
            });
            app.method('rule-get', async function ({ id }) {
                const rule = _accounts_transaction_rules__WEBPACK_IMPORTED_MODULE_2__.getRules().find((rule) => rule.id === id);
                return rule ? rule.serialize() : null;
            });
            app.method('rules-run', async function ({ transaction }) {
                return _accounts_transaction_rules__WEBPACK_IMPORTED_MODULE_2__.runRules(transaction);
            });
            /***/ 
        }),
        /***/ "./packages/loot-core/src/server/schedules/app.ts": 
        /*!********************************************************!*\
          !*** ./packages/loot-core/src/server/schedules/app.ts ***!
          \********************************************************/
        /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony export */ __webpack_require__.d(__webpack_exports__, {
                /* harmony export */ app: () => ( /* binding */app),
                /* harmony export */ createSchedule: () => ( /* binding */createSchedule),
                /* harmony export */ deleteSchedule: () => ( /* binding */deleteSchedule),
                /* harmony export */ getDateWithSkippedWeekend: () => ( /* binding */getDateWithSkippedWeekend),
                /* harmony export */ getNextDate: () => ( /* binding */getNextDate),
                /* harmony export */ getRuleForSchedule: () => ( /* binding */getRuleForSchedule),
                /* harmony export */ setNextDate: () => ( /* binding */setNextDate),
                /* harmony export */ updateConditions: () => ( /* binding */updateConditions),
                /* harmony export */ updateSchedule: () => ( /* binding */updateSchedule)
                /* harmony export */ 
            });
            /* harmony import */ var date_fns__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! date-fns */ "./node_modules/date-fns/esm/startOfDay/index.js");
            /* harmony import */ var date_fns__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! date-fns */ "./node_modules/date-fns/esm/addDays/index.js");
            /* harmony import */ var date_fns__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! date-fns */ "./node_modules/date-fns/esm/isWeekend/index.js");
            /* harmony import */ var date_fns__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! date-fns */ "./node_modules/date-fns/esm/nextMonday/index.js");
            /* harmony import */ var date_fns__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! date-fns */ "./node_modules/date-fns/esm/previousFriday/index.js");
            /* harmony import */ var deep_equal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! deep-equal */ "./node_modules/deep-equal/index.js");
            /* harmony import */ var deep_equal__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/ __webpack_require__.n(deep_equal__WEBPACK_IMPORTED_MODULE_0__);
            /* harmony import */ var uuid__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! uuid */ "./node_modules/uuid/dist/esm-node/v4.js");
            /* harmony import */ var _platform_exceptions__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../platform/exceptions */ "./packages/loot-core/src/platform/exceptions/index.electron.ts");
            /* harmony import */ var _platform_server_connection__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../platform/server/connection */ "./packages/loot-core/src/platform/server/connection/index.api.ts");
            /* harmony import */ var _shared_months__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../shared/months */ "./packages/loot-core/src/shared/months.ts");
            /* harmony import */ var _shared_query__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../shared/query */ "./packages/loot-core/src/shared/query.ts");
            /* harmony import */ var _shared_schedules__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../shared/schedules */ "./packages/loot-core/src/shared/schedules.ts");
            /* harmony import */ var _accounts_rules__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../accounts/rules */ "./packages/loot-core/src/server/accounts/rules.ts");
            /* harmony import */ var _accounts_sync__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../accounts/sync */ "./packages/loot-core/src/server/accounts/sync.ts");
            /* harmony import */ var _accounts_transaction_rules__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../accounts/transaction-rules */ "./packages/loot-core/src/server/accounts/transaction-rules.ts");
            /* harmony import */ var _app__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../app */ "./packages/loot-core/src/server/app.ts");
            /* harmony import */ var _aql__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../aql */ "./packages/loot-core/src/server/aql/index.ts");
            /* harmony import */ var _db__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../db */ "./packages/loot-core/src/server/db/index.ts");
            /* harmony import */ var _models__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../models */ "./packages/loot-core/src/server/models.ts");
            /* harmony import */ var _mutators__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../mutators */ "./packages/loot-core/src/server/mutators.ts");
            /* harmony import */ var _prefs__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ../prefs */ "./packages/loot-core/src/server/prefs.ts");
            /* harmony import */ var _sync__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ../sync */ "./packages/loot-core/src/server/sync/index.ts");
            /* harmony import */ var _undo__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ../undo */ "./packages/loot-core/src/server/undo.ts");
            /* harmony import */ var _util_rschedule__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ../util/rschedule */ "./packages/loot-core/src/server/util/rschedule.ts");
            /* harmony import */ var _find_schedules__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./find-schedules */ "./packages/loot-core/src/server/schedules/find-schedules.ts");
            // @ts-strict-ignore
            // Utilities
            function zip(arr1, arr2) {
                const result = [];
                for (let i = 0; i < arr1.length; i++) {
                    result.push([
                        arr1[i],
                        arr2[i]
                    ]);
                }
                return result;
            }
            function updateConditions(conditions, newConditions) {
                const scheduleConds = (0, _shared_schedules__WEBPACK_IMPORTED_MODULE_5__.extractScheduleConds)(conditions);
                const newScheduleConds = (0, _shared_schedules__WEBPACK_IMPORTED_MODULE_5__.extractScheduleConds)(newConditions);
                const replacements = zip(Object.values(scheduleConds), Object.values(newScheduleConds));
                const updated = conditions.map((cond) => {
                    const r = replacements.find((r) => cond === r[0]);
                    return r && r[1] ? r[1] : cond;
                });
                const added = replacements.filter((x) => x[0] == null && x[1] != null).map((x) => x[1]);
                return updated.concat(added);
            }
            function getNextDate(dateCond, start = new Date((0, _shared_months__WEBPACK_IMPORTED_MODULE_3__.currentDay)()), noSkipWeekend = false) {
                start = date_fns__WEBPACK_IMPORTED_MODULE_19__["default"](start);
                const cond = new _accounts_rules__WEBPACK_IMPORTED_MODULE_6__.Condition(dateCond.op, 'date', dateCond.value, null, new Map(Object.entries({
                    date: 'date'
                })));
                const value = cond.getValue();
                if (value.type === 'date') {
                    return value.date;
                }
                else if (value.type === 'recur') {
                    let dates = value.schedule.occurrences({
                        start,
                        take: 1
                    }).toArray();
                    if (dates.length === 0) {
                        // Could be a schedule with limited occurrences, so we try to
                        // find the last occurrence
                        dates = value.schedule.occurrences({
                            reverse: true,
                            take: 1
                        }).toArray();
                    }
                    if (dates.length > 0) {
                        let date = dates[0].date;
                        if (value.schedule.data.skipWeekend && !noSkipWeekend) {
                            date = getDateWithSkippedWeekend(date, value.schedule.data.weekendSolve);
                        }
                        return (0, _shared_months__WEBPACK_IMPORTED_MODULE_3__.dayFromDate)(date);
                    }
                }
                return null;
            }
            async function getRuleForSchedule(id) {
                if (id == null) {
                    throw new Error('Schedule not attached to a rule');
                }
                const { data: ruleId } = await (0, _aql__WEBPACK_IMPORTED_MODULE_10__.runQuery)((0, _shared_query__WEBPACK_IMPORTED_MODULE_4__.q)('schedules').filter({
                    id
                }).calculate('rule'));
                return (0, _accounts_transaction_rules__WEBPACK_IMPORTED_MODULE_8__.getRules)().find((rule) => rule.id === ruleId);
            }
            async function fixRuleForSchedule(id) {
                const { data: ruleId } = await (0, _aql__WEBPACK_IMPORTED_MODULE_10__.runQuery)((0, _shared_query__WEBPACK_IMPORTED_MODULE_4__.q)('schedules').filter({
                    id
                }).calculate('rule'));
                if (ruleId) {
                    // Take the bad rule out of the system so it never causes problems
                    // in the future
                    await _db__WEBPACK_IMPORTED_MODULE_11__.delete_('rules', ruleId);
                }
                const newId = await (0, _accounts_transaction_rules__WEBPACK_IMPORTED_MODULE_8__.insertRule)({
                    stage: null,
                    conditionsOp: 'and',
                    conditions: [
                        {
                            op: 'isapprox',
                            field: 'date',
                            value: (0, _shared_months__WEBPACK_IMPORTED_MODULE_3__.currentDay)()
                        },
                        {
                            op: 'isapprox',
                            field: 'amount',
                            value: 0
                        }
                    ],
                    actions: [
                        {
                            op: 'link-schedule',
                            value: id
                        }
                    ]
                });
                await _db__WEBPACK_IMPORTED_MODULE_11__.updateWithSchema('schedules', {
                    id,
                    rule: newId
                });
                return (0, _accounts_transaction_rules__WEBPACK_IMPORTED_MODULE_8__.getRules)().find((rule) => rule.id === newId);
            }
            async function setNextDate({ id, start, conditions, reset }) {
                if (conditions == null) {
                    const rule = await getRuleForSchedule(id);
                    if (rule == null) {
                        throw new Error('No rule found for schedule');
                    }
                    conditions = rule.serialize().conditions;
                }
                const { date: dateCond } = (0, _shared_schedules__WEBPACK_IMPORTED_MODULE_5__.extractScheduleConds)(conditions);
                const { data: nextDate } = await (0, _aql__WEBPACK_IMPORTED_MODULE_10__.runQuery)((0, _shared_query__WEBPACK_IMPORTED_MODULE_4__.q)('schedules').filter({
                    id
                }).calculate('next_date'));
                // Only do this if a date condition exists
                if (dateCond) {
                    const newNextDate = getNextDate(dateCond, start ? start(nextDate) : new Date());
                    if (newNextDate !== nextDate) {
                        // Our `update` functon requires the id of the item and we don't
                        // have it, so we need to query it
                        const nd = await _db__WEBPACK_IMPORTED_MODULE_11__.first('SELECT id, base_next_date_ts FROM schedules_next_date WHERE schedule_id = ?', [
                            id
                        ]);
                        await _db__WEBPACK_IMPORTED_MODULE_11__.update('schedules_next_date', reset ? {
                            id: nd.id,
                            base_next_date: (0, _models__WEBPACK_IMPORTED_MODULE_12__.toDateRepr)(newNextDate),
                            base_next_date_ts: Date.now()
                        } : {
                            id: nd.id,
                            local_next_date: (0, _models__WEBPACK_IMPORTED_MODULE_12__.toDateRepr)(newNextDate),
                            local_next_date_ts: nd.base_next_date_ts
                        });
                    }
                }
            }
            // Methods
            async function checkIfScheduleExists(name, scheduleId) {
                const idForName = await _db__WEBPACK_IMPORTED_MODULE_11__.first('SELECT id from schedules WHERE tombstone = 0 AND name = ?', [
                    name
                ]);
                if (idForName == null) {
                    return false;
                }
                if (scheduleId) {
                    return idForName['id'] !== scheduleId;
                }
                return true;
            }
            async function createSchedule({ schedule = null, conditions = [] } = {}) {
                const scheduleId = schedule?.id || (0, uuid__WEBPACK_IMPORTED_MODULE_20__["default"])();
                const { date: dateCond } = (0, _shared_schedules__WEBPACK_IMPORTED_MODULE_5__.extractScheduleConds)(conditions);
                if (dateCond == null) {
                    throw new Error('A date condition is required to create a schedule');
                }
                if (dateCond.value == null) {
                    throw new Error('Date is required');
                }
                const nextDate = getNextDate(dateCond);
                const nextDateRepr = nextDate ? (0, _models__WEBPACK_IMPORTED_MODULE_12__.toDateRepr)(nextDate) : null;
                if (schedule) {
                    if (schedule.name) {
                        if (await checkIfScheduleExists(schedule.name, scheduleId)) {
                            throw new Error('Cannot create schedules with the same name');
                        }
                    }
                    else {
                        schedule.name = null;
                    }
                }
                // Create the rule here based on the info
                const ruleId = await (0, _accounts_transaction_rules__WEBPACK_IMPORTED_MODULE_8__.insertRule)({
                    stage: null,
                    conditionsOp: 'and',
                    conditions,
                    actions: [
                        {
                            op: 'link-schedule',
                            value: scheduleId
                        }
                    ]
                });
                const now = Date.now();
                await _db__WEBPACK_IMPORTED_MODULE_11__.insertWithUUID('schedules_next_date', {
                    schedule_id: scheduleId,
                    local_next_date: nextDateRepr,
                    local_next_date_ts: now,
                    base_next_date: nextDateRepr,
                    base_next_date_ts: now
                });
                await _db__WEBPACK_IMPORTED_MODULE_11__.insertWithSchema('schedules', {
                    ...schedule,
                    id: scheduleId,
                    rule: ruleId
                });
                return scheduleId;
            }
            // TODO: don't allow deleting rules that link schedules
            async function updateSchedule({ schedule, conditions, resetNextDate }) {
                if (schedule.rule) {
                    throw new Error('You cannot change the rule of a schedule');
                }
                let rule;
                // This must be outside the `batchMessages` call because we change
                // and then read data
                if (conditions) {
                    const { date: dateCond } = (0, _shared_schedules__WEBPACK_IMPORTED_MODULE_5__.extractScheduleConds)(conditions);
                    if (dateCond && dateCond.value == null) {
                        throw new Error('Date is required');
                    }
                    // We need to get the full rule to merge in the updated
                    // conditions
                    rule = await getRuleForSchedule(schedule.id);
                    if (rule == null) {
                        // In the edge case that a rule gets corrupted (either by a bug in
                        // the system or user messing with their data), don't crash. We
                        // generate a new rule because schedules have to have a rule
                        // attached to them.
                        rule = await fixRuleForSchedule(schedule.id);
                    }
                }
                await (0, _sync__WEBPACK_IMPORTED_MODULE_15__.batchMessages)(async () => {
                    if (conditions) {
                        const oldConditions = rule.serialize().conditions;
                        const newConditions = updateConditions(oldConditions, conditions);
                        await (0, _accounts_transaction_rules__WEBPACK_IMPORTED_MODULE_8__.updateRule)({
                            id: rule.id,
                            conditions: newConditions
                        });
                        // Annoyingly, sometimes it has `type` and sometimes it doesn't
                        const stripType = ({ type, ...fields }) => fields;
                        // Update `next_date` if the user forced it, or if the account
                        // or date changed. We check account because we don't update
                        // schedules automatically for closed account, and the user
                        // might switch accounts from a closed one
                        if (resetNextDate || !deep_equal__WEBPACK_IMPORTED_MODULE_0___default()(oldConditions.find((c) => c.field === 'account'), oldConditions.find((c) => c.field === 'account')) || !deep_equal__WEBPACK_IMPORTED_MODULE_0___default()(stripType(oldConditions.find((c) => c.field === 'date') || {}), stripType(newConditions.find((c) => c.field === 'date') || {}))) {
                            await setNextDate({
                                id: schedule.id,
                                conditions: newConditions,
                                reset: true
                            });
                        }
                    }
                    else if (resetNextDate) {
                        await setNextDate({
                            id: schedule.id,
                            reset: true
                        });
                    }
                    await _db__WEBPACK_IMPORTED_MODULE_11__.updateWithSchema('schedules', schedule);
                });
            }
            async function deleteSchedule({ id }) {
                const { data: ruleId } = await (0, _aql__WEBPACK_IMPORTED_MODULE_10__.runQuery)((0, _shared_query__WEBPACK_IMPORTED_MODULE_4__.q)('schedules').filter({
                    id
                }).calculate('rule'));
                await (0, _sync__WEBPACK_IMPORTED_MODULE_15__.batchMessages)(async () => {
                    await _db__WEBPACK_IMPORTED_MODULE_11__.delete_('rules', ruleId);
                    await _db__WEBPACK_IMPORTED_MODULE_11__.delete_('schedules', id);
                });
            }
            async function skipNextDate({ id }) {
                return setNextDate({
                    id,
                    start: (nextDate) => {
                        return date_fns__WEBPACK_IMPORTED_MODULE_21__["default"]((0, _shared_months__WEBPACK_IMPORTED_MODULE_3__.parseDate)(nextDate), 1);
                    }
                });
            }
            function discoverSchedules() {
                return (0, _find_schedules__WEBPACK_IMPORTED_MODULE_18__.findSchedules)();
            }
            async function getUpcomingDates({ config, count }) {
                const rules = (0, _shared_schedules__WEBPACK_IMPORTED_MODULE_5__.recurConfigToRSchedule)(config);
                try {
                    const schedule = new _util_rschedule__WEBPACK_IMPORTED_MODULE_17__.Schedule({
                        rrules: rules
                    });
                    return schedule.occurrences({
                        start: date_fns__WEBPACK_IMPORTED_MODULE_19__["default"](new Date()),
                        take: count
                    }).toArray().map((date) => config.skipWeekend ? getDateWithSkippedWeekend(date.date, config.weekendSolveMode) : date.date).map((date) => (0, _shared_months__WEBPACK_IMPORTED_MODULE_3__.dayFromDate)(date));
                }
                catch (err) {
                    (0, _platform_exceptions__WEBPACK_IMPORTED_MODULE_1__.captureBreadcrumb)(config);
                    throw err;
                }
            }
            // Services
            function onRuleUpdate(rule) {
                const { actions, conditions } = rule instanceof _accounts_rules__WEBPACK_IMPORTED_MODULE_6__.Rule ? rule.serialize() : _accounts_transaction_rules__WEBPACK_IMPORTED_MODULE_8__.ruleModel.toJS(rule);
                if (actions && actions.find((a) => a.op === 'link-schedule')) {
                    const scheduleId = actions.find((a) => a.op === 'link-schedule').value;
                    if (scheduleId) {
                        const conds = (0, _shared_schedules__WEBPACK_IMPORTED_MODULE_5__.extractScheduleConds)(conditions);
                        const payeeIdx = conditions.findIndex((c) => c === conds.payee);
                        const accountIdx = conditions.findIndex((c) => c === conds.account);
                        const amountIdx = conditions.findIndex((c) => c === conds.amount);
                        const dateIdx = conditions.findIndex((c) => c === conds.date);
                        _db__WEBPACK_IMPORTED_MODULE_11__.runQuery('INSERT OR REPLACE INTO schedules_json_paths (schedule_id, payee, account, amount, date) VALUES (?, ?, ?, ?, ?)', [
                            scheduleId,
                            payeeIdx === -1 ? null : `$[${payeeIdx}]`,
                            accountIdx === -1 ? null : `$[${accountIdx}]`,
                            amountIdx === -1 ? null : `$[${amountIdx}]`,
                            dateIdx === -1 ? null : `$[${dateIdx}]`
                        ]);
                    }
                }
            }
            function trackJSONPaths() {
                // Populate the table
                _db__WEBPACK_IMPORTED_MODULE_11__.transaction(() => {
                    (0, _accounts_transaction_rules__WEBPACK_IMPORTED_MODULE_8__.getRules)().forEach((rule) => {
                        onRuleUpdate(rule);
                    });
                });
                return (0, _sync__WEBPACK_IMPORTED_MODULE_15__.addSyncListener)(onApplySync);
            }
            function onApplySync(oldValues, newValues) {
                newValues.forEach((items, table) => {
                    if (table === 'rules') {
                        items.forEach((newValue) => {
                            onRuleUpdate(newValue);
                        });
                    }
                });
            }
            // This is the service that move schedules forward automatically and
            // posts transactions
            async function postTransactionForSchedule({ id }) {
                const { data } = await (0, _aql__WEBPACK_IMPORTED_MODULE_10__.runQuery)((0, _shared_query__WEBPACK_IMPORTED_MODULE_4__.q)('schedules').filter({
                    id
                }).select('*'));
                const schedule = data[0];
                if (schedule == null || schedule._account == null) {
                    return;
                }
                const transaction = {
                    payee: schedule._payee,
                    account: schedule._account,
                    amount: (0, _shared_schedules__WEBPACK_IMPORTED_MODULE_5__.getScheduledAmount)(schedule._amount),
                    date: schedule.next_date,
                    schedule: schedule.id,
                    cleared: false
                };
                if (transaction.account) {
                    await (0, _accounts_sync__WEBPACK_IMPORTED_MODULE_7__.addTransactions)(transaction.account, [
                        transaction
                    ]);
                }
            }
            // TODO: make this sequential
            async function advanceSchedulesService(syncSuccess) {
                // Move all paid schedules
                const { data: schedules } = await (0, _aql__WEBPACK_IMPORTED_MODULE_10__.runQuery)((0, _shared_query__WEBPACK_IMPORTED_MODULE_4__.q)('schedules').filter({
                    completed: false,
                    '_account.closed': false
                }).select('*'));
                const { data: hasTransData } = await (0, _aql__WEBPACK_IMPORTED_MODULE_10__.runQuery)((0, _shared_schedules__WEBPACK_IMPORTED_MODULE_5__.getHasTransactionsQuery)(schedules));
                const hasTrans = new Set(hasTransData.filter(Boolean).map((row) => row.schedule));
                const failedToPost = [];
                let didPost = false;
                for (const schedule of schedules) {
                    const status = (0, _shared_schedules__WEBPACK_IMPORTED_MODULE_5__.getStatus)(schedule.next_date, schedule.completed, hasTrans.has(schedule.id));
                    if (status === 'paid') {
                        if (schedule._date) {
                            // Move forward recurring schedules
                            if (schedule._date.frequency) {
                                try {
                                    await setNextDate({
                                        id: schedule.id
                                    });
                                }
                                catch (err) {
                                    // This might error if the rule is corrupted and it can't
                                    // find the rule
                                }
                            }
                            else {
                                if (schedule._date < (0, _shared_months__WEBPACK_IMPORTED_MODULE_3__.currentDay)()) {
                                    // Complete any single schedules
                                    await updateSchedule({
                                        schedule: {
                                            id: schedule.id,
                                            completed: true
                                        }
                                    });
                                }
                            }
                        }
                    }
                    else if ((status === 'due' || status === 'missed') && schedule.posts_transaction && schedule._account) {
                        // Automatically create a transaction for due schedules
                        if (syncSuccess) {
                            await postTransactionForSchedule({
                                id: schedule.id
                            });
                            didPost = true;
                        }
                        else {
                            failedToPost.push(schedule._payee);
                        }
                    }
                }
                if (failedToPost.length > 0) {
                    _platform_server_connection__WEBPACK_IMPORTED_MODULE_2__.send('schedules-offline', {
                        payees: failedToPost
                    });
                }
                else if (didPost) {
                    // This forces a full refresh of transactions because it
                    // simulates them coming in from a full sync. This not a
                    // great API right now, but I think generally the approach
                    // is sane to treat them as external sync events.
                    _platform_server_connection__WEBPACK_IMPORTED_MODULE_2__.send('sync-event', {
                        type: 'success',
                        tables: [
                            'transactions'
                        ],
                        syncDisabled: 'false'
                    });
                }
            }
            // Expose functions to the client
            const app = (0, _app__WEBPACK_IMPORTED_MODULE_9__.createApp)();
            app.method('schedule/create', (0, _mutators__WEBPACK_IMPORTED_MODULE_13__.mutator)((0, _undo__WEBPACK_IMPORTED_MODULE_16__.undoable)(createSchedule)));
            app.method('schedule/update', (0, _mutators__WEBPACK_IMPORTED_MODULE_13__.mutator)((0, _undo__WEBPACK_IMPORTED_MODULE_16__.undoable)(updateSchedule)));
            app.method('schedule/delete', (0, _mutators__WEBPACK_IMPORTED_MODULE_13__.mutator)((0, _undo__WEBPACK_IMPORTED_MODULE_16__.undoable)(deleteSchedule)));
            app.method('schedule/skip-next-date', (0, _mutators__WEBPACK_IMPORTED_MODULE_13__.mutator)((0, _undo__WEBPACK_IMPORTED_MODULE_16__.undoable)(skipNextDate)));
            app.method('schedule/post-transaction', (0, _mutators__WEBPACK_IMPORTED_MODULE_13__.mutator)((0, _undo__WEBPACK_IMPORTED_MODULE_16__.undoable)(postTransactionForSchedule)));
            app.method('schedule/force-run-service', (0, _mutators__WEBPACK_IMPORTED_MODULE_13__.mutator)(() => advanceSchedulesService(true)));
            app.method('schedule/discover', discoverSchedules);
            app.method('schedule/get-upcoming-dates', getUpcomingDates);
            app.service(trackJSONPaths);
            app.events.on('sync', ({ type }) => {
                const completeEvent = type === 'success' || type === 'error' || type === 'unauthorized';
                if (completeEvent && _prefs__WEBPACK_IMPORTED_MODULE_14__.getPrefs()) {
                    const { lastScheduleRun } = _prefs__WEBPACK_IMPORTED_MODULE_14__.getPrefs();
                    if (lastScheduleRun !== (0, _shared_months__WEBPACK_IMPORTED_MODULE_3__.currentDay)()) {
                        (0, _mutators__WEBPACK_IMPORTED_MODULE_13__.runMutator)(() => advanceSchedulesService(type === 'success'));
                        _prefs__WEBPACK_IMPORTED_MODULE_14__.savePrefs({
                            lastScheduleRun: (0, _shared_months__WEBPACK_IMPORTED_MODULE_3__.currentDay)()
                        });
                    }
                }
            });
            function getDateWithSkippedWeekend(date, solveMode) {
                if (date_fns__WEBPACK_IMPORTED_MODULE_22__["default"](date)) {
                    if (solveMode === 'after') {
                        return date_fns__WEBPACK_IMPORTED_MODULE_23__["default"](date);
                    }
                    else if (solveMode === 'before') {
                        return date_fns__WEBPACK_IMPORTED_MODULE_24__["default"](date);
                    }
                    else {
                        throw new Error('Unknown weekend solve mode, this should not happen!');
                    }
                }
                return date;
            }
            /***/ 
        }),
        /***/ "./packages/loot-core/src/server/schedules/find-schedules.ts": 
        /*!*******************************************************************!*\
          !*** ./packages/loot-core/src/server/schedules/find-schedules.ts ***!
          \*******************************************************************/
        /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony export */ __webpack_require__.d(__webpack_exports__, {
                /* harmony export */ findSchedules: () => ( /* binding */findSchedules)
                /* harmony export */ 
            });
            /* harmony import */ var date_fns__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! date-fns */ "./node_modules/date-fns/esm/subDays/index.js");
            /* harmony import */ var date_fns__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! date-fns */ "./node_modules/date-fns/esm/addDays/index.js");
            /* harmony import */ var date_fns__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! date-fns */ "./node_modules/date-fns/esm/differenceInDays/index.js");
            /* harmony import */ var date_fns__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! date-fns */ "./node_modules/date-fns/esm/subWeeks/index.js");
            /* harmony import */ var date_fns__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! date-fns */ "./node_modules/date-fns/esm/subMonths/index.js");
            /* harmony import */ var date_fns__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! date-fns */ "./node_modules/date-fns/esm/getDate/index.js");
            /* harmony import */ var date_fns__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! date-fns */ "./node_modules/date-fns/esm/format/index.js");
            /* harmony import */ var date_fns__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! date-fns */ "./node_modules/date-fns/esm/subYears/index.js");
            /* harmony import */ var uuid__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! uuid */ "./node_modules/uuid/dist/esm-node/v4.js");
            /* harmony import */ var _shared_months__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../shared/months */ "./packages/loot-core/src/shared/months.ts");
            /* harmony import */ var _shared_query__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../shared/query */ "./packages/loot-core/src/shared/query.ts");
            /* harmony import */ var _shared_rules__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../shared/rules */ "./packages/loot-core/src/shared/rules.ts");
            /* harmony import */ var _shared_schedules__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../shared/schedules */ "./packages/loot-core/src/shared/schedules.ts");
            /* harmony import */ var _shared_util__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../shared/util */ "./packages/loot-core/src/shared/util.ts");
            /* harmony import */ var _accounts_transaction_rules__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../accounts/transaction-rules */ "./packages/loot-core/src/server/accounts/transaction-rules.ts");
            /* harmony import */ var _aql__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../aql */ "./packages/loot-core/src/server/aql/index.ts");
            /* harmony import */ var _db__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../db */ "./packages/loot-core/src/server/db/index.ts");
            /* harmony import */ var _models__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../models */ "./packages/loot-core/src/server/models.ts");
            /* harmony import */ var _util_rschedule__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../util/rschedule */ "./packages/loot-core/src/server/util/rschedule.ts");
            // @ts-strict-ignore
            function takeDates(config) {
                const schedule = new _util_rschedule__WEBPACK_IMPORTED_MODULE_9__.Schedule({
                    rrules: (0, _shared_schedules__WEBPACK_IMPORTED_MODULE_3__.recurConfigToRSchedule)(config)
                });
                return schedule.occurrences({
                    take: 3
                }).toArray().map((d) => d.date);
            }
            async function getTransactions(date, account) {
                const { data } = await (0, _aql__WEBPACK_IMPORTED_MODULE_6__.runQuery)((0, _shared_query__WEBPACK_IMPORTED_MODULE_1__.q)('transactions').filter({
                    account,
                    schedule: null,
                    // Don't match transfers
                    'payee.transfer_acct': null,
                    $and: [
                        {
                            date: {
                                $gte: date_fns__WEBPACK_IMPORTED_MODULE_10__["default"](date, 2)
                            }
                        },
                        {
                            date: {
                                $lte: date_fns__WEBPACK_IMPORTED_MODULE_11__["default"](date, 2)
                            }
                        }
                    ]
                }).select('*').options({
                    splits: 'none'
                }));
                return data;
            }
            function getRank(day1, day2) {
                const dayDiff = Math.abs(date_fns__WEBPACK_IMPORTED_MODULE_12__["default"]((0, _shared_months__WEBPACK_IMPORTED_MODULE_0__.parseDate)(day1), (0, _shared_months__WEBPACK_IMPORTED_MODULE_0__.parseDate)(day2)));
                // The amount of days off determines the rank: exact same day
                // is highest rank 1, 1 day off is .5, etc. This will find the
                // best start date that matches all the dates the closest
                return 1 / (dayDiff + 1);
            }
            function matchSchedules(allOccurs, config) {
                allOccurs = [
                    ...allOccurs
                ].reverse();
                const baseOccur = allOccurs[0];
                const occurs = allOccurs.slice(1);
                const schedules = [];
                for (const trans of baseOccur.transactions) {
                    const threshold = (0, _shared_rules__WEBPACK_IMPORTED_MODULE_2__.getApproxNumberThreshold)(trans.amount);
                    const payee = trans.payee;
                    const found = occurs.map((occur) => {
                        let matched = occur.transactions.find((t) => t.amount >= trans.amount - threshold && t.amount <= trans.amount + threshold);
                        matched = matched && matched.payee === payee ? matched : null;
                        if (matched) {
                            return {
                                trans: matched,
                                rank: getRank(occur.date, matched.date)
                            };
                        }
                        return null;
                    });
                    if (found.indexOf(null) !== -1) {
                        continue;
                    }
                    const rank = found.reduce((total, match) => total + match.rank, getRank(baseOccur.date, trans.date));
                    const exactAmount = found.reduce((exact, match) => exact && match.trans.amount === trans.amount, true);
                    schedules.push({
                        rank,
                        amount: trans.amount,
                        account: trans.account,
                        payee: trans.payee,
                        date: config,
                        // Exact dates rank as 1, so all of them matches exactly it
                        // would equal the number of `allOccurs`
                        exactDate: rank === allOccurs.length,
                        exactAmount
                    });
                }
                return schedules;
            }
            async function schedulesForPattern(baseStart, numDays, baseConfig, accountId) {
                let schedules = [];
                for (let i = 0; i < numDays; i++) {
                    const start = date_fns__WEBPACK_IMPORTED_MODULE_11__["default"](baseStart, i);
                    let config;
                    if (typeof baseConfig === 'function') {
                        config = baseConfig(start);
                        if (config === false) {
                            continue;
                        }
                    }
                    else {
                        config = {
                            ...baseConfig,
                            start
                        };
                    }
                    // Our recur config expects a day string, not a native date format
                    config.start = (0, _shared_months__WEBPACK_IMPORTED_MODULE_0__.dayFromDate)(config.start);
                    const data = [];
                    const dates = takeDates(config);
                    for (const date of dates) {
                        data.push({
                            date: (0, _shared_months__WEBPACK_IMPORTED_MODULE_0__.dayFromDate)(date),
                            transactions: await getTransactions(date, accountId)
                        });
                    }
                    schedules = schedules.concat(matchSchedules(data, config));
                }
                return schedules;
            }
            async function weekly(startDate, accountId) {
                return schedulesForPattern(date_fns__WEBPACK_IMPORTED_MODULE_13__["default"]((0, _shared_months__WEBPACK_IMPORTED_MODULE_0__.parseDate)(startDate), 4), 7 * 2, {
                    frequency: 'weekly'
                }, accountId);
            }
            async function every2weeks(startDate, accountId) {
                return schedulesForPattern(// 6 weeks would cover 3 instances, but we also scan an addition
                // week back
                date_fns__WEBPACK_IMPORTED_MODULE_13__["default"]((0, _shared_months__WEBPACK_IMPORTED_MODULE_0__.parseDate)(startDate), 7), 7 * 2, {
                    frequency: 'weekly',
                    interval: 2
                }, accountId);
            }
            async function monthly(startDate, accountId) {
                return schedulesForPattern(date_fns__WEBPACK_IMPORTED_MODULE_14__["default"]((0, _shared_months__WEBPACK_IMPORTED_MODULE_0__.parseDate)(startDate), 4), 31 * 2, (start) => {
                    // 28 is the max number of days that all months are guaranteed
                    // to have. We don't want to go any higher than that because
                    // we'll end up skipping months that don't have that day.
                    // The use cases of end of month days will be covered with the
                    // `monthlyLastDay` pattern;
                    if (date_fns__WEBPACK_IMPORTED_MODULE_15__["default"](start) > 28) {
                        return false;
                    }
                    return {
                        start,
                        frequency: 'monthly'
                    };
                }, accountId);
            }
            async function monthlyLastDay(startDate, accountId) {
                // We do two separate calls because this pattern doesn't fit into
                // how `schedulesForPattern` works
                const s1 = await schedulesForPattern(date_fns__WEBPACK_IMPORTED_MODULE_14__["default"]((0, _shared_months__WEBPACK_IMPORTED_MODULE_0__.parseDate)(startDate), 3), 1, {
                    frequency: 'monthly',
                    patterns: [
                        {
                            type: 'day',
                            value: -1
                        }
                    ]
                }, accountId);
                const s2 = await schedulesForPattern(date_fns__WEBPACK_IMPORTED_MODULE_14__["default"]((0, _shared_months__WEBPACK_IMPORTED_MODULE_0__.parseDate)(startDate), 4), 1, {
                    frequency: 'monthly',
                    patterns: [
                        {
                            type: 'day',
                            value: -1
                        }
                    ]
                }, accountId);
                return s1.concat(s2);
            }
            async function monthly1stor3rd(startDate, accountId) {
                return schedulesForPattern(date_fns__WEBPACK_IMPORTED_MODULE_13__["default"]((0, _shared_months__WEBPACK_IMPORTED_MODULE_0__.parseDate)(startDate), 8), 14, (start) => {
                    const day = date_fns__WEBPACK_IMPORTED_MODULE_16__["default"](new Date(), 'iiii');
                    const dayValue = day.slice(0, 2).toUpperCase();
                    return {
                        start,
                        frequency: 'monthly',
                        patterns: [
                            {
                                type: dayValue,
                                value: 1
                            },
                            {
                                type: dayValue,
                                value: 3
                            }
                        ]
                    };
                }, accountId);
            }
            async function monthly2ndor4th(startDate, accountId) {
                return schedulesForPattern(date_fns__WEBPACK_IMPORTED_MODULE_14__["default"]((0, _shared_months__WEBPACK_IMPORTED_MODULE_0__.parseDate)(startDate), 8), 14, (start) => {
                    const day = date_fns__WEBPACK_IMPORTED_MODULE_16__["default"](new Date(), 'iiii');
                    const dayValue = day.slice(0, 2).toUpperCase();
                    return {
                        start,
                        frequency: 'monthly',
                        patterns: [
                            {
                                type: dayValue,
                                value: 2
                            },
                            {
                                type: dayValue,
                                value: 4
                            }
                        ]
                    };
                }, accountId);
            }
            async function findStartDate(schedule) {
                const conditions = schedule._conditions;
                const dateCond = conditions.find((c) => c.field === 'date');
                let currentConfig = dateCond.value;
                while (1) {
                    const prevConfig = currentConfig;
                    currentConfig = {
                        ...prevConfig
                    };
                    switch (currentConfig.frequency) {
                        case 'weekly':
                            currentConfig.start = (0, _shared_months__WEBPACK_IMPORTED_MODULE_0__.dayFromDate)(date_fns__WEBPACK_IMPORTED_MODULE_13__["default"]((0, _shared_months__WEBPACK_IMPORTED_MODULE_0__.parseDate)(currentConfig.start), currentConfig.interval || 1));
                            break;
                        case 'monthly':
                            currentConfig.start = (0, _shared_months__WEBPACK_IMPORTED_MODULE_0__.dayFromDate)(date_fns__WEBPACK_IMPORTED_MODULE_14__["default"]((0, _shared_months__WEBPACK_IMPORTED_MODULE_0__.parseDate)(currentConfig.start), currentConfig.interval || 1));
                            break;
                        case 'yearly':
                            currentConfig.start = (0, _shared_months__WEBPACK_IMPORTED_MODULE_0__.dayFromDate)(date_fns__WEBPACK_IMPORTED_MODULE_17__["default"]((0, _shared_months__WEBPACK_IMPORTED_MODULE_0__.parseDate)(currentConfig.start), currentConfig.interval || 1));
                            break;
                        default:
                            throw new Error('findStartDate: invalid frequency');
                    }
                    const newConditions = conditions.map((c) => c.field === 'date' ? {
                        ...c,
                        value: currentConfig
                    } : c);
                    const { filters, errors } = (0, _accounts_transaction_rules__WEBPACK_IMPORTED_MODULE_5__.conditionsToAQL)(newConditions, {
                        recurDateBounds: 1
                    });
                    if (errors.length > 0) {
                        // Somehow we generated an invalid config. Abort the whole
                        // process and don't change the date at all
                        currentConfig = null;
                        break;
                    }
                    const { data } = await (0, _aql__WEBPACK_IMPORTED_MODULE_6__.runQuery)((0, _shared_query__WEBPACK_IMPORTED_MODULE_1__.q)('transactions').filter({
                        $and: filters
                    }).select('*'));
                    if (data.length === 0) {
                        // No data, revert back to the last valid value and stop
                        currentConfig = prevConfig;
                        break;
                    }
                }
                if (currentConfig) {
                    return {
                        ...schedule,
                        date: currentConfig,
                        _conditions: conditions.map((c) => c.field === 'date' ? {
                            ...c,
                            value: currentConfig
                        } : c)
                    };
                }
                return schedule;
            }
            async function findSchedules() {
                // Patterns to look for:
                // * Weekly
                // * Every two weeks
                // * Monthly on day X
                // * Monthly on every 1st or 3rd day
                // * Monthly on every 2nd or 4th day
                //
                // Search for them approx (+- 2 days) but track which transactions
                // and find the best one...
                const { data: accounts } = await (0, _aql__WEBPACK_IMPORTED_MODULE_6__.runQuery)((0, _shared_query__WEBPACK_IMPORTED_MODULE_1__.q)('accounts').filter({
                    closed: false
                }).select('*'));
                let allSchedules = [];
                for (const account of accounts) {
                    // Find latest transaction-ish to start with
                    const latestTrans = await _db__WEBPACK_IMPORTED_MODULE_7__.first('SELECT * FROM v_transactions WHERE account = ? AND parent_id IS NULL ORDER BY date DESC LIMIT 1', [
                        account.id
                    ]);
                    if (latestTrans) {
                        const latestDate = (0, _models__WEBPACK_IMPORTED_MODULE_8__.fromDateRepr)(latestTrans.date);
                        allSchedules = allSchedules.concat(await weekly(latestDate, account.id), await every2weeks(latestDate, account.id), await monthly(latestDate, account.id), await monthlyLastDay(latestDate, account.id), await monthly1stor3rd(latestDate, account.id), await monthly2ndor4th(latestDate, account.id));
                    }
                }
                const schedules = [
                    ...(0, _shared_util__WEBPACK_IMPORTED_MODULE_4__.groupBy)(allSchedules, 'payee').entries()
                ].map(([, schedules]) => {
                    schedules.sort((s1, s2) => s2.rank - s1.rank);
                    const winner = schedules[0];
                    // Convert to schedule and return it
                    return {
                        id: (0, uuid__WEBPACK_IMPORTED_MODULE_18__["default"])(),
                        account: winner.account,
                        payee: winner.payee,
                        date: winner.date,
                        amount: winner.amount,
                        _conditions: [
                            {
                                op: 'is',
                                field: 'account',
                                value: winner.account
                            },
                            {
                                op: 'is',
                                field: 'payee',
                                value: winner.payee
                            },
                            {
                                op: winner.exactDate ? 'is' : 'isapprox',
                                field: 'date',
                                value: winner.date
                            },
                            {
                                op: winner.exactAmount ? 'is' : 'isapprox',
                                field: 'amount',
                                value: winner.amount
                            }
                        ]
                    };
                });
                const finalized = [];
                for (const schedule of schedules) {
                    finalized.push(await findStartDate(schedule));
                }
                return finalized;
            }
            /***/ 
        }),
        /***/ "./packages/loot-core/src/server/server-config.ts": 
        /*!********************************************************!*\
          !*** ./packages/loot-core/src/server/server-config.ts ***!
          \********************************************************/
        /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony export */ __webpack_require__.d(__webpack_exports__, {
                /* harmony export */ getServer: () => ( /* binding */getServer),
                /* harmony export */ setServer: () => ( /* binding */setServer)
                /* harmony export */ 
            });
            /* harmony import */ var _platform_server_fs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../platform/server/fs */ "./packages/loot-core/src/platform/server/fs/index.electron.ts");
            let config = null;
            function joinURL(base, ...paths) {
                const url = new URL(base);
                url.pathname = _platform_server_fs__WEBPACK_IMPORTED_MODULE_0__.join(...paths);
                return url.toString();
            }
            function setServer(url) {
                if (url == null) {
                    config = null;
                }
                else {
                    config = getServer(url);
                }
            }
            // `url` is optional; if not given it will provide the global config
            function getServer(url) {
                if (url) {
                    return {
                        BASE_SERVER: url,
                        SYNC_SERVER: joinURL(url, '/sync'),
                        SIGNUP_SERVER: joinURL(url, '/account'),
                        GOCARDLESS_SERVER: joinURL(url, '/gocardless'),
                        SIMPLEFIN_SERVER: joinURL(url, '/simplefin')
                    };
                }
                return config;
            }
            /***/ 
        }),
        /***/ "./packages/loot-core/src/server/sheet.ts": 
        /*!************************************************!*\
          !*** ./packages/loot-core/src/server/sheet.ts ***!
          \************************************************/
        /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony export */ __webpack_require__.d(__webpack_exports__, {
                /* harmony export */ endTransaction: () => ( /* binding */endTransaction),
                /* harmony export */ get: () => ( /* binding */get),
                /* harmony export */ getCell: () => ( /* binding */getCell),
                /* harmony export */ getCellValue: () => ( /* binding */getCellValue),
                /* harmony export */ loadSpreadsheet: () => ( /* binding */loadSpreadsheet),
                /* harmony export */ loadUserBudgets: () => ( /* binding */loadUserBudgets),
                /* harmony export */ reloadSpreadsheet: () => ( /* binding */reloadSpreadsheet),
                /* harmony export */ startTransaction: () => ( /* binding */startTransaction),
                /* harmony export */ unloadSpreadsheet: () => ( /* binding */unloadSpreadsheet),
                /* harmony export */ waitOnSpreadsheet: () => ( /* binding */waitOnSpreadsheet)
                /* harmony export */ 
            });
            /* harmony import */ var _platform_exceptions__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../platform/exceptions */ "./packages/loot-core/src/platform/exceptions/index.electron.ts");
            /* harmony import */ var _platform_server_sqlite__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../platform/server/sqlite */ "./packages/loot-core/src/platform/server/sqlite/index.electron.ts");
            /* harmony import */ var _shared_months__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../shared/months */ "./packages/loot-core/src/shared/months.ts");
            /* harmony import */ var _platform__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./platform */ "./packages/loot-core/src/server/platform.ts");
            /* harmony import */ var _prefs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./prefs */ "./packages/loot-core/src/server/prefs.ts");
            /* harmony import */ var _spreadsheet_spreadsheet__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./spreadsheet/spreadsheet */ "./packages/loot-core/src/server/spreadsheet/spreadsheet.ts");
            /* harmony import */ var _spreadsheet_util__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./spreadsheet/util */ "./packages/loot-core/src/server/spreadsheet/util.ts");
            // @ts-strict-ignore
            let globalSheet;
            let globalOnChange;
            let globalCacheDb;
            function get() {
                return globalSheet;
            }
            async function updateSpreadsheetCache(rawDb, names) {
                await _platform_server_sqlite__WEBPACK_IMPORTED_MODULE_1__.transaction(rawDb, () => {
                    names.forEach((name) => {
                        const node = globalSheet._getNode(name);
                        // Don't cache query nodes yet
                        if (node.sql == null) {
                            _platform_server_sqlite__WEBPACK_IMPORTED_MODULE_1__.runQuery(rawDb, 'INSERT OR REPLACE INTO kvcache (key, value) VALUES (?, ?)', [
                                name,
                                JSON.stringify(node.value)
                            ]);
                        }
                    });
                });
            }
            function setCacheStatus(mainDb, cacheDb, { clean }) {
                if (clean) {
                    // Generate random number and stick in both places
                    const num = Math.random() * 10000000;
                    _platform_server_sqlite__WEBPACK_IMPORTED_MODULE_1__.runQuery(cacheDb, 'INSERT OR REPLACE INTO kvcache_key (id, key) VALUES (1, ?)', [
                        num
                    ]);
                    if (mainDb) {
                        _platform_server_sqlite__WEBPACK_IMPORTED_MODULE_1__.runQuery(mainDb, 'INSERT OR REPLACE INTO kvcache_key (id, key) VALUES (1, ?)', [
                            num
                        ]);
                    }
                }
                else {
                    _platform_server_sqlite__WEBPACK_IMPORTED_MODULE_1__.runQuery(cacheDb, 'DELETE FROM kvcache_key');
                }
            }
            function isCacheDirty(mainDb, cacheDb) {
                let rows = _platform_server_sqlite__WEBPACK_IMPORTED_MODULE_1__.runQuery(cacheDb, 'SELECT key FROM kvcache_key WHERE id = 1', [], true);
                const num = rows.length === 0 ? null : rows[0].key;
                if (num == null) {
                    return true;
                }
                if (mainDb) {
                    const rows = _platform_server_sqlite__WEBPACK_IMPORTED_MODULE_1__.runQuery(mainDb, 'SELECT key FROM kvcache_key WHERE id = 1', [], true);
                    if (rows.length === 0 || rows[0].key !== num) {
                        return true;
                    }
                }
                // Always also check if there is anything in `kvcache`. We ask for one item;
                // if we didn't get back anything it's empty so there is no cache
                rows = _platform_server_sqlite__WEBPACK_IMPORTED_MODULE_1__.runQuery(cacheDb, 'SELECT * FROM kvcache LIMIT 1', [], true);
                return rows.length === 0;
            }
            async function loadSpreadsheet(db, onSheetChange) {
                const cacheEnabled = "development" !== 'test';
                const mainDb = db.getDatabase();
                let cacheDb;
                if (_platform__WEBPACK_IMPORTED_MODULE_3__.isDesktop && cacheEnabled) {
                    // Desktop apps use a separate database for the cache. This is because it is
                    // much more likely to directly work with files on desktop, and this makes
                    // it a lot clearer what the true filesize of the main db is (and avoid
                    // copying the cache data around).
                    const cachePath = db.getDatabasePath().replace(/db\.sqlite$/, 'cache.sqlite');
                    globalCacheDb = cacheDb = _platform_server_sqlite__WEBPACK_IMPORTED_MODULE_1__.openDatabase(cachePath);
                    _platform_server_sqlite__WEBPACK_IMPORTED_MODULE_1__.execQuery(cacheDb, `
        CREATE TABLE IF NOT EXISTS kvcache (key TEXT PRIMARY KEY, value TEXT);
        CREATE TABLE IF NOT EXISTS kvcache_key (id INTEGER PRIMARY KEY, key REAL)
      `);
                }
                else {
                    // All other platforms use the same database for cache
                    cacheDb = mainDb;
                }
                let sheet;
                if (cacheEnabled) {
                    sheet = new _spreadsheet_spreadsheet__WEBPACK_IMPORTED_MODULE_5__.Spreadsheet(updateSpreadsheetCache.bind(null, cacheDb), setCacheStatus.bind(null, mainDb, cacheDb));
                }
                else {
                    sheet = new _spreadsheet_spreadsheet__WEBPACK_IMPORTED_MODULE_5__.Spreadsheet();
                }
                (0, _platform_exceptions__WEBPACK_IMPORTED_MODULE_0__.captureBreadcrumb)({
                    message: 'loading spreaadsheet',
                    category: 'server'
                });
                globalSheet = sheet;
                globalOnChange = onSheetChange;
                if (onSheetChange) {
                    sheet.addEventListener('change', onSheetChange);
                }
                if (cacheEnabled && !isCacheDirty(mainDb, cacheDb)) {
                    const cachedRows = await _platform_server_sqlite__WEBPACK_IMPORTED_MODULE_1__.runQuery(cacheDb, 'SELECT * FROM kvcache', [], true);
                    console.log(`Loaded spreadsheet from cache (${cachedRows.length} items)`);
                    for (const row of cachedRows) {
                        const parsed = JSON.parse(row.value);
                        sheet.load(row.key, parsed);
                    }
                }
                else {
                    console.log('Loading fresh spreadsheet');
                    await loadUserBudgets(db);
                }
                (0, _platform_exceptions__WEBPACK_IMPORTED_MODULE_0__.captureBreadcrumb)({
                    message: 'loaded spreaadsheet',
                    category: 'server'
                });
                return sheet;
            }
            function unloadSpreadsheet() {
                if (globalSheet) {
                    // TODO: Should wait for the sheet to finish
                    globalSheet.unload();
                    globalSheet = null;
                }
                if (globalCacheDb) {
                    _platform_server_sqlite__WEBPACK_IMPORTED_MODULE_1__.closeDatabase(globalCacheDb);
                    globalCacheDb = null;
                }
            }
            async function reloadSpreadsheet(db) {
                if (globalSheet) {
                    unloadSpreadsheet();
                    return loadSpreadsheet(db, globalOnChange);
                }
            }
            async function loadUserBudgets(db) {
                const sheet = globalSheet;
                // TODO: Clear out the cache here so make sure future loads of the app
                // don't load any extra values that aren't set here
                const { budgetType } = _prefs__WEBPACK_IMPORTED_MODULE_4__.getPrefs() || {};
                const table = budgetType === 'report' ? 'reflect_budgets' : 'zero_budgets';
                const budgets = await db.all(`
      SELECT * FROM ${table} b
      LEFT JOIN categories c ON c.id = b.category
      WHERE c.tombstone = 0
    `);
                sheet.startTransaction();
                // Load all the budget amounts and carryover values
                for (const budget of budgets) {
                    if (budget.month && budget.category) {
                        const sheetName = `budget${budget.month}`;
                        sheet.set(`${sheetName}!budget-${budget.category}`, budget.amount);
                        sheet.set(`${sheetName}!carryover-${budget.category}`, budget.carryover === 1 ? true : false);
                        sheet.set(`${sheetName}!goal-${budget.category}`, budget.goal);
                        sheet.set(`${sheetName}!long-goal-${budget.category}`, budget.long_goal);
                    }
                }
                // For zero-based budgets, load the buffered amounts
                if (budgetType !== 'report') {
                    const budgetMonths = await db.all('SELECT * FROM zero_budget_months');
                    for (const budgetMonth of budgetMonths) {
                        const sheetName = (0, _shared_months__WEBPACK_IMPORTED_MODULE_2__.sheetForMonth)(budgetMonth.id);
                        sheet.set(`${sheetName}!buffered`, budgetMonth.buffered);
                    }
                }
                sheet.endTransaction();
            }
            function getCell(sheet, name) {
                return globalSheet._getNode((0, _spreadsheet_util__WEBPACK_IMPORTED_MODULE_6__.resolveName)(sheet, name));
            }
            function getCellValue(sheet, name) {
                return globalSheet.getValue((0, _spreadsheet_util__WEBPACK_IMPORTED_MODULE_6__.resolveName)(sheet, name));
            }
            function startTransaction() {
                if (globalSheet) {
                    globalSheet.startTransaction();
                }
            }
            function endTransaction() {
                if (globalSheet) {
                    globalSheet.endTransaction();
                }
            }
            function waitOnSpreadsheet() {
                return new Promise((resolve) => {
                    if (globalSheet) {
                        globalSheet.onFinish(resolve);
                    }
                    else {
                        resolve(undefined);
                    }
                });
            }
            /***/ 
        }),
        /***/ "./packages/loot-core/src/server/spreadsheet/globals.ts": 
        /*!**************************************************************!*\
          !*** ./packages/loot-core/src/server/spreadsheet/globals.ts ***!
          \**************************************************************/
        /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony export */ __webpack_require__.d(__webpack_exports__, {
                /* harmony export */ number: () => ( /* binding */number)
                /* harmony export */ 
            });
            function number(v) {
                if (typeof v === 'number') {
                    return v;
                }
                else if (typeof v === 'string') {
                    const parsed = parseFloat(v);
                    if (isNaN(parsed)) {
                        return 0;
                    }
                    return parsed;
                }
                return 0;
            }
            /***/ 
        }),
        /***/ "./packages/loot-core/src/server/spreadsheet/graph-data-structure.ts": 
        /*!***************************************************************************!*\
          !*** ./packages/loot-core/src/server/spreadsheet/graph-data-structure.ts ***!
          \***************************************************************************/
        /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony export */ __webpack_require__.d(__webpack_exports__, {
                /* harmony export */ Graph: () => ( /* binding */Graph)
                /* harmony export */ 
            });
            /* harmony import */ var _prefs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../prefs */ "./packages/loot-core/src/server/prefs.ts");
            // @ts-strict-ignore
            function Graph() {
                const graph = {
                    addNode,
                    removeNode,
                    adjacent,
                    adjacentIncoming,
                    addEdge,
                    removeEdge,
                    removeIncomingEdges,
                    topologicalSort,
                    generateDOT,
                    getEdges
                };
                const edges = new Map();
                const incomingEdges = new Map();
                function getEdges() {
                    return {
                        edges,
                        incomingEdges
                    };
                }
                function addNode(node) {
                    edges.set(node, adjacent(node));
                    incomingEdges.set(node, adjacentIncoming(node));
                    return graph;
                }
                function removeIncomingEdges(node) {
                    const incoming = adjacentIncoming(node);
                    incomingEdges.set(node, new Set());
                    const iter = incoming.values();
                    let cur = iter.next();
                    while (!cur.done) {
                        removeEdge(cur.value, node);
                        cur = iter.next();
                    }
                }
                function removeNode(node) {
                    removeIncomingEdges(node);
                    edges.delete(node);
                    incomingEdges.delete(node);
                    return graph;
                }
                function adjacent(node) {
                    return edges.get(node) || new Set();
                }
                function adjacentIncoming(node) {
                    return incomingEdges.get(node) || new Set();
                }
                // Adds an edge from node u to node v.
                // Implicitly adds the nodes if they were not already added.
                function addEdge(node1, node2) {
                    addNode(node1);
                    addNode(node2);
                    adjacent(node1).add(node2);
                    adjacentIncoming(node2).add(node1);
                    return graph;
                }
                // Removes the edge from node u to node v.
                // Does not remove the nodes.
                // Does nothing if the edge does not exist.
                function removeEdge(node1, node2) {
                    if (edges.has(node1)) {
                        adjacent(node1).delete(node2);
                    }
                    if (incomingEdges.has(node2)) {
                        adjacentIncoming(node2).delete(node1);
                    }
                    return graph;
                }
                function topologicalSort(sourceNodes) {
                    const visited = new Set();
                    const sorted = [];
                    const prefs = (0, _prefs__WEBPACK_IMPORTED_MODULE_0__.getPrefs)();
                    const iterableTopologicalSort = prefs != null ? prefs['flags.iterableTopologicalSort'] : false;
                    sourceNodes.forEach((name) => {
                        if (!visited.has(name)) {
                            if (iterableTopologicalSort) {
                                topologicalSortIterable(name, visited, sorted);
                            }
                            else {
                                topologicalSortUntil(name, visited, sorted, 0);
                            }
                        }
                    });
                    return sorted;
                }
                function topologicalSortUntil(name, visited, sorted, level) {
                    visited.add(name);
                    if (level > 2500) {
                        console.error('Limit of recursions reached while sorting budget: 2500');
                        return;
                    }
                    const iter = adjacent(name).values();
                    let cur = iter.next();
                    while (!cur.done) {
                        if (!visited.has(cur.value)) {
                            topologicalSortUntil(cur.value, visited, sorted, level + 1);
                        }
                        cur = iter.next();
                    }
                    sorted.unshift(name);
                }
                function topologicalSortIterable(name, visited, sorted) {
                    const stackTrace = [];
                    stackTrace.push({
                        count: -1,
                        value: name,
                        parent: '',
                        level: 0
                    });
                    while (stackTrace.length > 0) {
                        const current = stackTrace.slice(-1)[0];
                        const adjacents = adjacent(current.value);
                        if (current.count === -1) {
                            current.count = adjacents.size;
                        }
                        if (current.count > 0) {
                            const iter = adjacents.values();
                            let cur = iter.next();
                            while (!cur.done) {
                                if (!visited.has(cur.value)) {
                                    stackTrace.push({
                                        count: -1,
                                        parent: current.value,
                                        value: cur.value,
                                        level: current.level + 1
                                    });
                                }
                                else {
                                    current.count--;
                                }
                                cur = iter.next();
                            }
                        }
                        else {
                            if (!visited.has(current.value)) {
                                visited.add(current.value);
                                sorted.unshift(current.value);
                            }
                            const removed = stackTrace.pop();
                            for (let i = 0; i < stackTrace.length; i++) {
                                if (stackTrace[i].value === removed.parent) {
                                    stackTrace[i].count--;
                                }
                            }
                        }
                    }
                }
                function generateDOT() {
                    const edgeStrings = [];
                    edges.forEach(function (adj, edge) {
                        if (adj.length !== 0) {
                            edgeStrings.push(`${edge} -> {${adj.join(',')}}`);
                        }
                    });
                    return `
    digraph G {
      ${edgeStrings.join('\n').replace(/!/g, '_')}
    }
    `;
                }
                return graph;
            }
            /***/ 
        }),
        /***/ "./packages/loot-core/src/server/spreadsheet/spreadsheet.ts": 
        /*!******************************************************************!*\
          !*** ./packages/loot-core/src/server/spreadsheet/spreadsheet.ts ***!
          \******************************************************************/
        /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony export */ __webpack_require__.d(__webpack_exports__, {
                /* harmony export */ Spreadsheet: () => ( /* binding */Spreadsheet)
                /* harmony export */ 
            });
            /* harmony import */ var mitt__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! mitt */ "./node_modules/mitt/dist/mitt.mjs");
            /* harmony import */ var _aql__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../aql */ "./packages/loot-core/src/server/aql/index.ts");
            /* harmony import */ var _graph_data_structure__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./graph-data-structure */ "./packages/loot-core/src/server/spreadsheet/graph-data-structure.ts");
            /* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./util */ "./packages/loot-core/src/server/spreadsheet/util.ts");
            // @ts-strict-ignore
            class Spreadsheet {
                constructor(saveCache, setCacheStatus) {
                    // @ts-expect-error Graph should be converted to class
                    this.graph = new _graph_data_structure__WEBPACK_IMPORTED_MODULE_2__.Graph();
                    this.nodes = new Map();
                    this.transactionDepth = 0;
                    this.saveCache = saveCache;
                    this.setCacheStatus = setCacheStatus;
                    this.dirtyCells = [];
                    this.computeQueue = [];
                    this.events = (0, mitt__WEBPACK_IMPORTED_MODULE_0__["default"])();
                    this._meta = {
                        createdMonths: new Set()
                    };
                }
                meta() {
                    return this._meta;
                }
                setMeta(meta) {
                    this._meta = meta;
                }
                // Spreadsheet interface
                _getNode(name) {
                    const { sheet } = (0, _util__WEBPACK_IMPORTED_MODULE_3__.unresolveName)(name);
                    if (!this.nodes.has(name)) {
                        this.nodes.set(name, {
                            name,
                            expr: null,
                            value: null,
                            sheet
                        });
                    }
                    return this.nodes.get(name);
                }
                getNode(name) {
                    return this._getNode(name);
                }
                hasCell(name) {
                    return this.nodes.has(name);
                }
                add(name, expr) {
                    this.set(name, expr);
                }
                getNodes() {
                    return this.nodes;
                }
                serialize() {
                    return {
                        graph: this.graph.getEdges(),
                        nodes: [
                            ...this.nodes.entries()
                        ]
                    };
                }
                transaction(func) {
                    this.startTransaction();
                    try {
                        func();
                    }
                    catch (e) {
                        console.log(e);
                    }
                    return this.endTransaction();
                }
                startTransaction() {
                    this.transactionDepth++;
                }
                endTransaction() {
                    this.transactionDepth--;
                    if (this.transactionDepth === 0) {
                        const cells = this.dirtyCells;
                        this.dirtyCells = [];
                        this.queueComputation(this.graph.topologicalSort(cells));
                    }
                    return [];
                }
                queueComputation(cellNames) {
                    // TODO: Formally write out the different cases when the existing
                    // queue is not empty. There should be cases where we can easily
                    // optimize this by skipping computations if we know they are
                    // going to be computed again. The hard thing is to ensure that
                    // the order of computations stays correct
                    this.computeQueue = this.computeQueue.concat(cellNames);
                    // Begin running on the next tick so we guarantee that it doesn't finish
                    // within the same tick. Since some computations are async, this makes it
                    // consistent (otherwise it would only sometimes finish sync)
                    Promise.resolve().then(() => {
                        if (!this.running) {
                            this.runComputations();
                        }
                    });
                }
                runComputations(idx = 0) {
                    this.running = true;
                    while (idx < this.computeQueue.length) {
                        const name = this.computeQueue[idx];
                        let node;
                        let result;
                        try {
                            node = this.getNode(name);
                            if (node._run) {
                                const args = node._dependencies.map((dep) => {
                                    return this.getNode(dep).value;
                                });
                                result = node._run(...args);
                                if (result instanceof Promise) {
                                    console.warn(`dynamic cell ${name} returned a promise! this is discouraged because errors are not handled properly`);
                                }
                            }
                            else if (node.sql) {
                                result = (0, _aql__WEBPACK_IMPORTED_MODULE_1__.runCompiledQuery)(node.query, node.sql.sqlPieces, node.sql.state);
                            }
                            else {
                                idx++;
                                continue;
                            }
                        }
                        catch (e) {
                            console.log('Error while evaluating ' + name + ':', e);
                            // If an error happens, bail on the rest of the computations
                            this.running = false;
                            this.computeQueue = [];
                            return;
                        }
                        if (result instanceof Promise) {
                            // When the cell is finished computing, finish computing the
                            // rest
                            result.then((value) => {
                                node.value = value;
                                this.runComputations(idx + 1);
                            }, (err) => {
                                // TODO: use captureException here
                                console.warn(`Failed running ${node.name}!`, err);
                                this.runComputations(idx + 1);
                            });
                            return;
                        }
                        else {
                            node.value = result;
                        }
                        idx++;
                    }
                    // If everything computed in one loop (no async operations) notify
                    // the user and empty the queue
                    if (idx === this.computeQueue.length) {
                        this.events.emit('change', {
                            names: this.computeQueue
                        });
                        // Cache the updated cells
                        if (typeof this.saveCache === 'function') {
                            this.saveCache(this.computeQueue);
                        }
                        this.markCacheSafe();
                        this.running = false;
                        this.computeQueue = [];
                    }
                }
                markCacheSafe() {
                    if (!this.cacheBarrier) {
                        if (this.setCacheStatus) {
                            this.setCacheStatus({
                                clean: true
                            });
                        }
                    }
                }
                markCacheDirty() {
                    if (this.setCacheStatus) {
                        this.setCacheStatus({
                            clean: false
                        });
                    }
                }
                startCacheBarrier() {
                    this.cacheBarrier = true;
                    this.markCacheDirty();
                }
                endCacheBarrier() {
                    this.cacheBarrier = false;
                    const pendingChange = this.running || this.computeQueue.length > 0;
                    if (!pendingChange) {
                        this.markCacheSafe();
                    }
                }
                addEventListener(name, func) {
                    this.events.on(name, func);
                    return () => this.events.off(name, func);
                }
                onFinish(func) {
                    if (this.transactionDepth !== 0) {
                        throw new Error('onFinish called while inside a spreadsheet transaction. This is not allowed as it will lead to race conditions');
                    }
                    if (!this.running && this.computeQueue.length === 0) {
                        func([]);
                        // The remove function does nothing
                        return () => { };
                    }
                    const remove = this.addEventListener('change', (...args) => {
                        remove();
                        return func(...args);
                    });
                    return remove;
                }
                unload() {
                    this.events.all.clear();
                }
                getValue(name) {
                    return this.getNode(name).value;
                }
                getExpr(name) {
                    return this.getNode(name).expr;
                }
                getCellValue(sheet, name) {
                    return this.getNode((0, _util__WEBPACK_IMPORTED_MODULE_3__.resolveName)(sheet, name)).value;
                }
                getCellExpr(sheet, name) {
                    return this.getNode((0, _util__WEBPACK_IMPORTED_MODULE_3__.resolveName)(sheet, name)).expr;
                }
                getCellValueLoose(sheetName, cellName) {
                    const name = (0, _util__WEBPACK_IMPORTED_MODULE_3__.resolveName)(sheetName, cellName);
                    if (this.nodes.has(name)) {
                        return this.getNode(name).value;
                    }
                    return null;
                }
                bootup(onReady) {
                    this.onFinish(() => {
                        onReady();
                    });
                }
                load(name, value) {
                    const node = this._getNode(name);
                    node.expr = value;
                    node.value = value;
                }
                create(name, value) {
                    return this.transaction(() => {
                        const node = this._getNode(name);
                        node.expr = value;
                        node.value = value;
                        this._markDirty(name);
                    });
                }
                set(name, value) {
                    this.create(name, value);
                }
                recompute(name) {
                    this.transaction(() => {
                        this.dirtyCells.push(name);
                    });
                }
                recomputeAll() {
                    // Recompute everything!
                    this.transaction(() => {
                        this.dirtyCells = [
                            ...this.nodes.keys()
                        ];
                    });
                }
                createQuery(sheetName, cellName, query) {
                    const name = (0, _util__WEBPACK_IMPORTED_MODULE_3__.resolveName)(sheetName, cellName);
                    const node = this._getNode(name);
                    if (node.query !== query) {
                        node.query = query;
                        const { sqlPieces, state } = (0, _aql__WEBPACK_IMPORTED_MODULE_1__.compileQuery)(node.query, _aql__WEBPACK_IMPORTED_MODULE_1__.schema, _aql__WEBPACK_IMPORTED_MODULE_1__.schemaConfig);
                        node.sql = {
                            sqlPieces,
                            state
                        };
                        this.transaction(() => {
                            this._markDirty(name);
                        });
                    }
                }
                createStatic(sheetName, cellName, initialValue) {
                    const name = (0, _util__WEBPACK_IMPORTED_MODULE_3__.resolveName)(sheetName, cellName);
                    const exists = this.nodes.has(name);
                    if (!exists) {
                        this.create(name, initialValue);
                    }
                }
                createDynamic(sheetName, cellName, { dependencies = [], run, initialValue, refresh = false }) {
                    const name = (0, _util__WEBPACK_IMPORTED_MODULE_3__.resolveName)(sheetName, cellName);
                    const node = this._getNode(name);
                    if (node.dynamic) {
                        // If it already exists, do nothing
                        return;
                    }
                    node.dynamic = true;
                    node._run = run;
                    dependencies = dependencies.map((dep) => {
                        let resolved;
                        if (!(0, _util__WEBPACK_IMPORTED_MODULE_3__.unresolveName)(dep).sheet) {
                            resolved = (0, _util__WEBPACK_IMPORTED_MODULE_3__.resolveName)(sheetName, dep);
                        }
                        else {
                            resolved = dep;
                        }
                        return resolved;
                    });
                    node._dependencies = dependencies;
                    // TODO: diff these
                    this.graph.removeIncomingEdges(name);
                    dependencies.forEach((dep) => {
                        this.graph.addEdge(dep, name);
                    });
                    if (node.value == null || refresh) {
                        this.transaction(() => {
                            node.value = initialValue;
                            this._markDirty(name);
                        });
                    }
                }
                clearSheet(sheetName) {
                    for (const [name, node] of this.nodes.entries()) {
                        if (node.sheet === sheetName) {
                            this.nodes.delete(name);
                        }
                    }
                }
                voidCell(sheetName, name, voidValue = null) {
                    const node = this.getNode((0, _util__WEBPACK_IMPORTED_MODULE_3__.resolveName)(sheetName, name));
                    node._run = null;
                    node.dynamic = false;
                    node.value = voidValue;
                }
                deleteCell(sheetName, name) {
                    this.voidCell(sheetName, name);
                    this.nodes.delete((0, _util__WEBPACK_IMPORTED_MODULE_3__.resolveName)(sheetName, name));
                }
                addDependencies(sheetName, cellName, deps) {
                    const name = (0, _util__WEBPACK_IMPORTED_MODULE_3__.resolveName)(sheetName, cellName);
                    deps = deps.map((dep) => {
                        if (!(0, _util__WEBPACK_IMPORTED_MODULE_3__.unresolveName)(dep).sheet) {
                            return (0, _util__WEBPACK_IMPORTED_MODULE_3__.resolveName)(sheetName, dep);
                        }
                        return dep;
                    });
                    const node = this.getNode(name);
                    const newDeps = deps.filter((dep) => (node._dependencies || []).indexOf(dep) === -1);
                    if (newDeps.length > 0) {
                        node._dependencies = (node._dependencies || []).concat(newDeps);
                        newDeps.forEach((dep) => {
                            this.graph.addEdge(dep, name);
                        });
                        this.recompute(name);
                    }
                }
                removeDependencies(sheetName, cellName, deps) {
                    const name = (0, _util__WEBPACK_IMPORTED_MODULE_3__.resolveName)(sheetName, cellName);
                    deps = deps.map((dep) => {
                        if (!(0, _util__WEBPACK_IMPORTED_MODULE_3__.unresolveName)(dep).sheet) {
                            return (0, _util__WEBPACK_IMPORTED_MODULE_3__.resolveName)(sheetName, dep);
                        }
                        return dep;
                    });
                    const node = this.getNode(name);
                    node._dependencies = (node._dependencies || []).filter((dep) => deps.indexOf(dep) === -1);
                    deps.forEach((dep) => {
                        this.graph.removeEdge(dep, name);
                    });
                    this.recompute(name);
                }
                _markDirty(name) {
                    this.dirtyCells.push(name);
                }
                triggerDatabaseChanges(oldValues, newValues) {
                    const tables = new Set([
                        ...oldValues.keys(),
                        ...newValues.keys()
                    ]);
                    this.startTransaction();
                    // TODO: Create an index of deps so we don't have to iterate
                    // across all nodes
                    this.nodes.forEach((node) => {
                        if (node.sql && node.sql.state.dependencies.some((dep) => tables.has(dep))) {
                            this._markDirty(node.name);
                        }
                    });
                    this.endTransaction();
                }
            }
            /***/ 
        }),
        /***/ "./packages/loot-core/src/server/spreadsheet/util.ts": 
        /*!***********************************************************!*\
          !*** ./packages/loot-core/src/server/spreadsheet/util.ts ***!
          \***********************************************************/
        /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony export */ __webpack_require__.d(__webpack_exports__, {
                /* harmony export */ resolveName: () => ( /* binding */resolveName),
                /* harmony export */ unresolveName: () => ( /* binding */unresolveName)
                /* harmony export */ 
            });
            // @ts-strict-ignore
            function unresolveName(name) {
                const idx = name.indexOf('!');
                if (idx !== -1) {
                    return {
                        sheet: name.slice(0, idx),
                        name: name.slice(idx + 1)
                    };
                }
                return {
                    sheet: null,
                    name
                };
            }
            function resolveName(sheet, name) {
                return sheet + '!' + name;
            }
            /***/ 
        }),
        /***/ "./packages/loot-core/src/server/sync/encoder.ts": 
        /*!*******************************************************!*\
          !*** ./packages/loot-core/src/server/sync/encoder.ts ***!
          \*******************************************************/
        /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony export */ __webpack_require__.d(__webpack_exports__, {
                /* harmony export */ decode: () => ( /* binding */decode),
                /* harmony export */ encode: () => ( /* binding */encode)
                /* harmony export */ 
            });
            /* harmony import */ var _actual_app_crdt__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @actual-app/crdt */ "@actual-app/crdt");
            /* harmony import */ var _actual_app_crdt__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/ __webpack_require__.n(_actual_app_crdt__WEBPACK_IMPORTED_MODULE_0__);
            /* harmony import */ var _encryption__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../encryption */ "./packages/loot-core/src/server/encryption.ts");
            /* harmony import */ var _errors__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../errors */ "./packages/loot-core/src/server/errors.ts");
            /* harmony import */ var _prefs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../prefs */ "./packages/loot-core/src/server/prefs.ts");
            // @ts-strict-ignore
            function coerceBuffer(value) {
                // The web encryption APIs give us back raw Uint8Array... but our
                // encryption code assumes we can work with it as a buffer. This is
                // a leaky abstraction and ideally the our abstraction over the web
                // encryption APIs should do this.
                if (!Buffer.isBuffer(value)) {
                    return Buffer.from(value);
                }
                return value;
            }
            async function encode(groupId, fileId, since, messages) {
                const { encryptKeyId } = _prefs__WEBPACK_IMPORTED_MODULE_3__.getPrefs();
                const requestPb = new _actual_app_crdt__WEBPACK_IMPORTED_MODULE_0__.SyncProtoBuf.SyncRequest();
                for (let i = 0; i < messages.length; i++) {
                    const msg = messages[i];
                    const envelopePb = new _actual_app_crdt__WEBPACK_IMPORTED_MODULE_0__.SyncProtoBuf.MessageEnvelope();
                    envelopePb.setTimestamp(msg.timestamp.toString());
                    const messagePb = new _actual_app_crdt__WEBPACK_IMPORTED_MODULE_0__.SyncProtoBuf.Message();
                    messagePb.setDataset(msg.dataset);
                    messagePb.setRow(msg.row);
                    messagePb.setColumn(msg.column);
                    messagePb.setValue(msg.value);
                    const binaryMsg = messagePb.serializeBinary();
                    if (encryptKeyId) {
                        const encrypted = new _actual_app_crdt__WEBPACK_IMPORTED_MODULE_0__.SyncProtoBuf.EncryptedData();
                        let result;
                        try {
                            result = await _encryption__WEBPACK_IMPORTED_MODULE_1__.encrypt(binaryMsg, encryptKeyId);
                        }
                        catch (e) {
                            throw new _errors__WEBPACK_IMPORTED_MODULE_2__.SyncError('encrypt-failure', {
                                isMissingKey: e.message === 'missing-key'
                            });
                        }
                        encrypted.setData(result.value);
                        encrypted.setIv(Buffer.from(result.meta.iv, 'base64'));
                        encrypted.setAuthtag(Buffer.from(result.meta.authTag, 'base64'));
                        envelopePb.setContent(encrypted.serializeBinary());
                        envelopePb.setIsencrypted(true);
                    }
                    else {
                        envelopePb.setContent(binaryMsg);
                    }
                    requestPb.addMessages(envelopePb);
                }
                requestPb.setGroupid(groupId);
                requestPb.setFileid(fileId);
                requestPb.setKeyid(encryptKeyId);
                requestPb.setSince(since.toString());
                return requestPb.serializeBinary();
            }
            async function decode(data) {
                const { encryptKeyId } = _prefs__WEBPACK_IMPORTED_MODULE_3__.getPrefs();
                const responsePb = _actual_app_crdt__WEBPACK_IMPORTED_MODULE_0__.SyncProtoBuf.SyncResponse.deserializeBinary(data);
                const merkle = JSON.parse(responsePb.getMerkle());
                const list = responsePb.getMessagesList();
                const messages = [];
                for (let i = 0; i < list.length; i++) {
                    const envelopePb = list[i];
                    const timestamp = _actual_app_crdt__WEBPACK_IMPORTED_MODULE_0__.Timestamp.parse(envelopePb.getTimestamp());
                    const encrypted = envelopePb.getIsencrypted();
                    let msg;
                    if (encrypted) {
                        const binary = _actual_app_crdt__WEBPACK_IMPORTED_MODULE_0__.SyncProtoBuf.EncryptedData.deserializeBinary(envelopePb.getContent());
                        let decrypted;
                        try {
                            decrypted = await _encryption__WEBPACK_IMPORTED_MODULE_1__.decrypt(coerceBuffer(binary.getData()), {
                                keyId: encryptKeyId,
                                algorithm: 'aes-256-gcm',
                                iv: coerceBuffer(binary.getIv()),
                                authTag: coerceBuffer(binary.getAuthtag())
                            });
                        }
                        catch (e) {
                            console.log(e);
                            throw new _errors__WEBPACK_IMPORTED_MODULE_2__.SyncError('decrypt-failure', {
                                isMissingKey: e.message === 'missing-key'
                            });
                        }
                        msg = _actual_app_crdt__WEBPACK_IMPORTED_MODULE_0__.SyncProtoBuf.Message.deserializeBinary(decrypted);
                    }
                    else {
                        msg = _actual_app_crdt__WEBPACK_IMPORTED_MODULE_0__.SyncProtoBuf.Message.deserializeBinary(envelopePb.getContent());
                    }
                    messages.push({
                        timestamp,
                        dataset: msg.getDataset(),
                        row: msg.getRow(),
                        column: msg.getColumn(),
                        value: msg.getValue()
                    });
                }
                return {
                    messages,
                    merkle
                };
            }
            /***/ 
        }),
        /***/ "./packages/loot-core/src/server/sync/index.ts": 
        /*!*****************************************************!*\
          !*** ./packages/loot-core/src/server/sync/index.ts ***!
          \*****************************************************/
        /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony export */ __webpack_require__.d(__webpack_exports__, {
                /* harmony export */ addSyncListener: () => ( /* binding */addSyncListener),
                /* harmony export */ applyMessages: () => ( /* binding */applyMessages),
                /* harmony export */ batchMessages: () => ( /* binding */batchMessages),
                /* harmony export */ checkSyncingMode: () => ( /* binding */checkSyncingMode),
                /* harmony export */ clearFullSyncTimeout: () => ( /* binding */clearFullSyncTimeout),
                /* harmony export */ deserializeValue: () => ( /* binding */deserializeValue),
                /* harmony export */ fullSync: () => ( /* binding */fullSync),
                /* harmony export */ getMessagesSince: () => ( /* binding */getMessagesSince),
                /* harmony export */ initialFullSync: () => ( /* binding */initialFullSync),
                /* harmony export */ makeTestMessage: () => ( /* reexport safe */_make_test_message__WEBPACK_IMPORTED_MODULE_20__.makeTestMessage),
                /* harmony export */ receiveMessages: () => ( /* binding */receiveMessages),
                /* harmony export */ repairSync: () => ( /* reexport safe */_repair__WEBPACK_IMPORTED_MODULE_18__.repairSync),
                /* harmony export */ resetSync: () => ( /* reexport safe */_reset__WEBPACK_IMPORTED_MODULE_21__.resetSync),
                /* harmony export */ scheduleFullSync: () => ( /* binding */scheduleFullSync),
                /* harmony export */ sendMessages: () => ( /* binding */sendMessages),
                /* harmony export */ serializeValue: () => ( /* binding */serializeValue),
                /* harmony export */ setSyncingMode: () => ( /* binding */setSyncingMode)
                /* harmony export */ 
            });
            /* harmony import */ var _actual_app_crdt__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @actual-app/crdt */ "@actual-app/crdt");
            /* harmony import */ var _actual_app_crdt__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/ __webpack_require__.n(_actual_app_crdt__WEBPACK_IMPORTED_MODULE_0__);
            /* harmony import */ var _platform_exceptions__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../platform/exceptions */ "./packages/loot-core/src/platform/exceptions/index.electron.ts");
            /* harmony import */ var _platform_server_asyncStorage__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../platform/server/asyncStorage */ "./packages/loot-core/src/platform/server/asyncStorage/index.electron.ts");
            /* harmony import */ var _platform_server_connection__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../platform/server/connection */ "./packages/loot-core/src/platform/server/connection/index.api.ts");
            /* harmony import */ var _platform_server_log__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../platform/server/log */ "./packages/loot-core/src/platform/server/log/index.api.ts");
            /* harmony import */ var _shared_async__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../shared/async */ "./packages/loot-core/src/shared/async.ts");
            /* harmony import */ var _shared_util__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../shared/util */ "./packages/loot-core/src/shared/util.ts");
            /* harmony import */ var _budget_base__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../budget/base */ "./packages/loot-core/src/server/budget/base.ts");
            /* harmony import */ var _db__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../db */ "./packages/loot-core/src/server/db/index.ts");
            /* harmony import */ var _errors__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../errors */ "./packages/loot-core/src/server/errors.ts");
            /* harmony import */ var _main_app__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../main-app */ "./packages/loot-core/src/server/main-app.ts");
            /* harmony import */ var _mutators__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../mutators */ "./packages/loot-core/src/server/mutators.ts");
            /* harmony import */ var _post__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../post */ "./packages/loot-core/src/server/post.ts");
            /* harmony import */ var _prefs__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../prefs */ "./packages/loot-core/src/server/prefs.ts");
            /* harmony import */ var _server_config__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ../server-config */ "./packages/loot-core/src/server/server-config.ts");
            /* harmony import */ var _sheet__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ../sheet */ "./packages/loot-core/src/server/sheet.ts");
            /* harmony import */ var _undo__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ../undo */ "./packages/loot-core/src/server/undo.ts");
            /* harmony import */ var _encoder__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./encoder */ "./packages/loot-core/src/server/sync/encoder.ts");
            /* harmony import */ var _repair__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./repair */ "./packages/loot-core/src/server/sync/repair.ts");
            /* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./utils */ "./packages/loot-core/src/server/sync/utils.ts");
            /* harmony import */ var _make_test_message__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./make-test-message */ "./packages/loot-core/src/server/sync/make-test-message.ts");
            /* harmony import */ var _reset__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ./reset */ "./packages/loot-core/src/server/sync/reset.ts");
            // @ts-strict-ignore
            const FULL_SYNC_DELAY = 1000;
            let SYNCING_MODE = 'enabled';
            function setSyncingMode(mode) {
                const prevMode = SYNCING_MODE;
                switch (mode) {
                    case 'enabled':
                        SYNCING_MODE = 'enabled';
                        break;
                    case 'offline':
                        SYNCING_MODE = 'offline';
                        break;
                    case 'disabled':
                        SYNCING_MODE = 'disabled';
                        break;
                    case 'import':
                        SYNCING_MODE = 'import';
                        break;
                    default:
                        throw new Error('setSyncingMode: invalid mode: ' + mode);
                }
                return prevMode;
            }
            function checkSyncingMode(mode) {
                switch (mode) {
                    case 'enabled':
                        return SYNCING_MODE === 'enabled' || SYNCING_MODE === 'offline';
                    case 'disabled':
                        return SYNCING_MODE === 'disabled' || SYNCING_MODE === 'import';
                    case 'offline':
                        return SYNCING_MODE === 'offline';
                    case 'import':
                        return SYNCING_MODE === 'import';
                    default:
                        throw new Error('checkSyncingMode: invalid mode: ' + mode);
                }
            }
            function apply(msg, prev) {
                const { dataset, row, column, value } = msg;
                if (dataset === 'prefs') {
                    // Do nothing, it doesn't exist in the db
                }
                else {
                    let query;
                    try {
                        if (prev) {
                            query = {
                                sql: `UPDATE ${dataset} SET ${column} = ? WHERE id = ?`,
                                params: [
                                    value,
                                    row
                                ]
                            };
                        }
                        else {
                            query = {
                                sql: `INSERT INTO ${dataset} (id, ${column}) VALUES (?, ?)`,
                                params: [
                                    row,
                                    value
                                ]
                            };
                        }
                        _db__WEBPACK_IMPORTED_MODULE_8__.runQuery(_db__WEBPACK_IMPORTED_MODULE_8__.cache(query.sql), query.params);
                    }
                    catch (error) {
                        throw new _errors__WEBPACK_IMPORTED_MODULE_9__.SyncError('invalid-schema', {
                            error: {
                                message: error.message,
                                stack: error.stack
                            },
                            query
                        });
                    }
                }
            }
            // TODO: convert to `whereIn`
            async function fetchAll(table, ids) {
                let results = [];
                // was 500, but that caused a stack overflow in Safari
                const batchSize = 100;
                for (let i = 0; i < ids.length; i += batchSize) {
                    const partIds = ids.slice(i, i + batchSize);
                    let sql;
                    let column = `${table}.id`;
                    // We have to provide *mapped* data so the spreadsheet works. The functions
                    // which trigger budget changes based on data changes assumes data has been
                    // mapped. The only mapped data that the budget is concerned about is
                    // categories. This is kind of annoying, but we manually map it here
                    if (table === 'transactions') {
                        sql = `
        SELECT t.*, c.transferId AS category
        FROM transactions t
        LEFT JOIN category_mapping c ON c.id = t.category
      `;
                        column = 't.id';
                    }
                    else {
                        sql = `SELECT * FROM ${table}`;
                    }
                    sql += ` WHERE `;
                    sql += partIds.map(() => `${column} = ?`).join(' OR ');
                    try {
                        const rows = await _db__WEBPACK_IMPORTED_MODULE_8__.runQuery(sql, partIds, true);
                        results = results.concat(rows);
                    }
                    catch (error) {
                        throw new _errors__WEBPACK_IMPORTED_MODULE_9__.SyncError('invalid-schema', {
                            error: {
                                message: error.message,
                                stack: error.stack
                            },
                            query: {
                                sql,
                                params: partIds
                            }
                        });
                    }
                }
                return results;
            }
            function serializeValue(value) {
                if (value === null) {
                    return '0:';
                }
                else if (typeof value === 'number') {
                    return 'N:' + value;
                }
                else if (typeof value === 'string') {
                    return 'S:' + value;
                }
                throw new Error('Unserializable value type: ' + JSON.stringify(value));
            }
            function deserializeValue(value) {
                const type = value[0];
                switch (type) {
                    case '0':
                        return null;
                    case 'N':
                        return parseFloat(value.slice(2));
                    case 'S':
                        return value.slice(2);
                    default:
                }
                throw new Error('Invalid type key for value: ' + value);
            }
            let _syncListeners = [];
            function addSyncListener(func) {
                _syncListeners.push(func);
                return () => {
                    _syncListeners = _syncListeners.filter((f) => f !== func);
                };
            }
            async function compareMessages(messages) {
                const newMessages = [];
                for (let i = 0; i < messages.length; i++) {
                    const message = messages[i];
                    const { dataset, row, column, timestamp } = message;
                    const timestampStr = timestamp.toString();
                    const res = _db__WEBPACK_IMPORTED_MODULE_8__.runQuery(_db__WEBPACK_IMPORTED_MODULE_8__.cache('SELECT timestamp FROM messages_crdt WHERE dataset = ? AND row = ? AND column = ? AND timestamp >= ?'), [
                        dataset,
                        row,
                        column,
                        timestampStr
                    ], true);
                    // Returned message is any one that is "later" than this message,
                    // meaning if the result exists this message is an old one
                    if (res.length === 0) {
                        newMessages.push(message);
                    }
                    else if (res[0].timestamp !== timestampStr) {
                        newMessages.push({
                            ...message,
                            old: true
                        });
                    }
                }
                return newMessages;
            }
            // This is the fast path `apply` function when in "import" mode.
            // There's no need to run through the whole sync system when
            // importing, but **there is a caveat**: because we don't run sync
            // listeners importers should not rely on any functions that use any
            // projected state (like rules). We can't fire those because they
            // depend on having both old and new data which we don't quere here
            function applyMessagesForImport(messages) {
                _db__WEBPACK_IMPORTED_MODULE_8__.transaction(() => {
                    for (let i = 0; i < messages.length; i++) {
                        const msg = messages[i];
                        const { dataset } = msg;
                        if (!msg.old) {
                            try {
                                apply(msg);
                            }
                            catch (e) {
                                apply(msg, true);
                            }
                            if (dataset === 'prefs') {
                                throw new Error('Cannot set prefs while importing');
                            }
                        }
                    }
                });
            }
            const applyMessages = (0, _shared_async__WEBPACK_IMPORTED_MODULE_5__.sequential)(async (messages) => {
                if (checkSyncingMode('import')) {
                    applyMessagesForImport(messages);
                    return undefined;
                }
                else if (checkSyncingMode('enabled')) {
                    // Compare the messages with the existing crdt. This filters out
                    // already applied messages and determines if a message is old or
                    // not. An "old" message doesn't need to be applied, but it still
                    // needs to be put into the merkle trie to maintain the hash.
                    messages = await compareMessages(messages);
                }
                messages = [
                    ...messages
                ].sort((m1, m2) => {
                    const t1 = m1.timestamp ? m1.timestamp.toString() : '';
                    const t2 = m2.timestamp ? m2.timestamp.toString() : '';
                    if (t1 < t2) {
                        return -1;
                    }
                    else if (t1 > t2) {
                        return 1;
                    }
                    return 0;
                });
                const idsPerTable = {};
                messages.forEach((msg) => {
                    if (msg.dataset === 'prefs') {
                        return;
                    }
                    if (idsPerTable[msg.dataset] == null) {
                        idsPerTable[msg.dataset] = [];
                    }
                    idsPerTable[msg.dataset].push(msg.row);
                });
                async function fetchData() {
                    const data = new Map();
                    for (const table of Object.keys(idsPerTable)) {
                        const rows = await fetchAll(table, idsPerTable[table]);
                        for (let i = 0; i < rows.length; i++) {
                            const row = rows[i];
                            (0, _shared_util__WEBPACK_IMPORTED_MODULE_6__.setIn)(data, [
                                table,
                                row.id
                            ], row);
                        }
                    }
                    return data;
                }
                const prefsToSet = {};
                const oldData = await fetchData();
                _undo__WEBPACK_IMPORTED_MODULE_16__.appendMessages(messages, oldData);
                // It's important to not mutate the clock while processing the
                // messages. We only want to mutate it if the transaction succeeds.
                // The merkle variable will be updated while applying the messages and
                // we'll apply it afterwards.
                let clock;
                let currentMerkle;
                if (checkSyncingMode('enabled')) {
                    clock = (0, _actual_app_crdt__WEBPACK_IMPORTED_MODULE_0__.getClock)();
                    currentMerkle = clock.merkle;
                }
                if (_sheet__WEBPACK_IMPORTED_MODULE_15__.get()) {
                    _sheet__WEBPACK_IMPORTED_MODULE_15__.get().startCacheBarrier();
                }
                // Now that we have all of the data, go through and apply the
                // messages carefully. This transaction is **crucial**: it
                // guarantees that everything is atomically committed to the
                // database, and if any part of it fails everything aborts and
                // nothing is changed. This is critical to maintain consistency. We
                // also avoid any side effects to in-memory objects, and apply them
                // after this succeeds.
                _db__WEBPACK_IMPORTED_MODULE_8__.transaction(() => {
                    const added = new Set();
                    for (const msg of messages) {
                        const { dataset, row, column, timestamp, value } = msg;
                        if (!msg.old) {
                            apply(msg, (0, _shared_util__WEBPACK_IMPORTED_MODULE_6__.getIn)(oldData, [
                                dataset,
                                row
                            ]) || added.has(dataset + row));
                            if (dataset === 'prefs') {
                                prefsToSet[row] = value;
                            }
                            else {
                                // Keep track of which items have been added it in this sync
                                // so it knows whether they already exist in the db or not. We
                                // ignore any changes to the spreadsheet.
                                added.add(dataset + row);
                            }
                        }
                        if (checkSyncingMode('enabled')) {
                            _db__WEBPACK_IMPORTED_MODULE_8__.runQuery(_db__WEBPACK_IMPORTED_MODULE_8__.cache(`INSERT INTO messages_crdt (timestamp, dataset, row, column, value)
           VALUES (?, ?, ?, ?, ?)`), [
                                timestamp.toString(),
                                dataset,
                                row,
                                column,
                                serializeValue(value)
                            ]);
                            currentMerkle = _actual_app_crdt__WEBPACK_IMPORTED_MODULE_0__.merkle.insert(currentMerkle, timestamp);
                        }
                    }
                    if (checkSyncingMode('enabled')) {
                        currentMerkle = _actual_app_crdt__WEBPACK_IMPORTED_MODULE_0__.merkle.prune(currentMerkle);
                        // Save the clock in the db first (queries might throw
                        // exceptions)
                        _db__WEBPACK_IMPORTED_MODULE_8__.runQuery(_db__WEBPACK_IMPORTED_MODULE_8__.cache('INSERT OR REPLACE INTO messages_clock (id, clock) VALUES (1, ?)'), [
                            (0, _actual_app_crdt__WEBPACK_IMPORTED_MODULE_0__.serializeClock)({
                                ...clock,
                                merkle: currentMerkle
                            })
                        ]);
                    }
                });
                if (checkSyncingMode('enabled')) {
                    // The transaction succeeded, so we can update in-memory objects
                    // now. Update the in-memory clock.
                    clock.merkle = currentMerkle;
                }
                // Save any synced prefs
                if (Object.keys(prefsToSet).length > 0) {
                    _prefs__WEBPACK_IMPORTED_MODULE_13__.savePrefs(prefsToSet, {
                        avoidSync: true
                    });
                    if (prefsToSet.budgetType) {
                        (0, _budget_base__WEBPACK_IMPORTED_MODULE_7__.setType)(prefsToSet.budgetType);
                    }
                    _platform_server_connection__WEBPACK_IMPORTED_MODULE_3__.send('prefs-updated');
                }
                const newData = await fetchData();
                // In testing, sometimes the spreadsheet isn't loaded, and that's ok
                if (_sheet__WEBPACK_IMPORTED_MODULE_15__.get()) {
                    // Need to clean up these APIs and make them consistent
                    _sheet__WEBPACK_IMPORTED_MODULE_15__.startTransaction();
                    (0, _budget_base__WEBPACK_IMPORTED_MODULE_7__.triggerBudgetChanges)(oldData, newData);
                    _sheet__WEBPACK_IMPORTED_MODULE_15__.get().triggerDatabaseChanges(oldData, newData);
                    _sheet__WEBPACK_IMPORTED_MODULE_15__.endTransaction();
                    // Allow the cache to be used in the future. At this point it's guaranteed
                    // to be up-to-date because we are done mutating any other data
                    _sheet__WEBPACK_IMPORTED_MODULE_15__.get().endCacheBarrier();
                }
                _syncListeners.forEach((func) => func(oldData, newData));
                const tables = getTablesFromMessages(messages.filter((msg) => !msg.old));
                _main_app__WEBPACK_IMPORTED_MODULE_10__.app.events.emit('sync', {
                    type: 'applied',
                    tables,
                    data: newData,
                    prevData: oldData
                });
                return messages;
            });
            function receiveMessages(messages) {
                messages.forEach((msg) => {
                    _actual_app_crdt__WEBPACK_IMPORTED_MODULE_0__.Timestamp.recv(msg.timestamp);
                });
                return (0, _mutators__WEBPACK_IMPORTED_MODULE_11__.runMutator)(() => applyMessages(messages));
            }
            async function _sendMessages(messages) {
                try {
                    await applyMessages(messages);
                }
                catch (e) {
                    if (e instanceof _errors__WEBPACK_IMPORTED_MODULE_9__.SyncError) {
                        if (e.reason === 'invalid-schema') {
                            // We know this message came from a local modification, and it
                            // couldn't apply, which doesn't make any sense. Must be a bug
                            // in the code. Send a specific error type for it for a custom
                            // message.
                            _main_app__WEBPACK_IMPORTED_MODULE_10__.app.events.emit('sync', {
                                type: 'error',
                                subtype: 'apply-failure',
                                meta: e.meta
                            });
                        }
                        else {
                            _main_app__WEBPACK_IMPORTED_MODULE_10__.app.events.emit('sync', {
                                type: 'error',
                                meta: e.meta
                            });
                        }
                    }
                    throw e;
                }
                await scheduleFullSync();
            }
            let IS_BATCHING = false;
            let _BATCHED = [];
            async function batchMessages(func) {
                if (IS_BATCHING) {
                    await func();
                    return;
                }
                IS_BATCHING = true;
                let batched = [];
                try {
                    await func();
                    // TODO: if it fails, it shouldn't apply them?
                }
                finally {
                    IS_BATCHING = false;
                    batched = _BATCHED;
                    _BATCHED = [];
                }
                if (batched.length > 0) {
                    await _sendMessages(batched);
                }
            }
            async function sendMessages(messages) {
                if (IS_BATCHING) {
                    _BATCHED = _BATCHED.concat(messages);
                }
                else {
                    return _sendMessages(messages);
                }
            }
            function getMessagesSince(since) {
                return _db__WEBPACK_IMPORTED_MODULE_8__.runQuery('SELECT timestamp, dataset, row, column, value FROM messages_crdt WHERE timestamp > ?', [
                    since
                ], true);
            }
            function clearFullSyncTimeout() {
                if (syncTimeout) {
                    clearTimeout(syncTimeout);
                    syncTimeout = null;
                }
            }
            let syncTimeout = null;
            function scheduleFullSync() {
                clearFullSyncTimeout();
                if (checkSyncingMode('enabled') && !checkSyncingMode('offline')) {
                    if (false) { }
                    else {
                        syncTimeout = setTimeout(fullSync, FULL_SYNC_DELAY);
                    }
                }
            }
            function getTablesFromMessages(messages) {
                return messages.reduce((acc, message) => {
                    const dataset = message.dataset === 'schedules_next_date' ? 'schedules' : message.dataset;
                    if (!acc.includes(dataset)) {
                        acc.push(dataset);
                    }
                    return acc;
                }, []);
            }
            // This is different than `fullSync` because it waits for the
            // spreadsheet to finish any processing. This is useful if we want to
            // perform a full sync and wait for everything to finish, usually if
            // you're doing an initial sync before working with a file.
            async function initialFullSync() {
                const result = await fullSync();
                if ((0, _utils__WEBPACK_IMPORTED_MODULE_19__.isError)(result)) {
                    // Make sure to wait for anything in the spreadsheet to process
                    await _sheet__WEBPACK_IMPORTED_MODULE_15__.waitOnSpreadsheet();
                    return result;
                }
                return {};
            }
            const fullSync = (0, _shared_async__WEBPACK_IMPORTED_MODULE_5__.once)(async function () {
                _main_app__WEBPACK_IMPORTED_MODULE_10__.app.events.emit('sync', {
                    type: 'start'
                });
                let messages;
                try {
                    messages = await _fullSync(null, 0, null);
                }
                catch (e) {
                    console.log(e);
                    if (e instanceof _errors__WEBPACK_IMPORTED_MODULE_9__.SyncError) {
                        if (e.reason === 'out-of-sync') {
                            (0, _platform_exceptions__WEBPACK_IMPORTED_MODULE_1__.captureException)(e);
                            _main_app__WEBPACK_IMPORTED_MODULE_10__.app.events.emit('sync', {
                                type: 'error',
                                subtype: 'out-of-sync',
                                meta: e.meta
                            });
                        }
                        else if (e.reason === 'invalid-schema') {
                            _main_app__WEBPACK_IMPORTED_MODULE_10__.app.events.emit('sync', {
                                type: 'error',
                                subtype: 'invalid-schema',
                                meta: e.meta
                            });
                        }
                        else if (e.reason === 'decrypt-failure' || e.reason === 'encrypt-failure') {
                            _main_app__WEBPACK_IMPORTED_MODULE_10__.app.events.emit('sync', {
                                type: 'error',
                                subtype: e.reason,
                                meta: e.meta
                            });
                        }
                        else {
                            _main_app__WEBPACK_IMPORTED_MODULE_10__.app.events.emit('sync', {
                                type: 'error',
                                meta: e.meta
                            });
                        }
                    }
                    else if (e instanceof _errors__WEBPACK_IMPORTED_MODULE_9__.PostError) {
                        console.log(e);
                        if (e.reason === 'unauthorized') {
                            _main_app__WEBPACK_IMPORTED_MODULE_10__.app.events.emit('sync', {
                                type: 'unauthorized'
                            });
                            // Set the user into read-only mode
                            _platform_server_asyncStorage__WEBPACK_IMPORTED_MODULE_2__.setItem('readOnly', 'true');
                        }
                        else if (e.reason === 'network-failure') {
                            _main_app__WEBPACK_IMPORTED_MODULE_10__.app.events.emit('sync', {
                                type: 'error',
                                subtype: 'network'
                            });
                        }
                        else {
                            _main_app__WEBPACK_IMPORTED_MODULE_10__.app.events.emit('sync', {
                                type: 'error',
                                subtype: e.reason
                            });
                        }
                    }
                    else {
                        (0, _platform_exceptions__WEBPACK_IMPORTED_MODULE_1__.captureException)(e);
                        // TODO: Send the message to the client and allow them to expand & view it
                        _main_app__WEBPACK_IMPORTED_MODULE_10__.app.events.emit('sync', {
                            type: 'error'
                        });
                    }
                    return {
                        error: {
                            message: e.message,
                            reason: e.reason,
                            meta: e.meta
                        }
                    };
                }
                const tables = getTablesFromMessages(messages);
                _main_app__WEBPACK_IMPORTED_MODULE_10__.app.events.emit('sync', {
                    type: 'success',
                    tables,
                    syncDisabled: checkSyncingMode('disabled')
                });
                return {
                    messages
                };
            });
            async function _fullSync(sinceTimestamp, count, prevDiffTime) {
                const { cloudFileId, groupId, lastSyncedTimestamp } = _prefs__WEBPACK_IMPORTED_MODULE_13__.getPrefs() || {};
                clearFullSyncTimeout();
                if (checkSyncingMode('disabled') || checkSyncingMode('offline')) {
                    return [];
                }
                // Snapshot the point at which we are currently syncing
                const currentTime = (0, _actual_app_crdt__WEBPACK_IMPORTED_MODULE_0__.getClock)().timestamp.toString();
                const since = sinceTimestamp || lastSyncedTimestamp || // Default to 5 minutes ago
                    new _actual_app_crdt__WEBPACK_IMPORTED_MODULE_0__.Timestamp(Date.now() - 5 * 60 * 1000, 0, '0').toString();
                const messages = getMessagesSince(since);
                const userToken = await _platform_server_asyncStorage__WEBPACK_IMPORTED_MODULE_2__.getItem('user-token');
                _platform_server_log__WEBPACK_IMPORTED_MODULE_4__.logger.info('Syncing since', since, messages.length, '(attempt: ' + count + ')');
                const buffer = await _encoder__WEBPACK_IMPORTED_MODULE_17__.encode(groupId, cloudFileId, since, messages);
                // TODO: There a limit on how many messages we can send because of
                // the payload size. Right now it's at 20MB on the server. We should
                // check the worst case here and make multiple requests if it's
                // really large.
                const resBuffer = await (0, _post__WEBPACK_IMPORTED_MODULE_12__.postBinary)((0, _server_config__WEBPACK_IMPORTED_MODULE_14__.getServer)().SYNC_SERVER + '/sync', buffer, {
                    'X-ACTUAL-TOKEN': userToken
                });
                // Abort if the file is either no longer loaded, the group id has
                // changed because of a sync reset
                if (!_prefs__WEBPACK_IMPORTED_MODULE_13__.getPrefs() || _prefs__WEBPACK_IMPORTED_MODULE_13__.getPrefs().groupId !== groupId) {
                    return [];
                }
                const res = await _encoder__WEBPACK_IMPORTED_MODULE_17__.decode(resBuffer);
                _platform_server_log__WEBPACK_IMPORTED_MODULE_4__.logger.info('Got messages from server', res.messages.length);
                const localTimeChanged = (0, _actual_app_crdt__WEBPACK_IMPORTED_MODULE_0__.getClock)().timestamp.toString() !== currentTime;
                // Apply the new messages
                let receivedMessages = [];
                if (res.messages.length > 0) {
                    receivedMessages = await receiveMessages(res.messages.map((msg) => ({
                        ...msg,
                        value: deserializeValue(msg.value)
                    })));
                }
                const diffTime = _actual_app_crdt__WEBPACK_IMPORTED_MODULE_0__.merkle.diff(res.merkle, (0, _actual_app_crdt__WEBPACK_IMPORTED_MODULE_0__.getClock)().merkle);
                if (diffTime !== null) {
                    // This is a bit wonky, but we loop until we are in sync with the
                    // server. While syncing, either the client or server could change
                    // out from under us, so it might take a couple passes to
                    // completely sync up. This is a check that stops the loop in case
                    // we are corrupted and can't sync up. We try 10 times if we keep
                    // getting the same diff time, and add a upper limit of 300 no
                    // matter what (just to stop this from ever being an infinite
                    // loop).
                    //
                    // It's slightly possible for the user to add more messages while we
                    // are in `receiveMessages`, but `localTimeChanged` would still be
                    // false. In that case, we don't reset the counter but it should be
                    // very unlikely that this happens enough to hit the loop limit.
                    if (count >= 10 && diffTime === prevDiffTime || count >= 100) {
                        _platform_server_log__WEBPACK_IMPORTED_MODULE_4__.logger.info('SENT -------');
                        _platform_server_log__WEBPACK_IMPORTED_MODULE_4__.logger.info(JSON.stringify(messages));
                        _platform_server_log__WEBPACK_IMPORTED_MODULE_4__.logger.info('RECEIVED -------');
                        _platform_server_log__WEBPACK_IMPORTED_MODULE_4__.logger.info(JSON.stringify(res.messages));
                        const rebuiltMerkle = (0, _repair__WEBPACK_IMPORTED_MODULE_18__.rebuildMerkleHash)();
                        console.log(count, 'messages:', messages.length, messages.length > 0 ? messages[0] : null, 'res.messages:', res.messages.length, res.messages.length > 0 ? res.messages[0] : null, 'clientId', (0, _actual_app_crdt__WEBPACK_IMPORTED_MODULE_0__.getClock)().timestamp.node(), 'groupId', groupId, 'diffTime:', diffTime, diffTime === prevDiffTime, 'local clock:', (0, _actual_app_crdt__WEBPACK_IMPORTED_MODULE_0__.getClock)().timestamp.toString(), (0, _actual_app_crdt__WEBPACK_IMPORTED_MODULE_0__.getClock)().merkle.hash, 'rebuilt hash:', rebuiltMerkle.numMessages, rebuiltMerkle.trie.hash, 'server hash:', res.merkle.hash, 'localTimeChanged:', localTimeChanged);
                        if (rebuiltMerkle.trie.hash === res.merkle.hash) {
                            // Rebuilding the merkle worked... but why?
                            const clocks = await _db__WEBPACK_IMPORTED_MODULE_8__.all('SELECT * FROM messages_clock');
                            if (clocks.length !== 1) {
                                console.log('Bad number of clocks:', clocks.length);
                            }
                            const hash = (0, _actual_app_crdt__WEBPACK_IMPORTED_MODULE_0__.deserializeClock)(clocks[0]).merkle.hash;
                            console.log('Merkle hash in db:', hash);
                        }
                        throw new _errors__WEBPACK_IMPORTED_MODULE_9__.SyncError('out-of-sync');
                    }
                    receivedMessages = receivedMessages.concat(await _fullSync(new _actual_app_crdt__WEBPACK_IMPORTED_MODULE_0__.Timestamp(diffTime, 0, '0').toString(), // If something local changed while we were syncing, always
                    // reset, token the counter. We never want to think syncing failed
                    // because we tried to syncing many times and couldn't sync,
                    // but it was because the user kept changing stuff in the
                    // middle of syncing.
                    localTimeChanged ? 0 : count + 1, diffTime));
                }
                else {
                    // All synced up, store the current time as a simple optimization
                    // for the next sync
                    await _prefs__WEBPACK_IMPORTED_MODULE_13__.savePrefs({
                        lastSyncedTimestamp: (0, _actual_app_crdt__WEBPACK_IMPORTED_MODULE_0__.getClock)().timestamp.toString()
                    });
                }
                return receivedMessages;
            }
            /***/ 
        }),
        /***/ "./packages/loot-core/src/server/sync/make-test-message.ts": 
        /*!*****************************************************************!*\
          !*** ./packages/loot-core/src/server/sync/make-test-message.ts ***!
          \*****************************************************************/
        /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony export */ __webpack_require__.d(__webpack_exports__, {
                /* harmony export */ makeTestMessage: () => ( /* binding */makeTestMessage)
                /* harmony export */ 
            });
            /* harmony import */ var _actual_app_crdt__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @actual-app/crdt */ "@actual-app/crdt");
            /* harmony import */ var _actual_app_crdt__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/ __webpack_require__.n(_actual_app_crdt__WEBPACK_IMPORTED_MODULE_0__);
            /* harmony import */ var _encryption__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../encryption */ "./packages/loot-core/src/server/encryption.ts");
            // @ts-strict-ignore
            async function randomString() {
                return (await _encryption__WEBPACK_IMPORTED_MODULE_1__.randomBytes(12)).toString();
            }
            async function makeTestMessage(keyId) {
                const messagePb = new _actual_app_crdt__WEBPACK_IMPORTED_MODULE_0__.SyncProtoBuf.Message();
                messagePb.setDataset(await randomString());
                messagePb.setRow(await randomString());
                messagePb.setColumn(await randomString());
                messagePb.setValue(await randomString());
                const binaryMsg = messagePb.serializeBinary();
                return await _encryption__WEBPACK_IMPORTED_MODULE_1__.encrypt(binaryMsg, keyId);
            }
            /***/ 
        }),
        /***/ "./packages/loot-core/src/server/sync/migrate.ts": 
        /*!*******************************************************!*\
          !*** ./packages/loot-core/src/server/sync/migrate.ts ***!
          \*******************************************************/
        /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony export */ __webpack_require__.d(__webpack_exports__, {
                /* harmony export */ listen: () => ( /* binding */listen),
                /* harmony export */ unlisten: () => ( /* binding */unlisten)
                /* harmony export */ 
            });
            /* harmony import */ var _actual_app_crdt__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @actual-app/crdt */ "@actual-app/crdt");
            /* harmony import */ var _actual_app_crdt__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/ __webpack_require__.n(_actual_app_crdt__WEBPACK_IMPORTED_MODULE_0__);
            /* harmony import */ var _index__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./index */ "./packages/loot-core/src/server/sync/index.ts");
            // @ts-strict-ignore
            function migrateParentIds(_oldValues, newValues) {
                newValues.forEach((items, table) => {
                    if (table === 'transactions') {
                        const toApply = [];
                        items.forEach((newValue) => {
                            if (newValue.isChild === 1 && newValue.parent_id == null && newValue.id.includes('/')) {
                                const parentId = newValue.id.split('/')[0];
                                toApply.push({
                                    dataset: 'transactions',
                                    row: newValue.id,
                                    column: 'parent_id',
                                    value: parentId,
                                    timestamp: _actual_app_crdt__WEBPACK_IMPORTED_MODULE_0__.Timestamp.send()
                                });
                            }
                        });
                        if (toApply.length > 0) {
                            (0, _index__WEBPACK_IMPORTED_MODULE_1__.applyMessages)(toApply);
                        }
                    }
                });
            }
            let _unlisten = null;
            function listen() {
                unlisten();
                _unlisten = (0, _index__WEBPACK_IMPORTED_MODULE_1__.addSyncListener)(migrateParentIds);
            }
            function unlisten() {
                if (_unlisten) {
                    _unlisten();
                    _unlisten = null;
                }
            }
            /***/ 
        }),
        /***/ "./packages/loot-core/src/server/sync/repair.ts": 
        /*!******************************************************!*\
          !*** ./packages/loot-core/src/server/sync/repair.ts ***!
          \******************************************************/
        /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony export */ __webpack_require__.d(__webpack_exports__, {
                /* harmony export */ rebuildMerkleHash: () => ( /* binding */rebuildMerkleHash),
                /* harmony export */ repairSync: () => ( /* binding */repairSync)
                /* harmony export */ 
            });
            /* harmony import */ var _actual_app_crdt__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @actual-app/crdt */ "@actual-app/crdt");
            /* harmony import */ var _actual_app_crdt__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/ __webpack_require__.n(_actual_app_crdt__WEBPACK_IMPORTED_MODULE_0__);
            /* harmony import */ var _db__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../db */ "./packages/loot-core/src/server/db/index.ts");
            // @ts-strict-ignore
            function rebuildMerkleHash() {
                const rows = _db__WEBPACK_IMPORTED_MODULE_1__.runQuery('SELECT timestamp FROM messages_crdt', [], true);
                let trie = _actual_app_crdt__WEBPACK_IMPORTED_MODULE_0__.merkle.emptyTrie();
                for (let i = 0; i < rows.length; i++) {
                    trie = _actual_app_crdt__WEBPACK_IMPORTED_MODULE_0__.merkle.insert(trie, _actual_app_crdt__WEBPACK_IMPORTED_MODULE_0__.Timestamp.parse(rows[i].timestamp));
                }
                return {
                    numMessages: rows.length,
                    trie
                };
            }
            async function repairSync() {
                const rebuilt = rebuildMerkleHash();
                const clock = (0, _actual_app_crdt__WEBPACK_IMPORTED_MODULE_0__.getClock)();
                // Save it locally
                clock.merkle = rebuilt.trie;
                // Persist it in the db
                _db__WEBPACK_IMPORTED_MODULE_1__.runQuery(_db__WEBPACK_IMPORTED_MODULE_1__.cache('INSERT OR REPLACE INTO messages_clock (id, clock) VALUES (1, ?)'), [
                    (0, _actual_app_crdt__WEBPACK_IMPORTED_MODULE_0__.serializeClock)(clock)
                ]);
            }
            /***/ 
        }),
        /***/ "./packages/loot-core/src/server/sync/reset.ts": 
        /*!*****************************************************!*\
          !*** ./packages/loot-core/src/server/sync/reset.ts ***!
          \*****************************************************/
        /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony export */ __webpack_require__.d(__webpack_exports__, {
                /* harmony export */ resetSync: () => ( /* binding */resetSync)
                /* harmony export */ 
            });
            /* harmony import */ var _platform_exceptions__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../platform/exceptions */ "./packages/loot-core/src/platform/exceptions/index.electron.ts");
            /* harmony import */ var _platform_server_asyncStorage__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../platform/server/asyncStorage */ "./packages/loot-core/src/platform/server/asyncStorage/index.electron.ts");
            /* harmony import */ var _platform_server_connection__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../platform/server/connection */ "./packages/loot-core/src/platform/server/connection/index.api.ts");
            /* harmony import */ var _cloud_storage__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../cloud-storage */ "./packages/loot-core/src/server/cloud-storage.ts");
            /* harmony import */ var _db__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../db */ "./packages/loot-core/src/server/db/index.ts");
            /* harmony import */ var _mutators__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../mutators */ "./packages/loot-core/src/server/mutators.ts");
            /* harmony import */ var _prefs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../prefs */ "./packages/loot-core/src/server/prefs.ts");
            // @ts-strict-ignore
            async function resetSync(keyState) {
                if (!keyState) {
                    // If we aren't resetting the key, make sure our key is up-to-date
                    // so we don't accidentally upload a file encrypted with the wrong
                    // key (or not encrypted at all)
                    const { valid, error } = await _cloud_storage__WEBPACK_IMPORTED_MODULE_3__.checkKey();
                    if (error) {
                        return {
                            error
                        };
                    }
                    else if (!valid) {
                        return {
                            error: {
                                reason: 'file-has-new-key'
                            }
                        };
                    }
                }
                const { error } = await _cloud_storage__WEBPACK_IMPORTED_MODULE_3__.resetSyncState(keyState);
                if (error) {
                    return {
                        error
                    };
                }
                await (0, _mutators__WEBPACK_IMPORTED_MODULE_5__.runMutator)(async () => {
                    // TOOD: We could automatically generate the list of tables to
                    // cleanup by looking at the schema
                    //
                    // Be VERY careful here since we are bulk deleting data. It should
                    // never delete any data that doesn't have `tombstone = 1`
                    await _db__WEBPACK_IMPORTED_MODULE_4__.execQuery(`
      DELETE FROM messages_crdt;
      DELETE FROM messages_clock;
      DELETE FROM transactions WHERE tombstone = 1;
      DELETE FROM accounts WHERE tombstone = 1;
      DELETE FROM payees WHERE tombstone = 1;
      DELETE FROM categories WHERE tombstone = 1;
      DELETE FROM category_groups WHERE tombstone = 1;
      DELETE FROM schedules WHERE tombstone = 1;
      DELETE FROM rules WHERE tombstone = 1;
      ANALYZE;
      VACUUM;
    `);
                    await _db__WEBPACK_IMPORTED_MODULE_4__.loadClock();
                });
                await _prefs__WEBPACK_IMPORTED_MODULE_6__.savePrefs({
                    groupId: null,
                    lastSyncedTimestamp: null,
                    lastUploaded: null
                });
                if (keyState) {
                    const { key } = keyState;
                    const { cloudFileId } = _prefs__WEBPACK_IMPORTED_MODULE_6__.getPrefs();
                    // The key has changed, we need to update our local data to
                    // store the new key
                    // Persist key in async storage
                    const keys = JSON.parse(await _platform_server_asyncStorage__WEBPACK_IMPORTED_MODULE_1__.getItem(`encrypt-keys`) || '{}');
                    keys[cloudFileId] = key.serialize();
                    await _platform_server_asyncStorage__WEBPACK_IMPORTED_MODULE_1__.setItem('encrypt-keys', JSON.stringify(keys));
                    // Save the key id in prefs
                    await _prefs__WEBPACK_IMPORTED_MODULE_6__.savePrefs({
                        encryptKeyId: key.getId()
                    });
                }
                // Finally, upload the file to make it the "true" version that all
                // other clients need to pull down to get back in sync
                try {
                    await _cloud_storage__WEBPACK_IMPORTED_MODULE_3__.upload();
                }
                catch (e) {
                    if (e.reason) {
                        return {
                            error: e
                        };
                    }
                    (0, _platform_exceptions__WEBPACK_IMPORTED_MODULE_0__.captureException)(e);
                    return {
                        error: {
                            reason: 'upload-failure'
                        }
                    };
                }
                finally {
                    _platform_server_connection__WEBPACK_IMPORTED_MODULE_2__.send('prefs-updated');
                }
                return {};
            }
            /***/ 
        }),
        /***/ "./packages/loot-core/src/server/sync/utils.ts": 
        /*!*****************************************************!*\
          !*** ./packages/loot-core/src/server/sync/utils.ts ***!
          \*****************************************************/
        /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony export */ __webpack_require__.d(__webpack_exports__, {
                /* harmony export */ isError: () => ( /* binding */isError)
                /* harmony export */ 
            });
            function isError(value) {
                return value.error !== undefined;
            }
            /***/ 
        }),
        /***/ "./packages/loot-core/src/server/tools/app.ts": 
        /*!****************************************************!*\
          !*** ./packages/loot-core/src/server/tools/app.ts ***!
          \****************************************************/
        /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony export */ __webpack_require__.d(__webpack_exports__, {
                /* harmony export */ app: () => ( /* binding */app)
                /* harmony export */ 
            });
            /* harmony import */ var _accounts_transactions__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../accounts/transactions */ "./packages/loot-core/src/server/accounts/transactions.ts");
            /* harmony import */ var _app__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../app */ "./packages/loot-core/src/server/app.ts");
            /* harmony import */ var _db__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../db */ "./packages/loot-core/src/server/db/index.ts");
            /* harmony import */ var _mutators__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../mutators */ "./packages/loot-core/src/server/mutators.ts");
            // @ts-strict-ignore
            const app = (0, _app__WEBPACK_IMPORTED_MODULE_1__.createApp)();
            app.method('tools/fix-split-transactions', async () => {
                // 1. Check for child transactions that have a blank payee, and set
                //    the payee to whatever the parent has
                const blankPayeeRows = await _db__WEBPACK_IMPORTED_MODULE_2__.all(`
    SELECT t.*, p.payee AS parentPayee FROM v_transactions_internal t
    LEFT JOIN v_transactions_internal p ON t.parent_id = p.id
    WHERE t.is_child = 1 AND t.payee IS NULL AND p.payee IS NOT NULL
  `);
                await (0, _mutators__WEBPACK_IMPORTED_MODULE_3__.runMutator)(async () => {
                    const updated = blankPayeeRows.map((row) => ({
                        id: row.id,
                        payee: row.parentPayee
                    }));
                    await (0, _accounts_transactions__WEBPACK_IMPORTED_MODULE_0__.batchUpdateTransactions)({
                        updated
                    });
                });
                // 2. Make sure the "cleared" flag is synced up with the parent
                // transactions
                const clearedRows = await _db__WEBPACK_IMPORTED_MODULE_2__.all(`
    SELECT t.id, p.cleared FROM v_transactions_internal t
    LEFT JOIN v_transactions_internal p ON t.parent_id = p.id
    WHERE t.is_child = 1 AND t.cleared != p.cleared
  `);
                await (0, _mutators__WEBPACK_IMPORTED_MODULE_3__.runMutator)(async () => {
                    const updated = clearedRows.map((row) => ({
                        id: row.id,
                        cleared: row.cleared === 1
                    }));
                    await (0, _accounts_transactions__WEBPACK_IMPORTED_MODULE_0__.batchUpdateTransactions)({
                        updated
                    });
                });
                // 3. Mark the `tombstone` field as true on any child transactions
                //    that have a dead parent
                const deletedRows = await _db__WEBPACK_IMPORTED_MODULE_2__.all(`
    SELECT t.* FROM v_transactions_internal t
    LEFT JOIN v_transactions_internal p ON t.parent_id = p.id
    WHERE t.is_child = 1 AND t.tombstone = 0 AND (p.tombstone = 1 OR p.id IS NULL)
  `);
                await (0, _mutators__WEBPACK_IMPORTED_MODULE_3__.runMutator)(async () => {
                    const updated = deletedRows.map((row) => ({
                        id: row.id,
                        tombstone: 1
                    }));
                    await (0, _accounts_transactions__WEBPACK_IMPORTED_MODULE_0__.batchUpdateTransactions)({
                        updated
                    });
                });
                return {
                    numBlankPayees: blankPayeeRows.length,
                    numCleared: clearedRows.length,
                    numDeleted: deletedRows.length
                };
            });
            /***/ 
        }),
        /***/ "./packages/loot-core/src/server/undo.ts": 
        /*!***********************************************!*\
          !*** ./packages/loot-core/src/server/undo.ts ***!
          \***********************************************/
        /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony export */ __webpack_require__.d(__webpack_exports__, {
                /* harmony export */ appendMessages: () => ( /* binding */appendMessages),
                /* harmony export */ clearUndo: () => ( /* binding */clearUndo),
                /* harmony export */ redo: () => ( /* binding */redo),
                /* harmony export */ undo: () => ( /* binding */undo),
                /* harmony export */ undoable: () => ( /* binding */undoable),
                /* harmony export */ withUndo: () => ( /* binding */withUndo)
                /* harmony export */ 
            });
            /* harmony import */ var _actual_app_crdt__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @actual-app/crdt */ "@actual-app/crdt");
            /* harmony import */ var _actual_app_crdt__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/ __webpack_require__.n(_actual_app_crdt__WEBPACK_IMPORTED_MODULE_0__);
            /* harmony import */ var _platform_server_connection__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../platform/server/connection */ "./packages/loot-core/src/platform/server/connection/index.api.ts");
            /* harmony import */ var _shared_util__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../shared/util */ "./packages/loot-core/src/shared/util.ts");
            /* harmony import */ var _mutators__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./mutators */ "./packages/loot-core/src/server/mutators.ts");
            /* harmony import */ var _sync__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./sync */ "./packages/loot-core/src/server/sync/index.ts");
            // @ts-strict-ignore
            let MESSAGE_HISTORY = [
                {
                    type: 'marker'
                }
            ];
            let CURSOR = 0;
            const HISTORY_SIZE = 20;
            function trimHistory() {
                MESSAGE_HISTORY = MESSAGE_HISTORY.slice(0, CURSOR + 1);
                const markers = MESSAGE_HISTORY.filter((item) => item.type === 'marker');
                if (markers.length > HISTORY_SIZE) {
                    const slice = markers.slice(-HISTORY_SIZE);
                    const cutoff = MESSAGE_HISTORY.indexOf(slice[0]);
                    MESSAGE_HISTORY = MESSAGE_HISTORY.slice(cutoff);
                    CURSOR = MESSAGE_HISTORY.length - 1;
                }
            }
            function appendMessages(messages, oldData) {
                const context = (0, _mutators__WEBPACK_IMPORTED_MODULE_3__.getMutatorContext)();
                if (context.undoListening && messages.length > 0) {
                    trimHistory();
                    const { undoTag } = context;
                    MESSAGE_HISTORY.push({
                        type: 'messages',
                        messages,
                        oldData,
                        undoTag
                    });
                    CURSOR++;
                }
            }
            function clearUndo() {
                MESSAGE_HISTORY = [
                    {
                        type: 'marker'
                    }
                ];
                CURSOR = 0;
            }
            function withUndo(func, meta) {
                const context = (0, _mutators__WEBPACK_IMPORTED_MODULE_3__.getMutatorContext)();
                if (context.undoDisabled || context.undoListening) {
                    return func();
                }
                MESSAGE_HISTORY = MESSAGE_HISTORY.slice(0, CURSOR + 1);
                const marker = {
                    type: 'marker',
                    meta
                };
                if (MESSAGE_HISTORY[MESSAGE_HISTORY.length - 1].type === 'marker') {
                    MESSAGE_HISTORY[MESSAGE_HISTORY.length - 1] = marker;
                }
                else {
                    MESSAGE_HISTORY.push(marker);
                    CURSOR++;
                }
                return (0, _mutators__WEBPACK_IMPORTED_MODULE_3__.withMutatorContext)({
                    undoListening: true,
                    undoTag: context.undoTag
                }, func);
            }
            function undoable(func) {
                return (...args) => {
                    return withUndo(() => {
                        return func.apply(null, args);
                    });
                };
            }
            async function applyUndoAction(messages, meta, undoTag) {
                await (0, _mutators__WEBPACK_IMPORTED_MODULE_3__.withMutatorContext)({
                    undoListening: false
                }, () => {
                    return (0, _sync__WEBPACK_IMPORTED_MODULE_4__.sendMessages)(messages.map((msg) => ({
                        ...msg,
                        timestamp: _actual_app_crdt__WEBPACK_IMPORTED_MODULE_0__.Timestamp.send()
                    })));
                });
                const tables = messages.reduce((acc, message) => {
                    if (!acc.includes(message.dataset)) {
                        acc.push(message.dataset);
                    }
                    return acc;
                }, []);
                _platform_server_connection__WEBPACK_IMPORTED_MODULE_1__.send('undo-event', {
                    messages,
                    tables,
                    meta,
                    undoTag
                });
            }
            async function undo() {
                const end = CURSOR;
                CURSOR = Math.max(CURSOR - 1, 0);
                // Walk back to the nearest marker
                while (CURSOR > 0 && MESSAGE_HISTORY[CURSOR].type !== 'marker') {
                    CURSOR--;
                }
                const meta = MESSAGE_HISTORY[CURSOR].meta;
                const start = Math.max(CURSOR, 0);
                const entries = MESSAGE_HISTORY.slice(start, end + 1).filter((entry) => entry.type === 'messages');
                if (entries.length > 0) {
                    const toApply = entries.reduce((acc, entry) => {
                        return acc.concat(entry.messages.map((message) => undoMessage(message, entry.oldData)).filter((x) => x));
                    }, []).reverse();
                    await applyUndoAction(toApply, meta, entries[0].undoTag);
                }
            }
            function undoMessage(message, oldData) {
                const oldItem = (0, _shared_util__WEBPACK_IMPORTED_MODULE_2__.getIn)(oldData, [
                    message.dataset,
                    message.row
                ]);
                if (oldItem) {
                    let column = message.column;
                    if (message.dataset === 'spreadsheet_cells') {
                        // The spreadsheet messages use the `expr` column, but only as a
                        // placeholder. We actually want to read the `cachedValue` prop
                        // from the old item.
                        column = 'cachedValue';
                    }
                    return {
                        ...message,
                        value: oldItem[column]
                    };
                }
                else {
                    if (message.dataset === 'spreadsheet_cells') {
                        if (message.column === 'expr') {
                            return {
                                ...message,
                                value: null
                            };
                        }
                        return message;
                    }
                    else if ( // The mapping fields aren't ever deleted... this should be
                    // harmless since all they are is meta information. Maybe we
                    // should fix this though.
                    message.dataset !== 'category_mapping' && message.dataset !== 'payee_mapping') {
                        if (message.dataset === 'zero_budget_months' || message.dataset === 'zero_budgets' || message.dataset === 'reflect_budgets') {
                            // Only these fields are reversable
                            if ([
                                'buffered',
                                'amount',
                                'carryover'
                            ].includes(message.column)) {
                                return {
                                    ...message,
                                    value: 0
                                };
                            }
                            return null;
                        }
                        else if (message.dataset === 'notes') {
                            return {
                                ...message,
                                value: null
                            };
                        }
                        return {
                            ...message,
                            column: 'tombstone',
                            value: 1
                        };
                    }
                }
                return null;
            }
            async function redo() {
                const meta = MESSAGE_HISTORY[CURSOR].type === 'marker' ? MESSAGE_HISTORY[CURSOR].meta : null;
                const start = CURSOR;
                CURSOR = Math.min(CURSOR + 1, MESSAGE_HISTORY.length - 1);
                // Walk forward to the nearest marker
                while (CURSOR < MESSAGE_HISTORY.length - 1 && MESSAGE_HISTORY[CURSOR].type !== 'marker') {
                    CURSOR++;
                }
                const end = CURSOR;
                const entries = MESSAGE_HISTORY.slice(start + 1, end + 1).filter((entry) => entry.type === 'messages');
                if (entries.length > 0) {
                    const toApply = entries.reduce((acc, entry) => {
                        return acc.concat(entry.messages).concat(redoResurrections(entry.messages, entry.oldData));
                    }, []);
                    await applyUndoAction(toApply, meta, entries[entries.length - 1].undoTag);
                }
            }
            function redoResurrections(messages, oldData) {
                const resurrect = new Set();
                messages.forEach((message) => {
                    // If any of the ids didn't exist before, we need to "resurrect"
                    // them by resetting their tombstones to 0
                    const oldItem = (0, _shared_util__WEBPACK_IMPORTED_MODULE_2__.getIn)(oldData, [
                        message.dataset,
                        message.row
                    ]);
                    if (!oldItem && ![
                        'zero_budget_months',
                        'zero_budgets',
                        'reflect_budgets',
                        'notes',
                        'category_mapping',
                        'payee_mapping'
                    ].includes(message.dataset)) {
                        resurrect.add(message.dataset + '.' + message.row);
                    }
                });
                return [
                    ...resurrect
                ].map((desc) => {
                    const [table, row] = desc.split('.');
                    return {
                        dataset: table,
                        row,
                        column: 'tombstone',
                        value: 0,
                        timestamp: _actual_app_crdt__WEBPACK_IMPORTED_MODULE_0__.Timestamp.send()
                    };
                });
            }
            /***/ 
        }),
        /***/ "./packages/loot-core/src/server/update.ts": 
        /*!*************************************************!*\
          !*** ./packages/loot-core/src/server/update.ts ***!
          \*************************************************/
        /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony export */ __webpack_require__.d(__webpack_exports__, {
                /* harmony export */ updateVersion: () => ( /* binding */updateVersion)
                /* harmony export */ 
            });
            /* harmony import */ var md5__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! md5 */ "./node_modules/md5/md5.js");
            /* harmony import */ var md5__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/ __webpack_require__.n(md5__WEBPACK_IMPORTED_MODULE_0__);
            /* harmony import */ var _aql__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./aql */ "./packages/loot-core/src/server/aql/index.ts");
            /* harmony import */ var _db__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./db */ "./packages/loot-core/src/server/db/index.ts");
            /* harmony import */ var _migrate_migrations__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./migrate/migrations */ "./packages/loot-core/src/server/migrate/migrations.ts");
            // @ts-strict-ignore
            // Managing the init/update process
            async function runMigrations() {
                await _migrate_migrations__WEBPACK_IMPORTED_MODULE_3__.migrate(_db__WEBPACK_IMPORTED_MODULE_2__.getDatabase());
            }
            async function updateViews() {
                const hashKey = 'view-hash';
                const row = await _db__WEBPACK_IMPORTED_MODULE_2__.first('SELECT value FROM __meta__ WHERE key = ?', [
                    hashKey
                ]);
                const { value: hash } = row || {};
                const views = (0, _aql__WEBPACK_IMPORTED_MODULE_1__.makeViews)(_aql__WEBPACK_IMPORTED_MODULE_1__.schema, _aql__WEBPACK_IMPORTED_MODULE_1__.schemaConfig);
                const currentHash = md5__WEBPACK_IMPORTED_MODULE_0___default()(views);
                if (hash !== currentHash) {
                    await _db__WEBPACK_IMPORTED_MODULE_2__.execQuery(views);
                    await _db__WEBPACK_IMPORTED_MODULE_2__.runQuery('INSERT OR REPLACE INTO __meta__ (key, value) VALUES (?, ?)', [
                        hashKey,
                        currentHash
                    ]);
                }
            }
            async function updateVersion() {
                await runMigrations();
                await updateViews();
            }
            /***/ 
        }),
        /***/ "./packages/loot-core/src/server/util/budget-name.ts": 
        /*!***********************************************************!*\
          !*** ./packages/loot-core/src/server/util/budget-name.ts ***!
          \***********************************************************/
        /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony export */ __webpack_require__.d(__webpack_exports__, {
                /* harmony export */ idFromFileName: () => ( /* binding */idFromFileName),
                /* harmony export */ uniqueFileName: () => ( /* binding */uniqueFileName)
                /* harmony export */ 
            });
            /* harmony import */ var uuid__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! uuid */ "./node_modules/uuid/dist/esm-node/v4.js");
            /* harmony import */ var _platform_server_fs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../platform/server/fs */ "./packages/loot-core/src/platform/server/fs/index.electron.ts");
            // @ts-strict-ignore
            async function uniqueFileName(existingFiles) {
                const initialName = 'My Finances';
                let idx = 1;
                // If there is a conflict, keep appending an index until there is no
                // conflict and we have a unique name
                let newName = initialName;
                while (existingFiles.find((file) => file.name === newName)) {
                    newName = `${initialName} ${idx}`;
                    idx++;
                }
                return newName;
            }
            async function idFromFileName(name) {
                let id = name.replace(/( |[^A-Za-z0-9])/g, '-') + '-' + (0, uuid__WEBPACK_IMPORTED_MODULE_1__["default"])().slice(0, 7);
                // Make sure the id is unique. There's a chance one could already
                // exist (although very unlikely now that we append unique
                // characters onto the id)
                let index = 0;
                let budgetDir = _platform_server_fs__WEBPACK_IMPORTED_MODULE_0__.getBudgetDir(id);
                while (await _platform_server_fs__WEBPACK_IMPORTED_MODULE_0__.exists(budgetDir)) {
                    index++;
                    budgetDir = _platform_server_fs__WEBPACK_IMPORTED_MODULE_0__.getBudgetDir(id + index.toString());
                }
                // If a suffix was added, update the id
                if (index > 0) {
                    id = id + index.toString();
                }
                return id;
            }
            /***/ 
        }),
        /***/ "./packages/loot-core/src/server/util/rschedule.ts": 
        /*!*********************************************************!*\
          !*** ./packages/loot-core/src/server/util/rschedule.ts ***!
          \*********************************************************/
        /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony export */ __webpack_require__.d(__webpack_exports__, {
                /* harmony export */ AddOperator: () => ( /* reexport safe */_rschedule_core_generators__WEBPACK_IMPORTED_MODULE_4__.AddOperator),
                /* harmony export */ ArgumentError: () => ( /* reexport safe */_rschedule_core__WEBPACK_IMPORTED_MODULE_3__.ArgumentError),
                /* harmony export */ Calendar: () => ( /* reexport safe */_rschedule_core_generators__WEBPACK_IMPORTED_MODULE_4__.Calendar),
                /* harmony export */ Collection: () => ( /* reexport safe */_rschedule_core_generators__WEBPACK_IMPORTED_MODULE_4__.Collection),
                /* harmony export */ CollectionIterator: () => ( /* reexport safe */_rschedule_core_generators__WEBPACK_IMPORTED_MODULE_4__.CollectionIterator),
                /* harmony export */ DateAdapter: () => ( /* reexport safe */_rschedule_core__WEBPACK_IMPORTED_MODULE_3__.DateAdapter),
                /* harmony export */ DateAdapterBase: () => ( /* reexport safe */_rschedule_core__WEBPACK_IMPORTED_MODULE_3__.DateAdapterBase),
                /* harmony export */ DateTime: () => ( /* reexport safe */_rschedule_core__WEBPACK_IMPORTED_MODULE_3__.DateTime),
                /* harmony export */ Dates: () => ( /* reexport safe */_rschedule_core_generators__WEBPACK_IMPORTED_MODULE_4__.Dates),
                /* harmony export */ InfiniteLoopError: () => ( /* reexport safe */_rschedule_core__WEBPACK_IMPORTED_MODULE_3__.InfiniteLoopError),
                /* harmony export */ IntersectionOperator: () => ( /* reexport safe */_rschedule_core_generators__WEBPACK_IMPORTED_MODULE_4__.IntersectionOperator),
                /* harmony export */ InvalidDateAdapterError: () => ( /* reexport safe */_rschedule_core__WEBPACK_IMPORTED_MODULE_3__.InvalidDateAdapterError),
                /* harmony export */ InvalidDateTime: () => ( /* reexport safe */_rschedule_core__WEBPACK_IMPORTED_MODULE_3__.InvalidDateTime),
                /* harmony export */ InvalidDateTimeError: () => ( /* reexport safe */_rschedule_core__WEBPACK_IMPORTED_MODULE_3__.InvalidDateTimeError),
                /* harmony export */ MergeDurationOperator: () => ( /* reexport safe */_rschedule_core_generators__WEBPACK_IMPORTED_MODULE_4__.MergeDurationOperator),
                /* harmony export */ MergeDurationOperatorError: () => ( /* reexport safe */_rschedule_core_generators__WEBPACK_IMPORTED_MODULE_4__.MergeDurationOperatorError),
                /* harmony export */ OccurrenceGenerator: () => ( /* reexport safe */_rschedule_core_generators__WEBPACK_IMPORTED_MODULE_4__.OccurrenceGenerator),
                /* harmony export */ OccurrenceIterator: () => ( /* reexport safe */_rschedule_core_generators__WEBPACK_IMPORTED_MODULE_4__.OccurrenceIterator),
                /* harmony export */ Operator: () => ( /* reexport safe */_rschedule_core_generators__WEBPACK_IMPORTED_MODULE_4__.Operator),
                /* harmony export */ RecurrenceRuleError: () => ( /* reexport safe */_rschedule_core__WEBPACK_IMPORTED_MODULE_3__.RecurrenceRuleError),
                /* harmony export */ RecurrenceRulesIterator: () => ( /* reexport safe */_rschedule_core__WEBPACK_IMPORTED_MODULE_3__.RecurrenceRulesIterator),
                /* harmony export */ Rule: () => ( /* reexport safe */_rschedule_core_generators__WEBPACK_IMPORTED_MODULE_4__.Rule),
                /* harmony export */ RuleBase: () => ( /* reexport safe */_rschedule_core_generators__WEBPACK_IMPORTED_MODULE_4__.RuleBase),
                /* harmony export */ RuleOptionError: () => ( /* reexport safe */_rschedule_core__WEBPACK_IMPORTED_MODULE_3__.RuleOptionError),
                /* harmony export */ Schedule: () => ( /* reexport safe */_rschedule_core_generators__WEBPACK_IMPORTED_MODULE_4__.Schedule),
                /* harmony export */ ScheduleBase: () => ( /* reexport safe */_rschedule_core_generators__WEBPACK_IMPORTED_MODULE_4__.ScheduleBase),
                /* harmony export */ SplitDurationOperator: () => ( /* reexport safe */_rschedule_core_generators__WEBPACK_IMPORTED_MODULE_4__.SplitDurationOperator),
                /* harmony export */ SplitDurationOperatorError: () => ( /* reexport safe */_rschedule_core_generators__WEBPACK_IMPORTED_MODULE_4__.SplitDurationOperatorError),
                /* harmony export */ StandardDateAdapter: () => ( /* reexport safe */_rschedule_standard_date_adapter__WEBPACK_IMPORTED_MODULE_2__.StandardDateAdapter),
                /* harmony export */ SubtractOperator: () => ( /* reexport safe */_rschedule_core_generators__WEBPACK_IMPORTED_MODULE_4__.SubtractOperator),
                /* harmony export */ UniqueOperator: () => ( /* reexport safe */_rschedule_core_generators__WEBPACK_IMPORTED_MODULE_4__.UniqueOperator),
                /* harmony export */ ValidDateTime: () => ( /* reexport safe */_rschedule_core__WEBPACK_IMPORTED_MODULE_3__.ValidDateTime),
                /* harmony export */ add: () => ( /* reexport safe */_rschedule_core_generators__WEBPACK_IMPORTED_MODULE_4__.add),
                /* harmony export */ cloneJSON: () => ( /* reexport safe */_rschedule_core__WEBPACK_IMPORTED_MODULE_3__.cloneJSON),
                /* harmony export */ cloneRuleOptions: () => ( /* reexport safe */_rschedule_core__WEBPACK_IMPORTED_MODULE_3__.cloneRuleOptions),
                /* harmony export */ dateInputToDateAdapter: () => ( /* reexport safe */_rschedule_core__WEBPACK_IMPORTED_MODULE_3__.dateInputToDateAdapter),
                /* harmony export */ dateInputToDateTime: () => ( /* reexport safe */_rschedule_core__WEBPACK_IMPORTED_MODULE_3__.dateInputToDateTime),
                /* harmony export */ dateTimeSortComparer: () => ( /* reexport safe */_rschedule_core__WEBPACK_IMPORTED_MODULE_3__.dateTimeSortComparer),
                /* harmony export */ freqToGranularity: () => ( /* reexport safe */_rschedule_core__WEBPACK_IMPORTED_MODULE_3__.freqToGranularity),
                /* harmony export */ getDaysInYear: () => ( /* reexport safe */_rschedule_core__WEBPACK_IMPORTED_MODULE_3__.getDaysInYear),
                /* harmony export */ getDifferenceBetweenWeekdays: () => ( /* reexport safe */_rschedule_core__WEBPACK_IMPORTED_MODULE_3__.getDifferenceBetweenWeekdays),
                /* harmony export */ intersection: () => ( /* reexport safe */_rschedule_core_generators__WEBPACK_IMPORTED_MODULE_4__.intersection),
                /* harmony export */ isLeapYear: () => ( /* reexport safe */_rschedule_core__WEBPACK_IMPORTED_MODULE_3__.isLeapYear),
                /* harmony export */ mergeDuration: () => ( /* reexport safe */_rschedule_core_generators__WEBPACK_IMPORTED_MODULE_4__.mergeDuration),
                /* harmony export */ normalizeDateTimeTimezone: () => ( /* reexport safe */_rschedule_core__WEBPACK_IMPORTED_MODULE_3__.normalizeDateTimeTimezone),
                /* harmony export */ normalizeRuleOptions: () => ( /* reexport safe */_rschedule_core__WEBPACK_IMPORTED_MODULE_3__.normalizeRuleOptions),
                /* harmony export */ numberSortComparer: () => ( /* reexport safe */_rschedule_core__WEBPACK_IMPORTED_MODULE_3__.numberSortComparer),
                /* harmony export */ orderedWeekdays: () => ( /* reexport safe */_rschedule_core__WEBPACK_IMPORTED_MODULE_3__.orderedWeekdays),
                /* harmony export */ recurrenceRulesReducer: () => ( /* reexport safe */_rschedule_core__WEBPACK_IMPORTED_MODULE_3__.recurrenceRulesReducer),
                /* harmony export */ splitDuration: () => ( /* reexport safe */_rschedule_core_generators__WEBPACK_IMPORTED_MODULE_4__.splitDuration),
                /* harmony export */ subtract: () => ( /* reexport safe */_rschedule_core_generators__WEBPACK_IMPORTED_MODULE_4__.subtract),
                /* harmony export */ uniqDateTimes: () => ( /* reexport safe */_rschedule_core__WEBPACK_IMPORTED_MODULE_3__.uniqDateTimes),
                /* harmony export */ unique: () => ( /* reexport safe */_rschedule_core_generators__WEBPACK_IMPORTED_MODULE_4__.unique)
                /* harmony export */ 
            });
            /* harmony import */ var _rschedule_standard_date_adapter_setup__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @rschedule/standard-date-adapter/setup */ "./node_modules/@rschedule/standard-date-adapter/es2015/setup.js");
            /* harmony import */ var _rschedule_json_tools_Schedule__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @rschedule/json-tools/Schedule */ "./node_modules/@rschedule/json-tools/es2015/Schedule.js");
            /* harmony import */ var _rschedule_standard_date_adapter__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @rschedule/standard-date-adapter */ "./node_modules/@rschedule/standard-date-adapter/es2015/main.js");
            /* harmony import */ var _rschedule_core__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @rschedule/core */ "./node_modules/@rschedule/core/es2015/main.js");
            /* harmony import */ var _rschedule_core_generators__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @rschedule/core/generators */ "./node_modules/@rschedule/core/es2015/generators.js");
            /***/ 
        }),
        /***/ "./packages/loot-core/src/shared/async.ts": 
        /*!************************************************!*\
          !*** ./packages/loot-core/src/shared/async.ts ***!
          \************************************************/
        /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony export */ __webpack_require__.d(__webpack_exports__, {
                /* harmony export */ once: () => ( /* binding */once),
                /* harmony export */ sequential: () => ( /* binding */sequential)
                /* harmony export */ 
            });
            // @ts-strict-ignore
            function sequential(fn) {
                const sequenceState = {
                    running: null,
                    queue: []
                };
                function pump() {
                    const next = sequenceState.queue.shift();
                    if (next !== undefined) {
                        run(next.args, next.resolve, next.reject);
                    }
                    else {
                        sequenceState.running = null;
                    }
                }
                function run(args, resolve, reject) {
                    sequenceState.running = fn.apply(null, args).then((val) => {
                        pump();
                        resolve(val);
                    }, (err) => {
                        pump();
                        reject(err);
                    });
                }
                return (...args) => {
                    if (!sequenceState.running) {
                        return new Promise((resolve, reject) => {
                            return run(args, resolve, reject);
                        });
                    }
                    else {
                        return new Promise((resolve, reject) => {
                            sequenceState.queue.push({
                                resolve,
                                reject,
                                args
                            });
                        });
                    }
                };
            }
            function once(fn) {
                let promise = null;
                return (...args) => {
                    if (!promise) {
                        promise = fn.apply(null, args).finally(() => {
                            promise = null;
                        });
                        return promise;
                    }
                    return promise;
                };
            }
            /***/ 
        }),
        /***/ "./packages/loot-core/src/shared/environment.ts": 
        /*!******************************************************!*\
          !*** ./packages/loot-core/src/shared/environment.ts ***!
          \******************************************************/
        /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony export */ __webpack_require__.d(__webpack_exports__, {
                /* harmony export */ isDevelopmentEnvironment: () => ( /* binding */isDevelopmentEnvironment),
                /* harmony export */ isElectron: () => ( /* binding */isElectron),
                /* harmony export */ isNonProductionEnvironment: () => ( /* binding */isNonProductionEnvironment),
                /* harmony export */ isPreviewEnvironment: () => ( /* binding */isPreviewEnvironment)
                /* harmony export */ 
            });
            /* eslint-disable import/no-unused-modules */ function isPreviewEnvironment() {
                return String(process.env.REACT_APP_NETLIFY) === 'true';
            }
            function isDevelopmentEnvironment() {
                return "development" === 'development';
            }
            function isNonProductionEnvironment() {
                return isPreviewEnvironment() || isDevelopmentEnvironment();
            }
            function isElectron() {
                if (navigator.userAgent.indexOf('Electron') >= 0) {
                    return true;
                }
                return false;
            }
            /***/ 
        }),
        /***/ "./packages/loot-core/src/shared/errors.ts": 
        /*!*************************************************!*\
          !*** ./packages/loot-core/src/shared/errors.ts ***!
          \*************************************************/
        /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony export */ __webpack_require__.d(__webpack_exports__, {
                /* harmony export */ LazyLoadFailedError: () => ( /* binding */LazyLoadFailedError),
                /* harmony export */ getBankSyncError: () => ( /* binding */getBankSyncError),
                /* harmony export */ getCreateKeyError: () => ( /* binding */getCreateKeyError),
                /* harmony export */ getDownloadError: () => ( /* binding */getDownloadError),
                /* harmony export */ getSyncError: () => ( /* binding */getSyncError),
                /* harmony export */ getTestKeyError: () => ( /* binding */getTestKeyError),
                /* harmony export */ getUploadError: () => ( /* binding */getUploadError)
                /* harmony export */ 
            });
            // @ts-strict-ignore
            function getUploadError({ reason, meta }) {
                switch (reason) {
                    case 'unauthorized':
                        return 'You are not logged in.';
                    case 'encrypt-failure':
                        if (meta.isMissingKey) {
                            return 'Encrypting your file failed because you are missing your encryption key. Create your key in the next step.';
                        }
                        return 'Encrypting the file failed. You have the correct key so this is an internal bug. To fix this, generate a new key in the next step.';
                    case 'file-has-reset':
                        // Something really weird happened - during reset a sanity
                        // check on the server failed. The user just needs to
                        // restart the whole process.
                        return 'Something went wrong while resetting your file. Please try again.';
                    case 'file-has-new-key':
                        return 'Unable to encrypt your data because you are missing the key. Create the latest key in the next step.';
                    case 'network':
                        return 'Uploading the file failed. Check your network connection.';
                    default:
                        return `An internal error occurred, sorry! Visit https://actualbudget.org/contact/ for support. (ref: ${reason})`;
                }
            }
            function getDownloadError({ reason, meta, fileName }) {
                switch (reason) {
                    case 'network':
                    case 'download-failure':
                        return 'Downloading the file failed. Check your network connection.';
                    case 'not-zip-file':
                    case 'invalid-zip-file':
                    case 'invalid-meta-file':
                        return 'Downloaded file is invalid, sorry! Visit https://actualbudget.org/contact/ for support.';
                    case 'decrypt-failure':
                        return 'Unable to decrypt file ' + (fileName || '(unknown)') + '. To change your key, first ' + 'download this file with the proper password.';
                    case 'out-of-sync-migrations':
                        return 'This budget cannot be loaded with this version of the app. ' + 'Make sure the app is up-to-date.';
                    default:
                        const info = meta && meta.fileId ? `, fileId: ${meta.fileId}` : '';
                        return 'Something went wrong trying to download that file, sorry! ' + 'Visit https://actualbudget.org/contact/ for support. ' + `(reason: ${reason}${info})`;
                }
            }
            function getCreateKeyError(error) {
                return getUploadError(error);
            }
            function getTestKeyError({ reason }) {
                switch (reason) {
                    case 'network':
                        return 'Unable to connect to the server. We need to access the server to get some information about your keys.';
                    case 'old-key-style':
                        return 'This file is encrypted with an old unsupported key style. Recreate the key ' + 'on a device where the file is available, or use an older version of Actual to download ' + 'it.';
                    case 'decrypt-failure':
                        return 'Unable to decrypt file with this password. Please try again.';
                    default:
                        return 'Something went wrong trying to create a key, sorry! Visit https://actualbudget.org/contact/ for support.';
                }
            }
            function getSyncError(error, id) {
                if (error === 'out-of-sync-migrations' || error === 'out-of-sync-data') {
                    return 'This budget cannot be loaded with this version of the app.';
                }
                else if (error === 'budget-not-found') {
                    return `Budget ${id} not found. Check the id of your budget in the Advanced section of the settings page.`;
                }
                else {
                    return `We had an unknown problem opening ${id}.`;
                }
            }
            function getBankSyncError(error) {
                return error.message || 'We had an unknown problem syncing the account.';
            }
            class LazyLoadFailedError extends Error {
                constructor(name) {
                    super(`Error: failed loading lazy-loaded module ${name}`);
                    this.type = 'app-init-failure';
                    this.meta = {};
                    this.meta = {
                        name
                    };
                }
            }
            /***/ 
        }),
        /***/ "./packages/loot-core/src/shared/months.ts": 
        /*!*************************************************!*\
          !*** ./packages/loot-core/src/shared/months.ts ***!
          \*************************************************/
        /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony export */ __webpack_require__.d(__webpack_exports__, {
                /* harmony export */ _dayRange: () => ( /* binding */_dayRange),
                /* harmony export */ _parse: () => ( /* binding */_parse),
                /* harmony export */ _range: () => ( /* binding */_range),
                /* harmony export */ _weekRange: () => ( /* binding */_weekRange),
                /* harmony export */ _yearRange: () => ( /* binding */_yearRange),
                /* harmony export */ addDays: () => ( /* binding */addDays),
                /* harmony export */ addMonths: () => ( /* binding */addMonths),
                /* harmony export */ addWeeks: () => ( /* binding */addWeeks),
                /* harmony export */ addYears: () => ( /* binding */addYears),
                /* harmony export */ bounds: () => ( /* binding */bounds),
                /* harmony export */ currentDate: () => ( /* binding */currentDate),
                /* harmony export */ currentDay: () => ( /* binding */currentDay),
                /* harmony export */ currentMonth: () => ( /* binding */currentMonth),
                /* harmony export */ currentWeek: () => ( /* binding */currentWeek),
                /* harmony export */ currentYear: () => ( /* binding */currentYear),
                /* harmony export */ dayFromDate: () => ( /* binding */dayFromDate),
                /* harmony export */ dayRange: () => ( /* binding */dayRange),
                /* harmony export */ dayRangeInclusive: () => ( /* binding */dayRangeInclusive),
                /* harmony export */ differenceInCalendarDays: () => ( /* binding */differenceInCalendarDays),
                /* harmony export */ differenceInCalendarMonths: () => ( /* binding */differenceInCalendarMonths),
                /* harmony export */ format: () => ( /* binding */format),
                /* harmony export */ getDateFormatRegex: () => ( /* binding */getDateFormatRegex),
                /* harmony export */ getDay: () => ( /* binding */getDay),
                /* harmony export */ getDayMonthFormat: () => ( /* binding */getDayMonthFormat),
                /* harmony export */ getDayMonthRegex: () => ( /* binding */getDayMonthRegex),
                /* harmony export */ getMonth: () => ( /* binding */getMonth),
                /* harmony export */ getMonthEnd: () => ( /* binding */getMonthEnd),
                /* harmony export */ getMonthFromIndex: () => ( /* binding */getMonthFromIndex),
                /* harmony export */ getMonthIndex: () => ( /* binding */getMonthIndex),
                /* harmony export */ getMonthYearFormat: () => ( /* binding */getMonthYearFormat),
                /* harmony export */ getMonthYearRegex: () => ( /* binding */getMonthYearRegex),
                /* harmony export */ getShortYearFormat: () => ( /* binding */getShortYearFormat),
                /* harmony export */ getShortYearRegex: () => ( /* binding */getShortYearRegex),
                /* harmony export */ getWeekEnd: () => ( /* binding */getWeekEnd),
                /* harmony export */ getYear: () => ( /* binding */getYear),
                /* harmony export */ getYearEnd: () => ( /* binding */getYearEnd),
                /* harmony export */ getYearStart: () => ( /* binding */getYearStart),
                /* harmony export */ isAfter: () => ( /* binding */isAfter),
                /* harmony export */ isBefore: () => ( /* binding */isBefore),
                /* harmony export */ monthFromDate: () => ( /* binding */monthFromDate),
                /* harmony export */ nameForMonth: () => ( /* binding */nameForMonth),
                /* harmony export */ nextMonth: () => ( /* binding */nextMonth),
                /* harmony export */ parseDate: () => ( /* binding */parseDate),
                /* harmony export */ prevMonth: () => ( /* binding */prevMonth),
                /* harmony export */ prevYear: () => ( /* binding */prevYear),
                /* harmony export */ range: () => ( /* binding */range),
                /* harmony export */ rangeInclusive: () => ( /* binding */rangeInclusive),
                /* harmony export */ sheetForMonth: () => ( /* binding */sheetForMonth),
                /* harmony export */ subDays: () => ( /* binding */subDays),
                /* harmony export */ subMonths: () => ( /* binding */subMonths),
                /* harmony export */ subWeeks: () => ( /* binding */subWeeks),
                /* harmony export */ subYears: () => ( /* binding */subYears),
                /* harmony export */ weekFromDate: () => ( /* binding */weekFromDate),
                /* harmony export */ weekRangeInclusive: () => ( /* binding */weekRangeInclusive),
                /* harmony export */ yearFromDate: () => ( /* binding */yearFromDate),
                /* harmony export */ yearRangeInclusive: () => ( /* binding */yearRangeInclusive)
                /* harmony export */ 
            });
            /* harmony import */ var date_fns__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! date-fns */ "./node_modules/date-fns/esm/format/index.js");
            /* harmony import */ var date_fns__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! date-fns */ "./node_modules/date-fns/esm/startOfWeek/index.js");
            /* harmony import */ var date_fns__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! date-fns */ "./node_modules/date-fns/esm/parse/index.js");
            /* harmony import */ var date_fns__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! date-fns */ "./node_modules/date-fns/esm/addMonths/index.js");
            /* harmony import */ var date_fns__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! date-fns */ "./node_modules/date-fns/esm/subMonths/index.js");
            /* harmony import */ var date_fns__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! date-fns */ "./node_modules/date-fns/esm/addYears/index.js");
            /* harmony import */ var date_fns__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! date-fns */ "./node_modules/date-fns/esm/addWeeks/index.js");
            /* harmony import */ var date_fns__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! date-fns */ "./node_modules/date-fns/esm/differenceInCalendarMonths/index.js");
            /* harmony import */ var date_fns__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! date-fns */ "./node_modules/date-fns/esm/differenceInCalendarDays/index.js");
            /* harmony import */ var date_fns__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! date-fns */ "./node_modules/date-fns/esm/subWeeks/index.js");
            /* harmony import */ var date_fns__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! date-fns */ "./node_modules/date-fns/esm/subYears/index.js");
            /* harmony import */ var date_fns__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! date-fns */ "./node_modules/date-fns/esm/addDays/index.js");
            /* harmony import */ var date_fns__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! date-fns */ "./node_modules/date-fns/esm/subDays/index.js");
            /* harmony import */ var date_fns__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! date-fns */ "./node_modules/date-fns/esm/isBefore/index.js");
            /* harmony import */ var date_fns__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! date-fns */ "./node_modules/date-fns/esm/isAfter/index.js");
            /* harmony import */ var date_fns__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! date-fns */ "./node_modules/date-fns/esm/startOfMonth/index.js");
            /* harmony import */ var date_fns__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! date-fns */ "./node_modules/date-fns/esm/endOfMonth/index.js");
            /* harmony import */ var date_fns__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! date-fns */ "./node_modules/date-fns/esm/endOfWeek/index.js");
            /* harmony import */ var memoize_one__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! memoize-one */ "./node_modules/memoize-one/dist/memoize-one.esm.js");
            /* harmony import */ var _client_platform__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../client/platform */ "./packages/loot-core/src/client/platform.electron.ts");
            // @ts-strict-ignore
            function _parse(value) {
                if (typeof value === 'string') {
                    // Dates are hard. We just want to deal with months in the format
                    // 2020-01 and days in the format 2020-01-01, but life is never
                    // simple. We want to rely on native dates for date logic because
                    // days are complicated (leap years, etc). But relying on native
                    // dates mean we're exposed to craziness.
                    //
                    // The biggest problem is that JS dates work with local time by
                    // default. We could try to only work with UTC, but there's not an
                    // easy way to make `format` avoid local time, and not sure if we
                    // want that anyway (`currentMonth` should surely print the local
                    // time). We need to embrace local time, and as long as inputs to
                    // date logic and outputs from format are local time, it should
                    // work.
                    //
                    // To make sure we're in local time, always give Date integer
                    // values. If you pass in a string to parse, different string
                    // formats produce different results.
                    //
                    // A big problem is daylight savings, however. Usually, when
                    // giving the time to the Date constructor, you get back a date
                    // specifically for that time in your local timezone. However, if
                    // daylight savings occurs on that exact time, you will get back
                    // something different:
                    //
                    // This is fine:
                    // > new Date(2017, 2, 12, 1).toString()
                    // > 'Sun Mar 12 2017 01:00:00 GMT-0500 (Eastern Standard Time)'
                    //
                    // But wait, we got back a different time (3AM instead of 2AM):
                    // > new Date(2017, 2, 12, 2).toString()
                    // > 'Sun Mar 12 2017 03:00:00 GMT-0400 (Eastern Daylight Time)'
                    //
                    // The time is "correctly" adjusted via DST, but we _really_
                    // wanted 2AM. The problem is that time simply doesn't exist.
                    //
                    // Why is this a problem? Well, consider a case where the DST
                    // shift happens *at midnight* and it goes back an hour. You think
                    // you have a date object for the next day, but when formatted it
                    // actually shows the previous day. A more likely scenario: buggy
                    // timezone data makes JS dates do this shift when it shouldn't,
                    // so using midnight at the time for date logic gives back the
                    // last day. See the time range of Sep 30 15:00 - Oct 1 1:00 for
                    // the AEST timezone when nodejs-mobile incorrectly gives you back
                    // a time an hour *before* you specified. Since this happens on
                    // Oct 1, doing `addMonths(September, 1)` still gives you back
                    // September. Issue here:
                    // https://github.com/JaneaSystems/nodejs-mobile/issues/251
                    //
                    // The fix is simple once you understand this. Always use the 12th
                    // hour of the day. That's it. There is no DST that shifts more
                    // than 12 hours (god let's hope not) so no matter how far DST has
                    // shifted backwards or forwards, doing date logic will stay
                    // within the day we want.
                    const [year, month, day] = value.split('-');
                    if (day != null) {
                        return new Date(parseInt(year), parseInt(month) - 1, parseInt(day), 12);
                    }
                    else if (month != null) {
                        return new Date(parseInt(year), parseInt(month) - 1, 1, 12);
                    }
                    else {
                        return new Date(parseInt(year), 0, 1, 12);
                    }
                }
                if (typeof value === 'number') {
                    return new Date(value);
                }
                return value;
            }
            const parseDate = _parse;
            function yearFromDate(date) {
                return date_fns__WEBPACK_IMPORTED_MODULE_1__["default"](_parse(date), 'yyyy');
            }
            function monthFromDate(date) {
                return date_fns__WEBPACK_IMPORTED_MODULE_1__["default"](_parse(date), 'yyyy-MM');
            }
            function weekFromDate(date, firstDayOfWeekIdx) {
                const converted = parseInt(firstDayOfWeekIdx || '0');
                return date_fns__WEBPACK_IMPORTED_MODULE_1__["default"](_parse(date_fns__WEBPACK_IMPORTED_MODULE_2__["default"](_parse(date), {
                    weekStartsOn: converted
                })), 'yyyy-MM-dd');
            }
            function dayFromDate(date) {
                return date_fns__WEBPACK_IMPORTED_MODULE_1__["default"](_parse(date), 'yyyy-MM-dd');
            }
            function currentMonth() {
                if (global.IS_TESTING || _client_platform__WEBPACK_IMPORTED_MODULE_0__.isPlaywright) {
                    return global.currentMonth || '2017-01';
                }
                else {
                    return date_fns__WEBPACK_IMPORTED_MODULE_1__["default"](new Date(), 'yyyy-MM');
                }
            }
            function currentWeek(firstDayOfWeekIdx) {
                if (global.IS_TESTING || _client_platform__WEBPACK_IMPORTED_MODULE_0__.isPlaywright) {
                    return global.currentWeek || '2017-01-01';
                }
                else {
                    const converted = parseInt(firstDayOfWeekIdx || '0');
                    return date_fns__WEBPACK_IMPORTED_MODULE_1__["default"](_parse(date_fns__WEBPACK_IMPORTED_MODULE_2__["default"](new Date(), {
                        weekStartsOn: converted
                    })), 'yyyy-MM-dd');
                }
            }
            function currentYear() {
                if (global.IS_TESTING || _client_platform__WEBPACK_IMPORTED_MODULE_0__.isPlaywright) {
                    return global.currentMonth || '2017';
                }
                else {
                    return date_fns__WEBPACK_IMPORTED_MODULE_1__["default"](new Date(), 'yyyy');
                }
            }
            function currentDate() {
                if (global.IS_TESTING || _client_platform__WEBPACK_IMPORTED_MODULE_0__.isPlaywright) {
                    return date_fns__WEBPACK_IMPORTED_MODULE_3__["default"](currentDay(), 'yyyy-MM-dd', new Date());
                }
                return new Date();
            }
            function currentDay() {
                if (global.IS_TESTING || _client_platform__WEBPACK_IMPORTED_MODULE_0__.isPlaywright) {
                    return '2017-01-01';
                }
                else {
                    return date_fns__WEBPACK_IMPORTED_MODULE_1__["default"](new Date(), 'yyyy-MM-dd');
                }
            }
            function nextMonth(month) {
                return date_fns__WEBPACK_IMPORTED_MODULE_1__["default"](date_fns__WEBPACK_IMPORTED_MODULE_4__["default"](_parse(month), 1), 'yyyy-MM');
            }
            function prevYear(month) {
                return date_fns__WEBPACK_IMPORTED_MODULE_1__["default"](date_fns__WEBPACK_IMPORTED_MODULE_5__["default"](_parse(month), 12), 'yyyy-MM');
            }
            function prevMonth(month) {
                return date_fns__WEBPACK_IMPORTED_MODULE_1__["default"](date_fns__WEBPACK_IMPORTED_MODULE_5__["default"](_parse(month), 1), 'yyyy-MM');
            }
            function addYears(year, n) {
                return date_fns__WEBPACK_IMPORTED_MODULE_1__["default"](date_fns__WEBPACK_IMPORTED_MODULE_6__["default"](_parse(year), n), 'yyyy');
            }
            function addMonths(month, n) {
                return date_fns__WEBPACK_IMPORTED_MODULE_1__["default"](date_fns__WEBPACK_IMPORTED_MODULE_4__["default"](_parse(month), n), 'yyyy-MM');
            }
            function addWeeks(date, n) {
                return date_fns__WEBPACK_IMPORTED_MODULE_1__["default"](date_fns__WEBPACK_IMPORTED_MODULE_7__["default"](_parse(date), n), 'yyyy-MM-dd');
            }
            function differenceInCalendarMonths(month1, month2) {
                return date_fns__WEBPACK_IMPORTED_MODULE_8__["default"](_parse(month1), _parse(month2));
            }
            function differenceInCalendarDays(month1, month2) {
                return date_fns__WEBPACK_IMPORTED_MODULE_9__["default"](_parse(month1), _parse(month2));
            }
            function subMonths(month, n) {
                return date_fns__WEBPACK_IMPORTED_MODULE_1__["default"](date_fns__WEBPACK_IMPORTED_MODULE_5__["default"](_parse(month), n), 'yyyy-MM');
            }
            function subWeeks(date, n) {
                return date_fns__WEBPACK_IMPORTED_MODULE_1__["default"](date_fns__WEBPACK_IMPORTED_MODULE_10__["default"](_parse(date), n), 'yyyy-MM-dd');
            }
            function subYears(year, n) {
                return date_fns__WEBPACK_IMPORTED_MODULE_1__["default"](date_fns__WEBPACK_IMPORTED_MODULE_11__["default"](_parse(year), n), 'yyyy');
            }
            function addDays(day, n) {
                return date_fns__WEBPACK_IMPORTED_MODULE_1__["default"](date_fns__WEBPACK_IMPORTED_MODULE_12__["default"](_parse(day), n), 'yyyy-MM-dd');
            }
            function subDays(day, n) {
                return date_fns__WEBPACK_IMPORTED_MODULE_1__["default"](date_fns__WEBPACK_IMPORTED_MODULE_13__["default"](_parse(day), n), 'yyyy-MM-dd');
            }
            function isBefore(month1, month2) {
                return date_fns__WEBPACK_IMPORTED_MODULE_14__["default"](_parse(month1), _parse(month2));
            }
            function isAfter(month1, month2) {
                return date_fns__WEBPACK_IMPORTED_MODULE_15__["default"](_parse(month1), _parse(month2));
            }
            // TODO: This doesn't really fit in this module anymore, should
            // probably live elsewhere
            function bounds(month) {
                return {
                    start: parseInt(date_fns__WEBPACK_IMPORTED_MODULE_1__["default"](date_fns__WEBPACK_IMPORTED_MODULE_16__["default"](_parse(month)), 'yyyyMMdd')),
                    end: parseInt(date_fns__WEBPACK_IMPORTED_MODULE_1__["default"](date_fns__WEBPACK_IMPORTED_MODULE_17__["default"](_parse(month)), 'yyyyMMdd'))
                };
            }
            function _yearRange(start, end, inclusive = false) {
                const years = [];
                let year = yearFromDate(start);
                const endYear = yearFromDate(end);
                while (date_fns__WEBPACK_IMPORTED_MODULE_14__["default"](_parse(year), _parse(endYear))) {
                    years.push(year);
                    year = addYears(year, 1);
                }
                if (inclusive) {
                    years.push(year);
                }
                return years;
            }
            function yearRangeInclusive(start, end) {
                return _yearRange(start, end, true);
            }
            function _weekRange(start, end, inclusive = false, firstDayOfWeekIdx) {
                const weeks = [];
                let week = weekFromDate(start, firstDayOfWeekIdx);
                const endWeek = weekFromDate(end, firstDayOfWeekIdx);
                while (date_fns__WEBPACK_IMPORTED_MODULE_14__["default"](_parse(week), _parse(endWeek))) {
                    weeks.push(week);
                    week = addWeeks(week, 1);
                }
                if (inclusive) {
                    weeks.push(week);
                }
                return weeks;
            }
            function weekRangeInclusive(start, end, firstDayOfWeekIdx) {
                return _weekRange(start, end, true, firstDayOfWeekIdx);
            }
            function _range(start, end, inclusive = false) {
                const months = [];
                let month = monthFromDate(start);
                const endMonth = monthFromDate(end);
                while (date_fns__WEBPACK_IMPORTED_MODULE_14__["default"](_parse(month), _parse(endMonth))) {
                    months.push(month);
                    month = addMonths(month, 1);
                }
                if (inclusive) {
                    months.push(month);
                }
                return months;
            }
            function range(start, end) {
                return _range(start, end);
            }
            function rangeInclusive(start, end) {
                return _range(start, end, true);
            }
            function _dayRange(start, end, inclusive = false) {
                const days = [];
                let day = start;
                while (date_fns__WEBPACK_IMPORTED_MODULE_14__["default"](_parse(day), _parse(end))) {
                    days.push(dayFromDate(day));
                    day = addDays(day, 1);
                }
                if (inclusive) {
                    days.push(dayFromDate(day));
                }
                return days;
            }
            function dayRange(start, end) {
                return _dayRange(start, end);
            }
            function dayRangeInclusive(start, end) {
                return _dayRange(start, end, true);
            }
            function getMonthFromIndex(year, monthIndex) {
                const formatMonth = `${monthIndex + 1}`.padStart(2, '0');
                return `${year}-${formatMonth}`;
            }
            function getMonthIndex(month) {
                return parseInt(month.slice(5, 7)) - 1;
            }
            function getYear(month) {
                return month.slice(0, 4);
            }
            function getMonth(day) {
                return day.slice(0, 7);
            }
            function getDay(day) {
                return Number(date_fns__WEBPACK_IMPORTED_MODULE_1__["default"](_parse(day), 'dd'));
            }
            function getMonthEnd(day) {
                return subDays(nextMonth(day.slice(0, 7)) + '-01', 1);
            }
            function getWeekEnd(date, firstDayOfWeekIdx) {
                const converted = parseInt(firstDayOfWeekIdx || '0');
                return date_fns__WEBPACK_IMPORTED_MODULE_1__["default"](_parse(date_fns__WEBPACK_IMPORTED_MODULE_18__["default"](_parse(date), {
                    weekStartsOn: converted
                })), 'yyyy-MM-dd');
            }
            function getYearStart(month) {
                return getYear(month) + '-01';
            }
            function getYearEnd(month) {
                return getYear(month) + '-12';
            }
            function sheetForMonth(month) {
                return 'budget' + month.replace('-', '');
            }
            function nameForMonth(month) {
                return date_fns__WEBPACK_IMPORTED_MODULE_1__["default"](_parse(month), 'MMMM yy');
            }
            function format(month, str) {
                return date_fns__WEBPACK_IMPORTED_MODULE_1__["default"](_parse(month), str);
            }
            const getDateFormatRegex = (0, memoize_one__WEBPACK_IMPORTED_MODULE_19__["default"])((format) => {
                return new RegExp(format.replace(/d+/g, '\\d{1,2}').replace(/M+/g, '\\d{1,2}').replace(/y+/g, '\\d{4}'));
            });
            const getDayMonthFormat = (0, memoize_one__WEBPACK_IMPORTED_MODULE_19__["default"])((format) => {
                return format.replace(/y+/g, '').replace(/[^\w]$/, '').replace(/^[^\w]/, '');
            });
            const getDayMonthRegex = (0, memoize_one__WEBPACK_IMPORTED_MODULE_19__["default"])((format) => {
                const regex = format.replace(/y+/g, '').replace(/[^\w]$/, '').replace(/^[^\w]/, '').replace(/d+/g, '\\d{1,2}').replace(/M+/g, '\\d{1,2}');
                return new RegExp('^' + regex + '$');
            });
            const getMonthYearFormat = (0, memoize_one__WEBPACK_IMPORTED_MODULE_19__["default"])((format) => {
                return format.replace(/d+/g, '').replace(/[^\w]$/, '').replace(/^[^\w]/, '').replace(/\/\//, '/').replace(/\.\./, '.').replace(/--/, '-');
            });
            const getMonthYearRegex = (0, memoize_one__WEBPACK_IMPORTED_MODULE_19__["default"])((format) => {
                const regex = format.replace(/d+/g, '').replace(/[^\w]$/, '').replace(/^[^\w]/, '').replace(/\/\//, '/').replace(/M+/g, '\\d{1,2}').replace(/y+/g, '\\d{2,4}');
                return new RegExp('^' + regex + '$');
            });
            const getShortYearFormat = (0, memoize_one__WEBPACK_IMPORTED_MODULE_19__["default"])((format) => {
                return format.replace(/y+/g, 'yy');
            });
            const getShortYearRegex = (0, memoize_one__WEBPACK_IMPORTED_MODULE_19__["default"])((format) => {
                const regex = format.replace(/[^\w]$/, '').replace(/^[^\w]/, '').replace(/d+/g, '\\d{1,2}').replace(/M+/g, '\\d{1,2}').replace(/y+/g, '\\d{2}');
                return new RegExp('^' + regex + '$');
            });
            /***/ 
        }),
        /***/ "./packages/loot-core/src/shared/normalisation.ts": 
        /*!********************************************************!*\
          !*** ./packages/loot-core/src/shared/normalisation.ts ***!
          \********************************************************/
        /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony export */ __webpack_require__.d(__webpack_exports__, {
                /* harmony export */ getNormalisedString: () => ( /* binding */getNormalisedString)
                /* harmony export */ 
            });
            function getNormalisedString(value) {
                return value.toLowerCase().normalize('NFD').replace(/\p{Diacritic}/gu, '');
            }
            /***/ 
        }),
        /***/ "./packages/loot-core/src/shared/query.ts": 
        /*!************************************************!*\
          !*** ./packages/loot-core/src/shared/query.ts ***!
          \************************************************/
        /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony export */ __webpack_require__.d(__webpack_exports__, {
                /* harmony export */ Query: () => ( /* binding */Query),
                /* harmony export */ getPrimaryOrderBy: () => ( /* binding */getPrimaryOrderBy),
                /* harmony export */ q: () => ( /* binding */q)
                /* harmony export */ 
            });
            // @ts-strict-ignore
            class Query {
                constructor(state) {
                    this.state = {
                        filterExpressions: state.filterExpressions || [],
                        selectExpressions: state.selectExpressions || [],
                        groupExpressions: state.groupExpressions || [],
                        orderExpressions: state.orderExpressions || [],
                        calculation: false,
                        rawMode: false,
                        withDead: false,
                        validateRefs: true,
                        limit: null,
                        offset: null,
                        ...state
                    };
                }
                filter(expr) {
                    return new Query({
                        ...this.state,
                        filterExpressions: [
                            ...this.state.filterExpressions,
                            expr
                        ]
                    });
                }
                unfilter(exprs) {
                    const exprSet = new Set(exprs);
                    return new Query({
                        ...this.state,
                        filterExpressions: this.state.filterExpressions.filter((expr) => !exprSet.has(Object.keys(expr)[0]))
                    });
                }
                select(exprs = []) {
                    if (!Array.isArray(exprs)) {
                        exprs = [
                            exprs
                        ];
                    }
                    const query = new Query({
                        ...this.state,
                        selectExpressions: exprs
                    });
                    query.state.calculation = false;
                    return query;
                }
                calculate(expr) {
                    const query = this.select({
                        result: expr
                    });
                    query.state.calculation = true;
                    return query;
                }
                groupBy(exprs) {
                    if (!Array.isArray(exprs)) {
                        exprs = [
                            exprs
                        ];
                    }
                    return new Query({
                        ...this.state,
                        groupExpressions: [
                            ...this.state.groupExpressions,
                            ...exprs
                        ]
                    });
                }
                orderBy(exprs) {
                    if (!Array.isArray(exprs)) {
                        exprs = [
                            exprs
                        ];
                    }
                    return new Query({
                        ...this.state,
                        orderExpressions: [
                            ...this.state.orderExpressions,
                            ...exprs
                        ]
                    });
                }
                limit(num) {
                    return new Query({
                        ...this.state,
                        limit: num
                    });
                }
                offset(num) {
                    return new Query({
                        ...this.state,
                        offset: num
                    });
                }
                raw() {
                    return new Query({
                        ...this.state,
                        rawMode: true
                    });
                }
                withDead() {
                    return new Query({
                        ...this.state,
                        withDead: true
                    });
                }
                withoutValidatedRefs() {
                    return new Query({
                        ...this.state,
                        validateRefs: false
                    });
                }
                options(opts) {
                    return new Query({
                        ...this.state,
                        tableOptions: opts
                    });
                }
                serialize() {
                    return this.state;
                }
            }
            function getPrimaryOrderBy(query, defaultOrderBy) {
                const orderExprs = query.serialize().orderExpressions;
                if (orderExprs.length === 0) {
                    if (defaultOrderBy) {
                        return {
                            order: 'asc',
                            ...defaultOrderBy
                        };
                    }
                    return null;
                }
                const firstOrder = orderExprs[0];
                if (typeof firstOrder === 'string') {
                    return {
                        field: firstOrder,
                        order: 'asc'
                    };
                }
                // Handle this form: { field: 'desc' }
                const [field] = Object.keys(firstOrder);
                return {
                    field,
                    order: firstOrder[field]
                };
            }
            function q(table) {
                return new Query({
                    table
                });
            }
            /***/ 
        }),
        /***/ "./packages/loot-core/src/shared/rules.ts": 
        /*!************************************************!*\
          !*** ./packages/loot-core/src/shared/rules.ts ***!
          \************************************************/
        /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony export */ __webpack_require__.d(__webpack_exports__, {
                /* harmony export */ ALLOCATION_METHODS: () => ( /* binding */ALLOCATION_METHODS),
                /* harmony export */ FIELD_TYPES: () => ( /* binding */FIELD_TYPES),
                /* harmony export */ TYPE_INFO: () => ( /* binding */TYPE_INFO),
                /* harmony export */ deserializeField: () => ( /* binding */deserializeField),
                /* harmony export */ friendlyOp: () => ( /* binding */friendlyOp),
                /* harmony export */ getApproxNumberThreshold: () => ( /* binding */getApproxNumberThreshold),
                /* harmony export */ getFieldError: () => ( /* binding */getFieldError),
                /* harmony export */ makeValue: () => ( /* binding */makeValue),
                /* harmony export */ mapField: () => ( /* binding */mapField),
                /* harmony export */ parse: () => ( /* binding */parse),
                /* harmony export */ sortNumbers: () => ( /* binding */sortNumbers),
                /* harmony export */ unparse: () => ( /* binding */unparse)
                /* harmony export */ 
            });
            /* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./util */ "./packages/loot-core/src/shared/util.ts");
            // @ts-strict-ignore
            // For now, this info is duplicated from the backend. Figure out how
            // to share it later.
            const TYPE_INFO = {
                date: {
                    ops: [
                        'is',
                        'isapprox',
                        'gt',
                        'gte',
                        'lt',
                        'lte'
                    ],
                    nullable: false
                },
                id: {
                    ops: [
                        'is',
                        'contains',
                        'matches',
                        'oneOf',
                        'isNot',
                        'doesNotContain',
                        'notOneOf'
                    ],
                    nullable: true
                },
                saved: {
                    ops: [],
                    nullable: false
                },
                string: {
                    ops: [
                        'is',
                        'contains',
                        'matches',
                        'oneOf',
                        'isNot',
                        'doesNotContain',
                        'notOneOf'
                    ],
                    nullable: true
                },
                number: {
                    ops: [
                        'is',
                        'isapprox',
                        'isbetween',
                        'gt',
                        'gte',
                        'lt',
                        'lte'
                    ],
                    nullable: false
                },
                boolean: {
                    ops: [
                        'is'
                    ],
                    nullable: false
                }
            };
            const FIELD_TYPES = new Map(Object.entries({
                imported_payee: 'string',
                payee: 'id',
                date: 'date',
                notes: 'string',
                amount: 'number',
                amountInflow: 'number',
                amountOutfow: 'number',
                category: 'id',
                account: 'id',
                cleared: 'boolean',
                reconciled: 'boolean',
                saved: 'saved'
            }));
            const ALLOCATION_METHODS = {
                'fixed-amount': 'a fixed amount',
                'fixed-percent': 'a fixed percent of the remainder',
                remainder: 'an equal portion of the remainder'
            };
            function mapField(field, opts) {
                opts = opts || {};
                switch (field) {
                    case 'imported_payee':
                        return 'imported payee';
                    case 'amount':
                        if (opts.inflow) {
                            return 'amount (inflow)';
                        }
                        else if (opts.outflow) {
                            return 'amount (outflow)';
                        }
                        return 'amount';
                    case 'amount-inflow':
                        return 'amount (inflow)';
                    case 'amount-outflow':
                        return 'amount (outflow)';
                    default:
                        return field;
                }
            }
            function friendlyOp(op, type) {
                switch (op) {
                    case 'oneOf':
                        return 'one of';
                    case 'notOneOf':
                        return 'not one of';
                    case 'is':
                        return 'is';
                    case 'isNot':
                        return 'is not';
                    case 'isapprox':
                        return 'is approx';
                    case 'isbetween':
                        return 'is between';
                    case 'contains':
                        return 'contains';
                    case 'matches':
                        return 'matches';
                    case 'doesNotContain':
                        return 'does not contain';
                    case 'gt':
                        if (type === 'date') {
                            return 'is after';
                        }
                        return 'is greater than';
                    case 'gte':
                        if (type === 'date') {
                            return 'is after or equals';
                        }
                        return 'is greater than or equals';
                    case 'lt':
                        if (type === 'date') {
                            return 'is before';
                        }
                        return 'is less than';
                    case 'lte':
                        if (type === 'date') {
                            return 'is before or equals';
                        }
                        return 'is less than or equals';
                    case 'true':
                        return 'is true';
                    case 'false':
                        return 'is false';
                    case 'set':
                        return 'set';
                    case 'set-split-amount':
                        return 'allocate';
                    case 'link-schedule':
                        return 'link schedule';
                    case 'and':
                        return 'and';
                    case 'or':
                        return 'or';
                    default:
                        return '';
                }
            }
            function deserializeField(field) {
                if (field === 'amount-inflow') {
                    return {
                        field: 'amount',
                        options: {
                            inflow: true
                        }
                    };
                }
                else if (field === 'amount-outflow') {
                    return {
                        field: 'amount',
                        options: {
                            outflow: true
                        }
                    };
                }
                else {
                    return {
                        field
                    };
                }
            }
            function getFieldError(type) {
                switch (type) {
                    case 'date-format':
                        return 'Invalid date format';
                    case 'no-null':
                    case 'no-empty-array':
                    case 'no-empty-string':
                        return 'Value cannot be empty';
                    case 'not-number':
                        return 'Value must be a number';
                    case 'invalid-field':
                        return 'Please choose a valid field for this type of rule';
                    default:
                        return 'Internal error, sorry! Please get in touch https://actualbudget.org/contact/ for support';
                }
            }
            function sortNumbers(num1, num2) {
                if (num1 < num2) {
                    return [
                        num1,
                        num2
                    ];
                }
                return [
                    num2,
                    num1
                ];
            }
            function parse(item) {
                if (item.op === 'set-split-amount') {
                    if (item.options.method === 'fixed-amount') {
                        return {
                            ...item,
                            value: item.value && (0, _util__WEBPACK_IMPORTED_MODULE_0__.integerToAmount)(item.value)
                        };
                    }
                    return item;
                }
                switch (item.type) {
                    case 'number':
                        {
                            let parsed = item.value;
                            if (item.field === 'amount' && item.op !== 'isbetween' && parsed != null) {
                                parsed = (0, _util__WEBPACK_IMPORTED_MODULE_0__.integerToAmount)(parsed);
                            }
                            return {
                                ...item,
                                value: parsed
                            };
                        }
                    case 'string':
                        {
                            const parsed = item.value == null ? '' : item.value;
                            return {
                                ...item,
                                value: parsed
                            };
                        }
                    case 'boolean':
                        {
                            const parsed = item.value;
                            return {
                                ...item,
                                value: parsed
                            };
                        }
                    default:
                }
                return {
                    ...item,
                    error: null
                };
            }
            function unparse({ error, inputKey, ...item }) {
                if (item.op === 'set-split-amount') {
                    if (item.options.method === 'fixed-amount') {
                        return {
                            ...item,
                            value: item.value && (0, _util__WEBPACK_IMPORTED_MODULE_0__.amountToInteger)(item.value)
                        };
                    }
                    if (item.options.method === 'fixed-percent') {
                        return {
                            ...item,
                            value: item.value && parseFloat(item.value)
                        };
                    }
                    return item;
                }
                switch (item.type) {
                    case 'number':
                        {
                            let unparsed = item.value;
                            if (item.field === 'amount' && item.op !== 'isbetween') {
                                unparsed = (0, _util__WEBPACK_IMPORTED_MODULE_0__.amountToInteger)(unparsed);
                            }
                            return {
                                ...item,
                                value: unparsed
                            };
                        }
                    case 'string':
                        {
                            const unparsed = item.value == null ? '' : item.value;
                            return {
                                ...item,
                                value: unparsed
                            };
                        }
                    case 'boolean':
                        {
                            const unparsed = item.value == null ? false : item.value;
                            return {
                                ...item,
                                value: unparsed
                            };
                        }
                    default:
                }
                return item;
            }
            function makeValue(value, cond) {
                switch (cond.type) {
                    case 'number':
                        {
                            if (cond.op !== 'isbetween') {
                                return {
                                    ...cond,
                                    error: null,
                                    value: value ? (0, _util__WEBPACK_IMPORTED_MODULE_0__.currencyToAmount)(String(value)) || 0 : 0
                                };
                            }
                            break;
                        }
                    default:
                }
                return {
                    ...cond,
                    error: null,
                    value
                };
            }
            function getApproxNumberThreshold(number) {
                return Math.round(Math.abs(number) * 0.075);
            }
            /***/ 
        }),
        /***/ "./packages/loot-core/src/shared/schedules.ts": 
        /*!****************************************************!*\
          !*** ./packages/loot-core/src/shared/schedules.ts ***!
          \****************************************************/
        /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony export */ __webpack_require__.d(__webpack_exports__, {
                /* harmony export */ describeSchedule: () => ( /* binding */describeSchedule),
                /* harmony export */ extractScheduleConds: () => ( /* binding */extractScheduleConds),
                /* harmony export */ getHasTransactionsQuery: () => ( /* binding */getHasTransactionsQuery),
                /* harmony export */ getRecurringDescription: () => ( /* binding */getRecurringDescription),
                /* harmony export */ getScheduledAmount: () => ( /* binding */getScheduledAmount),
                /* harmony export */ getStatus: () => ( /* binding */getStatus),
                /* harmony export */ recurConfigToRSchedule: () => ( /* binding */recurConfigToRSchedule)
                /* harmony export */ 
            });
            /* harmony import */ var _months__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./months */ "./packages/loot-core/src/shared/months.ts");
            /* harmony import */ var _query__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./query */ "./packages/loot-core/src/shared/query.ts");
            // @ts-strict-ignore
            function getStatus(nextDate, completed, hasTrans) {
                const today = _months__WEBPACK_IMPORTED_MODULE_0__.currentDay();
                if (completed) {
                    return 'completed';
                }
                else if (hasTrans) {
                    return 'paid';
                }
                else if (nextDate === today) {
                    return 'due';
                }
                else if (nextDate > today && nextDate <= _months__WEBPACK_IMPORTED_MODULE_0__.addDays(today, 7)) {
                    return 'upcoming';
                }
                else if (nextDate < today) {
                    return 'missed';
                }
                else {
                    return 'scheduled';
                }
            }
            function getHasTransactionsQuery(schedules) {
                const filters = schedules.map((schedule) => {
                    const dateCond = schedule._conditions.find((c) => c.field === 'date');
                    return {
                        $and: {
                            schedule: schedule.id,
                            date: {
                                $gte: dateCond && dateCond.op === 'is' ? schedule.next_date : _months__WEBPACK_IMPORTED_MODULE_0__.subDays(schedule.next_date, 2)
                            }
                        }
                    };
                });
                return (0, _query__WEBPACK_IMPORTED_MODULE_1__.q)('transactions').options({
                    splits: 'all'
                }).filter({
                    $or: filters
                }).orderBy({
                    date: 'desc'
                }).select([
                    'schedule',
                    'date'
                ]);
            }
            function makeNumberSuffix(num) {
                // Slight abuse of date-fns to turn a number like "1" into the full
                // form "1st" but formatting a date with that number
                return _months__WEBPACK_IMPORTED_MODULE_0__.format(new Date(2020, 0, num, 12), 'do');
            }
            function prettyDayName(day) {
                const days = {
                    SU: 'Sunday',
                    MO: 'Monday',
                    TU: 'Tuesday',
                    WE: 'Wednesday',
                    TH: 'Thursday',
                    FR: 'Friday',
                    SA: 'Saturday'
                };
                return days[day];
            }
            function getRecurringDescription(config, dateFormat) {
                const interval = config.interval || 1;
                let endModeSuffix = '';
                switch (config.endMode) {
                    case 'after_n_occurrences':
                        if (config.endOccurrences === 1) {
                            endModeSuffix = `, once`;
                        }
                        else {
                            endModeSuffix = `, ${config.endOccurrences} times`;
                        }
                        break;
                    case 'on_date':
                        endModeSuffix = `, until ${_months__WEBPACK_IMPORTED_MODULE_0__.format(config.endDate, dateFormat)}`;
                        break;
                    default:
                }
                const weekendSolveSuffix = config.skipWeekend ? ` (${config.weekendSolveMode} weekend) ` : '';
                const suffix = endModeSuffix + weekendSolveSuffix;
                switch (config.frequency) {
                    case 'daily':
                        {
                            let desc = 'Every ';
                            desc += interval !== 1 ? `${interval} days` : 'day';
                            return desc + suffix;
                        }
                    case 'weekly':
                        {
                            let desc = 'Every ';
                            desc += interval !== 1 ? `${interval} weeks` : 'week';
                            desc += ' on ' + _months__WEBPACK_IMPORTED_MODULE_0__.format(config.start, 'EEEE');
                            return desc + suffix;
                        }
                    case 'monthly':
                        {
                            let desc = 'Every ';
                            desc += interval !== 1 ? `${interval} months` : 'month';
                            if (config.patterns && config.patterns.length > 0) {
                                // Sort the days ascending. We filter out -1 because that
                                // represents "last days" and should always be last, but this
                                // sort would put them first
                                let patterns = [
                                    ...config.patterns
                                ].sort((p1, p2) => {
                                    const typeOrder = (p1.type === 'day' ? 1 : 0) - (p2.type === 'day' ? 1 : 0);
                                    const valOrder = p1.value - p2.value;
                                    if (typeOrder === 0) {
                                        return valOrder;
                                    }
                                    return typeOrder;
                                }).filter((p) => p.value !== -1);
                                // Add on all -1 values to the end
                                patterns = patterns.concat(config.patterns.filter((p) => p.value === -1));
                                desc += ' on the ';
                                const strs = [];
                                const uniqueDays = new Set(patterns.map((p) => p.type));
                                const isSameDay = uniqueDays.size === 1 && !uniqueDays.has('day');
                                for (const pattern of patterns) {
                                    if (pattern.type === 'day') {
                                        if (pattern.value === -1) {
                                            strs.push('last day');
                                        }
                                        else {
                                            // Example: 15th day
                                            strs.push(makeNumberSuffix(pattern.value));
                                        }
                                    }
                                    else {
                                        const dayName = isSameDay ? '' : ' ' + prettyDayName(pattern.type);
                                        if (pattern.value === -1) {
                                            // Example: last Monday
                                            strs.push('last' + dayName);
                                        }
                                        else {
                                            // Example: 3rd Monday
                                            strs.push(makeNumberSuffix(pattern.value) + dayName);
                                        }
                                    }
                                }
                                if (strs.length > 2) {
                                    desc += strs.slice(0, strs.length - 1).join(', ');
                                    desc += ', and ';
                                    desc += strs[strs.length - 1];
                                }
                                else {
                                    desc += strs.join(' and ');
                                }
                                if (isSameDay) {
                                    desc += ' ' + prettyDayName(patterns[0].type);
                                }
                            }
                            else {
                                desc += ' on the ' + _months__WEBPACK_IMPORTED_MODULE_0__.format(config.start, 'do');
                            }
                            return desc + suffix;
                        }
                    case 'yearly':
                        {
                            let desc = 'Every ';
                            desc += interval !== 1 ? `${interval} years` : 'year';
                            desc += ' on ' + _months__WEBPACK_IMPORTED_MODULE_0__.format(config.start, 'LLL do');
                            return desc + suffix;
                        }
                    default:
                        return 'Recurring error';
                }
            }
            function recurConfigToRSchedule(config) {
                const base = {
                    start: _months__WEBPACK_IMPORTED_MODULE_0__.parseDate(config.start),
                    // @ts-ignore: issues with https://gitlab.com/john.carroll.p/rschedule/-/issues/86
                    frequency: config.frequency.toUpperCase(),
                    byHourOfDay: [
                        12
                    ]
                };
                if (config.interval) {
                    // @ts-ignore: issues with https://gitlab.com/john.carroll.p/rschedule/-/issues/86
                    base.interval = config.interval;
                }
                switch (config.endMode) {
                    case 'after_n_occurrences':
                        base.count = config.endOccurrences;
                        break;
                    case 'on_date':
                        base.end = _months__WEBPACK_IMPORTED_MODULE_0__.parseDate(config.endDate);
                        break;
                    default:
                }
                const abbrevDay = (name) => name.slice(0, 2).toUpperCase();
                switch (config.frequency) {
                    case 'daily':
                        // Nothing to do
                        return [
                            base
                        ];
                    case 'weekly':
                        // Nothing to do
                        return [
                            base
                        ];
                    case 'monthly':
                        if (config.patterns && config.patterns.length > 0) {
                            const days = config.patterns.filter((p) => p.type === 'day');
                            const dayNames = config.patterns.filter((p) => p.type !== 'day');
                            return [
                                days.length > 0 && {
                                    ...base,
                                    byDayOfMonth: days.map((p) => p.value)
                                },
                                dayNames.length > 0 && {
                                    ...base,
                                    byDayOfWeek: dayNames.map((p) => [
                                        abbrevDay(p.type),
                                        p.value
                                    ])
                                }
                            ].filter(Boolean);
                        }
                        else {
                            // Nothing to do
                            return [
                                base
                            ];
                        }
                    case 'yearly':
                        return [
                            base
                        ];
                    default:
                        throw new Error('Invalid recurring date config');
                }
            }
            function extractScheduleConds(conditions) {
                return {
                    payee: conditions.find((cond) => cond.op === 'is' && cond.field === 'payee') || conditions.find((cond) => cond.op === 'is' && cond.field === 'description') || null,
                    account: conditions.find((cond) => cond.op === 'is' && cond.field === 'account') || conditions.find((cond) => cond.op === 'is' && cond.field === 'acct') || null,
                    amount: conditions.find((cond) => (cond.op === 'is' || cond.op === 'isapprox' || cond.op === 'isbetween') && cond.field === 'amount') || null,
                    date: conditions.find((cond) => (cond.op === 'is' || cond.op === 'isapprox') && cond.field === 'date') || null
                };
            }
            function getScheduledAmount(amount) {
                if (amount && typeof amount !== 'number') {
                    return Math.round((amount.num1 + amount.num2) / 2);
                }
                return amount;
            }
            function describeSchedule(schedule, payee) {
                if (payee) {
                    return `${payee.name} (${schedule.next_date})`;
                }
                else {
                    return `Next: ${schedule.next_date}`;
                }
            }
            /***/ 
        }),
        /***/ "./packages/loot-core/src/shared/transactions.ts": 
        /*!*******************************************************!*\
          !*** ./packages/loot-core/src/shared/transactions.ts ***!
          \*******************************************************/
        /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony export */ __webpack_require__.d(__webpack_exports__, {
                /* harmony export */ addSplitTransaction: () => ( /* binding */addSplitTransaction),
                /* harmony export */ applyTransactionDiff: () => ( /* binding */applyTransactionDiff),
                /* harmony export */ deleteTransaction: () => ( /* binding */deleteTransaction),
                /* harmony export */ groupTransaction: () => ( /* binding */groupTransaction),
                /* harmony export */ isPreviewId: () => ( /* binding */isPreviewId),
                /* harmony export */ isTemporaryId: () => ( /* binding */isTemporaryId),
                /* harmony export */ makeAsNonChildTransactions: () => ( /* binding */makeAsNonChildTransactions),
                /* harmony export */ makeChild: () => ( /* binding */makeChild),
                /* harmony export */ realizeTempTransactions: () => ( /* binding */realizeTempTransactions),
                /* harmony export */ recalculateSplit: () => ( /* binding */recalculateSplit),
                /* harmony export */ splitTransaction: () => ( /* binding */splitTransaction),
                /* harmony export */ ungroupTransaction: () => ( /* binding */ungroupTransaction),
                /* harmony export */ ungroupTransactions: () => ( /* binding */ungroupTransactions),
                /* harmony export */ updateTransaction: () => ( /* binding */updateTransaction)
                /* harmony export */ 
            });
            /* harmony import */ var uuid__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! uuid */ "./node_modules/uuid/dist/esm-node/v4.js");
            /* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./util */ "./packages/loot-core/src/shared/util.ts");
            function isTemporaryId(id) {
                return id.indexOf('temp') !== -1;
            }
            function isPreviewId(id) {
                return id.indexOf('preview/') !== -1;
            }
            // The amount might be null when adding a new transaction
            function num(n) {
                return typeof n === 'number' ? n : 0;
            }
            function SplitTransactionError(total, parent) {
                const difference = num(parent.amount) - total;
                return {
                    type: 'SplitTransactionError',
                    version: 1,
                    difference
                };
            }
            function makeChild(parent, data = {}) {
                const prefix = parent.id === 'temp' ? 'temp' : '';
                return {
                    amount: 0,
                    ...data,
                    category: 'category' in data ? data.category : parent.category,
                    payee: 'payee' in data ? data.payee : parent.payee,
                    id: 'id' in data ? data.id : prefix + (0, uuid__WEBPACK_IMPORTED_MODULE_1__["default"])(),
                    account: parent.account,
                    date: parent.date,
                    cleared: parent.cleared != null ? parent.cleared : null,
                    reconciled: 'reconciled' in data ? data.reconciled : parent.reconciled,
                    starting_balance_flag: parent.starting_balance_flag != null ? parent.starting_balance_flag : null,
                    is_child: true,
                    parent_id: parent.id,
                    error: null
                };
            }
            function makeNonChild(parent, data) {
                return {
                    amount: 0,
                    ...data,
                    cleared: parent.cleared != null ? parent.cleared : null,
                    reconciled: parent.reconciled != null ? parent.reconciled : null,
                    sort_order: parent.sort_order || null,
                    starting_balance_flag: null,
                    is_child: false,
                    parent_id: null
                };
            }
            function recalculateSplit(trans) {
                // Calculate the new total of split transactions and make sure
                // that it equals the parent amount
                const total = (trans.subtransactions || []).reduce((acc, t) => acc + num(t.amount), 0);
                return {
                    ...trans,
                    error: total === num(trans.amount) ? null : SplitTransactionError(total, trans)
                };
            }
            function findParentIndex(transactions, idx) {
                // This relies on transactions being sorted in a way where parents
                // are always before children, which is enforced in the db layer.
                // Walk backwards and find the last parent;
                while (idx >= 0) {
                    const trans = transactions[idx];
                    if (trans.is_parent) {
                        return idx;
                    }
                    idx--;
                }
                return null;
            }
            function getSplit(transactions, parentIndex) {
                const split = [
                    transactions[parentIndex]
                ];
                let curr = parentIndex + 1;
                while (curr < transactions.length && transactions[curr].is_child) {
                    split.push(transactions[curr]);
                    curr++;
                }
                return split;
            }
            function ungroupTransactions(transactions) {
                return transactions.reduce((list, parent) => {
                    const { subtransactions, ...trans } = parent;
                    const _subtransactions = subtransactions || [];
                    list.push(trans);
                    for (let i = 0; i < _subtransactions.length; i++) {
                        list.push(_subtransactions[i]);
                    }
                    return list;
                }, []);
            }
            function groupTransaction(split) {
                return {
                    ...split[0],
                    subtransactions: split.slice(1)
                };
            }
            function ungroupTransaction(split) {
                if (split == null) {
                    return null;
                }
                return ungroupTransactions([
                    split
                ]);
            }
            function applyTransactionDiff(groupedTrans, diff) {
                return groupTransaction((0, _util__WEBPACK_IMPORTED_MODULE_0__.applyChanges)(diff, ungroupTransaction(groupedTrans) || []));
            }
            function replaceTransactions(transactions, id, func) {
                const idx = transactions.findIndex((t) => t.id === id);
                const trans = transactions[idx];
                const transactionsCopy = [
                    ...transactions
                ];
                if (idx === -1) {
                    throw new Error('Tried to edit unknown transaction id: ' + id);
                }
                if (trans.is_parent || trans.is_child) {
                    const parentIndex = findParentIndex(transactions, idx);
                    if (parentIndex == null) {
                        console.log('Cannot find parent index');
                        return {
                            data: [],
                            diff: {
                                deleted: [],
                                updated: []
                            }
                        };
                    }
                    const split = getSplit(transactions, parentIndex);
                    let grouped = func(groupTransaction(split));
                    const newSplit = ungroupTransaction(grouped);
                    let diff;
                    if (newSplit == null) {
                        // If everything was deleted, just delete the parent which will
                        // delete everything
                        diff = {
                            deleted: [
                                {
                                    id: split[0].id
                                }
                            ],
                            updated: []
                        };
                        grouped = {
                            ...split[0],
                            _deleted: true
                        };
                        transactionsCopy.splice(parentIndex, split.length);
                    }
                    else {
                        diff = (0, _util__WEBPACK_IMPORTED_MODULE_0__.diffItems)(split, newSplit);
                        transactionsCopy.splice(parentIndex, split.length, ...newSplit);
                    }
                    return {
                        data: transactionsCopy,
                        newTransaction: grouped,
                        diff
                    };
                }
                else {
                    const grouped = func(trans);
                    const newTrans = ungroupTransaction(grouped) || [];
                    if (grouped) {
                        grouped.subtransactions = grouped.subtransactions || [];
                    }
                    transactionsCopy.splice(idx, 1, ...newTrans);
                    return {
                        data: transactionsCopy,
                        newTransaction: grouped || {
                            ...trans,
                            _deleted: true
                        },
                        diff: (0, _util__WEBPACK_IMPORTED_MODULE_0__.diffItems)([
                            trans
                        ], newTrans)
                    };
                }
            }
            function addSplitTransaction(transactions, id) {
                return replaceTransactions(transactions, id, (trans) => {
                    if (!trans.is_parent) {
                        return trans;
                    }
                    const prevSub = (0, _util__WEBPACK_IMPORTED_MODULE_0__.last)(trans.subtransactions || []);
                    trans.subtransactions?.push(makeChild(trans, {
                        amount: 0,
                        sort_order: num(prevSub && prevSub.sort_order) - 1
                    }));
                    return trans;
                });
            }
            function updateTransaction(transactions, transaction) {
                return replaceTransactions(transactions, transaction.id, (trans) => {
                    if (trans.is_parent) {
                        const parent = trans.id === transaction.id ? transaction : trans;
                        const originalSubtransactions = parent.subtransactions ?? trans.subtransactions;
                        const sub = originalSubtransactions?.map((t) => {
                            // Make sure to update the children to reflect the updated
                            // properties (if the parent updated)
                            let child = t;
                            if (trans.id === transaction.id) {
                                child = {
                                    ...t,
                                    payee: t.payee === trans.payee ? transaction.payee : t.payee
                                };
                            }
                            else if (t.id === transaction.id) {
                                child = transaction;
                            }
                            return makeChild(parent, child);
                        });
                        return recalculateSplit({
                            ...parent,
                            subtransactions: sub
                        });
                    }
                    else {
                        return transaction;
                    }
                });
            }
            function deleteTransaction(transactions, id) {
                return replaceTransactions(transactions, id, (trans) => {
                    if (trans.is_parent) {
                        if (trans.id === id) {
                            return null;
                        }
                        else if (trans.subtransactions?.length === 1) {
                            return {
                                ...trans,
                                subtransactions: undefined,
                                is_parent: false,
                                error: null
                            };
                        }
                        else {
                            const sub = trans.subtransactions?.filter((t) => t.id !== id);
                            return recalculateSplit({
                                ...trans,
                                subtransactions: sub
                            });
                        }
                    }
                    else {
                        return null;
                    }
                });
            }
            function splitTransaction(transactions, id, createSubtransactions) {
                return replaceTransactions(transactions, id, (trans) => {
                    if (trans.is_parent || trans.is_child) {
                        return trans;
                    }
                    const subtransactions = createSubtransactions?.(trans) || [
                        makeChild(trans)
                    ];
                    return {
                        ...trans,
                        is_parent: true,
                        error: num(trans.amount) === 0 ? null : SplitTransactionError(0, trans),
                        subtransactions: subtransactions.map((t) => ({
                            ...t,
                            sort_order: t.sort_order || -1
                        }))
                    };
                });
            }
            function realizeTempTransactions(transactions) {
                const parent = {
                    ...transactions.find((t) => !t.is_child),
                    id: (0, uuid__WEBPACK_IMPORTED_MODULE_1__["default"])()
                };
                const children = transactions.filter((t) => t.is_child);
                return [
                    parent,
                    ...children.map((child) => ({
                        ...child,
                        id: (0, uuid__WEBPACK_IMPORTED_MODULE_1__["default"])(),
                        parent_id: parent.id
                    }))
                ];
            }
            function makeAsNonChildTransactions(childTransactionsToUpdate, transactions) {
                const [parentTransaction, ...childTransactions] = transactions;
                const newNonChildTransactions = childTransactionsToUpdate.map((t) => makeNonChild(parentTransaction, t));
                const remainingChildTransactions = childTransactions.filter((t) => !newNonChildTransactions.some((updatedTrans) => updatedTrans.id === t.id));
                const nonChildTransactionsToUpdate = remainingChildTransactions.length === 1 ? [
                    ...newNonChildTransactions,
                    makeNonChild(parentTransaction, remainingChildTransactions[0])
                ] : newNonChildTransactions;
                const deleteParentTransaction = remainingChildTransactions.length <= 1;
                const updatedParentTransaction = {
                    ...parentTransaction,
                    ...!deleteParentTransaction ? {
                        amount: remainingChildTransactions.map((t) => t.amount).reduce((total, amount) => total + amount, 0)
                    } : {}
                };
                return {
                    updated: [
                        ...!deleteParentTransaction ? [
                            updatedParentTransaction
                        ] : [],
                        ...nonChildTransactionsToUpdate
                    ],
                    deleted: [
                        ...deleteParentTransaction ? [
                            updatedParentTransaction
                        ] : []
                    ]
                };
            }
            /***/ 
        }),
        /***/ "./packages/loot-core/src/shared/util.ts": 
        /*!***********************************************!*\
          !*** ./packages/loot-core/src/shared/util.ts ***!
          \***********************************************/
        /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony export */ __webpack_require__.d(__webpack_exports__, {
                /* harmony export */ amountToCurrency: () => ( /* binding */amountToCurrency),
                /* harmony export */ amountToCurrencyNoDecimal: () => ( /* binding */amountToCurrencyNoDecimal),
                /* harmony export */ amountToInteger: () => ( /* binding */amountToInteger),
                /* harmony export */ appendDecimals: () => ( /* binding */appendDecimals),
                /* harmony export */ applyChanges: () => ( /* binding */applyChanges),
                /* harmony export */ currencyToAmount: () => ( /* binding */currencyToAmount),
                /* harmony export */ currencyToInteger: () => ( /* binding */currencyToInteger),
                /* harmony export */ diffItems: () => ( /* binding */diffItems),
                /* harmony export */ fastSetMerge: () => ( /* binding */fastSetMerge),
                /* harmony export */ getChangedValues: () => ( /* binding */getChangedValues),
                /* harmony export */ getIn: () => ( /* binding */getIn),
                /* harmony export */ getNumberFormat: () => ( /* binding */getNumberFormat),
                /* harmony export */ groupBy: () => ( /* binding */groupBy),
                /* harmony export */ groupById: () => ( /* binding */groupById),
                /* harmony export */ hasFieldsChanged: () => ( /* binding */hasFieldsChanged),
                /* harmony export */ integerToAmount: () => ( /* binding */integerToAmount),
                /* harmony export */ integerToCurrency: () => ( /* binding */integerToCurrency),
                /* harmony export */ last: () => ( /* binding */last),
                /* harmony export */ looselyParseAmount: () => ( /* binding */looselyParseAmount),
                /* harmony export */ numberFormats: () => ( /* binding */numberFormats),
                /* harmony export */ partitionByField: () => ( /* binding */partitionByField),
                /* harmony export */ safeNumber: () => ( /* binding */safeNumber),
                /* harmony export */ setIn: () => ( /* binding */setIn),
                /* harmony export */ setNumberFormat: () => ( /* binding */setNumberFormat),
                /* harmony export */ sortByKey: () => ( /* binding */sortByKey),
                /* harmony export */ stringToInteger: () => ( /* binding */stringToInteger),
                /* harmony export */ titleFirst: () => ( /* binding */titleFirst),
                /* harmony export */ toRelaxedNumber: () => ( /* binding */toRelaxedNumber)
                /* harmony export */ 
            });
            // @ts-strict-ignore
            function last(arr) {
                return arr[arr.length - 1];
            }
            function getChangedValues(obj1, obj2) {
                const diff = {};
                const keys = Object.keys(obj2);
                let hasChanged = false;
                // Keep the id field because this is mostly used to diff database
                // objects
                if (obj1.id) {
                    diff.id = obj1.id;
                }
                for (let i = 0; i < keys.length; i++) {
                    const key = keys[i];
                    if (obj1[key] !== obj2[key]) {
                        diff[key] = obj2[key];
                        hasChanged = true;
                    }
                }
                return hasChanged ? diff : null;
            }
            function hasFieldsChanged(obj1, obj2, fields) {
                let changed = false;
                for (let i = 0; i < fields.length; i++) {
                    const field = fields[i];
                    if (obj1[field] !== obj2[field]) {
                        changed = true;
                        break;
                    }
                }
                return changed;
            }
            function applyChanges(changes, items) {
                items = [
                    ...items
                ];
                if (changes.added) {
                    changes.added.forEach((add) => {
                        items.push(add);
                    });
                }
                if (changes.updated) {
                    changes.updated.forEach(({ id, ...fields }) => {
                        const idx = items.findIndex((t) => t.id === id);
                        items[idx] = {
                            ...items[idx],
                            ...fields
                        };
                    });
                }
                if (changes.deleted) {
                    changes.deleted.forEach((t) => {
                        const idx = items.findIndex((t2) => t.id === t2.id);
                        if (idx !== -1) {
                            items.splice(idx, 1);
                        }
                    });
                }
                return items;
            }
            function partitionByField(data, field) {
                const res = new Map();
                for (let i = 0; i < data.length; i++) {
                    const item = data[i];
                    const key = item[field];
                    const items = res.get(key) || [];
                    items.push(item);
                    res.set(key, items);
                }
                return res;
            }
            function groupBy(data, field) {
                const res = new Map();
                for (let i = 0; i < data.length; i++) {
                    const item = data[i];
                    const key = item[field];
                    const existing = res.get(key) || [];
                    res.set(key, existing.concat([
                        item
                    ]));
                }
                return res;
            }
            // This should replace the existing `groupById` function, since a
            // `Map` is better, but we can't swap it out because `Map` has a
            // different API and we need to go through and update everywhere that
            // uses it.
            function _groupById(data) {
                const res = new Map();
                for (let i = 0; i < data.length; i++) {
                    const item = data[i];
                    res.set(item.id, item);
                }
                return res;
            }
            function diffItems(items, newItems) {
                const grouped = _groupById(items);
                const newGrouped = _groupById(newItems);
                const added = [];
                const updated = [];
                const deleted = items.filter((item) => !newGrouped.has(item.id)).map((item) => ({
                    id: item.id
                }));
                newItems.forEach((newItem) => {
                    const item = grouped.get(newItem.id);
                    if (!item) {
                        added.push(newItem);
                    }
                    else {
                        const changes = getChangedValues(item, newItem);
                        if (changes) {
                            updated.push(changes);
                        }
                    }
                });
                return {
                    added,
                    updated,
                    deleted
                };
            }
            function groupById(data) {
                const res = {};
                for (let i = 0; i < data.length; i++) {
                    const item = data[i];
                    res[item.id] = item;
                }
                return res;
            }
            function setIn(map, keys, item) {
                for (let i = 0; i < keys.length; i++) {
                    const key = keys[i];
                    if (i === keys.length - 1) {
                        map.set(key, item);
                    }
                    else {
                        if (!map.has(key)) {
                            map.set(key, new Map());
                        }
                        map = map.get(key);
                    }
                }
            }
            function getIn(map, keys) {
                let item = map;
                for (let i = 0; i < keys.length; i++) {
                    item = item.get(keys[i]);
                    if (item == null) {
                        return item;
                    }
                }
                return item;
            }
            function fastSetMerge(set1, set2) {
                const finalSet = new Set(set1);
                const iter = set2.values();
                let value = iter.next();
                while (!value.done) {
                    finalSet.add(value.value);
                    value = iter.next();
                }
                return finalSet;
            }
            function titleFirst(str) {
                return str[0].toUpperCase() + str.slice(1);
            }
            function appendDecimals(amountText, hideDecimals = false) {
                const { separator } = getNumberFormat();
                let result = amountText;
                if (result.slice(-1) === separator) {
                    result = result.slice(0, -1);
                }
                if (!hideDecimals) {
                    result = result.replaceAll(/[,.]/g, '');
                    result = result.replace(/^0+(?!$)/, '');
                    result = result.padStart(3, '0');
                    result = result.slice(0, -2) + separator + result.slice(-2);
                }
                return amountToCurrency(currencyToAmount(result));
            }
            const numberFormats = [
                {
                    value: 'comma-dot',
                    label: '1,000.33',
                    labelNoFraction: '1,000'
                },
                {
                    value: 'dot-comma',
                    label: '1.000,33',
                    labelNoFraction: '1.000'
                },
                {
                    value: 'space-comma',
                    label: '1\xa0000,33',
                    labelNoFraction: '1\xa0000'
                },
                {
                    value: 'apostrophe-dot',
                    label: '1000.33',
                    labelNoFraction: '1000'
                },
                {
                    value: 'comma-dot-in',
                    label: '1,00,000.33',
                    labelNoFraction: '1,00,000'
                }
            ];
            let numberFormatConfig = {
                format: 'comma-dot',
                hideFraction: false
            };
            function setNumberFormat(config) {
                numberFormatConfig = config;
            }
            function getNumberFormat({ format, hideFraction } = numberFormatConfig) {
                let locale, regex, separator, separatorRegex;
                switch (format) {
                    case 'space-comma':
                        locale = 'en-SE';
                        regex = /[^-0-9,.]/g;
                        separator = ',';
                        separatorRegex = /[,.]/g;
                        break;
                    case 'dot-comma':
                        locale = 'de-DE';
                        regex = /[^-0-9,]/g;
                        separator = ',';
                        break;
                    case 'apostrophe-dot':
                        locale = 'de-CH';
                        regex = /[^-0-9,.]/g;
                        separator = '.';
                        separatorRegex = /[,.]/g;
                        break;
                    case 'comma-dot-in':
                        locale = 'en-IN';
                        regex = /[^-0-9.]/g;
                        separator = '.';
                        break;
                    case 'comma-dot':
                    default:
                        locale = 'en-US';
                        regex = /[^-0-9.]/g;
                        separator = '.';
                }
                return {
                    value: format,
                    separator,
                    formatter: new Intl.NumberFormat(locale, {
                        minimumFractionDigits: hideFraction ? 0 : 2,
                        maximumFractionDigits: hideFraction ? 0 : 2
                    }),
                    regex,
                    separatorRegex
                };
            }
            // Number utilities
            // We dont use `Number.MAX_SAFE_NUMBER` and such here because those
            // numbers are so large that it's not safe to convert them to floats
            // (i.e. N / 100). For example, `9007199254740987 / 100 ===
            // 90071992547409.88`. While the internal arithemetic would be correct
            // because we always do that on numbers, the app would potentially
            // display wrong numbers. Instead of `2**53` we use `2**51` which
            // gives division more room to be correct
            const MAX_SAFE_NUMBER = 2 ** 51 - 1;
            const MIN_SAFE_NUMBER = -MAX_SAFE_NUMBER;
            function safeNumber(value) {
                if (!Number.isInteger(value)) {
                    throw new Error('safeNumber: number is not an integer: ' + JSON.stringify(value));
                }
                if (value > MAX_SAFE_NUMBER || value < MIN_SAFE_NUMBER) {
                    throw new Error('safeNumber: cant safely perform arithmetic with number: ' + value);
                }
                return value;
            }
            function toRelaxedNumber(value) {
                return integerToAmount(currencyToInteger(value) || 0);
            }
            function integerToCurrency(n, formatter = getNumberFormat().formatter) {
                return formatter.format(safeNumber(n) / 100);
            }
            function amountToCurrency(n) {
                return getNumberFormat().formatter.format(n);
            }
            function amountToCurrencyNoDecimal(n) {
                return getNumberFormat({
                    ...numberFormatConfig,
                    hideFraction: true
                }).formatter.format(n);
            }
            function currencyToAmount(str) {
                let amount;
                if (getNumberFormat().separatorRegex) {
                    amount = parseFloat(str.replace(getNumberFormat().regex, '').replace(getNumberFormat().separatorRegex, '.'));
                }
                else {
                    amount = parseFloat(str.replace(getNumberFormat().regex, '').replace(getNumberFormat().separator, '.'));
                }
                return isNaN(amount) ? null : amount;
            }
            function currencyToInteger(str) {
                const amount = currencyToAmount(str);
                return amount == null ? null : amountToInteger(amount);
            }
            function stringToInteger(str) {
                const amount = parseInt(str.replace(/[^-0-9.,]/g, ''));
                if (!isNaN(amount)) {
                    return amount;
                }
                return null;
            }
            function amountToInteger(n) {
                return Math.round(n * 100);
            }
            function integerToAmount(n) {
                return parseFloat((safeNumber(n) / 100).toFixed(2));
            }
            // This is used when the input format could be anything (from
            // financial files and we don't want to parse based on the user's
            // number format, because the user could be importing from many
            // currencies. We extract out the numbers and just ignore separators.
            function looselyParseAmount(amount) {
                function safeNumber(v) {
                    if (isNaN(v)) {
                        return null;
                    }
                    const value = v * 100;
                    if (value > MAX_SAFE_NUMBER || value < MIN_SAFE_NUMBER) {
                        return null;
                    }
                    return v;
                }
                function extractNumbers(v) {
                    return v.replace(/[^0-9-]/g, '');
                }
                if (amount.startsWith('(') && amount.endsWith(')')) {
                    amount = amount.replace('(', '-').replace(')', '');
                }
                // Look for a decimal marker, then look for either 1-2 or 5-9 decimal places.
                // This avoids matching against 3 places which may not actually be decimal
                const m = amount.match(/[.,]([^.,]{5,9}|[^.,]{1,2})$/);
                if (!m || m.index === undefined || m.index === 0) {
                    return safeNumber(parseFloat(extractNumbers(amount)));
                }
                const left = extractNumbers(amount.slice(0, m.index));
                const right = extractNumbers(amount.slice(m.index + 1));
                return safeNumber(parseFloat(left + '.' + right));
            }
            function sortByKey(arr, key) {
                return [
                    ...arr
                ].sort((item1, item2) => {
                    if (item1[key] < item2[key]) {
                        return -1;
                    }
                    else if (item1[key] > item2[key]) {
                        return 1;
                    }
                    return 0;
                });
            }
            /***/ 
        }),
        /***/ "./node_modules/uuid/dist/esm-node/native.js": 
        /*!***************************************************!*\
          !*** ./node_modules/uuid/dist/esm-node/native.js ***!
          \***************************************************/
        /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony export */ __webpack_require__.d(__webpack_exports__, {
                /* harmony export */ "default": () => (__WEBPACK_DEFAULT_EXPORT__)
                /* harmony export */ 
            });
            /* harmony import */ var crypto__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! crypto */ "crypto");
            /* harmony import */ var crypto__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/ __webpack_require__.n(crypto__WEBPACK_IMPORTED_MODULE_0__);
            /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
                randomUUID: (crypto__WEBPACK_IMPORTED_MODULE_0___default().randomUUID)
            });
            /***/ 
        }),
        /***/ "./node_modules/uuid/dist/esm-node/regex.js": 
        /*!**************************************************!*\
          !*** ./node_modules/uuid/dist/esm-node/regex.js ***!
          \**************************************************/
        /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony export */ __webpack_require__.d(__webpack_exports__, {
                /* harmony export */ "default": () => (__WEBPACK_DEFAULT_EXPORT__)
                /* harmony export */ 
            });
            /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (/^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i);
            /***/ 
        }),
        /***/ "./node_modules/uuid/dist/esm-node/rng.js": 
        /*!************************************************!*\
          !*** ./node_modules/uuid/dist/esm-node/rng.js ***!
          \************************************************/
        /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony export */ __webpack_require__.d(__webpack_exports__, {
                /* harmony export */ "default": () => ( /* binding */rng)
                /* harmony export */ 
            });
            /* harmony import */ var crypto__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! crypto */ "crypto");
            /* harmony import */ var crypto__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/ __webpack_require__.n(crypto__WEBPACK_IMPORTED_MODULE_0__);
            const rnds8Pool = new Uint8Array(256); // # of random values to pre-allocate
            let poolPtr = rnds8Pool.length;
            function rng() {
                if (poolPtr > rnds8Pool.length - 16) {
                    crypto__WEBPACK_IMPORTED_MODULE_0___default().randomFillSync(rnds8Pool);
                    poolPtr = 0;
                }
                return rnds8Pool.slice(poolPtr, poolPtr += 16);
            }
            /***/ 
        }),
        /***/ "./node_modules/uuid/dist/esm-node/stringify.js": 
        /*!******************************************************!*\
          !*** ./node_modules/uuid/dist/esm-node/stringify.js ***!
          \******************************************************/
        /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony export */ __webpack_require__.d(__webpack_exports__, {
                /* harmony export */ "default": () => (__WEBPACK_DEFAULT_EXPORT__),
                /* harmony export */ unsafeStringify: () => ( /* binding */unsafeStringify)
                /* harmony export */ 
            });
            /* harmony import */ var _validate_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./validate.js */ "./node_modules/uuid/dist/esm-node/validate.js");
            /**
             * Convert array of 16 byte values to UUID string format of the form:
             * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX
             */
            const byteToHex = [];
            for (let i = 0; i < 256; ++i) {
                byteToHex.push((i + 0x100).toString(16).slice(1));
            }
            function unsafeStringify(arr, offset = 0) {
                // Note: Be careful editing this code!  It's been tuned for performance
                // and works in ways you may not expect. See https://github.com/uuidjs/uuid/pull/434
                return byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + '-' + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + '-' + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + '-' + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + '-' + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]];
            }
            function stringify(arr, offset = 0) {
                const uuid = unsafeStringify(arr, offset); // Consistency check for valid UUID.  If this throws, it's likely due to one
                // of the following:
                // - One or more input array values don't map to a hex octet (leading to
                // "undefined" in the uuid)
                // - Invalid input values for the RFC `version` or `variant` fields
                if (!(0, _validate_js__WEBPACK_IMPORTED_MODULE_0__["default"])(uuid)) {
                    throw TypeError('Stringified UUID is invalid');
                }
                return uuid;
            }
            /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (stringify);
            /***/ 
        }),
        /***/ "./node_modules/uuid/dist/esm-node/v4.js": 
        /*!***********************************************!*\
          !*** ./node_modules/uuid/dist/esm-node/v4.js ***!
          \***********************************************/
        /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony export */ __webpack_require__.d(__webpack_exports__, {
                /* harmony export */ "default": () => (__WEBPACK_DEFAULT_EXPORT__)
                /* harmony export */ 
            });
            /* harmony import */ var _native_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./native.js */ "./node_modules/uuid/dist/esm-node/native.js");
            /* harmony import */ var _rng_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./rng.js */ "./node_modules/uuid/dist/esm-node/rng.js");
            /* harmony import */ var _stringify_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./stringify.js */ "./node_modules/uuid/dist/esm-node/stringify.js");
            function v4(options, buf, offset) {
                if (_native_js__WEBPACK_IMPORTED_MODULE_0__["default"].randomUUID && !buf && !options) {
                    return _native_js__WEBPACK_IMPORTED_MODULE_0__["default"].randomUUID();
                }
                options = options || {};
                const rnds = options.random || (options.rng || _rng_js__WEBPACK_IMPORTED_MODULE_1__["default"])(); // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`
                rnds[6] = rnds[6] & 0x0f | 0x40;
                rnds[8] = rnds[8] & 0x3f | 0x80; // Copy bytes to buffer, if provided
                if (buf) {
                    offset = offset || 0;
                    for (let i = 0; i < 16; ++i) {
                        buf[offset + i] = rnds[i];
                    }
                    return buf;
                }
                return (0, _stringify_js__WEBPACK_IMPORTED_MODULE_2__.unsafeStringify)(rnds);
            }
            /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (v4);
            /***/ 
        }),
        /***/ "./node_modules/uuid/dist/esm-node/validate.js": 
        /*!*****************************************************!*\
          !*** ./node_modules/uuid/dist/esm-node/validate.js ***!
          \*****************************************************/
        /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony export */ __webpack_require__.d(__webpack_exports__, {
                /* harmony export */ "default": () => (__WEBPACK_DEFAULT_EXPORT__)
                /* harmony export */ 
            });
            /* harmony import */ var _regex_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./regex.js */ "./node_modules/uuid/dist/esm-node/regex.js");
            function validate(uuid) {
                return typeof uuid === 'string' && _regex_js__WEBPACK_IMPORTED_MODULE_0__["default"].test(uuid);
            }
            /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (validate);
            /***/ 
        }),
        /***/ "./node_modules/which-boxed-primitive/index.js": 
        /*!*****************************************************!*\
          !*** ./node_modules/which-boxed-primitive/index.js ***!
          \*****************************************************/
        /***/ ((module, __unused_webpack_exports, __webpack_require__) => {
            "use strict";
            var isString = __webpack_require__(/*! is-string */ "./node_modules/is-string/index.js");
            var isNumber = __webpack_require__(/*! is-number-object */ "./node_modules/is-number-object/index.js");
            var isBoolean = __webpack_require__(/*! is-boolean-object */ "./node_modules/is-boolean-object/index.js");
            var isSymbol = __webpack_require__(/*! is-symbol */ "./node_modules/is-symbol/index.js");
            var isBigInt = __webpack_require__(/*! is-bigint */ "./node_modules/is-bigint/index.js");
            // eslint-disable-next-line consistent-return
            module.exports = function whichBoxedPrimitive(value) {
                // eslint-disable-next-line eqeqeq
                if (value == null || (typeof value !== 'object' && typeof value !== 'function')) {
                    return null;
                }
                if (isString(value)) {
                    return 'String';
                }
                if (isNumber(value)) {
                    return 'Number';
                }
                if (isBoolean(value)) {
                    return 'Boolean';
                }
                if (isSymbol(value)) {
                    return 'Symbol';
                }
                if (isBigInt(value)) {
                    return 'BigInt';
                }
            };
            /***/ 
        }),
        /***/ "./node_modules/which-typed-array/index.js": 
        /*!*************************************************!*\
          !*** ./node_modules/which-typed-array/index.js ***!
          \*************************************************/
        /***/ ((module, __unused_webpack_exports, __webpack_require__) => {
            "use strict";
            var forEach = __webpack_require__(/*! for-each */ "./node_modules/for-each/index.js");
            var availableTypedArrays = __webpack_require__(/*! available-typed-arrays */ "./node_modules/available-typed-arrays/index.js");
            var callBind = __webpack_require__(/*! call-bind */ "./node_modules/call-bind/index.js");
            var callBound = __webpack_require__(/*! call-bind/callBound */ "./node_modules/call-bind/callBound.js");
            var gOPD = __webpack_require__(/*! gopd */ "./node_modules/gopd/index.js");
            var $toString = callBound('Object.prototype.toString');
            var hasToStringTag = __webpack_require__(/*! has-tostringtag/shams */ "./node_modules/has-tostringtag/shams.js")();
            var g = typeof globalThis === 'undefined' ? global : globalThis;
            var typedArrays = availableTypedArrays();
            var $slice = callBound('String.prototype.slice');
            var getPrototypeOf = Object.getPrototypeOf; // require('getprototypeof');
            var $indexOf = callBound('Array.prototype.indexOf', true) || function indexOf(array, value) {
                for (var i = 0; i < array.length; i += 1) {
                    if (array[i] === value) {
                        return i;
                    }
                }
                return -1;
            };
            var cache = { __proto__: null };
            if (hasToStringTag && gOPD && getPrototypeOf) {
                forEach(typedArrays, function (typedArray) {
                    var arr = new g[typedArray]();
                    if (Symbol.toStringTag in arr) {
                        var proto = getPrototypeOf(arr);
                        var descriptor = gOPD(proto, Symbol.toStringTag);
                        if (!descriptor) {
                            var superProto = getPrototypeOf(proto);
                            descriptor = gOPD(superProto, Symbol.toStringTag);
                        }
                        cache['$' + typedArray] = callBind(descriptor.get);
                    }
                });
            }
            else {
                forEach(typedArrays, function (typedArray) {
                    var arr = new g[typedArray]();
                    var fn = arr.slice || arr.set;
                    if (fn) {
                        cache['$' + typedArray] = callBind(fn);
                    }
                });
            }
            var tryTypedArrays = function tryAllTypedArrays(value) {
                var found = false;
                forEach(cache, function (getter, typedArray) {
                    if (!found) {
                        try {
                            if ('$' + getter(value) === typedArray) {
                                found = $slice(typedArray, 1);
                            }
                        }
                        catch (e) { /**/ }
                    }
                });
                return found;
            };
            var trySlices = function tryAllSlices(value) {
                var found = false;
                forEach(cache, function (getter, name) {
                    if (!found) {
                        try {
                            getter(value);
                            found = $slice(name, 1);
                        }
                        catch (e) { /**/ }
                    }
                });
                return found;
            };
            module.exports = function whichTypedArray(value) {
                if (!value || typeof value !== 'object') {
                    return false;
                }
                if (!hasToStringTag) {
                    var tag = $slice($toString(value), 8, -1);
                    if ($indexOf(typedArrays, tag) > -1) {
                        return tag;
                    }
                    if (tag !== 'Object') {
                        return false;
                    }
                    // node < 0.6 hits here on real Typed Arrays
                    return trySlices(value);
                }
                if (!gOPD) {
                    return null;
                } // unknown engine
                return tryTypedArrays(value);
            };
            /***/ 
        }),
        /***/ "./node_modules/xml2js/lib/bom.js": 
        /*!****************************************!*\
          !*** ./node_modules/xml2js/lib/bom.js ***!
          \****************************************/
        /***/ (function (__unused_webpack_module, exports) {
            // Generated by CoffeeScript 1.12.7
            (function () {
                "use strict";
                exports.stripBOM = function (str) {
                    if (str[0] === '\uFEFF') {
                        return str.substring(1);
                    }
                    else {
                        return str;
                    }
                };
            }).call(this);
            /***/ 
        }),
        /***/ "./node_modules/xml2js/lib/builder.js": 
        /*!********************************************!*\
          !*** ./node_modules/xml2js/lib/builder.js ***!
          \********************************************/
        /***/ (function (__unused_webpack_module, exports, __webpack_require__) {
            // Generated by CoffeeScript 1.12.7
            (function () {
                "use strict";
                var builder, defaults, escapeCDATA, requiresCDATA, wrapCDATA, hasProp = {}.hasOwnProperty;
                builder = __webpack_require__(/*! xmlbuilder */ "./node_modules/xml2js/node_modules/xmlbuilder/lib/index.js");
                defaults = (__webpack_require__(/*! ./defaults */ "./node_modules/xml2js/lib/defaults.js").defaults);
                requiresCDATA = function (entry) {
                    return typeof entry === "string" && (entry.indexOf('&') >= 0 || entry.indexOf('>') >= 0 || entry.indexOf('<') >= 0);
                };
                wrapCDATA = function (entry) {
                    return "<![CDATA[" + (escapeCDATA(entry)) + "]]>";
                };
                escapeCDATA = function (entry) {
                    return entry.replace(']]>', ']]]]><![CDATA[>');
                };
                exports.Builder = (function () {
                    function Builder(opts) {
                        var key, ref, value;
                        this.options = {};
                        ref = defaults["0.2"];
                        for (key in ref) {
                            if (!hasProp.call(ref, key))
                                continue;
                            value = ref[key];
                            this.options[key] = value;
                        }
                        for (key in opts) {
                            if (!hasProp.call(opts, key))
                                continue;
                            value = opts[key];
                            this.options[key] = value;
                        }
                    }
                    Builder.prototype.buildObject = function (rootObj) {
                        var attrkey, charkey, render, rootElement, rootName;
                        attrkey = this.options.attrkey;
                        charkey = this.options.charkey;
                        if ((Object.keys(rootObj).length === 1) && (this.options.rootName === defaults['0.2'].rootName)) {
                            rootName = Object.keys(rootObj)[0];
                            rootObj = rootObj[rootName];
                        }
                        else {
                            rootName = this.options.rootName;
                        }
                        render = (function (_this) {
                            return function (element, obj) {
                                var attr, child, entry, index, key, value;
                                if (typeof obj !== 'object') {
                                    if (_this.options.cdata && requiresCDATA(obj)) {
                                        element.raw(wrapCDATA(obj));
                                    }
                                    else {
                                        element.txt(obj);
                                    }
                                }
                                else if (Array.isArray(obj)) {
                                    for (index in obj) {
                                        if (!hasProp.call(obj, index))
                                            continue;
                                        child = obj[index];
                                        for (key in child) {
                                            entry = child[key];
                                            element = render(element.ele(key), entry).up();
                                        }
                                    }
                                }
                                else {
                                    for (key in obj) {
                                        if (!hasProp.call(obj, key))
                                            continue;
                                        child = obj[key];
                                        if (key === attrkey) {
                                            if (typeof child === "object") {
                                                for (attr in child) {
                                                    value = child[attr];
                                                    element = element.att(attr, value);
                                                }
                                            }
                                        }
                                        else if (key === charkey) {
                                            if (_this.options.cdata && requiresCDATA(child)) {
                                                element = element.raw(wrapCDATA(child));
                                            }
                                            else {
                                                element = element.txt(child);
                                            }
                                        }
                                        else if (Array.isArray(child)) {
                                            for (index in child) {
                                                if (!hasProp.call(child, index))
                                                    continue;
                                                entry = child[index];
                                                if (typeof entry === 'string') {
                                                    if (_this.options.cdata && requiresCDATA(entry)) {
                                                        element = element.ele(key).raw(wrapCDATA(entry)).up();
                                                    }
                                                    else {
                                                        element = element.ele(key, entry).up();
                                                    }
                                                }
                                                else {
                                                    element = render(element.ele(key), entry).up();
                                                }
                                            }
                                        }
                                        else if (typeof child === "object") {
                                            element = render(element.ele(key), child).up();
                                        }
                                        else {
                                            if (typeof child === 'string' && _this.options.cdata && requiresCDATA(child)) {
                                                element = element.ele(key).raw(wrapCDATA(child)).up();
                                            }
                                            else {
                                                if (child == null) {
                                                    child = '';
                                                }
                                                element = element.ele(key, child.toString()).up();
                                            }
                                        }
                                    }
                                }
                                return element;
                            };
                        })(this);
                        rootElement = builder.create(rootName, this.options.xmldec, this.options.doctype, {
                            headless: this.options.headless,
                            allowSurrogateChars: this.options.allowSurrogateChars
                        });
                        return render(rootElement, rootObj).end(this.options.renderOpts);
                    };
                    return Builder;
                })();
            }).call(this);
            /***/ 
        }),
        /***/ "./node_modules/xml2js/lib/defaults.js": 
        /*!*********************************************!*\
          !*** ./node_modules/xml2js/lib/defaults.js ***!
          \*********************************************/
        /***/ (function (__unused_webpack_module, exports) {
            // Generated by CoffeeScript 1.12.7
            (function () {
                exports.defaults = {
                    "0.1": {
                        explicitCharkey: false,
                        trim: true,
                        normalize: true,
                        normalizeTags: false,
                        attrkey: "@",
                        charkey: "#",
                        explicitArray: false,
                        ignoreAttrs: false,
                        mergeAttrs: false,
                        explicitRoot: false,
                        validator: null,
                        xmlns: false,
                        explicitChildren: false,
                        childkey: '@@',
                        charsAsChildren: false,
                        includeWhiteChars: false,
                        async: false,
                        strict: true,
                        attrNameProcessors: null,
                        attrValueProcessors: null,
                        tagNameProcessors: null,
                        valueProcessors: null,
                        emptyTag: ''
                    },
                    "0.2": {
                        explicitCharkey: false,
                        trim: false,
                        normalize: false,
                        normalizeTags: false,
                        attrkey: "$",
                        charkey: "_",
                        explicitArray: true,
                        ignoreAttrs: false,
                        mergeAttrs: false,
                        explicitRoot: true,
                        validator: null,
                        xmlns: false,
                        explicitChildren: false,
                        preserveChildrenOrder: false,
                        childkey: '$$',
                        charsAsChildren: false,
                        includeWhiteChars: false,
                        async: false,
                        strict: true,
                        attrNameProcessors: null,
                        attrValueProcessors: null,
                        tagNameProcessors: null,
                        valueProcessors: null,
                        rootName: 'root',
                        xmldec: {
                            'version': '1.0',
                            'encoding': 'UTF-8',
                            'standalone': true
                        },
                        doctype: null,
                        renderOpts: {
                            'pretty': true,
                            'indent': '  ',
                            'newline': '\n'
                        },
                        headless: false,
                        chunkSize: 10000,
                        emptyTag: '',
                        cdata: false
                    }
                };
            }).call(this);
            /***/ 
        }),
        /***/ "./node_modules/xml2js/lib/parser.js": 
        /*!*******************************************!*\
          !*** ./node_modules/xml2js/lib/parser.js ***!
          \*******************************************/
        /***/ (function (__unused_webpack_module, exports, __webpack_require__) {
            // Generated by CoffeeScript 1.12.7
            (function () {
                "use strict";
                var bom, defaults, defineProperty, events, isEmpty, processItem, processors, sax, setImmediate, bind = function (fn, me) { return function () { return fn.apply(me, arguments); }; }, extend = function (child, parent) { for (var key in parent) {
                    if (hasProp.call(parent, key))
                        child[key] = parent[key];
                } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty;
                sax = __webpack_require__(/*! sax */ "./node_modules/sax/lib/sax.js");
                events = __webpack_require__(/*! events */ "events");
                bom = __webpack_require__(/*! ./bom */ "./node_modules/xml2js/lib/bom.js");
                processors = __webpack_require__(/*! ./processors */ "./node_modules/xml2js/lib/processors.js");
                setImmediate = (__webpack_require__(/*! timers */ "timers").setImmediate);
                defaults = (__webpack_require__(/*! ./defaults */ "./node_modules/xml2js/lib/defaults.js").defaults);
                isEmpty = function (thing) {
                    return typeof thing === "object" && (thing != null) && Object.keys(thing).length === 0;
                };
                processItem = function (processors, item, key) {
                    var i, len, process;
                    for (i = 0, len = processors.length; i < len; i++) {
                        process = processors[i];
                        item = process(item, key);
                    }
                    return item;
                };
                defineProperty = function (obj, key, value) {
                    var descriptor;
                    descriptor = Object.create(null);
                    descriptor.value = value;
                    descriptor.writable = true;
                    descriptor.enumerable = true;
                    descriptor.configurable = true;
                    return Object.defineProperty(obj, key, descriptor);
                };
                exports.Parser = (function (superClass) {
                    extend(Parser, superClass);
                    function Parser(opts) {
                        this.parseStringPromise = bind(this.parseStringPromise, this);
                        this.parseString = bind(this.parseString, this);
                        this.reset = bind(this.reset, this);
                        this.assignOrPush = bind(this.assignOrPush, this);
                        this.processAsync = bind(this.processAsync, this);
                        var key, ref, value;
                        if (!(this instanceof exports.Parser)) {
                            return new exports.Parser(opts);
                        }
                        this.options = {};
                        ref = defaults["0.2"];
                        for (key in ref) {
                            if (!hasProp.call(ref, key))
                                continue;
                            value = ref[key];
                            this.options[key] = value;
                        }
                        for (key in opts) {
                            if (!hasProp.call(opts, key))
                                continue;
                            value = opts[key];
                            this.options[key] = value;
                        }
                        if (this.options.xmlns) {
                            this.options.xmlnskey = this.options.attrkey + "ns";
                        }
                        if (this.options.normalizeTags) {
                            if (!this.options.tagNameProcessors) {
                                this.options.tagNameProcessors = [];
                            }
                            this.options.tagNameProcessors.unshift(processors.normalize);
                        }
                        this.reset();
                    }
                    Parser.prototype.processAsync = function () {
                        var chunk, err;
                        try {
                            if (this.remaining.length <= this.options.chunkSize) {
                                chunk = this.remaining;
                                this.remaining = '';
                                this.saxParser = this.saxParser.write(chunk);
                                return this.saxParser.close();
                            }
                            else {
                                chunk = this.remaining.substr(0, this.options.chunkSize);
                                this.remaining = this.remaining.substr(this.options.chunkSize, this.remaining.length);
                                this.saxParser = this.saxParser.write(chunk);
                                return setImmediate(this.processAsync);
                            }
                        }
                        catch (error1) {
                            err = error1;
                            if (!this.saxParser.errThrown) {
                                this.saxParser.errThrown = true;
                                return this.emit(err);
                            }
                        }
                    };
                    Parser.prototype.assignOrPush = function (obj, key, newValue) {
                        if (!(key in obj)) {
                            if (!this.options.explicitArray) {
                                return defineProperty(obj, key, newValue);
                            }
                            else {
                                return defineProperty(obj, key, [newValue]);
                            }
                        }
                        else {
                            if (!(obj[key] instanceof Array)) {
                                defineProperty(obj, key, [obj[key]]);
                            }
                            return obj[key].push(newValue);
                        }
                    };
                    Parser.prototype.reset = function () {
                        var attrkey, charkey, ontext, stack;
                        this.removeAllListeners();
                        this.saxParser = sax.parser(this.options.strict, {
                            trim: false,
                            normalize: false,
                            xmlns: this.options.xmlns
                        });
                        this.saxParser.errThrown = false;
                        this.saxParser.onerror = (function (_this) {
                            return function (error) {
                                _this.saxParser.resume();
                                if (!_this.saxParser.errThrown) {
                                    _this.saxParser.errThrown = true;
                                    return _this.emit("error", error);
                                }
                            };
                        })(this);
                        this.saxParser.onend = (function (_this) {
                            return function () {
                                if (!_this.saxParser.ended) {
                                    _this.saxParser.ended = true;
                                    return _this.emit("end", _this.resultObject);
                                }
                            };
                        })(this);
                        this.saxParser.ended = false;
                        this.EXPLICIT_CHARKEY = this.options.explicitCharkey;
                        this.resultObject = null;
                        stack = [];
                        attrkey = this.options.attrkey;
                        charkey = this.options.charkey;
                        this.saxParser.onopentag = (function (_this) {
                            return function (node) {
                                var key, newValue, obj, processedKey, ref;
                                obj = {};
                                obj[charkey] = "";
                                if (!_this.options.ignoreAttrs) {
                                    ref = node.attributes;
                                    for (key in ref) {
                                        if (!hasProp.call(ref, key))
                                            continue;
                                        if (!(attrkey in obj) && !_this.options.mergeAttrs) {
                                            obj[attrkey] = {};
                                        }
                                        newValue = _this.options.attrValueProcessors ? processItem(_this.options.attrValueProcessors, node.attributes[key], key) : node.attributes[key];
                                        processedKey = _this.options.attrNameProcessors ? processItem(_this.options.attrNameProcessors, key) : key;
                                        if (_this.options.mergeAttrs) {
                                            _this.assignOrPush(obj, processedKey, newValue);
                                        }
                                        else {
                                            defineProperty(obj[attrkey], processedKey, newValue);
                                        }
                                    }
                                }
                                obj["#name"] = _this.options.tagNameProcessors ? processItem(_this.options.tagNameProcessors, node.name) : node.name;
                                if (_this.options.xmlns) {
                                    obj[_this.options.xmlnskey] = {
                                        uri: node.uri,
                                        local: node.local
                                    };
                                }
                                return stack.push(obj);
                            };
                        })(this);
                        this.saxParser.onclosetag = (function (_this) {
                            return function () {
                                var cdata, emptyStr, key, node, nodeName, obj, objClone, old, s, xpath;
                                obj = stack.pop();
                                nodeName = obj["#name"];
                                if (!_this.options.explicitChildren || !_this.options.preserveChildrenOrder) {
                                    delete obj["#name"];
                                }
                                if (obj.cdata === true) {
                                    cdata = obj.cdata;
                                    delete obj.cdata;
                                }
                                s = stack[stack.length - 1];
                                if (obj[charkey].match(/^\s*$/) && !cdata) {
                                    emptyStr = obj[charkey];
                                    delete obj[charkey];
                                }
                                else {
                                    if (_this.options.trim) {
                                        obj[charkey] = obj[charkey].trim();
                                    }
                                    if (_this.options.normalize) {
                                        obj[charkey] = obj[charkey].replace(/\s{2,}/g, " ").trim();
                                    }
                                    obj[charkey] = _this.options.valueProcessors ? processItem(_this.options.valueProcessors, obj[charkey], nodeName) : obj[charkey];
                                    if (Object.keys(obj).length === 1 && charkey in obj && !_this.EXPLICIT_CHARKEY) {
                                        obj = obj[charkey];
                                    }
                                }
                                if (isEmpty(obj)) {
                                    if (typeof _this.options.emptyTag === 'function') {
                                        obj = _this.options.emptyTag();
                                    }
                                    else {
                                        obj = _this.options.emptyTag !== '' ? _this.options.emptyTag : emptyStr;
                                    }
                                }
                                if (_this.options.validator != null) {
                                    xpath = "/" + ((function () {
                                        var i, len, results;
                                        results = [];
                                        for (i = 0, len = stack.length; i < len; i++) {
                                            node = stack[i];
                                            results.push(node["#name"]);
                                        }
                                        return results;
                                    })()).concat(nodeName).join("/");
                                    (function () {
                                        var err;
                                        try {
                                            return obj = _this.options.validator(xpath, s && s[nodeName], obj);
                                        }
                                        catch (error1) {
                                            err = error1;
                                            return _this.emit("error", err);
                                        }
                                    })();
                                }
                                if (_this.options.explicitChildren && !_this.options.mergeAttrs && typeof obj === 'object') {
                                    if (!_this.options.preserveChildrenOrder) {
                                        node = {};
                                        if (_this.options.attrkey in obj) {
                                            node[_this.options.attrkey] = obj[_this.options.attrkey];
                                            delete obj[_this.options.attrkey];
                                        }
                                        if (!_this.options.charsAsChildren && _this.options.charkey in obj) {
                                            node[_this.options.charkey] = obj[_this.options.charkey];
                                            delete obj[_this.options.charkey];
                                        }
                                        if (Object.getOwnPropertyNames(obj).length > 0) {
                                            node[_this.options.childkey] = obj;
                                        }
                                        obj = node;
                                    }
                                    else if (s) {
                                        s[_this.options.childkey] = s[_this.options.childkey] || [];
                                        objClone = {};
                                        for (key in obj) {
                                            if (!hasProp.call(obj, key))
                                                continue;
                                            defineProperty(objClone, key, obj[key]);
                                        }
                                        s[_this.options.childkey].push(objClone);
                                        delete obj["#name"];
                                        if (Object.keys(obj).length === 1 && charkey in obj && !_this.EXPLICIT_CHARKEY) {
                                            obj = obj[charkey];
                                        }
                                    }
                                }
                                if (stack.length > 0) {
                                    return _this.assignOrPush(s, nodeName, obj);
                                }
                                else {
                                    if (_this.options.explicitRoot) {
                                        old = obj;
                                        obj = {};
                                        defineProperty(obj, nodeName, old);
                                    }
                                    _this.resultObject = obj;
                                    _this.saxParser.ended = true;
                                    return _this.emit("end", _this.resultObject);
                                }
                            };
                        })(this);
                        ontext = (function (_this) {
                            return function (text) {
                                var charChild, s;
                                s = stack[stack.length - 1];
                                if (s) {
                                    s[charkey] += text;
                                    if (_this.options.explicitChildren && _this.options.preserveChildrenOrder && _this.options.charsAsChildren && (_this.options.includeWhiteChars || text.replace(/\\n/g, '').trim() !== '')) {
                                        s[_this.options.childkey] = s[_this.options.childkey] || [];
                                        charChild = {
                                            '#name': '__text__'
                                        };
                                        charChild[charkey] = text;
                                        if (_this.options.normalize) {
                                            charChild[charkey] = charChild[charkey].replace(/\s{2,}/g, " ").trim();
                                        }
                                        s[_this.options.childkey].push(charChild);
                                    }
                                    return s;
                                }
                            };
                        })(this);
                        this.saxParser.ontext = ontext;
                        return this.saxParser.oncdata = (function (_this) {
                            return function (text) {
                                var s;
                                s = ontext(text);
                                if (s) {
                                    return s.cdata = true;
                                }
                            };
                        })(this);
                    };
                    Parser.prototype.parseString = function (str, cb) {
                        var err;
                        if ((cb != null) && typeof cb === "function") {
                            this.on("end", function (result) {
                                this.reset();
                                return cb(null, result);
                            });
                            this.on("error", function (err) {
                                this.reset();
                                return cb(err);
                            });
                        }
                        try {
                            str = str.toString();
                            if (str.trim() === '') {
                                this.emit("end", null);
                                return true;
                            }
                            str = bom.stripBOM(str);
                            if (this.options.async) {
                                this.remaining = str;
                                setImmediate(this.processAsync);
                                return this.saxParser;
                            }
                            return this.saxParser.write(str).close();
                        }
                        catch (error1) {
                            err = error1;
                            if (!(this.saxParser.errThrown || this.saxParser.ended)) {
                                this.emit('error', err);
                                return this.saxParser.errThrown = true;
                            }
                            else if (this.saxParser.ended) {
                                throw err;
                            }
                        }
                    };
                    Parser.prototype.parseStringPromise = function (str) {
                        return new Promise((function (_this) {
                            return function (resolve, reject) {
                                return _this.parseString(str, function (err, value) {
                                    if (err) {
                                        return reject(err);
                                    }
                                    else {
                                        return resolve(value);
                                    }
                                });
                            };
                        })(this));
                    };
                    return Parser;
                })(events);
                exports.parseString = function (str, a, b) {
                    var cb, options, parser;
                    if (b != null) {
                        if (typeof b === 'function') {
                            cb = b;
                        }
                        if (typeof a === 'object') {
                            options = a;
                        }
                    }
                    else {
                        if (typeof a === 'function') {
                            cb = a;
                        }
                        options = {};
                    }
                    parser = new exports.Parser(options);
                    return parser.parseString(str, cb);
                };
                exports.parseStringPromise = function (str, a) {
                    var options, parser;
                    if (typeof a === 'object') {
                        options = a;
                    }
                    parser = new exports.Parser(options);
                    return parser.parseStringPromise(str);
                };
            }).call(this);
            /***/ 
        }),
        /***/ "./node_modules/xml2js/lib/processors.js": 
        /*!***********************************************!*\
          !*** ./node_modules/xml2js/lib/processors.js ***!
          \***********************************************/
        /***/ (function (__unused_webpack_module, exports) {
            // Generated by CoffeeScript 1.12.7
            (function () {
                "use strict";
                var prefixMatch;
                prefixMatch = new RegExp(/(?!xmlns)^.*:/);
                exports.normalize = function (str) {
                    return str.toLowerCase();
                };
                exports.firstCharLowerCase = function (str) {
                    return str.charAt(0).toLowerCase() + str.slice(1);
                };
                exports.stripPrefix = function (str) {
                    return str.replace(prefixMatch, '');
                };
                exports.parseNumbers = function (str) {
                    if (!isNaN(str)) {
                        str = str % 1 === 0 ? parseInt(str, 10) : parseFloat(str);
                    }
                    return str;
                };
                exports.parseBooleans = function (str) {
                    if (/^(?:true|false)$/i.test(str)) {
                        str = str.toLowerCase() === 'true';
                    }
                    return str;
                };
            }).call(this);
            /***/ 
        }),
        /***/ "./node_modules/xml2js/lib/xml2js.js": 
        /*!*******************************************!*\
          !*** ./node_modules/xml2js/lib/xml2js.js ***!
          \*******************************************/
        /***/ (function (__unused_webpack_module, exports, __webpack_require__) {
            // Generated by CoffeeScript 1.12.7
            (function () {
                "use strict";
                var builder, defaults, parser, processors, extend = function (child, parent) { for (var key in parent) {
                    if (hasProp.call(parent, key))
                        child[key] = parent[key];
                } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty;
                defaults = __webpack_require__(/*! ./defaults */ "./node_modules/xml2js/lib/defaults.js");
                builder = __webpack_require__(/*! ./builder */ "./node_modules/xml2js/lib/builder.js");
                parser = __webpack_require__(/*! ./parser */ "./node_modules/xml2js/lib/parser.js");
                processors = __webpack_require__(/*! ./processors */ "./node_modules/xml2js/lib/processors.js");
                exports.defaults = defaults.defaults;
                exports.processors = processors;
                exports.ValidationError = (function (superClass) {
                    extend(ValidationError, superClass);
                    function ValidationError(message) {
                        this.message = message;
                    }
                    return ValidationError;
                })(Error);
                exports.Builder = builder.Builder;
                exports.Parser = parser.Parser;
                exports.parseString = parser.parseString;
                exports.parseStringPromise = parser.parseStringPromise;
            }).call(this);
            /***/ 
        }),
        /***/ "./node_modules/xml2js/node_modules/xmlbuilder/lib/DocumentPosition.js": 
        /*!*****************************************************************************!*\
          !*** ./node_modules/xml2js/node_modules/xmlbuilder/lib/DocumentPosition.js ***!
          \*****************************************************************************/
        /***/ (function (module) {
            // Generated by CoffeeScript 1.12.7
            (function () {
                module.exports = {
                    Disconnected: 1,
                    Preceding: 2,
                    Following: 4,
                    Contains: 8,
                    ContainedBy: 16,
                    ImplementationSpecific: 32
                };
            }).call(this);
            /***/ 
        }),
        /***/ "./node_modules/xml2js/node_modules/xmlbuilder/lib/NodeType.js": 
        /*!*********************************************************************!*\
          !*** ./node_modules/xml2js/node_modules/xmlbuilder/lib/NodeType.js ***!
          \*********************************************************************/
        /***/ (function (module) {
            // Generated by CoffeeScript 1.12.7
            (function () {
                module.exports = {
                    Element: 1,
                    Attribute: 2,
                    Text: 3,
                    CData: 4,
                    EntityReference: 5,
                    EntityDeclaration: 6,
                    ProcessingInstruction: 7,
                    Comment: 8,
                    Document: 9,
                    DocType: 10,
                    DocumentFragment: 11,
                    NotationDeclaration: 12,
                    Declaration: 201,
                    Raw: 202,
                    AttributeDeclaration: 203,
                    ElementDeclaration: 204,
                    Dummy: 205
                };
            }).call(this);
            /***/ 
        }),
        /***/ "./node_modules/xml2js/node_modules/xmlbuilder/lib/Utility.js": 
        /*!********************************************************************!*\
          !*** ./node_modules/xml2js/node_modules/xmlbuilder/lib/Utility.js ***!
          \********************************************************************/
        /***/ (function (module) {
            // Generated by CoffeeScript 1.12.7
            (function () {
                var assign, getValue, isArray, isEmpty, isFunction, isObject, isPlainObject, slice = [].slice, hasProp = {}.hasOwnProperty;
                assign = function () {
                    var i, key, len, source, sources, target;
                    target = arguments[0], sources = 2 <= arguments.length ? slice.call(arguments, 1) : [];
                    if (isFunction(Object.assign)) {
                        Object.assign.apply(null, arguments);
                    }
                    else {
                        for (i = 0, len = sources.length; i < len; i++) {
                            source = sources[i];
                            if (source != null) {
                                for (key in source) {
                                    if (!hasProp.call(source, key))
                                        continue;
                                    target[key] = source[key];
                                }
                            }
                        }
                    }
                    return target;
                };
                isFunction = function (val) {
                    return !!val && Object.prototype.toString.call(val) === '[object Function]';
                };
                isObject = function (val) {
                    var ref;
                    return !!val && ((ref = typeof val) === 'function' || ref === 'object');
                };
                isArray = function (val) {
                    if (isFunction(Array.isArray)) {
                        return Array.isArray(val);
                    }
                    else {
                        return Object.prototype.toString.call(val) === '[object Array]';
                    }
                };
                isEmpty = function (val) {
                    var key;
                    if (isArray(val)) {
                        return !val.length;
                    }
                    else {
                        for (key in val) {
                            if (!hasProp.call(val, key))
                                continue;
                            return false;
                        }
                        return true;
                    }
                };
                isPlainObject = function (val) {
                    var ctor, proto;
                    return isObject(val) && (proto = Object.getPrototypeOf(val)) && (ctor = proto.constructor) && (typeof ctor === 'function') && (ctor instanceof ctor) && (Function.prototype.toString.call(ctor) === Function.prototype.toString.call(Object));
                };
                getValue = function (obj) {
                    if (isFunction(obj.valueOf)) {
                        return obj.valueOf();
                    }
                    else {
                        return obj;
                    }
                };
                module.exports.assign = assign;
                module.exports.isFunction = isFunction;
                module.exports.isObject = isObject;
                module.exports.isArray = isArray;
                module.exports.isEmpty = isEmpty;
                module.exports.isPlainObject = isPlainObject;
                module.exports.getValue = getValue;
            }).call(this);
            /***/ 
        }),
        /***/ "./node_modules/xml2js/node_modules/xmlbuilder/lib/WriterState.js": 
        /*!************************************************************************!*\
          !*** ./node_modules/xml2js/node_modules/xmlbuilder/lib/WriterState.js ***!
          \************************************************************************/
        /***/ (function (module) {
            // Generated by CoffeeScript 1.12.7
            (function () {
                module.exports = {
                    None: 0,
                    OpenTag: 1,
                    InsideTag: 2,
                    CloseTag: 3
                };
            }).call(this);
            /***/ 
        }),
        /***/ "./node_modules/xml2js/node_modules/xmlbuilder/lib/XMLAttribute.js": 
        /*!*************************************************************************!*\
          !*** ./node_modules/xml2js/node_modules/xmlbuilder/lib/XMLAttribute.js ***!
          \*************************************************************************/
        /***/ (function (module, __unused_webpack_exports, __webpack_require__) {
            // Generated by CoffeeScript 1.12.7
            (function () {
                var NodeType, XMLAttribute, XMLNode;
                NodeType = __webpack_require__(/*! ./NodeType */ "./node_modules/xml2js/node_modules/xmlbuilder/lib/NodeType.js");
                XMLNode = __webpack_require__(/*! ./XMLNode */ "./node_modules/xml2js/node_modules/xmlbuilder/lib/XMLNode.js");
                module.exports = XMLAttribute = (function () {
                    function XMLAttribute(parent, name, value) {
                        this.parent = parent;
                        if (this.parent) {
                            this.options = this.parent.options;
                            this.stringify = this.parent.stringify;
                        }
                        if (name == null) {
                            throw new Error("Missing attribute name. " + this.debugInfo(name));
                        }
                        this.name = this.stringify.name(name);
                        this.value = this.stringify.attValue(value);
                        this.type = NodeType.Attribute;
                        this.isId = false;
                        this.schemaTypeInfo = null;
                    }
                    Object.defineProperty(XMLAttribute.prototype, 'nodeType', {
                        get: function () {
                            return this.type;
                        }
                    });
                    Object.defineProperty(XMLAttribute.prototype, 'ownerElement', {
                        get: function () {
                            return this.parent;
                        }
                    });
                    Object.defineProperty(XMLAttribute.prototype, 'textContent', {
                        get: function () {
                            return this.value;
                        },
                        set: function (value) {
                            return this.value = value || '';
                        }
                    });
                    Object.defineProperty(XMLAttribute.prototype, 'namespaceURI', {
                        get: function () {
                            return '';
                        }
                    });
                    Object.defineProperty(XMLAttribute.prototype, 'prefix', {
                        get: function () {
                            return '';
                        }
                    });
                    Object.defineProperty(XMLAttribute.prototype, 'localName', {
                        get: function () {
                            return this.name;
                        }
                    });
                    Object.defineProperty(XMLAttribute.prototype, 'specified', {
                        get: function () {
                            return true;
                        }
                    });
                    XMLAttribute.prototype.clone = function () {
                        return Object.create(this);
                    };
                    XMLAttribute.prototype.toString = function (options) {
                        return this.options.writer.attribute(this, this.options.writer.filterOptions(options));
                    };
                    XMLAttribute.prototype.debugInfo = function (name) {
                        name = name || this.name;
                        if (name == null) {
                            return "parent: <" + this.parent.name + ">";
                        }
                        else {
                            return "attribute: {" + name + "}, parent: <" + this.parent.name + ">";
                        }
                    };
                    XMLAttribute.prototype.isEqualNode = function (node) {
                        if (node.namespaceURI !== this.namespaceURI) {
                            return false;
                        }
                        if (node.prefix !== this.prefix) {
                            return false;
                        }
                        if (node.localName !== this.localName) {
                            return false;
                        }
                        if (node.value !== this.value) {
                            return false;
                        }
                        return true;
                    };
                    return XMLAttribute;
                })();
            }).call(this);
            /***/ 
        }),
        /***/ "./node_modules/xml2js/node_modules/xmlbuilder/lib/XMLCData.js": 
        /*!*********************************************************************!*\
          !*** ./node_modules/xml2js/node_modules/xmlbuilder/lib/XMLCData.js ***!
          \*********************************************************************/
        /***/ (function (module, __unused_webpack_exports, __webpack_require__) {
            // Generated by CoffeeScript 1.12.7
            (function () {
                var NodeType, XMLCData, XMLCharacterData, extend = function (child, parent) { for (var key in parent) {
                    if (hasProp.call(parent, key))
                        child[key] = parent[key];
                } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty;
                NodeType = __webpack_require__(/*! ./NodeType */ "./node_modules/xml2js/node_modules/xmlbuilder/lib/NodeType.js");
                XMLCharacterData = __webpack_require__(/*! ./XMLCharacterData */ "./node_modules/xml2js/node_modules/xmlbuilder/lib/XMLCharacterData.js");
                module.exports = XMLCData = (function (superClass) {
                    extend(XMLCData, superClass);
                    function XMLCData(parent, text) {
                        XMLCData.__super__.constructor.call(this, parent);
                        if (text == null) {
                            throw new Error("Missing CDATA text. " + this.debugInfo());
                        }
                        this.name = "#cdata-section";
                        this.type = NodeType.CData;
                        this.value = this.stringify.cdata(text);
                    }
                    XMLCData.prototype.clone = function () {
                        return Object.create(this);
                    };
                    XMLCData.prototype.toString = function (options) {
                        return this.options.writer.cdata(this, this.options.writer.filterOptions(options));
                    };
                    return XMLCData;
                })(XMLCharacterData);
            }).call(this);
            /***/ 
        }),
        /***/ "./node_modules/xml2js/node_modules/xmlbuilder/lib/XMLCharacterData.js": 
        /*!*****************************************************************************!*\
          !*** ./node_modules/xml2js/node_modules/xmlbuilder/lib/XMLCharacterData.js ***!
          \*****************************************************************************/
        /***/ (function (module, __unused_webpack_exports, __webpack_require__) {
            // Generated by CoffeeScript 1.12.7
            (function () {
                var XMLCharacterData, XMLNode, extend = function (child, parent) { for (var key in parent) {
                    if (hasProp.call(parent, key))
                        child[key] = parent[key];
                } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty;
                XMLNode = __webpack_require__(/*! ./XMLNode */ "./node_modules/xml2js/node_modules/xmlbuilder/lib/XMLNode.js");
                module.exports = XMLCharacterData = (function (superClass) {
                    extend(XMLCharacterData, superClass);
                    function XMLCharacterData(parent) {
                        XMLCharacterData.__super__.constructor.call(this, parent);
                        this.value = '';
                    }
                    Object.defineProperty(XMLCharacterData.prototype, 'data', {
                        get: function () {
                            return this.value;
                        },
                        set: function (value) {
                            return this.value = value || '';
                        }
                    });
                    Object.defineProperty(XMLCharacterData.prototype, 'length', {
                        get: function () {
                            return this.value.length;
                        }
                    });
                    Object.defineProperty(XMLCharacterData.prototype, 'textContent', {
                        get: function () {
                            return this.value;
                        },
                        set: function (value) {
                            return this.value = value || '';
                        }
                    });
                    XMLCharacterData.prototype.clone = function () {
                        return Object.create(this);
                    };
                    XMLCharacterData.prototype.substringData = function (offset, count) {
                        throw new Error("This DOM method is not implemented." + this.debugInfo());
                    };
                    XMLCharacterData.prototype.appendData = function (arg) {
                        throw new Error("This DOM method is not implemented." + this.debugInfo());
                    };
                    XMLCharacterData.prototype.insertData = function (offset, arg) {
                        throw new Error("This DOM method is not implemented." + this.debugInfo());
                    };
                    XMLCharacterData.prototype.deleteData = function (offset, count) {
                        throw new Error("This DOM method is not implemented." + this.debugInfo());
                    };
                    XMLCharacterData.prototype.replaceData = function (offset, count, arg) {
                        throw new Error("This DOM method is not implemented." + this.debugInfo());
                    };
                    XMLCharacterData.prototype.isEqualNode = function (node) {
                        if (!XMLCharacterData.__super__.isEqualNode.apply(this, arguments).isEqualNode(node)) {
                            return false;
                        }
                        if (node.data !== this.data) {
                            return false;
                        }
                        return true;
                    };
                    return XMLCharacterData;
                })(XMLNode);
            }).call(this);
            /***/ 
        }),
        /***/ "./node_modules/xml2js/node_modules/xmlbuilder/lib/XMLComment.js": 
        /*!***********************************************************************!*\
          !*** ./node_modules/xml2js/node_modules/xmlbuilder/lib/XMLComment.js ***!
          \***********************************************************************/
        /***/ (function (module, __unused_webpack_exports, __webpack_require__) {
            // Generated by CoffeeScript 1.12.7
            (function () {
                var NodeType, XMLCharacterData, XMLComment, extend = function (child, parent) { for (var key in parent) {
                    if (hasProp.call(parent, key))
                        child[key] = parent[key];
                } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty;
                NodeType = __webpack_require__(/*! ./NodeType */ "./node_modules/xml2js/node_modules/xmlbuilder/lib/NodeType.js");
                XMLCharacterData = __webpack_require__(/*! ./XMLCharacterData */ "./node_modules/xml2js/node_modules/xmlbuilder/lib/XMLCharacterData.js");
                module.exports = XMLComment = (function (superClass) {
                    extend(XMLComment, superClass);
                    function XMLComment(parent, text) {
                        XMLComment.__super__.constructor.call(this, parent);
                        if (text == null) {
                            throw new Error("Missing comment text. " + this.debugInfo());
                        }
                        this.name = "#comment";
                        this.type = NodeType.Comment;
                        this.value = this.stringify.comment(text);
                    }
                    XMLComment.prototype.clone = function () {
                        return Object.create(this);
                    };
                    XMLComment.prototype.toString = function (options) {
                        return this.options.writer.comment(this, this.options.writer.filterOptions(options));
                    };
                    return XMLComment;
                })(XMLCharacterData);
            }).call(this);
            /***/ 
        }),
        /***/ "./node_modules/xml2js/node_modules/xmlbuilder/lib/XMLDOMConfiguration.js": 
        /*!********************************************************************************!*\
          !*** ./node_modules/xml2js/node_modules/xmlbuilder/lib/XMLDOMConfiguration.js ***!
          \********************************************************************************/
        /***/ (function (module, __unused_webpack_exports, __webpack_require__) {
            // Generated by CoffeeScript 1.12.7
            (function () {
                var XMLDOMConfiguration, XMLDOMErrorHandler, XMLDOMStringList;
                XMLDOMErrorHandler = __webpack_require__(/*! ./XMLDOMErrorHandler */ "./node_modules/xml2js/node_modules/xmlbuilder/lib/XMLDOMErrorHandler.js");
                XMLDOMStringList = __webpack_require__(/*! ./XMLDOMStringList */ "./node_modules/xml2js/node_modules/xmlbuilder/lib/XMLDOMStringList.js");
                module.exports = XMLDOMConfiguration = (function () {
                    function XMLDOMConfiguration() {
                        var clonedSelf;
                        this.defaultParams = {
                            "canonical-form": false,
                            "cdata-sections": false,
                            "comments": false,
                            "datatype-normalization": false,
                            "element-content-whitespace": true,
                            "entities": true,
                            "error-handler": new XMLDOMErrorHandler(),
                            "infoset": true,
                            "validate-if-schema": false,
                            "namespaces": true,
                            "namespace-declarations": true,
                            "normalize-characters": false,
                            "schema-location": '',
                            "schema-type": '',
                            "split-cdata-sections": true,
                            "validate": false,
                            "well-formed": true
                        };
                        this.params = clonedSelf = Object.create(this.defaultParams);
                    }
                    Object.defineProperty(XMLDOMConfiguration.prototype, 'parameterNames', {
                        get: function () {
                            return new XMLDOMStringList(Object.keys(this.defaultParams));
                        }
                    });
                    XMLDOMConfiguration.prototype.getParameter = function (name) {
                        if (this.params.hasOwnProperty(name)) {
                            return this.params[name];
                        }
                        else {
                            return null;
                        }
                    };
                    XMLDOMConfiguration.prototype.canSetParameter = function (name, value) {
                        return true;
                    };
                    XMLDOMConfiguration.prototype.setParameter = function (name, value) {
                        if (value != null) {
                            return this.params[name] = value;
                        }
                        else {
                            return delete this.params[name];
                        }
                    };
                    return XMLDOMConfiguration;
                })();
            }).call(this);
            /***/ 
        }),
        /***/ "./node_modules/xml2js/node_modules/xmlbuilder/lib/XMLDOMErrorHandler.js": 
        /*!*******************************************************************************!*\
          !*** ./node_modules/xml2js/node_modules/xmlbuilder/lib/XMLDOMErrorHandler.js ***!
          \*******************************************************************************/
        /***/ (function (module) {
            // Generated by CoffeeScript 1.12.7
            (function () {
                var XMLDOMErrorHandler;
                module.exports = XMLDOMErrorHandler = (function () {
                    function XMLDOMErrorHandler() { }
                    XMLDOMErrorHandler.prototype.handleError = function (error) {
                        throw new Error(error);
                    };
                    return XMLDOMErrorHandler;
                })();
            }).call(this);
            /***/ 
        }),
        /***/ "./node_modules/xml2js/node_modules/xmlbuilder/lib/XMLDOMImplementation.js": 
        /*!*********************************************************************************!*\
          !*** ./node_modules/xml2js/node_modules/xmlbuilder/lib/XMLDOMImplementation.js ***!
          \*********************************************************************************/
        /***/ (function (module) {
            // Generated by CoffeeScript 1.12.7
            (function () {
                var XMLDOMImplementation;
                module.exports = XMLDOMImplementation = (function () {
                    function XMLDOMImplementation() { }
                    XMLDOMImplementation.prototype.hasFeature = function (feature, version) {
                        return true;
                    };
                    XMLDOMImplementation.prototype.createDocumentType = function (qualifiedName, publicId, systemId) {
                        throw new Error("This DOM method is not implemented.");
                    };
                    XMLDOMImplementation.prototype.createDocument = function (namespaceURI, qualifiedName, doctype) {
                        throw new Error("This DOM method is not implemented.");
                    };
                    XMLDOMImplementation.prototype.createHTMLDocument = function (title) {
                        throw new Error("This DOM method is not implemented.");
                    };
                    XMLDOMImplementation.prototype.getFeature = function (feature, version) {
                        throw new Error("This DOM method is not implemented.");
                    };
                    return XMLDOMImplementation;
                })();
            }).call(this);
            /***/ 
        }),
        /***/ "./node_modules/xml2js/node_modules/xmlbuilder/lib/XMLDOMStringList.js": 
        /*!*****************************************************************************!*\
          !*** ./node_modules/xml2js/node_modules/xmlbuilder/lib/XMLDOMStringList.js ***!
          \*****************************************************************************/
        /***/ (function (module) {
            // Generated by CoffeeScript 1.12.7
            (function () {
                var XMLDOMStringList;
                module.exports = XMLDOMStringList = (function () {
                    function XMLDOMStringList(arr) {
                        this.arr = arr || [];
                    }
                    Object.defineProperty(XMLDOMStringList.prototype, 'length', {
                        get: function () {
                            return this.arr.length;
                        }
                    });
                    XMLDOMStringList.prototype.item = function (index) {
                        return this.arr[index] || null;
                    };
                    XMLDOMStringList.prototype.contains = function (str) {
                        return this.arr.indexOf(str) !== -1;
                    };
                    return XMLDOMStringList;
                })();
            }).call(this);
            /***/ 
        }),
        /***/ "./node_modules/xml2js/node_modules/xmlbuilder/lib/XMLDTDAttList.js": 
        /*!**************************************************************************!*\
          !*** ./node_modules/xml2js/node_modules/xmlbuilder/lib/XMLDTDAttList.js ***!
          \**************************************************************************/
        /***/ (function (module, __unused_webpack_exports, __webpack_require__) {
            // Generated by CoffeeScript 1.12.7
            (function () {
                var NodeType, XMLDTDAttList, XMLNode, extend = function (child, parent) { for (var key in parent) {
                    if (hasProp.call(parent, key))
                        child[key] = parent[key];
                } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty;
                XMLNode = __webpack_require__(/*! ./XMLNode */ "./node_modules/xml2js/node_modules/xmlbuilder/lib/XMLNode.js");
                NodeType = __webpack_require__(/*! ./NodeType */ "./node_modules/xml2js/node_modules/xmlbuilder/lib/NodeType.js");
                module.exports = XMLDTDAttList = (function (superClass) {
                    extend(XMLDTDAttList, superClass);
                    function XMLDTDAttList(parent, elementName, attributeName, attributeType, defaultValueType, defaultValue) {
                        XMLDTDAttList.__super__.constructor.call(this, parent);
                        if (elementName == null) {
                            throw new Error("Missing DTD element name. " + this.debugInfo());
                        }
                        if (attributeName == null) {
                            throw new Error("Missing DTD attribute name. " + this.debugInfo(elementName));
                        }
                        if (!attributeType) {
                            throw new Error("Missing DTD attribute type. " + this.debugInfo(elementName));
                        }
                        if (!defaultValueType) {
                            throw new Error("Missing DTD attribute default. " + this.debugInfo(elementName));
                        }
                        if (defaultValueType.indexOf('#') !== 0) {
                            defaultValueType = '#' + defaultValueType;
                        }
                        if (!defaultValueType.match(/^(#REQUIRED|#IMPLIED|#FIXED|#DEFAULT)$/)) {
                            throw new Error("Invalid default value type; expected: #REQUIRED, #IMPLIED, #FIXED or #DEFAULT. " + this.debugInfo(elementName));
                        }
                        if (defaultValue && !defaultValueType.match(/^(#FIXED|#DEFAULT)$/)) {
                            throw new Error("Default value only applies to #FIXED or #DEFAULT. " + this.debugInfo(elementName));
                        }
                        this.elementName = this.stringify.name(elementName);
                        this.type = NodeType.AttributeDeclaration;
                        this.attributeName = this.stringify.name(attributeName);
                        this.attributeType = this.stringify.dtdAttType(attributeType);
                        if (defaultValue) {
                            this.defaultValue = this.stringify.dtdAttDefault(defaultValue);
                        }
                        this.defaultValueType = defaultValueType;
                    }
                    XMLDTDAttList.prototype.toString = function (options) {
                        return this.options.writer.dtdAttList(this, this.options.writer.filterOptions(options));
                    };
                    return XMLDTDAttList;
                })(XMLNode);
            }).call(this);
            /***/ 
        }),
        /***/ "./node_modules/xml2js/node_modules/xmlbuilder/lib/XMLDTDElement.js": 
        /*!**************************************************************************!*\
          !*** ./node_modules/xml2js/node_modules/xmlbuilder/lib/XMLDTDElement.js ***!
          \**************************************************************************/
        /***/ (function (module, __unused_webpack_exports, __webpack_require__) {
            // Generated by CoffeeScript 1.12.7
            (function () {
                var NodeType, XMLDTDElement, XMLNode, extend = function (child, parent) { for (var key in parent) {
                    if (hasProp.call(parent, key))
                        child[key] = parent[key];
                } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty;
                XMLNode = __webpack_require__(/*! ./XMLNode */ "./node_modules/xml2js/node_modules/xmlbuilder/lib/XMLNode.js");
                NodeType = __webpack_require__(/*! ./NodeType */ "./node_modules/xml2js/node_modules/xmlbuilder/lib/NodeType.js");
                module.exports = XMLDTDElement = (function (superClass) {
                    extend(XMLDTDElement, superClass);
                    function XMLDTDElement(parent, name, value) {
                        XMLDTDElement.__super__.constructor.call(this, parent);
                        if (name == null) {
                            throw new Error("Missing DTD element name. " + this.debugInfo());
                        }
                        if (!value) {
                            value = '(#PCDATA)';
                        }
                        if (Array.isArray(value)) {
                            value = '(' + value.join(',') + ')';
                        }
                        this.name = this.stringify.name(name);
                        this.type = NodeType.ElementDeclaration;
                        this.value = this.stringify.dtdElementValue(value);
                    }
                    XMLDTDElement.prototype.toString = function (options) {
                        return this.options.writer.dtdElement(this, this.options.writer.filterOptions(options));
                    };
                    return XMLDTDElement;
                })(XMLNode);
            }).call(this);
            /***/ 
        }),
        /***/ "./node_modules/xml2js/node_modules/xmlbuilder/lib/XMLDTDEntity.js": 
        /*!*************************************************************************!*\
          !*** ./node_modules/xml2js/node_modules/xmlbuilder/lib/XMLDTDEntity.js ***!
          \*************************************************************************/
        /***/ (function (module, __unused_webpack_exports, __webpack_require__) {
            // Generated by CoffeeScript 1.12.7
            (function () {
                var NodeType, XMLDTDEntity, XMLNode, isObject, extend = function (child, parent) { for (var key in parent) {
                    if (hasProp.call(parent, key))
                        child[key] = parent[key];
                } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty;
                isObject = (__webpack_require__(/*! ./Utility */ "./node_modules/xml2js/node_modules/xmlbuilder/lib/Utility.js").isObject);
                XMLNode = __webpack_require__(/*! ./XMLNode */ "./node_modules/xml2js/node_modules/xmlbuilder/lib/XMLNode.js");
                NodeType = __webpack_require__(/*! ./NodeType */ "./node_modules/xml2js/node_modules/xmlbuilder/lib/NodeType.js");
                module.exports = XMLDTDEntity = (function (superClass) {
                    extend(XMLDTDEntity, superClass);
                    function XMLDTDEntity(parent, pe, name, value) {
                        XMLDTDEntity.__super__.constructor.call(this, parent);
                        if (name == null) {
                            throw new Error("Missing DTD entity name. " + this.debugInfo(name));
                        }
                        if (value == null) {
                            throw new Error("Missing DTD entity value. " + this.debugInfo(name));
                        }
                        this.pe = !!pe;
                        this.name = this.stringify.name(name);
                        this.type = NodeType.EntityDeclaration;
                        if (!isObject(value)) {
                            this.value = this.stringify.dtdEntityValue(value);
                            this.internal = true;
                        }
                        else {
                            if (!value.pubID && !value.sysID) {
                                throw new Error("Public and/or system identifiers are required for an external entity. " + this.debugInfo(name));
                            }
                            if (value.pubID && !value.sysID) {
                                throw new Error("System identifier is required for a public external entity. " + this.debugInfo(name));
                            }
                            this.internal = false;
                            if (value.pubID != null) {
                                this.pubID = this.stringify.dtdPubID(value.pubID);
                            }
                            if (value.sysID != null) {
                                this.sysID = this.stringify.dtdSysID(value.sysID);
                            }
                            if (value.nData != null) {
                                this.nData = this.stringify.dtdNData(value.nData);
                            }
                            if (this.pe && this.nData) {
                                throw new Error("Notation declaration is not allowed in a parameter entity. " + this.debugInfo(name));
                            }
                        }
                    }
                    Object.defineProperty(XMLDTDEntity.prototype, 'publicId', {
                        get: function () {
                            return this.pubID;
                        }
                    });
                    Object.defineProperty(XMLDTDEntity.prototype, 'systemId', {
                        get: function () {
                            return this.sysID;
                        }
                    });
                    Object.defineProperty(XMLDTDEntity.prototype, 'notationName', {
                        get: function () {
                            return this.nData || null;
                        }
                    });
                    Object.defineProperty(XMLDTDEntity.prototype, 'inputEncoding', {
                        get: function () {
                            return null;
                        }
                    });
                    Object.defineProperty(XMLDTDEntity.prototype, 'xmlEncoding', {
                        get: function () {
                            return null;
                        }
                    });
                    Object.defineProperty(XMLDTDEntity.prototype, 'xmlVersion', {
                        get: function () {
                            return null;
                        }
                    });
                    XMLDTDEntity.prototype.toString = function (options) {
                        return this.options.writer.dtdEntity(this, this.options.writer.filterOptions(options));
                    };
                    return XMLDTDEntity;
                })(XMLNode);
            }).call(this);
            /***/ 
        }),
        /***/ "./node_modules/xml2js/node_modules/xmlbuilder/lib/XMLDTDNotation.js": 
        /*!***************************************************************************!*\
          !*** ./node_modules/xml2js/node_modules/xmlbuilder/lib/XMLDTDNotation.js ***!
          \***************************************************************************/
        /***/ (function (module, __unused_webpack_exports, __webpack_require__) {
            // Generated by CoffeeScript 1.12.7
            (function () {
                var NodeType, XMLDTDNotation, XMLNode, extend = function (child, parent) { for (var key in parent) {
                    if (hasProp.call(parent, key))
                        child[key] = parent[key];
                } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty;
                XMLNode = __webpack_require__(/*! ./XMLNode */ "./node_modules/xml2js/node_modules/xmlbuilder/lib/XMLNode.js");
                NodeType = __webpack_require__(/*! ./NodeType */ "./node_modules/xml2js/node_modules/xmlbuilder/lib/NodeType.js");
                module.exports = XMLDTDNotation = (function (superClass) {
                    extend(XMLDTDNotation, superClass);
                    function XMLDTDNotation(parent, name, value) {
                        XMLDTDNotation.__super__.constructor.call(this, parent);
                        if (name == null) {
                            throw new Error("Missing DTD notation name. " + this.debugInfo(name));
                        }
                        if (!value.pubID && !value.sysID) {
                            throw new Error("Public or system identifiers are required for an external entity. " + this.debugInfo(name));
                        }
                        this.name = this.stringify.name(name);
                        this.type = NodeType.NotationDeclaration;
                        if (value.pubID != null) {
                            this.pubID = this.stringify.dtdPubID(value.pubID);
                        }
                        if (value.sysID != null) {
                            this.sysID = this.stringify.dtdSysID(value.sysID);
                        }
                    }
                    Object.defineProperty(XMLDTDNotation.prototype, 'publicId', {
                        get: function () {
                            return this.pubID;
                        }
                    });
                    Object.defineProperty(XMLDTDNotation.prototype, 'systemId', {
                        get: function () {
                            return this.sysID;
                        }
                    });
                    XMLDTDNotation.prototype.toString = function (options) {
                        return this.options.writer.dtdNotation(this, this.options.writer.filterOptions(options));
                    };
                    return XMLDTDNotation;
                })(XMLNode);
            }).call(this);
            /***/ 
        }),
        /***/ "./node_modules/xml2js/node_modules/xmlbuilder/lib/XMLDeclaration.js": 
        /*!***************************************************************************!*\
          !*** ./node_modules/xml2js/node_modules/xmlbuilder/lib/XMLDeclaration.js ***!
          \***************************************************************************/
        /***/ (function (module, __unused_webpack_exports, __webpack_require__) {
            // Generated by CoffeeScript 1.12.7
            (function () {
                var NodeType, XMLDeclaration, XMLNode, isObject, extend = function (child, parent) { for (var key in parent) {
                    if (hasProp.call(parent, key))
                        child[key] = parent[key];
                } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty;
                isObject = (__webpack_require__(/*! ./Utility */ "./node_modules/xml2js/node_modules/xmlbuilder/lib/Utility.js").isObject);
                XMLNode = __webpack_require__(/*! ./XMLNode */ "./node_modules/xml2js/node_modules/xmlbuilder/lib/XMLNode.js");
                NodeType = __webpack_require__(/*! ./NodeType */ "./node_modules/xml2js/node_modules/xmlbuilder/lib/NodeType.js");
                module.exports = XMLDeclaration = (function (superClass) {
                    extend(XMLDeclaration, superClass);
                    function XMLDeclaration(parent, version, encoding, standalone) {
                        var ref;
                        XMLDeclaration.__super__.constructor.call(this, parent);
                        if (isObject(version)) {
                            ref = version, version = ref.version, encoding = ref.encoding, standalone = ref.standalone;
                        }
                        if (!version) {
                            version = '1.0';
                        }
                        this.type = NodeType.Declaration;
                        this.version = this.stringify.xmlVersion(version);
                        if (encoding != null) {
                            this.encoding = this.stringify.xmlEncoding(encoding);
                        }
                        if (standalone != null) {
                            this.standalone = this.stringify.xmlStandalone(standalone);
                        }
                    }
                    XMLDeclaration.prototype.toString = function (options) {
                        return this.options.writer.declaration(this, this.options.writer.filterOptions(options));
                    };
                    return XMLDeclaration;
                })(XMLNode);
            }).call(this);
            /***/ 
        }),
        /***/ "./node_modules/xml2js/node_modules/xmlbuilder/lib/XMLDocType.js": 
        /*!***********************************************************************!*\
          !*** ./node_modules/xml2js/node_modules/xmlbuilder/lib/XMLDocType.js ***!
          \***********************************************************************/
        /***/ (function (module, __unused_webpack_exports, __webpack_require__) {
            // Generated by CoffeeScript 1.12.7
            (function () {
                var NodeType, XMLDTDAttList, XMLDTDElement, XMLDTDEntity, XMLDTDNotation, XMLDocType, XMLNamedNodeMap, XMLNode, isObject, extend = function (child, parent) { for (var key in parent) {
                    if (hasProp.call(parent, key))
                        child[key] = parent[key];
                } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty;
                isObject = (__webpack_require__(/*! ./Utility */ "./node_modules/xml2js/node_modules/xmlbuilder/lib/Utility.js").isObject);
                XMLNode = __webpack_require__(/*! ./XMLNode */ "./node_modules/xml2js/node_modules/xmlbuilder/lib/XMLNode.js");
                NodeType = __webpack_require__(/*! ./NodeType */ "./node_modules/xml2js/node_modules/xmlbuilder/lib/NodeType.js");
                XMLDTDAttList = __webpack_require__(/*! ./XMLDTDAttList */ "./node_modules/xml2js/node_modules/xmlbuilder/lib/XMLDTDAttList.js");
                XMLDTDEntity = __webpack_require__(/*! ./XMLDTDEntity */ "./node_modules/xml2js/node_modules/xmlbuilder/lib/XMLDTDEntity.js");
                XMLDTDElement = __webpack_require__(/*! ./XMLDTDElement */ "./node_modules/xml2js/node_modules/xmlbuilder/lib/XMLDTDElement.js");
                XMLDTDNotation = __webpack_require__(/*! ./XMLDTDNotation */ "./node_modules/xml2js/node_modules/xmlbuilder/lib/XMLDTDNotation.js");
                XMLNamedNodeMap = __webpack_require__(/*! ./XMLNamedNodeMap */ "./node_modules/xml2js/node_modules/xmlbuilder/lib/XMLNamedNodeMap.js");
                module.exports = XMLDocType = (function (superClass) {
                    extend(XMLDocType, superClass);
                    function XMLDocType(parent, pubID, sysID) {
                        var child, i, len, ref, ref1, ref2;
                        XMLDocType.__super__.constructor.call(this, parent);
                        this.type = NodeType.DocType;
                        if (parent.children) {
                            ref = parent.children;
                            for (i = 0, len = ref.length; i < len; i++) {
                                child = ref[i];
                                if (child.type === NodeType.Element) {
                                    this.name = child.name;
                                    break;
                                }
                            }
                        }
                        this.documentObject = parent;
                        if (isObject(pubID)) {
                            ref1 = pubID, pubID = ref1.pubID, sysID = ref1.sysID;
                        }
                        if (sysID == null) {
                            ref2 = [pubID, sysID], sysID = ref2[0], pubID = ref2[1];
                        }
                        if (pubID != null) {
                            this.pubID = this.stringify.dtdPubID(pubID);
                        }
                        if (sysID != null) {
                            this.sysID = this.stringify.dtdSysID(sysID);
                        }
                    }
                    Object.defineProperty(XMLDocType.prototype, 'entities', {
                        get: function () {
                            var child, i, len, nodes, ref;
                            nodes = {};
                            ref = this.children;
                            for (i = 0, len = ref.length; i < len; i++) {
                                child = ref[i];
                                if ((child.type === NodeType.EntityDeclaration) && !child.pe) {
                                    nodes[child.name] = child;
                                }
                            }
                            return new XMLNamedNodeMap(nodes);
                        }
                    });
                    Object.defineProperty(XMLDocType.prototype, 'notations', {
                        get: function () {
                            var child, i, len, nodes, ref;
                            nodes = {};
                            ref = this.children;
                            for (i = 0, len = ref.length; i < len; i++) {
                                child = ref[i];
                                if (child.type === NodeType.NotationDeclaration) {
                                    nodes[child.name] = child;
                                }
                            }
                            return new XMLNamedNodeMap(nodes);
                        }
                    });
                    Object.defineProperty(XMLDocType.prototype, 'publicId', {
                        get: function () {
                            return this.pubID;
                        }
                    });
                    Object.defineProperty(XMLDocType.prototype, 'systemId', {
                        get: function () {
                            return this.sysID;
                        }
                    });
                    Object.defineProperty(XMLDocType.prototype, 'internalSubset', {
                        get: function () {
                            throw new Error("This DOM method is not implemented." + this.debugInfo());
                        }
                    });
                    XMLDocType.prototype.element = function (name, value) {
                        var child;
                        child = new XMLDTDElement(this, name, value);
                        this.children.push(child);
                        return this;
                    };
                    XMLDocType.prototype.attList = function (elementName, attributeName, attributeType, defaultValueType, defaultValue) {
                        var child;
                        child = new XMLDTDAttList(this, elementName, attributeName, attributeType, defaultValueType, defaultValue);
                        this.children.push(child);
                        return this;
                    };
                    XMLDocType.prototype.entity = function (name, value) {
                        var child;
                        child = new XMLDTDEntity(this, false, name, value);
                        this.children.push(child);
                        return this;
                    };
                    XMLDocType.prototype.pEntity = function (name, value) {
                        var child;
                        child = new XMLDTDEntity(this, true, name, value);
                        this.children.push(child);
                        return this;
                    };
                    XMLDocType.prototype.notation = function (name, value) {
                        var child;
                        child = new XMLDTDNotation(this, name, value);
                        this.children.push(child);
                        return this;
                    };
                    XMLDocType.prototype.toString = function (options) {
                        return this.options.writer.docType(this, this.options.writer.filterOptions(options));
                    };
                    XMLDocType.prototype.ele = function (name, value) {
                        return this.element(name, value);
                    };
                    XMLDocType.prototype.att = function (elementName, attributeName, attributeType, defaultValueType, defaultValue) {
                        return this.attList(elementName, attributeName, attributeType, defaultValueType, defaultValue);
                    };
                    XMLDocType.prototype.ent = function (name, value) {
                        return this.entity(name, value);
                    };
                    XMLDocType.prototype.pent = function (name, value) {
                        return this.pEntity(name, value);
                    };
                    XMLDocType.prototype.not = function (name, value) {
                        return this.notation(name, value);
                    };
                    XMLDocType.prototype.up = function () {
                        return this.root() || this.documentObject;
                    };
                    XMLDocType.prototype.isEqualNode = function (node) {
                        if (!XMLDocType.__super__.isEqualNode.apply(this, arguments).isEqualNode(node)) {
                            return false;
                        }
                        if (node.name !== this.name) {
                            return false;
                        }
                        if (node.publicId !== this.publicId) {
                            return false;
                        }
                        if (node.systemId !== this.systemId) {
                            return false;
                        }
                        return true;
                    };
                    return XMLDocType;
                })(XMLNode);
            }).call(this);
            /***/ 
        }),
        /***/ "./node_modules/xml2js/node_modules/xmlbuilder/lib/XMLDocument.js": 
        /*!************************************************************************!*\
          !*** ./node_modules/xml2js/node_modules/xmlbuilder/lib/XMLDocument.js ***!
          \************************************************************************/
        /***/ (function (module, __unused_webpack_exports, __webpack_require__) {
            // Generated by CoffeeScript 1.12.7
            (function () {
                var NodeType, XMLDOMConfiguration, XMLDOMImplementation, XMLDocument, XMLNode, XMLStringWriter, XMLStringifier, isPlainObject, extend = function (child, parent) { for (var key in parent) {
                    if (hasProp.call(parent, key))
                        child[key] = parent[key];
                } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty;
                isPlainObject = (__webpack_require__(/*! ./Utility */ "./node_modules/xml2js/node_modules/xmlbuilder/lib/Utility.js").isPlainObject);
                XMLDOMImplementation = __webpack_require__(/*! ./XMLDOMImplementation */ "./node_modules/xml2js/node_modules/xmlbuilder/lib/XMLDOMImplementation.js");
                XMLDOMConfiguration = __webpack_require__(/*! ./XMLDOMConfiguration */ "./node_modules/xml2js/node_modules/xmlbuilder/lib/XMLDOMConfiguration.js");
                XMLNode = __webpack_require__(/*! ./XMLNode */ "./node_modules/xml2js/node_modules/xmlbuilder/lib/XMLNode.js");
                NodeType = __webpack_require__(/*! ./NodeType */ "./node_modules/xml2js/node_modules/xmlbuilder/lib/NodeType.js");
                XMLStringifier = __webpack_require__(/*! ./XMLStringifier */ "./node_modules/xml2js/node_modules/xmlbuilder/lib/XMLStringifier.js");
                XMLStringWriter = __webpack_require__(/*! ./XMLStringWriter */ "./node_modules/xml2js/node_modules/xmlbuilder/lib/XMLStringWriter.js");
                module.exports = XMLDocument = (function (superClass) {
                    extend(XMLDocument, superClass);
                    function XMLDocument(options) {
                        XMLDocument.__super__.constructor.call(this, null);
                        this.name = "#document";
                        this.type = NodeType.Document;
                        this.documentURI = null;
                        this.domConfig = new XMLDOMConfiguration();
                        options || (options = {});
                        if (!options.writer) {
                            options.writer = new XMLStringWriter();
                        }
                        this.options = options;
                        this.stringify = new XMLStringifier(options);
                    }
                    Object.defineProperty(XMLDocument.prototype, 'implementation', {
                        value: new XMLDOMImplementation()
                    });
                    Object.defineProperty(XMLDocument.prototype, 'doctype', {
                        get: function () {
                            var child, i, len, ref;
                            ref = this.children;
                            for (i = 0, len = ref.length; i < len; i++) {
                                child = ref[i];
                                if (child.type === NodeType.DocType) {
                                    return child;
                                }
                            }
                            return null;
                        }
                    });
                    Object.defineProperty(XMLDocument.prototype, 'documentElement', {
                        get: function () {
                            return this.rootObject || null;
                        }
                    });
                    Object.defineProperty(XMLDocument.prototype, 'inputEncoding', {
                        get: function () {
                            return null;
                        }
                    });
                    Object.defineProperty(XMLDocument.prototype, 'strictErrorChecking', {
                        get: function () {
                            return false;
                        }
                    });
                    Object.defineProperty(XMLDocument.prototype, 'xmlEncoding', {
                        get: function () {
                            if (this.children.length !== 0 && this.children[0].type === NodeType.Declaration) {
                                return this.children[0].encoding;
                            }
                            else {
                                return null;
                            }
                        }
                    });
                    Object.defineProperty(XMLDocument.prototype, 'xmlStandalone', {
                        get: function () {
                            if (this.children.length !== 0 && this.children[0].type === NodeType.Declaration) {
                                return this.children[0].standalone === 'yes';
                            }
                            else {
                                return false;
                            }
                        }
                    });
                    Object.defineProperty(XMLDocument.prototype, 'xmlVersion', {
                        get: function () {
                            if (this.children.length !== 0 && this.children[0].type === NodeType.Declaration) {
                                return this.children[0].version;
                            }
                            else {
                                return "1.0";
                            }
                        }
                    });
                    Object.defineProperty(XMLDocument.prototype, 'URL', {
                        get: function () {
                            return this.documentURI;
                        }
                    });
                    Object.defineProperty(XMLDocument.prototype, 'origin', {
                        get: function () {
                            return null;
                        }
                    });
                    Object.defineProperty(XMLDocument.prototype, 'compatMode', {
                        get: function () {
                            return null;
                        }
                    });
                    Object.defineProperty(XMLDocument.prototype, 'characterSet', {
                        get: function () {
                            return null;
                        }
                    });
                    Object.defineProperty(XMLDocument.prototype, 'contentType', {
                        get: function () {
                            return null;
                        }
                    });
                    XMLDocument.prototype.end = function (writer) {
                        var writerOptions;
                        writerOptions = {};
                        if (!writer) {
                            writer = this.options.writer;
                        }
                        else if (isPlainObject(writer)) {
                            writerOptions = writer;
                            writer = this.options.writer;
                        }
                        return writer.document(this, writer.filterOptions(writerOptions));
                    };
                    XMLDocument.prototype.toString = function (options) {
                        return this.options.writer.document(this, this.options.writer.filterOptions(options));
                    };
                    XMLDocument.prototype.createElement = function (tagName) {
                        throw new Error("This DOM method is not implemented." + this.debugInfo());
                    };
                    XMLDocument.prototype.createDocumentFragment = function () {
                        throw new Error("This DOM method is not implemented." + this.debugInfo());
                    };
                    XMLDocument.prototype.createTextNode = function (data) {
                        throw new Error("This DOM method is not implemented." + this.debugInfo());
                    };
                    XMLDocument.prototype.createComment = function (data) {
                        throw new Error("This DOM method is not implemented." + this.debugInfo());
                    };
                    XMLDocument.prototype.createCDATASection = function (data) {
                        throw new Error("This DOM method is not implemented." + this.debugInfo());
                    };
                    XMLDocument.prototype.createProcessingInstruction = function (target, data) {
                        throw new Error("This DOM method is not implemented." + this.debugInfo());
                    };
                    XMLDocument.prototype.createAttribute = function (name) {
                        throw new Error("This DOM method is not implemented." + this.debugInfo());
                    };
                    XMLDocument.prototype.createEntityReference = function (name) {
                        throw new Error("This DOM method is not implemented." + this.debugInfo());
                    };
                    XMLDocument.prototype.getElementsByTagName = function (tagname) {
                        throw new Error("This DOM method is not implemented." + this.debugInfo());
                    };
                    XMLDocument.prototype.importNode = function (importedNode, deep) {
                        throw new Error("This DOM method is not implemented." + this.debugInfo());
                    };
                    XMLDocument.prototype.createElementNS = function (namespaceURI, qualifiedName) {
                        throw new Error("This DOM method is not implemented." + this.debugInfo());
                    };
                    XMLDocument.prototype.createAttributeNS = function (namespaceURI, qualifiedName) {
                        throw new Error("This DOM method is not implemented." + this.debugInfo());
                    };
                    XMLDocument.prototype.getElementsByTagNameNS = function (namespaceURI, localName) {
                        throw new Error("This DOM method is not implemented." + this.debugInfo());
                    };
                    XMLDocument.prototype.getElementById = function (elementId) {
                        throw new Error("This DOM method is not implemented." + this.debugInfo());
                    };
                    XMLDocument.prototype.adoptNode = function (source) {
                        throw new Error("This DOM method is not implemented." + this.debugInfo());
                    };
                    XMLDocument.prototype.normalizeDocument = function () {
                        throw new Error("This DOM method is not implemented." + this.debugInfo());
                    };
                    XMLDocument.prototype.renameNode = function (node, namespaceURI, qualifiedName) {
                        throw new Error("This DOM method is not implemented." + this.debugInfo());
                    };
                    XMLDocument.prototype.getElementsByClassName = function (classNames) {
                        throw new Error("This DOM method is not implemented." + this.debugInfo());
                    };
                    XMLDocument.prototype.createEvent = function (eventInterface) {
                        throw new Error("This DOM method is not implemented." + this.debugInfo());
                    };
                    XMLDocument.prototype.createRange = function () {
                        throw new Error("This DOM method is not implemented." + this.debugInfo());
                    };
                    XMLDocument.prototype.createNodeIterator = function (root, whatToShow, filter) {
                        throw new Error("This DOM method is not implemented." + this.debugInfo());
                    };
                    XMLDocument.prototype.createTreeWalker = function (root, whatToShow, filter) {
                        throw new Error("This DOM method is not implemented." + this.debugInfo());
                    };
                    return XMLDocument;
                })(XMLNode);
            }).call(this);
            /***/ 
        }),
        /***/ "./node_modules/xml2js/node_modules/xmlbuilder/lib/XMLDocumentCB.js": 
        /*!**************************************************************************!*\
          !*** ./node_modules/xml2js/node_modules/xmlbuilder/lib/XMLDocumentCB.js ***!
          \**************************************************************************/
        /***/ (function (module, __unused_webpack_exports, __webpack_require__) {
            // Generated by CoffeeScript 1.12.7
            (function () {
                var NodeType, WriterState, XMLAttribute, XMLCData, XMLComment, XMLDTDAttList, XMLDTDElement, XMLDTDEntity, XMLDTDNotation, XMLDeclaration, XMLDocType, XMLDocument, XMLDocumentCB, XMLElement, XMLProcessingInstruction, XMLRaw, XMLStringWriter, XMLStringifier, XMLText, getValue, isFunction, isObject, isPlainObject, ref, hasProp = {}.hasOwnProperty;
                ref = __webpack_require__(/*! ./Utility */ "./node_modules/xml2js/node_modules/xmlbuilder/lib/Utility.js"), isObject = ref.isObject, isFunction = ref.isFunction, isPlainObject = ref.isPlainObject, getValue = ref.getValue;
                NodeType = __webpack_require__(/*! ./NodeType */ "./node_modules/xml2js/node_modules/xmlbuilder/lib/NodeType.js");
                XMLDocument = __webpack_require__(/*! ./XMLDocument */ "./node_modules/xml2js/node_modules/xmlbuilder/lib/XMLDocument.js");
                XMLElement = __webpack_require__(/*! ./XMLElement */ "./node_modules/xml2js/node_modules/xmlbuilder/lib/XMLElement.js");
                XMLCData = __webpack_require__(/*! ./XMLCData */ "./node_modules/xml2js/node_modules/xmlbuilder/lib/XMLCData.js");
                XMLComment = __webpack_require__(/*! ./XMLComment */ "./node_modules/xml2js/node_modules/xmlbuilder/lib/XMLComment.js");
                XMLRaw = __webpack_require__(/*! ./XMLRaw */ "./node_modules/xml2js/node_modules/xmlbuilder/lib/XMLRaw.js");
                XMLText = __webpack_require__(/*! ./XMLText */ "./node_modules/xml2js/node_modules/xmlbuilder/lib/XMLText.js");
                XMLProcessingInstruction = __webpack_require__(/*! ./XMLProcessingInstruction */ "./node_modules/xml2js/node_modules/xmlbuilder/lib/XMLProcessingInstruction.js");
                XMLDeclaration = __webpack_require__(/*! ./XMLDeclaration */ "./node_modules/xml2js/node_modules/xmlbuilder/lib/XMLDeclaration.js");
                XMLDocType = __webpack_require__(/*! ./XMLDocType */ "./node_modules/xml2js/node_modules/xmlbuilder/lib/XMLDocType.js");
                XMLDTDAttList = __webpack_require__(/*! ./XMLDTDAttList */ "./node_modules/xml2js/node_modules/xmlbuilder/lib/XMLDTDAttList.js");
                XMLDTDEntity = __webpack_require__(/*! ./XMLDTDEntity */ "./node_modules/xml2js/node_modules/xmlbuilder/lib/XMLDTDEntity.js");
                XMLDTDElement = __webpack_require__(/*! ./XMLDTDElement */ "./node_modules/xml2js/node_modules/xmlbuilder/lib/XMLDTDElement.js");
                XMLDTDNotation = __webpack_require__(/*! ./XMLDTDNotation */ "./node_modules/xml2js/node_modules/xmlbuilder/lib/XMLDTDNotation.js");
                XMLAttribute = __webpack_require__(/*! ./XMLAttribute */ "./node_modules/xml2js/node_modules/xmlbuilder/lib/XMLAttribute.js");
                XMLStringifier = __webpack_require__(/*! ./XMLStringifier */ "./node_modules/xml2js/node_modules/xmlbuilder/lib/XMLStringifier.js");
                XMLStringWriter = __webpack_require__(/*! ./XMLStringWriter */ "./node_modules/xml2js/node_modules/xmlbuilder/lib/XMLStringWriter.js");
                WriterState = __webpack_require__(/*! ./WriterState */ "./node_modules/xml2js/node_modules/xmlbuilder/lib/WriterState.js");
                module.exports = XMLDocumentCB = (function () {
                    function XMLDocumentCB(options, onData, onEnd) {
                        var writerOptions;
                        this.name = "?xml";
                        this.type = NodeType.Document;
                        options || (options = {});
                        writerOptions = {};
                        if (!options.writer) {
                            options.writer = new XMLStringWriter();
                        }
                        else if (isPlainObject(options.writer)) {
                            writerOptions = options.writer;
                            options.writer = new XMLStringWriter();
                        }
                        this.options = options;
                        this.writer = options.writer;
                        this.writerOptions = this.writer.filterOptions(writerOptions);
                        this.stringify = new XMLStringifier(options);
                        this.onDataCallback = onData || function () { };
                        this.onEndCallback = onEnd || function () { };
                        this.currentNode = null;
                        this.currentLevel = -1;
                        this.openTags = {};
                        this.documentStarted = false;
                        this.documentCompleted = false;
                        this.root = null;
                    }
                    XMLDocumentCB.prototype.createChildNode = function (node) {
                        var att, attName, attributes, child, i, len, ref1, ref2;
                        switch (node.type) {
                            case NodeType.CData:
                                this.cdata(node.value);
                                break;
                            case NodeType.Comment:
                                this.comment(node.value);
                                break;
                            case NodeType.Element:
                                attributes = {};
                                ref1 = node.attribs;
                                for (attName in ref1) {
                                    if (!hasProp.call(ref1, attName))
                                        continue;
                                    att = ref1[attName];
                                    attributes[attName] = att.value;
                                }
                                this.node(node.name, attributes);
                                break;
                            case NodeType.Dummy:
                                this.dummy();
                                break;
                            case NodeType.Raw:
                                this.raw(node.value);
                                break;
                            case NodeType.Text:
                                this.text(node.value);
                                break;
                            case NodeType.ProcessingInstruction:
                                this.instruction(node.target, node.value);
                                break;
                            default:
                                throw new Error("This XML node type is not supported in a JS object: " + node.constructor.name);
                        }
                        ref2 = node.children;
                        for (i = 0, len = ref2.length; i < len; i++) {
                            child = ref2[i];
                            this.createChildNode(child);
                            if (child.type === NodeType.Element) {
                                this.up();
                            }
                        }
                        return this;
                    };
                    XMLDocumentCB.prototype.dummy = function () {
                        return this;
                    };
                    XMLDocumentCB.prototype.node = function (name, attributes, text) {
                        var ref1;
                        if (name == null) {
                            throw new Error("Missing node name.");
                        }
                        if (this.root && this.currentLevel === -1) {
                            throw new Error("Document can only have one root node. " + this.debugInfo(name));
                        }
                        this.openCurrent();
                        name = getValue(name);
                        if (attributes == null) {
                            attributes = {};
                        }
                        attributes = getValue(attributes);
                        if (!isObject(attributes)) {
                            ref1 = [attributes, text], text = ref1[0], attributes = ref1[1];
                        }
                        this.currentNode = new XMLElement(this, name, attributes);
                        this.currentNode.children = false;
                        this.currentLevel++;
                        this.openTags[this.currentLevel] = this.currentNode;
                        if (text != null) {
                            this.text(text);
                        }
                        return this;
                    };
                    XMLDocumentCB.prototype.element = function (name, attributes, text) {
                        var child, i, len, oldValidationFlag, ref1, root;
                        if (this.currentNode && this.currentNode.type === NodeType.DocType) {
                            this.dtdElement.apply(this, arguments);
                        }
                        else {
                            if (Array.isArray(name) || isObject(name) || isFunction(name)) {
                                oldValidationFlag = this.options.noValidation;
                                this.options.noValidation = true;
                                root = new XMLDocument(this.options).element('TEMP_ROOT');
                                root.element(name);
                                this.options.noValidation = oldValidationFlag;
                                ref1 = root.children;
                                for (i = 0, len = ref1.length; i < len; i++) {
                                    child = ref1[i];
                                    this.createChildNode(child);
                                    if (child.type === NodeType.Element) {
                                        this.up();
                                    }
                                }
                            }
                            else {
                                this.node(name, attributes, text);
                            }
                        }
                        return this;
                    };
                    XMLDocumentCB.prototype.attribute = function (name, value) {
                        var attName, attValue;
                        if (!this.currentNode || this.currentNode.children) {
                            throw new Error("att() can only be used immediately after an ele() call in callback mode. " + this.debugInfo(name));
                        }
                        if (name != null) {
                            name = getValue(name);
                        }
                        if (isObject(name)) {
                            for (attName in name) {
                                if (!hasProp.call(name, attName))
                                    continue;
                                attValue = name[attName];
                                this.attribute(attName, attValue);
                            }
                        }
                        else {
                            if (isFunction(value)) {
                                value = value.apply();
                            }
                            if (this.options.keepNullAttributes && (value == null)) {
                                this.currentNode.attribs[name] = new XMLAttribute(this, name, "");
                            }
                            else if (value != null) {
                                this.currentNode.attribs[name] = new XMLAttribute(this, name, value);
                            }
                        }
                        return this;
                    };
                    XMLDocumentCB.prototype.text = function (value) {
                        var node;
                        this.openCurrent();
                        node = new XMLText(this, value);
                        this.onData(this.writer.text(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);
                        return this;
                    };
                    XMLDocumentCB.prototype.cdata = function (value) {
                        var node;
                        this.openCurrent();
                        node = new XMLCData(this, value);
                        this.onData(this.writer.cdata(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);
                        return this;
                    };
                    XMLDocumentCB.prototype.comment = function (value) {
                        var node;
                        this.openCurrent();
                        node = new XMLComment(this, value);
                        this.onData(this.writer.comment(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);
                        return this;
                    };
                    XMLDocumentCB.prototype.raw = function (value) {
                        var node;
                        this.openCurrent();
                        node = new XMLRaw(this, value);
                        this.onData(this.writer.raw(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);
                        return this;
                    };
                    XMLDocumentCB.prototype.instruction = function (target, value) {
                        var i, insTarget, insValue, len, node;
                        this.openCurrent();
                        if (target != null) {
                            target = getValue(target);
                        }
                        if (value != null) {
                            value = getValue(value);
                        }
                        if (Array.isArray(target)) {
                            for (i = 0, len = target.length; i < len; i++) {
                                insTarget = target[i];
                                this.instruction(insTarget);
                            }
                        }
                        else if (isObject(target)) {
                            for (insTarget in target) {
                                if (!hasProp.call(target, insTarget))
                                    continue;
                                insValue = target[insTarget];
                                this.instruction(insTarget, insValue);
                            }
                        }
                        else {
                            if (isFunction(value)) {
                                value = value.apply();
                            }
                            node = new XMLProcessingInstruction(this, target, value);
                            this.onData(this.writer.processingInstruction(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);
                        }
                        return this;
                    };
                    XMLDocumentCB.prototype.declaration = function (version, encoding, standalone) {
                        var node;
                        this.openCurrent();
                        if (this.documentStarted) {
                            throw new Error("declaration() must be the first node.");
                        }
                        node = new XMLDeclaration(this, version, encoding, standalone);
                        this.onData(this.writer.declaration(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);
                        return this;
                    };
                    XMLDocumentCB.prototype.doctype = function (root, pubID, sysID) {
                        this.openCurrent();
                        if (root == null) {
                            throw new Error("Missing root node name.");
                        }
                        if (this.root) {
                            throw new Error("dtd() must come before the root node.");
                        }
                        this.currentNode = new XMLDocType(this, pubID, sysID);
                        this.currentNode.rootNodeName = root;
                        this.currentNode.children = false;
                        this.currentLevel++;
                        this.openTags[this.currentLevel] = this.currentNode;
                        return this;
                    };
                    XMLDocumentCB.prototype.dtdElement = function (name, value) {
                        var node;
                        this.openCurrent();
                        node = new XMLDTDElement(this, name, value);
                        this.onData(this.writer.dtdElement(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);
                        return this;
                    };
                    XMLDocumentCB.prototype.attList = function (elementName, attributeName, attributeType, defaultValueType, defaultValue) {
                        var node;
                        this.openCurrent();
                        node = new XMLDTDAttList(this, elementName, attributeName, attributeType, defaultValueType, defaultValue);
                        this.onData(this.writer.dtdAttList(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);
                        return this;
                    };
                    XMLDocumentCB.prototype.entity = function (name, value) {
                        var node;
                        this.openCurrent();
                        node = new XMLDTDEntity(this, false, name, value);
                        this.onData(this.writer.dtdEntity(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);
                        return this;
                    };
                    XMLDocumentCB.prototype.pEntity = function (name, value) {
                        var node;
                        this.openCurrent();
                        node = new XMLDTDEntity(this, true, name, value);
                        this.onData(this.writer.dtdEntity(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);
                        return this;
                    };
                    XMLDocumentCB.prototype.notation = function (name, value) {
                        var node;
                        this.openCurrent();
                        node = new XMLDTDNotation(this, name, value);
                        this.onData(this.writer.dtdNotation(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);
                        return this;
                    };
                    XMLDocumentCB.prototype.up = function () {
                        if (this.currentLevel < 0) {
                            throw new Error("The document node has no parent.");
                        }
                        if (this.currentNode) {
                            if (this.currentNode.children) {
                                this.closeNode(this.currentNode);
                            }
                            else {
                                this.openNode(this.currentNode);
                            }
                            this.currentNode = null;
                        }
                        else {
                            this.closeNode(this.openTags[this.currentLevel]);
                        }
                        delete this.openTags[this.currentLevel];
                        this.currentLevel--;
                        return this;
                    };
                    XMLDocumentCB.prototype.end = function () {
                        while (this.currentLevel >= 0) {
                            this.up();
                        }
                        return this.onEnd();
                    };
                    XMLDocumentCB.prototype.openCurrent = function () {
                        if (this.currentNode) {
                            this.currentNode.children = true;
                            return this.openNode(this.currentNode);
                        }
                    };
                    XMLDocumentCB.prototype.openNode = function (node) {
                        var att, chunk, name, ref1;
                        if (!node.isOpen) {
                            if (!this.root && this.currentLevel === 0 && node.type === NodeType.Element) {
                                this.root = node;
                            }
                            chunk = '';
                            if (node.type === NodeType.Element) {
                                this.writerOptions.state = WriterState.OpenTag;
                                chunk = this.writer.indent(node, this.writerOptions, this.currentLevel) + '<' + node.name;
                                ref1 = node.attribs;
                                for (name in ref1) {
                                    if (!hasProp.call(ref1, name))
                                        continue;
                                    att = ref1[name];
                                    chunk += this.writer.attribute(att, this.writerOptions, this.currentLevel);
                                }
                                chunk += (node.children ? '>' : '/>') + this.writer.endline(node, this.writerOptions, this.currentLevel);
                                this.writerOptions.state = WriterState.InsideTag;
                            }
                            else {
                                this.writerOptions.state = WriterState.OpenTag;
                                chunk = this.writer.indent(node, this.writerOptions, this.currentLevel) + '<!DOCTYPE ' + node.rootNodeName;
                                if (node.pubID && node.sysID) {
                                    chunk += ' PUBLIC "' + node.pubID + '" "' + node.sysID + '"';
                                }
                                else if (node.sysID) {
                                    chunk += ' SYSTEM "' + node.sysID + '"';
                                }
                                if (node.children) {
                                    chunk += ' [';
                                    this.writerOptions.state = WriterState.InsideTag;
                                }
                                else {
                                    this.writerOptions.state = WriterState.CloseTag;
                                    chunk += '>';
                                }
                                chunk += this.writer.endline(node, this.writerOptions, this.currentLevel);
                            }
                            this.onData(chunk, this.currentLevel);
                            return node.isOpen = true;
                        }
                    };
                    XMLDocumentCB.prototype.closeNode = function (node) {
                        var chunk;
                        if (!node.isClosed) {
                            chunk = '';
                            this.writerOptions.state = WriterState.CloseTag;
                            if (node.type === NodeType.Element) {
                                chunk = this.writer.indent(node, this.writerOptions, this.currentLevel) + '</' + node.name + '>' + this.writer.endline(node, this.writerOptions, this.currentLevel);
                            }
                            else {
                                chunk = this.writer.indent(node, this.writerOptions, this.currentLevel) + ']>' + this.writer.endline(node, this.writerOptions, this.currentLevel);
                            }
                            this.writerOptions.state = WriterState.None;
                            this.onData(chunk, this.currentLevel);
                            return node.isClosed = true;
                        }
                    };
                    XMLDocumentCB.prototype.onData = function (chunk, level) {
                        this.documentStarted = true;
                        return this.onDataCallback(chunk, level + 1);
                    };
                    XMLDocumentCB.prototype.onEnd = function () {
                        this.documentCompleted = true;
                        return this.onEndCallback();
                    };
                    XMLDocumentCB.prototype.debugInfo = function (name) {
                        if (name == null) {
                            return "";
                        }
                        else {
                            return "node: <" + name + ">";
                        }
                    };
                    XMLDocumentCB.prototype.ele = function () {
                        return this.element.apply(this, arguments);
                    };
                    XMLDocumentCB.prototype.nod = function (name, attributes, text) {
                        return this.node(name, attributes, text);
                    };
                    XMLDocumentCB.prototype.txt = function (value) {
                        return this.text(value);
                    };
                    XMLDocumentCB.prototype.dat = function (value) {
                        return this.cdata(value);
                    };
                    XMLDocumentCB.prototype.com = function (value) {
                        return this.comment(value);
                    };
                    XMLDocumentCB.prototype.ins = function (target, value) {
                        return this.instruction(target, value);
                    };
                    XMLDocumentCB.prototype.dec = function (version, encoding, standalone) {
                        return this.declaration(version, encoding, standalone);
                    };
                    XMLDocumentCB.prototype.dtd = function (root, pubID, sysID) {
                        return this.doctype(root, pubID, sysID);
                    };
                    XMLDocumentCB.prototype.e = function (name, attributes, text) {
                        return this.element(name, attributes, text);
                    };
                    XMLDocumentCB.prototype.n = function (name, attributes, text) {
                        return this.node(name, attributes, text);
                    };
                    XMLDocumentCB.prototype.t = function (value) {
                        return this.text(value);
                    };
                    XMLDocumentCB.prototype.d = function (value) {
                        return this.cdata(value);
                    };
                    XMLDocumentCB.prototype.c = function (value) {
                        return this.comment(value);
                    };
                    XMLDocumentCB.prototype.r = function (value) {
                        return this.raw(value);
                    };
                    XMLDocumentCB.prototype.i = function (target, value) {
                        return this.instruction(target, value);
                    };
                    XMLDocumentCB.prototype.att = function () {
                        if (this.currentNode && this.currentNode.type === NodeType.DocType) {
                            return this.attList.apply(this, arguments);
                        }
                        else {
                            return this.attribute.apply(this, arguments);
                        }
                    };
                    XMLDocumentCB.prototype.a = function () {
                        if (this.currentNode && this.currentNode.type === NodeType.DocType) {
                            return this.attList.apply(this, arguments);
                        }
                        else {
                            return this.attribute.apply(this, arguments);
                        }
                    };
                    XMLDocumentCB.prototype.ent = function (name, value) {
                        return this.entity(name, value);
                    };
                    XMLDocumentCB.prototype.pent = function (name, value) {
                        return this.pEntity(name, value);
                    };
                    XMLDocumentCB.prototype.not = function (name, value) {
                        return this.notation(name, value);
                    };
                    return XMLDocumentCB;
                })();
            }).call(this);
            /***/ 
        }),
        /***/ "./node_modules/xml2js/node_modules/xmlbuilder/lib/XMLDummy.js": 
        /*!*********************************************************************!*\
          !*** ./node_modules/xml2js/node_modules/xmlbuilder/lib/XMLDummy.js ***!
          \*********************************************************************/
        /***/ (function (module, __unused_webpack_exports, __webpack_require__) {
            // Generated by CoffeeScript 1.12.7
            (function () {
                var NodeType, XMLDummy, XMLNode, extend = function (child, parent) { for (var key in parent) {
                    if (hasProp.call(parent, key))
                        child[key] = parent[key];
                } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty;
                XMLNode = __webpack_require__(/*! ./XMLNode */ "./node_modules/xml2js/node_modules/xmlbuilder/lib/XMLNode.js");
                NodeType = __webpack_require__(/*! ./NodeType */ "./node_modules/xml2js/node_modules/xmlbuilder/lib/NodeType.js");
                module.exports = XMLDummy = (function (superClass) {
                    extend(XMLDummy, superClass);
                    function XMLDummy(parent) {
                        XMLDummy.__super__.constructor.call(this, parent);
                        this.type = NodeType.Dummy;
                    }
                    XMLDummy.prototype.clone = function () {
                        return Object.create(this);
                    };
                    XMLDummy.prototype.toString = function (options) {
                        return '';
                    };
                    return XMLDummy;
                })(XMLNode);
            }).call(this);
            /***/ 
        }),
        /***/ "./node_modules/xml2js/node_modules/xmlbuilder/lib/XMLElement.js": 
        /*!***********************************************************************!*\
          !*** ./node_modules/xml2js/node_modules/xmlbuilder/lib/XMLElement.js ***!
          \***********************************************************************/
        /***/ (function (module, __unused_webpack_exports, __webpack_require__) {
            // Generated by CoffeeScript 1.12.7
            (function () {
                var NodeType, XMLAttribute, XMLElement, XMLNamedNodeMap, XMLNode, getValue, isFunction, isObject, ref, extend = function (child, parent) { for (var key in parent) {
                    if (hasProp.call(parent, key))
                        child[key] = parent[key];
                } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty;
                ref = __webpack_require__(/*! ./Utility */ "./node_modules/xml2js/node_modules/xmlbuilder/lib/Utility.js"), isObject = ref.isObject, isFunction = ref.isFunction, getValue = ref.getValue;
                XMLNode = __webpack_require__(/*! ./XMLNode */ "./node_modules/xml2js/node_modules/xmlbuilder/lib/XMLNode.js");
                NodeType = __webpack_require__(/*! ./NodeType */ "./node_modules/xml2js/node_modules/xmlbuilder/lib/NodeType.js");
                XMLAttribute = __webpack_require__(/*! ./XMLAttribute */ "./node_modules/xml2js/node_modules/xmlbuilder/lib/XMLAttribute.js");
                XMLNamedNodeMap = __webpack_require__(/*! ./XMLNamedNodeMap */ "./node_modules/xml2js/node_modules/xmlbuilder/lib/XMLNamedNodeMap.js");
                module.exports = XMLElement = (function (superClass) {
                    extend(XMLElement, superClass);
                    function XMLElement(parent, name, attributes) {
                        var child, j, len, ref1;
                        XMLElement.__super__.constructor.call(this, parent);
                        if (name == null) {
                            throw new Error("Missing element name. " + this.debugInfo());
                        }
                        this.name = this.stringify.name(name);
                        this.type = NodeType.Element;
                        this.attribs = {};
                        this.schemaTypeInfo = null;
                        if (attributes != null) {
                            this.attribute(attributes);
                        }
                        if (parent.type === NodeType.Document) {
                            this.isRoot = true;
                            this.documentObject = parent;
                            parent.rootObject = this;
                            if (parent.children) {
                                ref1 = parent.children;
                                for (j = 0, len = ref1.length; j < len; j++) {
                                    child = ref1[j];
                                    if (child.type === NodeType.DocType) {
                                        child.name = this.name;
                                        break;
                                    }
                                }
                            }
                        }
                    }
                    Object.defineProperty(XMLElement.prototype, 'tagName', {
                        get: function () {
                            return this.name;
                        }
                    });
                    Object.defineProperty(XMLElement.prototype, 'namespaceURI', {
                        get: function () {
                            return '';
                        }
                    });
                    Object.defineProperty(XMLElement.prototype, 'prefix', {
                        get: function () {
                            return '';
                        }
                    });
                    Object.defineProperty(XMLElement.prototype, 'localName', {
                        get: function () {
                            return this.name;
                        }
                    });
                    Object.defineProperty(XMLElement.prototype, 'id', {
                        get: function () {
                            throw new Error("This DOM method is not implemented." + this.debugInfo());
                        }
                    });
                    Object.defineProperty(XMLElement.prototype, 'className', {
                        get: function () {
                            throw new Error("This DOM method is not implemented." + this.debugInfo());
                        }
                    });
                    Object.defineProperty(XMLElement.prototype, 'classList', {
                        get: function () {
                            throw new Error("This DOM method is not implemented." + this.debugInfo());
                        }
                    });
                    Object.defineProperty(XMLElement.prototype, 'attributes', {
                        get: function () {
                            if (!this.attributeMap || !this.attributeMap.nodes) {
                                this.attributeMap = new XMLNamedNodeMap(this.attribs);
                            }
                            return this.attributeMap;
                        }
                    });
                    XMLElement.prototype.clone = function () {
                        var att, attName, clonedSelf, ref1;
                        clonedSelf = Object.create(this);
                        if (clonedSelf.isRoot) {
                            clonedSelf.documentObject = null;
                        }
                        clonedSelf.attribs = {};
                        ref1 = this.attribs;
                        for (attName in ref1) {
                            if (!hasProp.call(ref1, attName))
                                continue;
                            att = ref1[attName];
                            clonedSelf.attribs[attName] = att.clone();
                        }
                        clonedSelf.children = [];
                        this.children.forEach(function (child) {
                            var clonedChild;
                            clonedChild = child.clone();
                            clonedChild.parent = clonedSelf;
                            return clonedSelf.children.push(clonedChild);
                        });
                        return clonedSelf;
                    };
                    XMLElement.prototype.attribute = function (name, value) {
                        var attName, attValue;
                        if (name != null) {
                            name = getValue(name);
                        }
                        if (isObject(name)) {
                            for (attName in name) {
                                if (!hasProp.call(name, attName))
                                    continue;
                                attValue = name[attName];
                                this.attribute(attName, attValue);
                            }
                        }
                        else {
                            if (isFunction(value)) {
                                value = value.apply();
                            }
                            if (this.options.keepNullAttributes && (value == null)) {
                                this.attribs[name] = new XMLAttribute(this, name, "");
                            }
                            else if (value != null) {
                                this.attribs[name] = new XMLAttribute(this, name, value);
                            }
                        }
                        return this;
                    };
                    XMLElement.prototype.removeAttribute = function (name) {
                        var attName, j, len;
                        if (name == null) {
                            throw new Error("Missing attribute name. " + this.debugInfo());
                        }
                        name = getValue(name);
                        if (Array.isArray(name)) {
                            for (j = 0, len = name.length; j < len; j++) {
                                attName = name[j];
                                delete this.attribs[attName];
                            }
                        }
                        else {
                            delete this.attribs[name];
                        }
                        return this;
                    };
                    XMLElement.prototype.toString = function (options) {
                        return this.options.writer.element(this, this.options.writer.filterOptions(options));
                    };
                    XMLElement.prototype.att = function (name, value) {
                        return this.attribute(name, value);
                    };
                    XMLElement.prototype.a = function (name, value) {
                        return this.attribute(name, value);
                    };
                    XMLElement.prototype.getAttribute = function (name) {
                        if (this.attribs.hasOwnProperty(name)) {
                            return this.attribs[name].value;
                        }
                        else {
                            return null;
                        }
                    };
                    XMLElement.prototype.setAttribute = function (name, value) {
                        throw new Error("This DOM method is not implemented." + this.debugInfo());
                    };
                    XMLElement.prototype.getAttributeNode = function (name) {
                        if (this.attribs.hasOwnProperty(name)) {
                            return this.attribs[name];
                        }
                        else {
                            return null;
                        }
                    };
                    XMLElement.prototype.setAttributeNode = function (newAttr) {
                        throw new Error("This DOM method is not implemented." + this.debugInfo());
                    };
                    XMLElement.prototype.removeAttributeNode = function (oldAttr) {
                        throw new Error("This DOM method is not implemented." + this.debugInfo());
                    };
                    XMLElement.prototype.getElementsByTagName = function (name) {
                        throw new Error("This DOM method is not implemented." + this.debugInfo());
                    };
                    XMLElement.prototype.getAttributeNS = function (namespaceURI, localName) {
                        throw new Error("This DOM method is not implemented." + this.debugInfo());
                    };
                    XMLElement.prototype.setAttributeNS = function (namespaceURI, qualifiedName, value) {
                        throw new Error("This DOM method is not implemented." + this.debugInfo());
                    };
                    XMLElement.prototype.removeAttributeNS = function (namespaceURI, localName) {
                        throw new Error("This DOM method is not implemented." + this.debugInfo());
                    };
                    XMLElement.prototype.getAttributeNodeNS = function (namespaceURI, localName) {
                        throw new Error("This DOM method is not implemented." + this.debugInfo());
                    };
                    XMLElement.prototype.setAttributeNodeNS = function (newAttr) {
                        throw new Error("This DOM method is not implemented." + this.debugInfo());
                    };
                    XMLElement.prototype.getElementsByTagNameNS = function (namespaceURI, localName) {
                        throw new Error("This DOM method is not implemented." + this.debugInfo());
                    };
                    XMLElement.prototype.hasAttribute = function (name) {
                        return this.attribs.hasOwnProperty(name);
                    };
                    XMLElement.prototype.hasAttributeNS = function (namespaceURI, localName) {
                        throw new Error("This DOM method is not implemented." + this.debugInfo());
                    };
                    XMLElement.prototype.setIdAttribute = function (name, isId) {
                        if (this.attribs.hasOwnProperty(name)) {
                            return this.attribs[name].isId;
                        }
                        else {
                            return isId;
                        }
                    };
                    XMLElement.prototype.setIdAttributeNS = function (namespaceURI, localName, isId) {
                        throw new Error("This DOM method is not implemented." + this.debugInfo());
                    };
                    XMLElement.prototype.setIdAttributeNode = function (idAttr, isId) {
                        throw new Error("This DOM method is not implemented." + this.debugInfo());
                    };
                    XMLElement.prototype.getElementsByTagName = function (tagname) {
                        throw new Error("This DOM method is not implemented." + this.debugInfo());
                    };
                    XMLElement.prototype.getElementsByTagNameNS = function (namespaceURI, localName) {
                        throw new Error("This DOM method is not implemented." + this.debugInfo());
                    };
                    XMLElement.prototype.getElementsByClassName = function (classNames) {
                        throw new Error("This DOM method is not implemented." + this.debugInfo());
                    };
                    XMLElement.prototype.isEqualNode = function (node) {
                        var i, j, ref1;
                        if (!XMLElement.__super__.isEqualNode.apply(this, arguments).isEqualNode(node)) {
                            return false;
                        }
                        if (node.namespaceURI !== this.namespaceURI) {
                            return false;
                        }
                        if (node.prefix !== this.prefix) {
                            return false;
                        }
                        if (node.localName !== this.localName) {
                            return false;
                        }
                        if (node.attribs.length !== this.attribs.length) {
                            return false;
                        }
                        for (i = j = 0, ref1 = this.attribs.length - 1; 0 <= ref1 ? j <= ref1 : j >= ref1; i = 0 <= ref1 ? ++j : --j) {
                            if (!this.attribs[i].isEqualNode(node.attribs[i])) {
                                return false;
                            }
                        }
                        return true;
                    };
                    return XMLElement;
                })(XMLNode);
            }).call(this);
            /***/ 
        }),
        /***/ "./node_modules/xml2js/node_modules/xmlbuilder/lib/XMLNamedNodeMap.js": 
        /*!****************************************************************************!*\
          !*** ./node_modules/xml2js/node_modules/xmlbuilder/lib/XMLNamedNodeMap.js ***!
          \****************************************************************************/
        /***/ (function (module) {
            // Generated by CoffeeScript 1.12.7
            (function () {
                var XMLNamedNodeMap;
                module.exports = XMLNamedNodeMap = (function () {
                    function XMLNamedNodeMap(nodes) {
                        this.nodes = nodes;
                    }
                    Object.defineProperty(XMLNamedNodeMap.prototype, 'length', {
                        get: function () {
                            return Object.keys(this.nodes).length || 0;
                        }
                    });
                    XMLNamedNodeMap.prototype.clone = function () {
                        return this.nodes = null;
                    };
                    XMLNamedNodeMap.prototype.getNamedItem = function (name) {
                        return this.nodes[name];
                    };
                    XMLNamedNodeMap.prototype.setNamedItem = function (node) {
                        var oldNode;
                        oldNode = this.nodes[node.nodeName];
                        this.nodes[node.nodeName] = node;
                        return oldNode || null;
                    };
                    XMLNamedNodeMap.prototype.removeNamedItem = function (name) {
                        var oldNode;
                        oldNode = this.nodes[name];
                        delete this.nodes[name];
                        return oldNode || null;
                    };
                    XMLNamedNodeMap.prototype.item = function (index) {
                        return this.nodes[Object.keys(this.nodes)[index]] || null;
                    };
                    XMLNamedNodeMap.prototype.getNamedItemNS = function (namespaceURI, localName) {
                        throw new Error("This DOM method is not implemented.");
                    };
                    XMLNamedNodeMap.prototype.setNamedItemNS = function (node) {
                        throw new Error("This DOM method is not implemented.");
                    };
                    XMLNamedNodeMap.prototype.removeNamedItemNS = function (namespaceURI, localName) {
                        throw new Error("This DOM method is not implemented.");
                    };
                    return XMLNamedNodeMap;
                })();
            }).call(this);
            /***/ 
        }),
        /***/ "./node_modules/xml2js/node_modules/xmlbuilder/lib/XMLNode.js": 
        /*!********************************************************************!*\
          !*** ./node_modules/xml2js/node_modules/xmlbuilder/lib/XMLNode.js ***!
          \********************************************************************/
        /***/ (function (module, __unused_webpack_exports, __webpack_require__) {
            // Generated by CoffeeScript 1.12.7
            (function () {
                var DocumentPosition, NodeType, XMLCData, XMLComment, XMLDeclaration, XMLDocType, XMLDummy, XMLElement, XMLNamedNodeMap, XMLNode, XMLNodeList, XMLProcessingInstruction, XMLRaw, XMLText, getValue, isEmpty, isFunction, isObject, ref1, hasProp = {}.hasOwnProperty;
                ref1 = __webpack_require__(/*! ./Utility */ "./node_modules/xml2js/node_modules/xmlbuilder/lib/Utility.js"), isObject = ref1.isObject, isFunction = ref1.isFunction, isEmpty = ref1.isEmpty, getValue = ref1.getValue;
                XMLElement = null;
                XMLCData = null;
                XMLComment = null;
                XMLDeclaration = null;
                XMLDocType = null;
                XMLRaw = null;
                XMLText = null;
                XMLProcessingInstruction = null;
                XMLDummy = null;
                NodeType = null;
                XMLNodeList = null;
                XMLNamedNodeMap = null;
                DocumentPosition = null;
                module.exports = XMLNode = (function () {
                    function XMLNode(parent1) {
                        this.parent = parent1;
                        if (this.parent) {
                            this.options = this.parent.options;
                            this.stringify = this.parent.stringify;
                        }
                        this.value = null;
                        this.children = [];
                        this.baseURI = null;
                        if (!XMLElement) {
                            XMLElement = __webpack_require__(/*! ./XMLElement */ "./node_modules/xml2js/node_modules/xmlbuilder/lib/XMLElement.js");
                            XMLCData = __webpack_require__(/*! ./XMLCData */ "./node_modules/xml2js/node_modules/xmlbuilder/lib/XMLCData.js");
                            XMLComment = __webpack_require__(/*! ./XMLComment */ "./node_modules/xml2js/node_modules/xmlbuilder/lib/XMLComment.js");
                            XMLDeclaration = __webpack_require__(/*! ./XMLDeclaration */ "./node_modules/xml2js/node_modules/xmlbuilder/lib/XMLDeclaration.js");
                            XMLDocType = __webpack_require__(/*! ./XMLDocType */ "./node_modules/xml2js/node_modules/xmlbuilder/lib/XMLDocType.js");
                            XMLRaw = __webpack_require__(/*! ./XMLRaw */ "./node_modules/xml2js/node_modules/xmlbuilder/lib/XMLRaw.js");
                            XMLText = __webpack_require__(/*! ./XMLText */ "./node_modules/xml2js/node_modules/xmlbuilder/lib/XMLText.js");
                            XMLProcessingInstruction = __webpack_require__(/*! ./XMLProcessingInstruction */ "./node_modules/xml2js/node_modules/xmlbuilder/lib/XMLProcessingInstruction.js");
                            XMLDummy = __webpack_require__(/*! ./XMLDummy */ "./node_modules/xml2js/node_modules/xmlbuilder/lib/XMLDummy.js");
                            NodeType = __webpack_require__(/*! ./NodeType */ "./node_modules/xml2js/node_modules/xmlbuilder/lib/NodeType.js");
                            XMLNodeList = __webpack_require__(/*! ./XMLNodeList */ "./node_modules/xml2js/node_modules/xmlbuilder/lib/XMLNodeList.js");
                            XMLNamedNodeMap = __webpack_require__(/*! ./XMLNamedNodeMap */ "./node_modules/xml2js/node_modules/xmlbuilder/lib/XMLNamedNodeMap.js");
                            DocumentPosition = __webpack_require__(/*! ./DocumentPosition */ "./node_modules/xml2js/node_modules/xmlbuilder/lib/DocumentPosition.js");
                        }
                    }
                    Object.defineProperty(XMLNode.prototype, 'nodeName', {
                        get: function () {
                            return this.name;
                        }
                    });
                    Object.defineProperty(XMLNode.prototype, 'nodeType', {
                        get: function () {
                            return this.type;
                        }
                    });
                    Object.defineProperty(XMLNode.prototype, 'nodeValue', {
                        get: function () {
                            return this.value;
                        }
                    });
                    Object.defineProperty(XMLNode.prototype, 'parentNode', {
                        get: function () {
                            return this.parent;
                        }
                    });
                    Object.defineProperty(XMLNode.prototype, 'childNodes', {
                        get: function () {
                            if (!this.childNodeList || !this.childNodeList.nodes) {
                                this.childNodeList = new XMLNodeList(this.children);
                            }
                            return this.childNodeList;
                        }
                    });
                    Object.defineProperty(XMLNode.prototype, 'firstChild', {
                        get: function () {
                            return this.children[0] || null;
                        }
                    });
                    Object.defineProperty(XMLNode.prototype, 'lastChild', {
                        get: function () {
                            return this.children[this.children.length - 1] || null;
                        }
                    });
                    Object.defineProperty(XMLNode.prototype, 'previousSibling', {
                        get: function () {
                            var i;
                            i = this.parent.children.indexOf(this);
                            return this.parent.children[i - 1] || null;
                        }
                    });
                    Object.defineProperty(XMLNode.prototype, 'nextSibling', {
                        get: function () {
                            var i;
                            i = this.parent.children.indexOf(this);
                            return this.parent.children[i + 1] || null;
                        }
                    });
                    Object.defineProperty(XMLNode.prototype, 'ownerDocument', {
                        get: function () {
                            return this.document() || null;
                        }
                    });
                    Object.defineProperty(XMLNode.prototype, 'textContent', {
                        get: function () {
                            var child, j, len, ref2, str;
                            if (this.nodeType === NodeType.Element || this.nodeType === NodeType.DocumentFragment) {
                                str = '';
                                ref2 = this.children;
                                for (j = 0, len = ref2.length; j < len; j++) {
                                    child = ref2[j];
                                    if (child.textContent) {
                                        str += child.textContent;
                                    }
                                }
                                return str;
                            }
                            else {
                                return null;
                            }
                        },
                        set: function (value) {
                            throw new Error("This DOM method is not implemented." + this.debugInfo());
                        }
                    });
                    XMLNode.prototype.setParent = function (parent) {
                        var child, j, len, ref2, results;
                        this.parent = parent;
                        if (parent) {
                            this.options = parent.options;
                            this.stringify = parent.stringify;
                        }
                        ref2 = this.children;
                        results = [];
                        for (j = 0, len = ref2.length; j < len; j++) {
                            child = ref2[j];
                            results.push(child.setParent(this));
                        }
                        return results;
                    };
                    XMLNode.prototype.element = function (name, attributes, text) {
                        var childNode, item, j, k, key, lastChild, len, len1, ref2, ref3, val;
                        lastChild = null;
                        if (attributes === null && (text == null)) {
                            ref2 = [{}, null], attributes = ref2[0], text = ref2[1];
                        }
                        if (attributes == null) {
                            attributes = {};
                        }
                        attributes = getValue(attributes);
                        if (!isObject(attributes)) {
                            ref3 = [attributes, text], text = ref3[0], attributes = ref3[1];
                        }
                        if (name != null) {
                            name = getValue(name);
                        }
                        if (Array.isArray(name)) {
                            for (j = 0, len = name.length; j < len; j++) {
                                item = name[j];
                                lastChild = this.element(item);
                            }
                        }
                        else if (isFunction(name)) {
                            lastChild = this.element(name.apply());
                        }
                        else if (isObject(name)) {
                            for (key in name) {
                                if (!hasProp.call(name, key))
                                    continue;
                                val = name[key];
                                if (isFunction(val)) {
                                    val = val.apply();
                                }
                                if (!this.options.ignoreDecorators && this.stringify.convertAttKey && key.indexOf(this.stringify.convertAttKey) === 0) {
                                    lastChild = this.attribute(key.substr(this.stringify.convertAttKey.length), val);
                                }
                                else if (!this.options.separateArrayItems && Array.isArray(val) && isEmpty(val)) {
                                    lastChild = this.dummy();
                                }
                                else if (isObject(val) && isEmpty(val)) {
                                    lastChild = this.element(key);
                                }
                                else if (!this.options.keepNullNodes && (val == null)) {
                                    lastChild = this.dummy();
                                }
                                else if (!this.options.separateArrayItems && Array.isArray(val)) {
                                    for (k = 0, len1 = val.length; k < len1; k++) {
                                        item = val[k];
                                        childNode = {};
                                        childNode[key] = item;
                                        lastChild = this.element(childNode);
                                    }
                                }
                                else if (isObject(val)) {
                                    if (!this.options.ignoreDecorators && this.stringify.convertTextKey && key.indexOf(this.stringify.convertTextKey) === 0) {
                                        lastChild = this.element(val);
                                    }
                                    else {
                                        lastChild = this.element(key);
                                        lastChild.element(val);
                                    }
                                }
                                else {
                                    lastChild = this.element(key, val);
                                }
                            }
                        }
                        else if (!this.options.keepNullNodes && text === null) {
                            lastChild = this.dummy();
                        }
                        else {
                            if (!this.options.ignoreDecorators && this.stringify.convertTextKey && name.indexOf(this.stringify.convertTextKey) === 0) {
                                lastChild = this.text(text);
                            }
                            else if (!this.options.ignoreDecorators && this.stringify.convertCDataKey && name.indexOf(this.stringify.convertCDataKey) === 0) {
                                lastChild = this.cdata(text);
                            }
                            else if (!this.options.ignoreDecorators && this.stringify.convertCommentKey && name.indexOf(this.stringify.convertCommentKey) === 0) {
                                lastChild = this.comment(text);
                            }
                            else if (!this.options.ignoreDecorators && this.stringify.convertRawKey && name.indexOf(this.stringify.convertRawKey) === 0) {
                                lastChild = this.raw(text);
                            }
                            else if (!this.options.ignoreDecorators && this.stringify.convertPIKey && name.indexOf(this.stringify.convertPIKey) === 0) {
                                lastChild = this.instruction(name.substr(this.stringify.convertPIKey.length), text);
                            }
                            else {
                                lastChild = this.node(name, attributes, text);
                            }
                        }
                        if (lastChild == null) {
                            throw new Error("Could not create any elements with: " + name + ". " + this.debugInfo());
                        }
                        return lastChild;
                    };
                    XMLNode.prototype.insertBefore = function (name, attributes, text) {
                        var child, i, newChild, refChild, removed;
                        if (name != null ? name.type : void 0) {
                            newChild = name;
                            refChild = attributes;
                            newChild.setParent(this);
                            if (refChild) {
                                i = children.indexOf(refChild);
                                removed = children.splice(i);
                                children.push(newChild);
                                Array.prototype.push.apply(children, removed);
                            }
                            else {
                                children.push(newChild);
                            }
                            return newChild;
                        }
                        else {
                            if (this.isRoot) {
                                throw new Error("Cannot insert elements at root level. " + this.debugInfo(name));
                            }
                            i = this.parent.children.indexOf(this);
                            removed = this.parent.children.splice(i);
                            child = this.parent.element(name, attributes, text);
                            Array.prototype.push.apply(this.parent.children, removed);
                            return child;
                        }
                    };
                    XMLNode.prototype.insertAfter = function (name, attributes, text) {
                        var child, i, removed;
                        if (this.isRoot) {
                            throw new Error("Cannot insert elements at root level. " + this.debugInfo(name));
                        }
                        i = this.parent.children.indexOf(this);
                        removed = this.parent.children.splice(i + 1);
                        child = this.parent.element(name, attributes, text);
                        Array.prototype.push.apply(this.parent.children, removed);
                        return child;
                    };
                    XMLNode.prototype.remove = function () {
                        var i, ref2;
                        if (this.isRoot) {
                            throw new Error("Cannot remove the root element. " + this.debugInfo());
                        }
                        i = this.parent.children.indexOf(this);
                        [].splice.apply(this.parent.children, [i, i - i + 1].concat(ref2 = [])), ref2;
                        return this.parent;
                    };
                    XMLNode.prototype.node = function (name, attributes, text) {
                        var child, ref2;
                        if (name != null) {
                            name = getValue(name);
                        }
                        attributes || (attributes = {});
                        attributes = getValue(attributes);
                        if (!isObject(attributes)) {
                            ref2 = [attributes, text], text = ref2[0], attributes = ref2[1];
                        }
                        child = new XMLElement(this, name, attributes);
                        if (text != null) {
                            child.text(text);
                        }
                        this.children.push(child);
                        return child;
                    };
                    XMLNode.prototype.text = function (value) {
                        var child;
                        if (isObject(value)) {
                            this.element(value);
                        }
                        child = new XMLText(this, value);
                        this.children.push(child);
                        return this;
                    };
                    XMLNode.prototype.cdata = function (value) {
                        var child;
                        child = new XMLCData(this, value);
                        this.children.push(child);
                        return this;
                    };
                    XMLNode.prototype.comment = function (value) {
                        var child;
                        child = new XMLComment(this, value);
                        this.children.push(child);
                        return this;
                    };
                    XMLNode.prototype.commentBefore = function (value) {
                        var child, i, removed;
                        i = this.parent.children.indexOf(this);
                        removed = this.parent.children.splice(i);
                        child = this.parent.comment(value);
                        Array.prototype.push.apply(this.parent.children, removed);
                        return this;
                    };
                    XMLNode.prototype.commentAfter = function (value) {
                        var child, i, removed;
                        i = this.parent.children.indexOf(this);
                        removed = this.parent.children.splice(i + 1);
                        child = this.parent.comment(value);
                        Array.prototype.push.apply(this.parent.children, removed);
                        return this;
                    };
                    XMLNode.prototype.raw = function (value) {
                        var child;
                        child = new XMLRaw(this, value);
                        this.children.push(child);
                        return this;
                    };
                    XMLNode.prototype.dummy = function () {
                        var child;
                        child = new XMLDummy(this);
                        return child;
                    };
                    XMLNode.prototype.instruction = function (target, value) {
                        var insTarget, insValue, instruction, j, len;
                        if (target != null) {
                            target = getValue(target);
                        }
                        if (value != null) {
                            value = getValue(value);
                        }
                        if (Array.isArray(target)) {
                            for (j = 0, len = target.length; j < len; j++) {
                                insTarget = target[j];
                                this.instruction(insTarget);
                            }
                        }
                        else if (isObject(target)) {
                            for (insTarget in target) {
                                if (!hasProp.call(target, insTarget))
                                    continue;
                                insValue = target[insTarget];
                                this.instruction(insTarget, insValue);
                            }
                        }
                        else {
                            if (isFunction(value)) {
                                value = value.apply();
                            }
                            instruction = new XMLProcessingInstruction(this, target, value);
                            this.children.push(instruction);
                        }
                        return this;
                    };
                    XMLNode.prototype.instructionBefore = function (target, value) {
                        var child, i, removed;
                        i = this.parent.children.indexOf(this);
                        removed = this.parent.children.splice(i);
                        child = this.parent.instruction(target, value);
                        Array.prototype.push.apply(this.parent.children, removed);
                        return this;
                    };
                    XMLNode.prototype.instructionAfter = function (target, value) {
                        var child, i, removed;
                        i = this.parent.children.indexOf(this);
                        removed = this.parent.children.splice(i + 1);
                        child = this.parent.instruction(target, value);
                        Array.prototype.push.apply(this.parent.children, removed);
                        return this;
                    };
                    XMLNode.prototype.declaration = function (version, encoding, standalone) {
                        var doc, xmldec;
                        doc = this.document();
                        xmldec = new XMLDeclaration(doc, version, encoding, standalone);
                        if (doc.children.length === 0) {
                            doc.children.unshift(xmldec);
                        }
                        else if (doc.children[0].type === NodeType.Declaration) {
                            doc.children[0] = xmldec;
                        }
                        else {
                            doc.children.unshift(xmldec);
                        }
                        return doc.root() || doc;
                    };
                    XMLNode.prototype.dtd = function (pubID, sysID) {
                        var child, doc, doctype, i, j, k, len, len1, ref2, ref3;
                        doc = this.document();
                        doctype = new XMLDocType(doc, pubID, sysID);
                        ref2 = doc.children;
                        for (i = j = 0, len = ref2.length; j < len; i = ++j) {
                            child = ref2[i];
                            if (child.type === NodeType.DocType) {
                                doc.children[i] = doctype;
                                return doctype;
                            }
                        }
                        ref3 = doc.children;
                        for (i = k = 0, len1 = ref3.length; k < len1; i = ++k) {
                            child = ref3[i];
                            if (child.isRoot) {
                                doc.children.splice(i, 0, doctype);
                                return doctype;
                            }
                        }
                        doc.children.push(doctype);
                        return doctype;
                    };
                    XMLNode.prototype.up = function () {
                        if (this.isRoot) {
                            throw new Error("The root node has no parent. Use doc() if you need to get the document object.");
                        }
                        return this.parent;
                    };
                    XMLNode.prototype.root = function () {
                        var node;
                        node = this;
                        while (node) {
                            if (node.type === NodeType.Document) {
                                return node.rootObject;
                            }
                            else if (node.isRoot) {
                                return node;
                            }
                            else {
                                node = node.parent;
                            }
                        }
                    };
                    XMLNode.prototype.document = function () {
                        var node;
                        node = this;
                        while (node) {
                            if (node.type === NodeType.Document) {
                                return node;
                            }
                            else {
                                node = node.parent;
                            }
                        }
                    };
                    XMLNode.prototype.end = function (options) {
                        return this.document().end(options);
                    };
                    XMLNode.prototype.prev = function () {
                        var i;
                        i = this.parent.children.indexOf(this);
                        if (i < 1) {
                            throw new Error("Already at the first node. " + this.debugInfo());
                        }
                        return this.parent.children[i - 1];
                    };
                    XMLNode.prototype.next = function () {
                        var i;
                        i = this.parent.children.indexOf(this);
                        if (i === -1 || i === this.parent.children.length - 1) {
                            throw new Error("Already at the last node. " + this.debugInfo());
                        }
                        return this.parent.children[i + 1];
                    };
                    XMLNode.prototype.importDocument = function (doc) {
                        var clonedRoot;
                        clonedRoot = doc.root().clone();
                        clonedRoot.parent = this;
                        clonedRoot.isRoot = false;
                        this.children.push(clonedRoot);
                        return this;
                    };
                    XMLNode.prototype.debugInfo = function (name) {
                        var ref2, ref3;
                        name = name || this.name;
                        if ((name == null) && !((ref2 = this.parent) != null ? ref2.name : void 0)) {
                            return "";
                        }
                        else if (name == null) {
                            return "parent: <" + this.parent.name + ">";
                        }
                        else if (!((ref3 = this.parent) != null ? ref3.name : void 0)) {
                            return "node: <" + name + ">";
                        }
                        else {
                            return "node: <" + name + ">, parent: <" + this.parent.name + ">";
                        }
                    };
                    XMLNode.prototype.ele = function (name, attributes, text) {
                        return this.element(name, attributes, text);
                    };
                    XMLNode.prototype.nod = function (name, attributes, text) {
                        return this.node(name, attributes, text);
                    };
                    XMLNode.prototype.txt = function (value) {
                        return this.text(value);
                    };
                    XMLNode.prototype.dat = function (value) {
                        return this.cdata(value);
                    };
                    XMLNode.prototype.com = function (value) {
                        return this.comment(value);
                    };
                    XMLNode.prototype.ins = function (target, value) {
                        return this.instruction(target, value);
                    };
                    XMLNode.prototype.doc = function () {
                        return this.document();
                    };
                    XMLNode.prototype.dec = function (version, encoding, standalone) {
                        return this.declaration(version, encoding, standalone);
                    };
                    XMLNode.prototype.e = function (name, attributes, text) {
                        return this.element(name, attributes, text);
                    };
                    XMLNode.prototype.n = function (name, attributes, text) {
                        return this.node(name, attributes, text);
                    };
                    XMLNode.prototype.t = function (value) {
                        return this.text(value);
                    };
                    XMLNode.prototype.d = function (value) {
                        return this.cdata(value);
                    };
                    XMLNode.prototype.c = function (value) {
                        return this.comment(value);
                    };
                    XMLNode.prototype.r = function (value) {
                        return this.raw(value);
                    };
                    XMLNode.prototype.i = function (target, value) {
                        return this.instruction(target, value);
                    };
                    XMLNode.prototype.u = function () {
                        return this.up();
                    };
                    XMLNode.prototype.importXMLBuilder = function (doc) {
                        return this.importDocument(doc);
                    };
                    XMLNode.prototype.replaceChild = function (newChild, oldChild) {
                        throw new Error("This DOM method is not implemented." + this.debugInfo());
                    };
                    XMLNode.prototype.removeChild = function (oldChild) {
                        throw new Error("This DOM method is not implemented." + this.debugInfo());
                    };
                    XMLNode.prototype.appendChild = function (newChild) {
                        throw new Error("This DOM method is not implemented." + this.debugInfo());
                    };
                    XMLNode.prototype.hasChildNodes = function () {
                        return this.children.length !== 0;
                    };
                    XMLNode.prototype.cloneNode = function (deep) {
                        throw new Error("This DOM method is not implemented." + this.debugInfo());
                    };
                    XMLNode.prototype.normalize = function () {
                        throw new Error("This DOM method is not implemented." + this.debugInfo());
                    };
                    XMLNode.prototype.isSupported = function (feature, version) {
                        return true;
                    };
                    XMLNode.prototype.hasAttributes = function () {
                        return this.attribs.length !== 0;
                    };
                    XMLNode.prototype.compareDocumentPosition = function (other) {
                        var ref, res;
                        ref = this;
                        if (ref === other) {
                            return 0;
                        }
                        else if (this.document() !== other.document()) {
                            res = DocumentPosition.Disconnected | DocumentPosition.ImplementationSpecific;
                            if (Math.random() < 0.5) {
                                res |= DocumentPosition.Preceding;
                            }
                            else {
                                res |= DocumentPosition.Following;
                            }
                            return res;
                        }
                        else if (ref.isAncestor(other)) {
                            return DocumentPosition.Contains | DocumentPosition.Preceding;
                        }
                        else if (ref.isDescendant(other)) {
                            return DocumentPosition.Contains | DocumentPosition.Following;
                        }
                        else if (ref.isPreceding(other)) {
                            return DocumentPosition.Preceding;
                        }
                        else {
                            return DocumentPosition.Following;
                        }
                    };
                    XMLNode.prototype.isSameNode = function (other) {
                        throw new Error("This DOM method is not implemented." + this.debugInfo());
                    };
                    XMLNode.prototype.lookupPrefix = function (namespaceURI) {
                        throw new Error("This DOM method is not implemented." + this.debugInfo());
                    };
                    XMLNode.prototype.isDefaultNamespace = function (namespaceURI) {
                        throw new Error("This DOM method is not implemented." + this.debugInfo());
                    };
                    XMLNode.prototype.lookupNamespaceURI = function (prefix) {
                        throw new Error("This DOM method is not implemented." + this.debugInfo());
                    };
                    XMLNode.prototype.isEqualNode = function (node) {
                        var i, j, ref2;
                        if (node.nodeType !== this.nodeType) {
                            return false;
                        }
                        if (node.children.length !== this.children.length) {
                            return false;
                        }
                        for (i = j = 0, ref2 = this.children.length - 1; 0 <= ref2 ? j <= ref2 : j >= ref2; i = 0 <= ref2 ? ++j : --j) {
                            if (!this.children[i].isEqualNode(node.children[i])) {
                                return false;
                            }
                        }
                        return true;
                    };
                    XMLNode.prototype.getFeature = function (feature, version) {
                        throw new Error("This DOM method is not implemented." + this.debugInfo());
                    };
                    XMLNode.prototype.setUserData = function (key, data, handler) {
                        throw new Error("This DOM method is not implemented." + this.debugInfo());
                    };
                    XMLNode.prototype.getUserData = function (key) {
                        throw new Error("This DOM method is not implemented." + this.debugInfo());
                    };
                    XMLNode.prototype.contains = function (other) {
                        if (!other) {
                            return false;
                        }
                        return other === this || this.isDescendant(other);
                    };
                    XMLNode.prototype.isDescendant = function (node) {
                        var child, isDescendantChild, j, len, ref2;
                        ref2 = this.children;
                        for (j = 0, len = ref2.length; j < len; j++) {
                            child = ref2[j];
                            if (node === child) {
                                return true;
                            }
                            isDescendantChild = child.isDescendant(node);
                            if (isDescendantChild) {
                                return true;
                            }
                        }
                        return false;
                    };
                    XMLNode.prototype.isAncestor = function (node) {
                        return node.isDescendant(this);
                    };
                    XMLNode.prototype.isPreceding = function (node) {
                        var nodePos, thisPos;
                        nodePos = this.treePosition(node);
                        thisPos = this.treePosition(this);
                        if (nodePos === -1 || thisPos === -1) {
                            return false;
                        }
                        else {
                            return nodePos < thisPos;
                        }
                    };
                    XMLNode.prototype.isFollowing = function (node) {
                        var nodePos, thisPos;
                        nodePos = this.treePosition(node);
                        thisPos = this.treePosition(this);
                        if (nodePos === -1 || thisPos === -1) {
                            return false;
                        }
                        else {
                            return nodePos > thisPos;
                        }
                    };
                    XMLNode.prototype.treePosition = function (node) {
                        var found, pos;
                        pos = 0;
                        found = false;
                        this.foreachTreeNode(this.document(), function (childNode) {
                            pos++;
                            if (!found && childNode === node) {
                                return found = true;
                            }
                        });
                        if (found) {
                            return pos;
                        }
                        else {
                            return -1;
                        }
                    };
                    XMLNode.prototype.foreachTreeNode = function (node, func) {
                        var child, j, len, ref2, res;
                        node || (node = this.document());
                        ref2 = node.children;
                        for (j = 0, len = ref2.length; j < len; j++) {
                            child = ref2[j];
                            if (res = func(child)) {
                                return res;
                            }
                            else {
                                res = this.foreachTreeNode(child, func);
                                if (res) {
                                    return res;
                                }
                            }
                        }
                    };
                    return XMLNode;
                })();
            }).call(this);
            /***/ 
        }),
        /***/ "./node_modules/xml2js/node_modules/xmlbuilder/lib/XMLNodeList.js": 
        /*!************************************************************************!*\
          !*** ./node_modules/xml2js/node_modules/xmlbuilder/lib/XMLNodeList.js ***!
          \************************************************************************/
        /***/ (function (module) {
            // Generated by CoffeeScript 1.12.7
            (function () {
                var XMLNodeList;
                module.exports = XMLNodeList = (function () {
                    function XMLNodeList(nodes) {
                        this.nodes = nodes;
                    }
                    Object.defineProperty(XMLNodeList.prototype, 'length', {
                        get: function () {
                            return this.nodes.length || 0;
                        }
                    });
                    XMLNodeList.prototype.clone = function () {
                        return this.nodes = null;
                    };
                    XMLNodeList.prototype.item = function (index) {
                        return this.nodes[index] || null;
                    };
                    return XMLNodeList;
                })();
            }).call(this);
            /***/ 
        }),
        /***/ "./node_modules/xml2js/node_modules/xmlbuilder/lib/XMLProcessingInstruction.js": 
        /*!*************************************************************************************!*\
          !*** ./node_modules/xml2js/node_modules/xmlbuilder/lib/XMLProcessingInstruction.js ***!
          \*************************************************************************************/
        /***/ (function (module, __unused_webpack_exports, __webpack_require__) {
            // Generated by CoffeeScript 1.12.7
            (function () {
                var NodeType, XMLCharacterData, XMLProcessingInstruction, extend = function (child, parent) { for (var key in parent) {
                    if (hasProp.call(parent, key))
                        child[key] = parent[key];
                } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty;
                NodeType = __webpack_require__(/*! ./NodeType */ "./node_modules/xml2js/node_modules/xmlbuilder/lib/NodeType.js");
                XMLCharacterData = __webpack_require__(/*! ./XMLCharacterData */ "./node_modules/xml2js/node_modules/xmlbuilder/lib/XMLCharacterData.js");
                module.exports = XMLProcessingInstruction = (function (superClass) {
                    extend(XMLProcessingInstruction, superClass);
                    function XMLProcessingInstruction(parent, target, value) {
                        XMLProcessingInstruction.__super__.constructor.call(this, parent);
                        if (target == null) {
                            throw new Error("Missing instruction target. " + this.debugInfo());
                        }
                        this.type = NodeType.ProcessingInstruction;
                        this.target = this.stringify.insTarget(target);
                        this.name = this.target;
                        if (value) {
                            this.value = this.stringify.insValue(value);
                        }
                    }
                    XMLProcessingInstruction.prototype.clone = function () {
                        return Object.create(this);
                    };
                    XMLProcessingInstruction.prototype.toString = function (options) {
                        return this.options.writer.processingInstruction(this, this.options.writer.filterOptions(options));
                    };
                    XMLProcessingInstruction.prototype.isEqualNode = function (node) {
                        if (!XMLProcessingInstruction.__super__.isEqualNode.apply(this, arguments).isEqualNode(node)) {
                            return false;
                        }
                        if (node.target !== this.target) {
                            return false;
                        }
                        return true;
                    };
                    return XMLProcessingInstruction;
                })(XMLCharacterData);
            }).call(this);
            /***/ 
        }),
        /***/ "./node_modules/xml2js/node_modules/xmlbuilder/lib/XMLRaw.js": 
        /*!*******************************************************************!*\
          !*** ./node_modules/xml2js/node_modules/xmlbuilder/lib/XMLRaw.js ***!
          \*******************************************************************/
        /***/ (function (module, __unused_webpack_exports, __webpack_require__) {
            // Generated by CoffeeScript 1.12.7
            (function () {
                var NodeType, XMLNode, XMLRaw, extend = function (child, parent) { for (var key in parent) {
                    if (hasProp.call(parent, key))
                        child[key] = parent[key];
                } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty;
                NodeType = __webpack_require__(/*! ./NodeType */ "./node_modules/xml2js/node_modules/xmlbuilder/lib/NodeType.js");
                XMLNode = __webpack_require__(/*! ./XMLNode */ "./node_modules/xml2js/node_modules/xmlbuilder/lib/XMLNode.js");
                module.exports = XMLRaw = (function (superClass) {
                    extend(XMLRaw, superClass);
                    function XMLRaw(parent, text) {
                        XMLRaw.__super__.constructor.call(this, parent);
                        if (text == null) {
                            throw new Error("Missing raw text. " + this.debugInfo());
                        }
                        this.type = NodeType.Raw;
                        this.value = this.stringify.raw(text);
                    }
                    XMLRaw.prototype.clone = function () {
                        return Object.create(this);
                    };
                    XMLRaw.prototype.toString = function (options) {
                        return this.options.writer.raw(this, this.options.writer.filterOptions(options));
                    };
                    return XMLRaw;
                })(XMLNode);
            }).call(this);
            /***/ 
        }),
        /***/ "./node_modules/xml2js/node_modules/xmlbuilder/lib/XMLStreamWriter.js": 
        /*!****************************************************************************!*\
          !*** ./node_modules/xml2js/node_modules/xmlbuilder/lib/XMLStreamWriter.js ***!
          \****************************************************************************/
        /***/ (function (module, __unused_webpack_exports, __webpack_require__) {
            // Generated by CoffeeScript 1.12.7
            (function () {
                var NodeType, WriterState, XMLStreamWriter, XMLWriterBase, extend = function (child, parent) { for (var key in parent) {
                    if (hasProp.call(parent, key))
                        child[key] = parent[key];
                } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty;
                NodeType = __webpack_require__(/*! ./NodeType */ "./node_modules/xml2js/node_modules/xmlbuilder/lib/NodeType.js");
                XMLWriterBase = __webpack_require__(/*! ./XMLWriterBase */ "./node_modules/xml2js/node_modules/xmlbuilder/lib/XMLWriterBase.js");
                WriterState = __webpack_require__(/*! ./WriterState */ "./node_modules/xml2js/node_modules/xmlbuilder/lib/WriterState.js");
                module.exports = XMLStreamWriter = (function (superClass) {
                    extend(XMLStreamWriter, superClass);
                    function XMLStreamWriter(stream, options) {
                        this.stream = stream;
                        XMLStreamWriter.__super__.constructor.call(this, options);
                    }
                    XMLStreamWriter.prototype.endline = function (node, options, level) {
                        if (node.isLastRootNode && options.state === WriterState.CloseTag) {
                            return '';
                        }
                        else {
                            return XMLStreamWriter.__super__.endline.call(this, node, options, level);
                        }
                    };
                    XMLStreamWriter.prototype.document = function (doc, options) {
                        var child, i, j, k, len, len1, ref, ref1, results;
                        ref = doc.children;
                        for (i = j = 0, len = ref.length; j < len; i = ++j) {
                            child = ref[i];
                            child.isLastRootNode = i === doc.children.length - 1;
                        }
                        options = this.filterOptions(options);
                        ref1 = doc.children;
                        results = [];
                        for (k = 0, len1 = ref1.length; k < len1; k++) {
                            child = ref1[k];
                            results.push(this.writeChildNode(child, options, 0));
                        }
                        return results;
                    };
                    XMLStreamWriter.prototype.attribute = function (att, options, level) {
                        return this.stream.write(XMLStreamWriter.__super__.attribute.call(this, att, options, level));
                    };
                    XMLStreamWriter.prototype.cdata = function (node, options, level) {
                        return this.stream.write(XMLStreamWriter.__super__.cdata.call(this, node, options, level));
                    };
                    XMLStreamWriter.prototype.comment = function (node, options, level) {
                        return this.stream.write(XMLStreamWriter.__super__.comment.call(this, node, options, level));
                    };
                    XMLStreamWriter.prototype.declaration = function (node, options, level) {
                        return this.stream.write(XMLStreamWriter.__super__.declaration.call(this, node, options, level));
                    };
                    XMLStreamWriter.prototype.docType = function (node, options, level) {
                        var child, j, len, ref;
                        level || (level = 0);
                        this.openNode(node, options, level);
                        options.state = WriterState.OpenTag;
                        this.stream.write(this.indent(node, options, level));
                        this.stream.write('<!DOCTYPE ' + node.root().name);
                        if (node.pubID && node.sysID) {
                            this.stream.write(' PUBLIC "' + node.pubID + '" "' + node.sysID + '"');
                        }
                        else if (node.sysID) {
                            this.stream.write(' SYSTEM "' + node.sysID + '"');
                        }
                        if (node.children.length > 0) {
                            this.stream.write(' [');
                            this.stream.write(this.endline(node, options, level));
                            options.state = WriterState.InsideTag;
                            ref = node.children;
                            for (j = 0, len = ref.length; j < len; j++) {
                                child = ref[j];
                                this.writeChildNode(child, options, level + 1);
                            }
                            options.state = WriterState.CloseTag;
                            this.stream.write(']');
                        }
                        options.state = WriterState.CloseTag;
                        this.stream.write(options.spaceBeforeSlash + '>');
                        this.stream.write(this.endline(node, options, level));
                        options.state = WriterState.None;
                        return this.closeNode(node, options, level);
                    };
                    XMLStreamWriter.prototype.element = function (node, options, level) {
                        var att, child, childNodeCount, firstChildNode, j, len, name, prettySuppressed, ref, ref1;
                        level || (level = 0);
                        this.openNode(node, options, level);
                        options.state = WriterState.OpenTag;
                        this.stream.write(this.indent(node, options, level) + '<' + node.name);
                        ref = node.attribs;
                        for (name in ref) {
                            if (!hasProp.call(ref, name))
                                continue;
                            att = ref[name];
                            this.attribute(att, options, level);
                        }
                        childNodeCount = node.children.length;
                        firstChildNode = childNodeCount === 0 ? null : node.children[0];
                        if (childNodeCount === 0 || node.children.every(function (e) {
                            return (e.type === NodeType.Text || e.type === NodeType.Raw) && e.value === '';
                        })) {
                            if (options.allowEmpty) {
                                this.stream.write('>');
                                options.state = WriterState.CloseTag;
                                this.stream.write('</' + node.name + '>');
                            }
                            else {
                                options.state = WriterState.CloseTag;
                                this.stream.write(options.spaceBeforeSlash + '/>');
                            }
                        }
                        else if (options.pretty && childNodeCount === 1 && (firstChildNode.type === NodeType.Text || firstChildNode.type === NodeType.Raw) && (firstChildNode.value != null)) {
                            this.stream.write('>');
                            options.state = WriterState.InsideTag;
                            options.suppressPrettyCount++;
                            prettySuppressed = true;
                            this.writeChildNode(firstChildNode, options, level + 1);
                            options.suppressPrettyCount--;
                            prettySuppressed = false;
                            options.state = WriterState.CloseTag;
                            this.stream.write('</' + node.name + '>');
                        }
                        else {
                            this.stream.write('>' + this.endline(node, options, level));
                            options.state = WriterState.InsideTag;
                            ref1 = node.children;
                            for (j = 0, len = ref1.length; j < len; j++) {
                                child = ref1[j];
                                this.writeChildNode(child, options, level + 1);
                            }
                            options.state = WriterState.CloseTag;
                            this.stream.write(this.indent(node, options, level) + '</' + node.name + '>');
                        }
                        this.stream.write(this.endline(node, options, level));
                        options.state = WriterState.None;
                        return this.closeNode(node, options, level);
                    };
                    XMLStreamWriter.prototype.processingInstruction = function (node, options, level) {
                        return this.stream.write(XMLStreamWriter.__super__.processingInstruction.call(this, node, options, level));
                    };
                    XMLStreamWriter.prototype.raw = function (node, options, level) {
                        return this.stream.write(XMLStreamWriter.__super__.raw.call(this, node, options, level));
                    };
                    XMLStreamWriter.prototype.text = function (node, options, level) {
                        return this.stream.write(XMLStreamWriter.__super__.text.call(this, node, options, level));
                    };
                    XMLStreamWriter.prototype.dtdAttList = function (node, options, level) {
                        return this.stream.write(XMLStreamWriter.__super__.dtdAttList.call(this, node, options, level));
                    };
                    XMLStreamWriter.prototype.dtdElement = function (node, options, level) {
                        return this.stream.write(XMLStreamWriter.__super__.dtdElement.call(this, node, options, level));
                    };
                    XMLStreamWriter.prototype.dtdEntity = function (node, options, level) {
                        return this.stream.write(XMLStreamWriter.__super__.dtdEntity.call(this, node, options, level));
                    };
                    XMLStreamWriter.prototype.dtdNotation = function (node, options, level) {
                        return this.stream.write(XMLStreamWriter.__super__.dtdNotation.call(this, node, options, level));
                    };
                    return XMLStreamWriter;
                })(XMLWriterBase);
            }).call(this);
            /***/ 
        }),
        /***/ "./node_modules/xml2js/node_modules/xmlbuilder/lib/XMLStringWriter.js": 
        /*!****************************************************************************!*\
          !*** ./node_modules/xml2js/node_modules/xmlbuilder/lib/XMLStringWriter.js ***!
          \****************************************************************************/
        /***/ (function (module, __unused_webpack_exports, __webpack_require__) {
            // Generated by CoffeeScript 1.12.7
            (function () {
                var XMLStringWriter, XMLWriterBase, extend = function (child, parent) { for (var key in parent) {
                    if (hasProp.call(parent, key))
                        child[key] = parent[key];
                } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty;
                XMLWriterBase = __webpack_require__(/*! ./XMLWriterBase */ "./node_modules/xml2js/node_modules/xmlbuilder/lib/XMLWriterBase.js");
                module.exports = XMLStringWriter = (function (superClass) {
                    extend(XMLStringWriter, superClass);
                    function XMLStringWriter(options) {
                        XMLStringWriter.__super__.constructor.call(this, options);
                    }
                    XMLStringWriter.prototype.document = function (doc, options) {
                        var child, i, len, r, ref;
                        options = this.filterOptions(options);
                        r = '';
                        ref = doc.children;
                        for (i = 0, len = ref.length; i < len; i++) {
                            child = ref[i];
                            r += this.writeChildNode(child, options, 0);
                        }
                        if (options.pretty && r.slice(-options.newline.length) === options.newline) {
                            r = r.slice(0, -options.newline.length);
                        }
                        return r;
                    };
                    return XMLStringWriter;
                })(XMLWriterBase);
            }).call(this);
            /***/ 
        }),
        /***/ "./node_modules/xml2js/node_modules/xmlbuilder/lib/XMLStringifier.js": 
        /*!***************************************************************************!*\
          !*** ./node_modules/xml2js/node_modules/xmlbuilder/lib/XMLStringifier.js ***!
          \***************************************************************************/
        /***/ (function (module) {
            // Generated by CoffeeScript 1.12.7
            (function () {
                var XMLStringifier, bind = function (fn, me) { return function () { return fn.apply(me, arguments); }; }, hasProp = {}.hasOwnProperty;
                module.exports = XMLStringifier = (function () {
                    function XMLStringifier(options) {
                        this.assertLegalName = bind(this.assertLegalName, this);
                        this.assertLegalChar = bind(this.assertLegalChar, this);
                        var key, ref, value;
                        options || (options = {});
                        this.options = options;
                        if (!this.options.version) {
                            this.options.version = '1.0';
                        }
                        ref = options.stringify || {};
                        for (key in ref) {
                            if (!hasProp.call(ref, key))
                                continue;
                            value = ref[key];
                            this[key] = value;
                        }
                    }
                    XMLStringifier.prototype.name = function (val) {
                        if (this.options.noValidation) {
                            return val;
                        }
                        return this.assertLegalName('' + val || '');
                    };
                    XMLStringifier.prototype.text = function (val) {
                        if (this.options.noValidation) {
                            return val;
                        }
                        return this.assertLegalChar(this.textEscape('' + val || ''));
                    };
                    XMLStringifier.prototype.cdata = function (val) {
                        if (this.options.noValidation) {
                            return val;
                        }
                        val = '' + val || '';
                        val = val.replace(']]>', ']]]]><![CDATA[>');
                        return this.assertLegalChar(val);
                    };
                    XMLStringifier.prototype.comment = function (val) {
                        if (this.options.noValidation) {
                            return val;
                        }
                        val = '' + val || '';
                        if (val.match(/--/)) {
                            throw new Error("Comment text cannot contain double-hypen: " + val);
                        }
                        return this.assertLegalChar(val);
                    };
                    XMLStringifier.prototype.raw = function (val) {
                        if (this.options.noValidation) {
                            return val;
                        }
                        return '' + val || '';
                    };
                    XMLStringifier.prototype.attValue = function (val) {
                        if (this.options.noValidation) {
                            return val;
                        }
                        return this.assertLegalChar(this.attEscape(val = '' + val || ''));
                    };
                    XMLStringifier.prototype.insTarget = function (val) {
                        if (this.options.noValidation) {
                            return val;
                        }
                        return this.assertLegalChar('' + val || '');
                    };
                    XMLStringifier.prototype.insValue = function (val) {
                        if (this.options.noValidation) {
                            return val;
                        }
                        val = '' + val || '';
                        if (val.match(/\?>/)) {
                            throw new Error("Invalid processing instruction value: " + val);
                        }
                        return this.assertLegalChar(val);
                    };
                    XMLStringifier.prototype.xmlVersion = function (val) {
                        if (this.options.noValidation) {
                            return val;
                        }
                        val = '' + val || '';
                        if (!val.match(/1\.[0-9]+/)) {
                            throw new Error("Invalid version number: " + val);
                        }
                        return val;
                    };
                    XMLStringifier.prototype.xmlEncoding = function (val) {
                        if (this.options.noValidation) {
                            return val;
                        }
                        val = '' + val || '';
                        if (!val.match(/^[A-Za-z](?:[A-Za-z0-9._-])*$/)) {
                            throw new Error("Invalid encoding: " + val);
                        }
                        return this.assertLegalChar(val);
                    };
                    XMLStringifier.prototype.xmlStandalone = function (val) {
                        if (this.options.noValidation) {
                            return val;
                        }
                        if (val) {
                            return "yes";
                        }
                        else {
                            return "no";
                        }
                    };
                    XMLStringifier.prototype.dtdPubID = function (val) {
                        if (this.options.noValidation) {
                            return val;
                        }
                        return this.assertLegalChar('' + val || '');
                    };
                    XMLStringifier.prototype.dtdSysID = function (val) {
                        if (this.options.noValidation) {
                            return val;
                        }
                        return this.assertLegalChar('' + val || '');
                    };
                    XMLStringifier.prototype.dtdElementValue = function (val) {
                        if (this.options.noValidation) {
                            return val;
                        }
                        return this.assertLegalChar('' + val || '');
                    };
                    XMLStringifier.prototype.dtdAttType = function (val) {
                        if (this.options.noValidation) {
                            return val;
                        }
                        return this.assertLegalChar('' + val || '');
                    };
                    XMLStringifier.prototype.dtdAttDefault = function (val) {
                        if (this.options.noValidation) {
                            return val;
                        }
                        return this.assertLegalChar('' + val || '');
                    };
                    XMLStringifier.prototype.dtdEntityValue = function (val) {
                        if (this.options.noValidation) {
                            return val;
                        }
                        return this.assertLegalChar('' + val || '');
                    };
                    XMLStringifier.prototype.dtdNData = function (val) {
                        if (this.options.noValidation) {
                            return val;
                        }
                        return this.assertLegalChar('' + val || '');
                    };
                    XMLStringifier.prototype.convertAttKey = '@';
                    XMLStringifier.prototype.convertPIKey = '?';
                    XMLStringifier.prototype.convertTextKey = '#text';
                    XMLStringifier.prototype.convertCDataKey = '#cdata';
                    XMLStringifier.prototype.convertCommentKey = '#comment';
                    XMLStringifier.prototype.convertRawKey = '#raw';
                    XMLStringifier.prototype.assertLegalChar = function (str) {
                        var regex, res;
                        if (this.options.noValidation) {
                            return str;
                        }
                        regex = '';
                        if (this.options.version === '1.0') {
                            regex = /[\0-\x08\x0B\f\x0E-\x1F\uFFFE\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/;
                            if (res = str.match(regex)) {
                                throw new Error("Invalid character in string: " + str + " at index " + res.index);
                            }
                        }
                        else if (this.options.version === '1.1') {
                            regex = /[\0\uFFFE\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/;
                            if (res = str.match(regex)) {
                                throw new Error("Invalid character in string: " + str + " at index " + res.index);
                            }
                        }
                        return str;
                    };
                    XMLStringifier.prototype.assertLegalName = function (str) {
                        var regex;
                        if (this.options.noValidation) {
                            return str;
                        }
                        this.assertLegalChar(str);
                        regex = /^([:A-Z_a-z\xC0-\xD6\xD8-\xF6\xF8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]|[\uD800-\uDB7F][\uDC00-\uDFFF])([\x2D\.0-:A-Z_a-z\xB7\xC0-\xD6\xD8-\xF6\xF8-\u037D\u037F-\u1FFF\u200C\u200D\u203F\u2040\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]|[\uD800-\uDB7F][\uDC00-\uDFFF])*$/;
                        if (!str.match(regex)) {
                            throw new Error("Invalid character in name");
                        }
                        return str;
                    };
                    XMLStringifier.prototype.textEscape = function (str) {
                        var ampregex;
                        if (this.options.noValidation) {
                            return str;
                        }
                        ampregex = this.options.noDoubleEncoding ? /(?!&\S+;)&/g : /&/g;
                        return str.replace(ampregex, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/\r/g, '&#xD;');
                    };
                    XMLStringifier.prototype.attEscape = function (str) {
                        var ampregex;
                        if (this.options.noValidation) {
                            return str;
                        }
                        ampregex = this.options.noDoubleEncoding ? /(?!&\S+;)&/g : /&/g;
                        return str.replace(ampregex, '&amp;').replace(/</g, '&lt;').replace(/"/g, '&quot;').replace(/\t/g, '&#x9;').replace(/\n/g, '&#xA;').replace(/\r/g, '&#xD;');
                    };
                    return XMLStringifier;
                })();
            }).call(this);
            /***/ 
        }),
        /***/ "./node_modules/xml2js/node_modules/xmlbuilder/lib/XMLText.js": 
        /*!********************************************************************!*\
          !*** ./node_modules/xml2js/node_modules/xmlbuilder/lib/XMLText.js ***!
          \********************************************************************/
        /***/ (function (module, __unused_webpack_exports, __webpack_require__) {
            // Generated by CoffeeScript 1.12.7
            (function () {
                var NodeType, XMLCharacterData, XMLText, extend = function (child, parent) { for (var key in parent) {
                    if (hasProp.call(parent, key))
                        child[key] = parent[key];
                } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty;
                NodeType = __webpack_require__(/*! ./NodeType */ "./node_modules/xml2js/node_modules/xmlbuilder/lib/NodeType.js");
                XMLCharacterData = __webpack_require__(/*! ./XMLCharacterData */ "./node_modules/xml2js/node_modules/xmlbuilder/lib/XMLCharacterData.js");
                module.exports = XMLText = (function (superClass) {
                    extend(XMLText, superClass);
                    function XMLText(parent, text) {
                        XMLText.__super__.constructor.call(this, parent);
                        if (text == null) {
                            throw new Error("Missing element text. " + this.debugInfo());
                        }
                        this.name = "#text";
                        this.type = NodeType.Text;
                        this.value = this.stringify.text(text);
                    }
                    Object.defineProperty(XMLText.prototype, 'isElementContentWhitespace', {
                        get: function () {
                            throw new Error("This DOM method is not implemented." + this.debugInfo());
                        }
                    });
                    Object.defineProperty(XMLText.prototype, 'wholeText', {
                        get: function () {
                            var next, prev, str;
                            str = '';
                            prev = this.previousSibling;
                            while (prev) {
                                str = prev.data + str;
                                prev = prev.previousSibling;
                            }
                            str += this.data;
                            next = this.nextSibling;
                            while (next) {
                                str = str + next.data;
                                next = next.nextSibling;
                            }
                            return str;
                        }
                    });
                    XMLText.prototype.clone = function () {
                        return Object.create(this);
                    };
                    XMLText.prototype.toString = function (options) {
                        return this.options.writer.text(this, this.options.writer.filterOptions(options));
                    };
                    XMLText.prototype.splitText = function (offset) {
                        throw new Error("This DOM method is not implemented." + this.debugInfo());
                    };
                    XMLText.prototype.replaceWholeText = function (content) {
                        throw new Error("This DOM method is not implemented." + this.debugInfo());
                    };
                    return XMLText;
                })(XMLCharacterData);
            }).call(this);
            /***/ 
        }),
        /***/ "./node_modules/xml2js/node_modules/xmlbuilder/lib/XMLWriterBase.js": 
        /*!**************************************************************************!*\
          !*** ./node_modules/xml2js/node_modules/xmlbuilder/lib/XMLWriterBase.js ***!
          \**************************************************************************/
        /***/ (function (module, __unused_webpack_exports, __webpack_require__) {
            // Generated by CoffeeScript 1.12.7
            (function () {
                var NodeType, WriterState, XMLCData, XMLComment, XMLDTDAttList, XMLDTDElement, XMLDTDEntity, XMLDTDNotation, XMLDeclaration, XMLDocType, XMLDummy, XMLElement, XMLProcessingInstruction, XMLRaw, XMLText, XMLWriterBase, assign, hasProp = {}.hasOwnProperty;
                assign = (__webpack_require__(/*! ./Utility */ "./node_modules/xml2js/node_modules/xmlbuilder/lib/Utility.js").assign);
                NodeType = __webpack_require__(/*! ./NodeType */ "./node_modules/xml2js/node_modules/xmlbuilder/lib/NodeType.js");
                XMLDeclaration = __webpack_require__(/*! ./XMLDeclaration */ "./node_modules/xml2js/node_modules/xmlbuilder/lib/XMLDeclaration.js");
                XMLDocType = __webpack_require__(/*! ./XMLDocType */ "./node_modules/xml2js/node_modules/xmlbuilder/lib/XMLDocType.js");
                XMLCData = __webpack_require__(/*! ./XMLCData */ "./node_modules/xml2js/node_modules/xmlbuilder/lib/XMLCData.js");
                XMLComment = __webpack_require__(/*! ./XMLComment */ "./node_modules/xml2js/node_modules/xmlbuilder/lib/XMLComment.js");
                XMLElement = __webpack_require__(/*! ./XMLElement */ "./node_modules/xml2js/node_modules/xmlbuilder/lib/XMLElement.js");
                XMLRaw = __webpack_require__(/*! ./XMLRaw */ "./node_modules/xml2js/node_modules/xmlbuilder/lib/XMLRaw.js");
                XMLText = __webpack_require__(/*! ./XMLText */ "./node_modules/xml2js/node_modules/xmlbuilder/lib/XMLText.js");
                XMLProcessingInstruction = __webpack_require__(/*! ./XMLProcessingInstruction */ "./node_modules/xml2js/node_modules/xmlbuilder/lib/XMLProcessingInstruction.js");
                XMLDummy = __webpack_require__(/*! ./XMLDummy */ "./node_modules/xml2js/node_modules/xmlbuilder/lib/XMLDummy.js");
                XMLDTDAttList = __webpack_require__(/*! ./XMLDTDAttList */ "./node_modules/xml2js/node_modules/xmlbuilder/lib/XMLDTDAttList.js");
                XMLDTDElement = __webpack_require__(/*! ./XMLDTDElement */ "./node_modules/xml2js/node_modules/xmlbuilder/lib/XMLDTDElement.js");
                XMLDTDEntity = __webpack_require__(/*! ./XMLDTDEntity */ "./node_modules/xml2js/node_modules/xmlbuilder/lib/XMLDTDEntity.js");
                XMLDTDNotation = __webpack_require__(/*! ./XMLDTDNotation */ "./node_modules/xml2js/node_modules/xmlbuilder/lib/XMLDTDNotation.js");
                WriterState = __webpack_require__(/*! ./WriterState */ "./node_modules/xml2js/node_modules/xmlbuilder/lib/WriterState.js");
                module.exports = XMLWriterBase = (function () {
                    function XMLWriterBase(options) {
                        var key, ref, value;
                        options || (options = {});
                        this.options = options;
                        ref = options.writer || {};
                        for (key in ref) {
                            if (!hasProp.call(ref, key))
                                continue;
                            value = ref[key];
                            this["_" + key] = this[key];
                            this[key] = value;
                        }
                    }
                    XMLWriterBase.prototype.filterOptions = function (options) {
                        var filteredOptions, ref, ref1, ref2, ref3, ref4, ref5, ref6;
                        options || (options = {});
                        options = assign({}, this.options, options);
                        filteredOptions = {
                            writer: this
                        };
                        filteredOptions.pretty = options.pretty || false;
                        filteredOptions.allowEmpty = options.allowEmpty || false;
                        filteredOptions.indent = (ref = options.indent) != null ? ref : '  ';
                        filteredOptions.newline = (ref1 = options.newline) != null ? ref1 : '\n';
                        filteredOptions.offset = (ref2 = options.offset) != null ? ref2 : 0;
                        filteredOptions.dontPrettyTextNodes = (ref3 = (ref4 = options.dontPrettyTextNodes) != null ? ref4 : options.dontprettytextnodes) != null ? ref3 : 0;
                        filteredOptions.spaceBeforeSlash = (ref5 = (ref6 = options.spaceBeforeSlash) != null ? ref6 : options.spacebeforeslash) != null ? ref5 : '';
                        if (filteredOptions.spaceBeforeSlash === true) {
                            filteredOptions.spaceBeforeSlash = ' ';
                        }
                        filteredOptions.suppressPrettyCount = 0;
                        filteredOptions.user = {};
                        filteredOptions.state = WriterState.None;
                        return filteredOptions;
                    };
                    XMLWriterBase.prototype.indent = function (node, options, level) {
                        var indentLevel;
                        if (!options.pretty || options.suppressPrettyCount) {
                            return '';
                        }
                        else if (options.pretty) {
                            indentLevel = (level || 0) + options.offset + 1;
                            if (indentLevel > 0) {
                                return new Array(indentLevel).join(options.indent);
                            }
                        }
                        return '';
                    };
                    XMLWriterBase.prototype.endline = function (node, options, level) {
                        if (!options.pretty || options.suppressPrettyCount) {
                            return '';
                        }
                        else {
                            return options.newline;
                        }
                    };
                    XMLWriterBase.prototype.attribute = function (att, options, level) {
                        var r;
                        this.openAttribute(att, options, level);
                        r = ' ' + att.name + '="' + att.value + '"';
                        this.closeAttribute(att, options, level);
                        return r;
                    };
                    XMLWriterBase.prototype.cdata = function (node, options, level) {
                        var r;
                        this.openNode(node, options, level);
                        options.state = WriterState.OpenTag;
                        r = this.indent(node, options, level) + '<![CDATA[';
                        options.state = WriterState.InsideTag;
                        r += node.value;
                        options.state = WriterState.CloseTag;
                        r += ']]>' + this.endline(node, options, level);
                        options.state = WriterState.None;
                        this.closeNode(node, options, level);
                        return r;
                    };
                    XMLWriterBase.prototype.comment = function (node, options, level) {
                        var r;
                        this.openNode(node, options, level);
                        options.state = WriterState.OpenTag;
                        r = this.indent(node, options, level) + '<!-- ';
                        options.state = WriterState.InsideTag;
                        r += node.value;
                        options.state = WriterState.CloseTag;
                        r += ' -->' + this.endline(node, options, level);
                        options.state = WriterState.None;
                        this.closeNode(node, options, level);
                        return r;
                    };
                    XMLWriterBase.prototype.declaration = function (node, options, level) {
                        var r;
                        this.openNode(node, options, level);
                        options.state = WriterState.OpenTag;
                        r = this.indent(node, options, level) + '<?xml';
                        options.state = WriterState.InsideTag;
                        r += ' version="' + node.version + '"';
                        if (node.encoding != null) {
                            r += ' encoding="' + node.encoding + '"';
                        }
                        if (node.standalone != null) {
                            r += ' standalone="' + node.standalone + '"';
                        }
                        options.state = WriterState.CloseTag;
                        r += options.spaceBeforeSlash + '?>';
                        r += this.endline(node, options, level);
                        options.state = WriterState.None;
                        this.closeNode(node, options, level);
                        return r;
                    };
                    XMLWriterBase.prototype.docType = function (node, options, level) {
                        var child, i, len, r, ref;
                        level || (level = 0);
                        this.openNode(node, options, level);
                        options.state = WriterState.OpenTag;
                        r = this.indent(node, options, level);
                        r += '<!DOCTYPE ' + node.root().name;
                        if (node.pubID && node.sysID) {
                            r += ' PUBLIC "' + node.pubID + '" "' + node.sysID + '"';
                        }
                        else if (node.sysID) {
                            r += ' SYSTEM "' + node.sysID + '"';
                        }
                        if (node.children.length > 0) {
                            r += ' [';
                            r += this.endline(node, options, level);
                            options.state = WriterState.InsideTag;
                            ref = node.children;
                            for (i = 0, len = ref.length; i < len; i++) {
                                child = ref[i];
                                r += this.writeChildNode(child, options, level + 1);
                            }
                            options.state = WriterState.CloseTag;
                            r += ']';
                        }
                        options.state = WriterState.CloseTag;
                        r += options.spaceBeforeSlash + '>';
                        r += this.endline(node, options, level);
                        options.state = WriterState.None;
                        this.closeNode(node, options, level);
                        return r;
                    };
                    XMLWriterBase.prototype.element = function (node, options, level) {
                        var att, child, childNodeCount, firstChildNode, i, j, len, len1, name, prettySuppressed, r, ref, ref1, ref2;
                        level || (level = 0);
                        prettySuppressed = false;
                        r = '';
                        this.openNode(node, options, level);
                        options.state = WriterState.OpenTag;
                        r += this.indent(node, options, level) + '<' + node.name;
                        ref = node.attribs;
                        for (name in ref) {
                            if (!hasProp.call(ref, name))
                                continue;
                            att = ref[name];
                            r += this.attribute(att, options, level);
                        }
                        childNodeCount = node.children.length;
                        firstChildNode = childNodeCount === 0 ? null : node.children[0];
                        if (childNodeCount === 0 || node.children.every(function (e) {
                            return (e.type === NodeType.Text || e.type === NodeType.Raw) && e.value === '';
                        })) {
                            if (options.allowEmpty) {
                                r += '>';
                                options.state = WriterState.CloseTag;
                                r += '</' + node.name + '>' + this.endline(node, options, level);
                            }
                            else {
                                options.state = WriterState.CloseTag;
                                r += options.spaceBeforeSlash + '/>' + this.endline(node, options, level);
                            }
                        }
                        else if (options.pretty && childNodeCount === 1 && (firstChildNode.type === NodeType.Text || firstChildNode.type === NodeType.Raw) && (firstChildNode.value != null)) {
                            r += '>';
                            options.state = WriterState.InsideTag;
                            options.suppressPrettyCount++;
                            prettySuppressed = true;
                            r += this.writeChildNode(firstChildNode, options, level + 1);
                            options.suppressPrettyCount--;
                            prettySuppressed = false;
                            options.state = WriterState.CloseTag;
                            r += '</' + node.name + '>' + this.endline(node, options, level);
                        }
                        else {
                            if (options.dontPrettyTextNodes) {
                                ref1 = node.children;
                                for (i = 0, len = ref1.length; i < len; i++) {
                                    child = ref1[i];
                                    if ((child.type === NodeType.Text || child.type === NodeType.Raw) && (child.value != null)) {
                                        options.suppressPrettyCount++;
                                        prettySuppressed = true;
                                        break;
                                    }
                                }
                            }
                            r += '>' + this.endline(node, options, level);
                            options.state = WriterState.InsideTag;
                            ref2 = node.children;
                            for (j = 0, len1 = ref2.length; j < len1; j++) {
                                child = ref2[j];
                                r += this.writeChildNode(child, options, level + 1);
                            }
                            options.state = WriterState.CloseTag;
                            r += this.indent(node, options, level) + '</' + node.name + '>';
                            if (prettySuppressed) {
                                options.suppressPrettyCount--;
                            }
                            r += this.endline(node, options, level);
                            options.state = WriterState.None;
                        }
                        this.closeNode(node, options, level);
                        return r;
                    };
                    XMLWriterBase.prototype.writeChildNode = function (node, options, level) {
                        switch (node.type) {
                            case NodeType.CData:
                                return this.cdata(node, options, level);
                            case NodeType.Comment:
                                return this.comment(node, options, level);
                            case NodeType.Element:
                                return this.element(node, options, level);
                            case NodeType.Raw:
                                return this.raw(node, options, level);
                            case NodeType.Text:
                                return this.text(node, options, level);
                            case NodeType.ProcessingInstruction:
                                return this.processingInstruction(node, options, level);
                            case NodeType.Dummy:
                                return '';
                            case NodeType.Declaration:
                                return this.declaration(node, options, level);
                            case NodeType.DocType:
                                return this.docType(node, options, level);
                            case NodeType.AttributeDeclaration:
                                return this.dtdAttList(node, options, level);
                            case NodeType.ElementDeclaration:
                                return this.dtdElement(node, options, level);
                            case NodeType.EntityDeclaration:
                                return this.dtdEntity(node, options, level);
                            case NodeType.NotationDeclaration:
                                return this.dtdNotation(node, options, level);
                            default:
                                throw new Error("Unknown XML node type: " + node.constructor.name);
                        }
                    };
                    XMLWriterBase.prototype.processingInstruction = function (node, options, level) {
                        var r;
                        this.openNode(node, options, level);
                        options.state = WriterState.OpenTag;
                        r = this.indent(node, options, level) + '<?';
                        options.state = WriterState.InsideTag;
                        r += node.target;
                        if (node.value) {
                            r += ' ' + node.value;
                        }
                        options.state = WriterState.CloseTag;
                        r += options.spaceBeforeSlash + '?>';
                        r += this.endline(node, options, level);
                        options.state = WriterState.None;
                        this.closeNode(node, options, level);
                        return r;
                    };
                    XMLWriterBase.prototype.raw = function (node, options, level) {
                        var r;
                        this.openNode(node, options, level);
                        options.state = WriterState.OpenTag;
                        r = this.indent(node, options, level);
                        options.state = WriterState.InsideTag;
                        r += node.value;
                        options.state = WriterState.CloseTag;
                        r += this.endline(node, options, level);
                        options.state = WriterState.None;
                        this.closeNode(node, options, level);
                        return r;
                    };
                    XMLWriterBase.prototype.text = function (node, options, level) {
                        var r;
                        this.openNode(node, options, level);
                        options.state = WriterState.OpenTag;
                        r = this.indent(node, options, level);
                        options.state = WriterState.InsideTag;
                        r += node.value;
                        options.state = WriterState.CloseTag;
                        r += this.endline(node, options, level);
                        options.state = WriterState.None;
                        this.closeNode(node, options, level);
                        return r;
                    };
                    XMLWriterBase.prototype.dtdAttList = function (node, options, level) {
                        var r;
                        this.openNode(node, options, level);
                        options.state = WriterState.OpenTag;
                        r = this.indent(node, options, level) + '<!ATTLIST';
                        options.state = WriterState.InsideTag;
                        r += ' ' + node.elementName + ' ' + node.attributeName + ' ' + node.attributeType;
                        if (node.defaultValueType !== '#DEFAULT') {
                            r += ' ' + node.defaultValueType;
                        }
                        if (node.defaultValue) {
                            r += ' "' + node.defaultValue + '"';
                        }
                        options.state = WriterState.CloseTag;
                        r += options.spaceBeforeSlash + '>' + this.endline(node, options, level);
                        options.state = WriterState.None;
                        this.closeNode(node, options, level);
                        return r;
                    };
                    XMLWriterBase.prototype.dtdElement = function (node, options, level) {
                        var r;
                        this.openNode(node, options, level);
                        options.state = WriterState.OpenTag;
                        r = this.indent(node, options, level) + '<!ELEMENT';
                        options.state = WriterState.InsideTag;
                        r += ' ' + node.name + ' ' + node.value;
                        options.state = WriterState.CloseTag;
                        r += options.spaceBeforeSlash + '>' + this.endline(node, options, level);
                        options.state = WriterState.None;
                        this.closeNode(node, options, level);
                        return r;
                    };
                    XMLWriterBase.prototype.dtdEntity = function (node, options, level) {
                        var r;
                        this.openNode(node, options, level);
                        options.state = WriterState.OpenTag;
                        r = this.indent(node, options, level) + '<!ENTITY';
                        options.state = WriterState.InsideTag;
                        if (node.pe) {
                            r += ' %';
                        }
                        r += ' ' + node.name;
                        if (node.value) {
                            r += ' "' + node.value + '"';
                        }
                        else {
                            if (node.pubID && node.sysID) {
                                r += ' PUBLIC "' + node.pubID + '" "' + node.sysID + '"';
                            }
                            else if (node.sysID) {
                                r += ' SYSTEM "' + node.sysID + '"';
                            }
                            if (node.nData) {
                                r += ' NDATA ' + node.nData;
                            }
                        }
                        options.state = WriterState.CloseTag;
                        r += options.spaceBeforeSlash + '>' + this.endline(node, options, level);
                        options.state = WriterState.None;
                        this.closeNode(node, options, level);
                        return r;
                    };
                    XMLWriterBase.prototype.dtdNotation = function (node, options, level) {
                        var r;
                        this.openNode(node, options, level);
                        options.state = WriterState.OpenTag;
                        r = this.indent(node, options, level) + '<!NOTATION';
                        options.state = WriterState.InsideTag;
                        r += ' ' + node.name;
                        if (node.pubID && node.sysID) {
                            r += ' PUBLIC "' + node.pubID + '" "' + node.sysID + '"';
                        }
                        else if (node.pubID) {
                            r += ' PUBLIC "' + node.pubID + '"';
                        }
                        else if (node.sysID) {
                            r += ' SYSTEM "' + node.sysID + '"';
                        }
                        options.state = WriterState.CloseTag;
                        r += options.spaceBeforeSlash + '>' + this.endline(node, options, level);
                        options.state = WriterState.None;
                        this.closeNode(node, options, level);
                        return r;
                    };
                    XMLWriterBase.prototype.openNode = function (node, options, level) { };
                    XMLWriterBase.prototype.closeNode = function (node, options, level) { };
                    XMLWriterBase.prototype.openAttribute = function (att, options, level) { };
                    XMLWriterBase.prototype.closeAttribute = function (att, options, level) { };
                    return XMLWriterBase;
                })();
            }).call(this);
            /***/ 
        }),
        /***/ "./node_modules/xml2js/node_modules/xmlbuilder/lib/index.js": 
        /*!******************************************************************!*\
          !*** ./node_modules/xml2js/node_modules/xmlbuilder/lib/index.js ***!
          \******************************************************************/
        /***/ (function (module, __unused_webpack_exports, __webpack_require__) {
            // Generated by CoffeeScript 1.12.7
            (function () {
                var NodeType, WriterState, XMLDOMImplementation, XMLDocument, XMLDocumentCB, XMLStreamWriter, XMLStringWriter, assign, isFunction, ref;
                ref = __webpack_require__(/*! ./Utility */ "./node_modules/xml2js/node_modules/xmlbuilder/lib/Utility.js"), assign = ref.assign, isFunction = ref.isFunction;
                XMLDOMImplementation = __webpack_require__(/*! ./XMLDOMImplementation */ "./node_modules/xml2js/node_modules/xmlbuilder/lib/XMLDOMImplementation.js");
                XMLDocument = __webpack_require__(/*! ./XMLDocument */ "./node_modules/xml2js/node_modules/xmlbuilder/lib/XMLDocument.js");
                XMLDocumentCB = __webpack_require__(/*! ./XMLDocumentCB */ "./node_modules/xml2js/node_modules/xmlbuilder/lib/XMLDocumentCB.js");
                XMLStringWriter = __webpack_require__(/*! ./XMLStringWriter */ "./node_modules/xml2js/node_modules/xmlbuilder/lib/XMLStringWriter.js");
                XMLStreamWriter = __webpack_require__(/*! ./XMLStreamWriter */ "./node_modules/xml2js/node_modules/xmlbuilder/lib/XMLStreamWriter.js");
                NodeType = __webpack_require__(/*! ./NodeType */ "./node_modules/xml2js/node_modules/xmlbuilder/lib/NodeType.js");
                WriterState = __webpack_require__(/*! ./WriterState */ "./node_modules/xml2js/node_modules/xmlbuilder/lib/WriterState.js");
                module.exports.create = function (name, xmldec, doctype, options) {
                    var doc, root;
                    if (name == null) {
                        throw new Error("Root element needs a name.");
                    }
                    options = assign({}, xmldec, doctype, options);
                    doc = new XMLDocument(options);
                    root = doc.element(name);
                    if (!options.headless) {
                        doc.declaration(options);
                        if ((options.pubID != null) || (options.sysID != null)) {
                            doc.dtd(options);
                        }
                    }
                    return root;
                };
                module.exports.begin = function (options, onData, onEnd) {
                    var ref1;
                    if (isFunction(options)) {
                        ref1 = [options, onData], onData = ref1[0], onEnd = ref1[1];
                        options = {};
                    }
                    if (onData) {
                        return new XMLDocumentCB(options, onData, onEnd);
                    }
                    else {
                        return new XMLDocument(options);
                    }
                };
                module.exports.stringWriter = function (options) {
                    return new XMLStringWriter(options);
                };
                module.exports.streamWriter = function (stream, options) {
                    return new XMLStreamWriter(stream, options);
                };
                module.exports.implementation = new XMLDOMImplementation();
                module.exports.nodeType = NodeType;
                module.exports.writerState = WriterState;
            }).call(this);
            /***/ 
        }),
        /***/ "./packages/loot-core/src/server/budget/cleanup-template.pegjs": 
        /*!*********************************************************************!*\
          !*** ./packages/loot-core/src/server/budget/cleanup-template.pegjs ***!
          \*********************************************************************/
        /***/ (function (module, exports) {
            var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__; // Generated by Peggy 3.0.2.
            //
            // https://peggyjs.org/
            (function (root, factory) {
                if (true) {
                    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
                        __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
                            (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
                        __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
                }
                else { }
            })(this, function () {
                "use strict";
                function peg$subclass(child, parent) {
                    function C() { this.constructor = child; }
                    C.prototype = parent.prototype;
                    child.prototype = new C();
                }
                function peg$SyntaxError(message, expected, found, location) {
                    var self = Error.call(this, message);
                    // istanbul ignore next Check is a necessary evil to support older environments
                    if (Object.setPrototypeOf) {
                        Object.setPrototypeOf(self, peg$SyntaxError.prototype);
                    }
                    self.expected = expected;
                    self.found = found;
                    self.location = location;
                    self.name = "SyntaxError";
                    return self;
                }
                peg$subclass(peg$SyntaxError, Error);
                function peg$padEnd(str, targetLength, padString) {
                    padString = padString || " ";
                    if (str.length > targetLength) {
                        return str;
                    }
                    targetLength -= str.length;
                    padString += padString.repeat(targetLength);
                    return str + padString.slice(0, targetLength);
                }
                peg$SyntaxError.prototype.format = function (sources) {
                    var str = "Error: " + this.message;
                    if (this.location) {
                        var src = null;
                        var k;
                        for (k = 0; k < sources.length; k++) {
                            if (sources[k].source === this.location.source) {
                                src = sources[k].text.split(/\r\n|\n|\r/g);
                                break;
                            }
                        }
                        var s = this.location.start;
                        var offset_s = (this.location.source && (typeof this.location.source.offset === "function"))
                            ? this.location.source.offset(s)
                            : s;
                        var loc = this.location.source + ":" + offset_s.line + ":" + offset_s.column;
                        if (src) {
                            var e = this.location.end;
                            var filler = peg$padEnd("", offset_s.line.toString().length, ' ');
                            var line = src[s.line - 1];
                            var last = s.line === e.line ? e.column : line.length + 1;
                            var hatLen = (last - s.column) || 1;
                            str += "\n --> " + loc + "\n"
                                + filler + " |\n"
                                + offset_s.line + " | " + line + "\n"
                                + filler + " | " + peg$padEnd("", s.column - 1, ' ')
                                + peg$padEnd("", hatLen, "^");
                        }
                        else {
                            str += "\n at " + loc;
                        }
                    }
                    return str;
                };
                peg$SyntaxError.buildMessage = function (expected, found) {
                    var DESCRIBE_EXPECTATION_FNS = {
                        literal: function (expectation) {
                            return "\"" + literalEscape(expectation.text) + "\"";
                        },
                        class: function (expectation) {
                            var escapedParts = expectation.parts.map(function (part) {
                                return Array.isArray(part)
                                    ? classEscape(part[0]) + "-" + classEscape(part[1])
                                    : classEscape(part);
                            });
                            return "[" + (expectation.inverted ? "^" : "") + escapedParts.join("") + "]";
                        },
                        any: function () {
                            return "any character";
                        },
                        end: function () {
                            return "end of input";
                        },
                        other: function (expectation) {
                            return expectation.description;
                        }
                    };
                    function hex(ch) {
                        return ch.charCodeAt(0).toString(16).toUpperCase();
                    }
                    function literalEscape(s) {
                        return s
                            .replace(/\\/g, "\\\\")
                            .replace(/"/g, "\\\"")
                            .replace(/\0/g, "\\0")
                            .replace(/\t/g, "\\t")
                            .replace(/\n/g, "\\n")
                            .replace(/\r/g, "\\r")
                            .replace(/[\x00-\x0F]/g, function (ch) { return "\\x0" + hex(ch); })
                            .replace(/[\x10-\x1F\x7F-\x9F]/g, function (ch) { return "\\x" + hex(ch); });
                    }
                    function classEscape(s) {
                        return s
                            .replace(/\\/g, "\\\\")
                            .replace(/\]/g, "\\]")
                            .replace(/\^/g, "\\^")
                            .replace(/-/g, "\\-")
                            .replace(/\0/g, "\\0")
                            .replace(/\t/g, "\\t")
                            .replace(/\n/g, "\\n")
                            .replace(/\r/g, "\\r")
                            .replace(/[\x00-\x0F]/g, function (ch) { return "\\x0" + hex(ch); })
                            .replace(/[\x10-\x1F\x7F-\x9F]/g, function (ch) { return "\\x" + hex(ch); });
                    }
                    function describeExpectation(expectation) {
                        return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);
                    }
                    function describeExpected(expected) {
                        var descriptions = expected.map(describeExpectation);
                        var i, j;
                        descriptions.sort();
                        if (descriptions.length > 0) {
                            for (i = 1, j = 1; i < descriptions.length; i++) {
                                if (descriptions[i - 1] !== descriptions[i]) {
                                    descriptions[j] = descriptions[i];
                                    j++;
                                }
                            }
                            descriptions.length = j;
                        }
                        switch (descriptions.length) {
                            case 1:
                                return descriptions[0];
                            case 2:
                                return descriptions[0] + " or " + descriptions[1];
                            default:
                                return descriptions.slice(0, -1).join(", ")
                                    + ", or "
                                    + descriptions[descriptions.length - 1];
                        }
                    }
                    function describeFound(found) {
                        return found ? "\"" + literalEscape(found) + "\"" : "end of input";
                    }
                    return "Expected " + describeExpected(expected) + " but " + describeFound(found) + " found.";
                };
                function peg$parse(input, options) {
                    options = options !== undefined ? options : {};
                    var peg$FAILED = {};
                    var peg$source = options.grammarSource;
                    var peg$startRuleFunctions = { expr: peg$parseexpr };
                    var peg$startRuleFunction = peg$parseexpr;
                    var peg$c0 = "source";
                    var peg$c1 = "sink";
                    var peg$c2 = " ";
                    var peg$c3 = " source";
                    var peg$c4 = " sink";
                    var peg$r0 = /^[0-9]/;
                    var peg$e0 = peg$literalExpectation("source", false);
                    var peg$e1 = peg$literalExpectation("sink", false);
                    var peg$e2 = peg$otherExpectation("space");
                    var peg$e3 = peg$literalExpectation(" ", false);
                    var peg$e4 = peg$otherExpectation("digit");
                    var peg$e5 = peg$classExpectation([["0", "9"]], false, false);
                    var peg$e6 = peg$otherExpectation("weight");
                    var peg$e7 = peg$otherExpectation("Name");
                    var peg$e8 = peg$literalExpectation(" source", false);
                    var peg$e9 = peg$anyExpectation();
                    var peg$e10 = peg$literalExpectation(" sink", false);
                    var peg$f0 = function () { return { group: null, type: 'source' }; };
                    var peg$f1 = function (weight) { return { type: 'sink', weight: +weight || 1, group: null }; };
                    var peg$f2 = function (group) { return { group: group || null, type: 'source' }; };
                    var peg$f3 = function (group, weight) { return { type: 'sink', weight: +weight || 1, group: group || null }; };
                    var peg$f4 = function (group) { return { group: group, type: null }; };
                    var peg$f5 = function (weight) { return +weight; };
                    var peg$currPos = 0;
                    var peg$savedPos = 0;
                    var peg$posDetailsCache = [{ line: 1, column: 1 }];
                    var peg$maxFailPos = 0;
                    var peg$maxFailExpected = [];
                    var peg$silentFails = 0;
                    var peg$result;
                    if ("startRule" in options) {
                        if (!(options.startRule in peg$startRuleFunctions)) {
                            throw new Error("Can't start parsing from rule \"" + options.startRule + "\".");
                        }
                        peg$startRuleFunction = peg$startRuleFunctions[options.startRule];
                    }
                    function text() {
                        return input.substring(peg$savedPos, peg$currPos);
                    }
                    function offset() {
                        return peg$savedPos;
                    }
                    function range() {
                        return {
                            source: peg$source,
                            start: peg$savedPos,
                            end: peg$currPos
                        };
                    }
                    function location() {
                        return peg$computeLocation(peg$savedPos, peg$currPos);
                    }
                    function expected(description, location) {
                        location = location !== undefined
                            ? location
                            : peg$computeLocation(peg$savedPos, peg$currPos);
                        throw peg$buildStructuredError([peg$otherExpectation(description)], input.substring(peg$savedPos, peg$currPos), location);
                    }
                    function error(message, location) {
                        location = location !== undefined
                            ? location
                            : peg$computeLocation(peg$savedPos, peg$currPos);
                        throw peg$buildSimpleError(message, location);
                    }
                    function peg$literalExpectation(text, ignoreCase) {
                        return { type: "literal", text: text, ignoreCase: ignoreCase };
                    }
                    function peg$classExpectation(parts, inverted, ignoreCase) {
                        return { type: "class", parts: parts, inverted: inverted, ignoreCase: ignoreCase };
                    }
                    function peg$anyExpectation() {
                        return { type: "any" };
                    }
                    function peg$endExpectation() {
                        return { type: "end" };
                    }
                    function peg$otherExpectation(description) {
                        return { type: "other", description: description };
                    }
                    function peg$computePosDetails(pos) {
                        var details = peg$posDetailsCache[pos];
                        var p;
                        if (details) {
                            return details;
                        }
                        else {
                            p = pos - 1;
                            while (!peg$posDetailsCache[p]) {
                                p--;
                            }
                            details = peg$posDetailsCache[p];
                            details = {
                                line: details.line,
                                column: details.column
                            };
                            while (p < pos) {
                                if (input.charCodeAt(p) === 10) {
                                    details.line++;
                                    details.column = 1;
                                }
                                else {
                                    details.column++;
                                }
                                p++;
                            }
                            peg$posDetailsCache[pos] = details;
                            return details;
                        }
                    }
                    function peg$computeLocation(startPos, endPos, offset) {
                        var startPosDetails = peg$computePosDetails(startPos);
                        var endPosDetails = peg$computePosDetails(endPos);
                        var res = {
                            source: peg$source,
                            start: {
                                offset: startPos,
                                line: startPosDetails.line,
                                column: startPosDetails.column
                            },
                            end: {
                                offset: endPos,
                                line: endPosDetails.line,
                                column: endPosDetails.column
                            }
                        };
                        if (offset && peg$source && (typeof peg$source.offset === "function")) {
                            res.start = peg$source.offset(res.start);
                            res.end = peg$source.offset(res.end);
                        }
                        return res;
                    }
                    function peg$fail(expected) {
                        if (peg$currPos < peg$maxFailPos) {
                            return;
                        }
                        if (peg$currPos > peg$maxFailPos) {
                            peg$maxFailPos = peg$currPos;
                            peg$maxFailExpected = [];
                        }
                        peg$maxFailExpected.push(expected);
                    }
                    function peg$buildSimpleError(message, location) {
                        return new peg$SyntaxError(message, null, null, location);
                    }
                    function peg$buildStructuredError(expected, found, location) {
                        return new peg$SyntaxError(peg$SyntaxError.buildMessage(expected, found), expected, found, location);
                    }
                    function peg$parseexpr() {
                        var s0, s1, s2, s3, s4, s5;
                        s0 = peg$currPos;
                        s1 = peg$parsesource();
                        if (s1 !== peg$FAILED) {
                            peg$savedPos = s0;
                            s1 = peg$f0();
                        }
                        s0 = s1;
                        if (s0 === peg$FAILED) {
                            s0 = peg$currPos;
                            s1 = peg$parsesink();
                            if (s1 !== peg$FAILED) {
                                s2 = peg$parse_();
                                if (s2 === peg$FAILED) {
                                    s2 = null;
                                }
                                s3 = peg$parseweight();
                                if (s3 === peg$FAILED) {
                                    s3 = null;
                                }
                                peg$savedPos = s0;
                                s0 = peg$f1(s3);
                            }
                            else {
                                peg$currPos = s0;
                                s0 = peg$FAILED;
                            }
                            if (s0 === peg$FAILED) {
                                s0 = peg$currPos;
                                s1 = peg$parsesourcegroup();
                                s2 = peg$parse_();
                                if (s2 === peg$FAILED) {
                                    s2 = null;
                                }
                                s3 = peg$parsesource();
                                if (s3 !== peg$FAILED) {
                                    peg$savedPos = s0;
                                    s0 = peg$f2(s1);
                                }
                                else {
                                    peg$currPos = s0;
                                    s0 = peg$FAILED;
                                }
                                if (s0 === peg$FAILED) {
                                    s0 = peg$currPos;
                                    s1 = peg$parsesinkgroup();
                                    s2 = peg$parse_();
                                    if (s2 === peg$FAILED) {
                                        s2 = null;
                                    }
                                    s3 = peg$parsesink();
                                    if (s3 !== peg$FAILED) {
                                        s4 = peg$parse_();
                                        if (s4 === peg$FAILED) {
                                            s4 = null;
                                        }
                                        s5 = peg$parseweight();
                                        if (s5 === peg$FAILED) {
                                            s5 = null;
                                        }
                                        peg$savedPos = s0;
                                        s0 = peg$f3(s1, s5);
                                    }
                                    else {
                                        peg$currPos = s0;
                                        s0 = peg$FAILED;
                                    }
                                    if (s0 === peg$FAILED) {
                                        s0 = peg$currPos;
                                        s1 = peg$parsesourcegroup();
                                        peg$savedPos = s0;
                                        s1 = peg$f4(s1);
                                        s0 = s1;
                                    }
                                }
                            }
                        }
                        return s0;
                    }
                    function peg$parsesource() {
                        var s0;
                        if (input.substr(peg$currPos, 6) === peg$c0) {
                            s0 = peg$c0;
                            peg$currPos += 6;
                        }
                        else {
                            s0 = peg$FAILED;
                            if (peg$silentFails === 0) {
                                peg$fail(peg$e0);
                            }
                        }
                        return s0;
                    }
                    function peg$parsesink() {
                        var s0;
                        if (input.substr(peg$currPos, 4) === peg$c1) {
                            s0 = peg$c1;
                            peg$currPos += 4;
                        }
                        else {
                            s0 = peg$FAILED;
                            if (peg$silentFails === 0) {
                                peg$fail(peg$e1);
                            }
                        }
                        return s0;
                    }
                    function peg$parse_() {
                        var s0, s1;
                        peg$silentFails++;
                        s0 = [];
                        if (input.charCodeAt(peg$currPos) === 32) {
                            s1 = peg$c2;
                            peg$currPos++;
                        }
                        else {
                            s1 = peg$FAILED;
                            if (peg$silentFails === 0) {
                                peg$fail(peg$e3);
                            }
                        }
                        if (s1 !== peg$FAILED) {
                            while (s1 !== peg$FAILED) {
                                s0.push(s1);
                                if (input.charCodeAt(peg$currPos) === 32) {
                                    s1 = peg$c2;
                                    peg$currPos++;
                                }
                                else {
                                    s1 = peg$FAILED;
                                    if (peg$silentFails === 0) {
                                        peg$fail(peg$e3);
                                    }
                                }
                            }
                        }
                        else {
                            s0 = peg$FAILED;
                        }
                        peg$silentFails--;
                        if (s0 === peg$FAILED) {
                            s1 = peg$FAILED;
                            if (peg$silentFails === 0) {
                                peg$fail(peg$e2);
                            }
                        }
                        return s0;
                    }
                    function peg$parsed() {
                        var s0, s1;
                        peg$silentFails++;
                        if (peg$r0.test(input.charAt(peg$currPos))) {
                            s0 = input.charAt(peg$currPos);
                            peg$currPos++;
                        }
                        else {
                            s0 = peg$FAILED;
                            if (peg$silentFails === 0) {
                                peg$fail(peg$e5);
                            }
                        }
                        peg$silentFails--;
                        if (s0 === peg$FAILED) {
                            s1 = peg$FAILED;
                            if (peg$silentFails === 0) {
                                peg$fail(peg$e4);
                            }
                        }
                        return s0;
                    }
                    function peg$parseweight() {
                        var s0, s1, s2, s3;
                        peg$silentFails++;
                        s0 = peg$currPos;
                        s1 = peg$currPos;
                        s2 = [];
                        s3 = peg$parsed();
                        if (s3 !== peg$FAILED) {
                            while (s3 !== peg$FAILED) {
                                s2.push(s3);
                                s3 = peg$parsed();
                            }
                        }
                        else {
                            s2 = peg$FAILED;
                        }
                        if (s2 !== peg$FAILED) {
                            s1 = input.substring(s1, peg$currPos);
                        }
                        else {
                            s1 = s2;
                        }
                        if (s1 !== peg$FAILED) {
                            peg$savedPos = s0;
                            s1 = peg$f5(s1);
                        }
                        s0 = s1;
                        peg$silentFails--;
                        if (s0 === peg$FAILED) {
                            s1 = peg$FAILED;
                            if (peg$silentFails === 0) {
                                peg$fail(peg$e6);
                            }
                        }
                        return s0;
                    }
                    function peg$parsesourcegroup() {
                        var s0, s1, s2, s3, s4;
                        peg$silentFails++;
                        s0 = peg$currPos;
                        s1 = [];
                        s2 = peg$currPos;
                        s3 = peg$currPos;
                        peg$silentFails++;
                        if (input.substr(peg$currPos, 7) === peg$c3) {
                            s4 = peg$c3;
                            peg$currPos += 7;
                        }
                        else {
                            s4 = peg$FAILED;
                            if (peg$silentFails === 0) {
                                peg$fail(peg$e8);
                            }
                        }
                        peg$silentFails--;
                        if (s4 === peg$FAILED) {
                            s3 = undefined;
                        }
                        else {
                            peg$currPos = s3;
                            s3 = peg$FAILED;
                        }
                        if (s3 !== peg$FAILED) {
                            if (input.length > peg$currPos) {
                                s4 = input.charAt(peg$currPos);
                                peg$currPos++;
                            }
                            else {
                                s4 = peg$FAILED;
                                if (peg$silentFails === 0) {
                                    peg$fail(peg$e9);
                                }
                            }
                            if (s4 !== peg$FAILED) {
                                s3 = [s3, s4];
                                s2 = s3;
                            }
                            else {
                                peg$currPos = s2;
                                s2 = peg$FAILED;
                            }
                        }
                        else {
                            peg$currPos = s2;
                            s2 = peg$FAILED;
                        }
                        while (s2 !== peg$FAILED) {
                            s1.push(s2);
                            s2 = peg$currPos;
                            s3 = peg$currPos;
                            peg$silentFails++;
                            if (input.substr(peg$currPos, 7) === peg$c3) {
                                s4 = peg$c3;
                                peg$currPos += 7;
                            }
                            else {
                                s4 = peg$FAILED;
                                if (peg$silentFails === 0) {
                                    peg$fail(peg$e8);
                                }
                            }
                            peg$silentFails--;
                            if (s4 === peg$FAILED) {
                                s3 = undefined;
                            }
                            else {
                                peg$currPos = s3;
                                s3 = peg$FAILED;
                            }
                            if (s3 !== peg$FAILED) {
                                if (input.length > peg$currPos) {
                                    s4 = input.charAt(peg$currPos);
                                    peg$currPos++;
                                }
                                else {
                                    s4 = peg$FAILED;
                                    if (peg$silentFails === 0) {
                                        peg$fail(peg$e9);
                                    }
                                }
                                if (s4 !== peg$FAILED) {
                                    s3 = [s3, s4];
                                    s2 = s3;
                                }
                                else {
                                    peg$currPos = s2;
                                    s2 = peg$FAILED;
                                }
                            }
                            else {
                                peg$currPos = s2;
                                s2 = peg$FAILED;
                            }
                        }
                        s0 = input.substring(s0, peg$currPos);
                        peg$silentFails--;
                        s1 = peg$FAILED;
                        if (peg$silentFails === 0) {
                            peg$fail(peg$e7);
                        }
                        return s0;
                    }
                    function peg$parsesinkgroup() {
                        var s0, s1, s2, s3, s4;
                        peg$silentFails++;
                        s0 = peg$currPos;
                        s1 = [];
                        s2 = peg$currPos;
                        s3 = peg$currPos;
                        peg$silentFails++;
                        if (input.substr(peg$currPos, 5) === peg$c4) {
                            s4 = peg$c4;
                            peg$currPos += 5;
                        }
                        else {
                            s4 = peg$FAILED;
                            if (peg$silentFails === 0) {
                                peg$fail(peg$e10);
                            }
                        }
                        peg$silentFails--;
                        if (s4 === peg$FAILED) {
                            s3 = undefined;
                        }
                        else {
                            peg$currPos = s3;
                            s3 = peg$FAILED;
                        }
                        if (s3 !== peg$FAILED) {
                            if (input.length > peg$currPos) {
                                s4 = input.charAt(peg$currPos);
                                peg$currPos++;
                            }
                            else {
                                s4 = peg$FAILED;
                                if (peg$silentFails === 0) {
                                    peg$fail(peg$e9);
                                }
                            }
                            if (s4 !== peg$FAILED) {
                                s3 = [s3, s4];
                                s2 = s3;
                            }
                            else {
                                peg$currPos = s2;
                                s2 = peg$FAILED;
                            }
                        }
                        else {
                            peg$currPos = s2;
                            s2 = peg$FAILED;
                        }
                        while (s2 !== peg$FAILED) {
                            s1.push(s2);
                            s2 = peg$currPos;
                            s3 = peg$currPos;
                            peg$silentFails++;
                            if (input.substr(peg$currPos, 5) === peg$c4) {
                                s4 = peg$c4;
                                peg$currPos += 5;
                            }
                            else {
                                s4 = peg$FAILED;
                                if (peg$silentFails === 0) {
                                    peg$fail(peg$e10);
                                }
                            }
                            peg$silentFails--;
                            if (s4 === peg$FAILED) {
                                s3 = undefined;
                            }
                            else {
                                peg$currPos = s3;
                                s3 = peg$FAILED;
                            }
                            if (s3 !== peg$FAILED) {
                                if (input.length > peg$currPos) {
                                    s4 = input.charAt(peg$currPos);
                                    peg$currPos++;
                                }
                                else {
                                    s4 = peg$FAILED;
                                    if (peg$silentFails === 0) {
                                        peg$fail(peg$e9);
                                    }
                                }
                                if (s4 !== peg$FAILED) {
                                    s3 = [s3, s4];
                                    s2 = s3;
                                }
                                else {
                                    peg$currPos = s2;
                                    s2 = peg$FAILED;
                                }
                            }
                            else {
                                peg$currPos = s2;
                                s2 = peg$FAILED;
                            }
                        }
                        s0 = input.substring(s0, peg$currPos);
                        peg$silentFails--;
                        s1 = peg$FAILED;
                        if (peg$silentFails === 0) {
                            peg$fail(peg$e7);
                        }
                        return s0;
                    }
                    peg$result = peg$startRuleFunction();
                    if (peg$result !== peg$FAILED && peg$currPos === input.length) {
                        return peg$result;
                    }
                    else {
                        if (peg$result !== peg$FAILED && peg$currPos < input.length) {
                            peg$fail(peg$endExpectation());
                        }
                        throw peg$buildStructuredError(peg$maxFailExpected, peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null, peg$maxFailPos < input.length
                            ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1)
                            : peg$computeLocation(peg$maxFailPos, peg$maxFailPos));
                    }
                }
                return {
                    SyntaxError: peg$SyntaxError,
                    parse: peg$parse
                };
            });
            /***/ 
        }),
        /***/ "./packages/loot-core/src/server/budget/goal-template.pegjs": 
        /*!******************************************************************!*\
          !*** ./packages/loot-core/src/server/budget/goal-template.pegjs ***!
          \******************************************************************/
        /***/ (function (module, exports) {
            var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__; // Generated by Peggy 3.0.2.
            //
            // https://peggyjs.org/
            (function (root, factory) {
                if (true) {
                    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
                        __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
                            (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
                        __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
                }
                else { }
            })(this, function () {
                "use strict";
                function peg$subclass(child, parent) {
                    function C() { this.constructor = child; }
                    C.prototype = parent.prototype;
                    child.prototype = new C();
                }
                function peg$SyntaxError(message, expected, found, location) {
                    var self = Error.call(this, message);
                    // istanbul ignore next Check is a necessary evil to support older environments
                    if (Object.setPrototypeOf) {
                        Object.setPrototypeOf(self, peg$SyntaxError.prototype);
                    }
                    self.expected = expected;
                    self.found = found;
                    self.location = location;
                    self.name = "SyntaxError";
                    return self;
                }
                peg$subclass(peg$SyntaxError, Error);
                function peg$padEnd(str, targetLength, padString) {
                    padString = padString || " ";
                    if (str.length > targetLength) {
                        return str;
                    }
                    targetLength -= str.length;
                    padString += padString.repeat(targetLength);
                    return str + padString.slice(0, targetLength);
                }
                peg$SyntaxError.prototype.format = function (sources) {
                    var str = "Error: " + this.message;
                    if (this.location) {
                        var src = null;
                        var k;
                        for (k = 0; k < sources.length; k++) {
                            if (sources[k].source === this.location.source) {
                                src = sources[k].text.split(/\r\n|\n|\r/g);
                                break;
                            }
                        }
                        var s = this.location.start;
                        var offset_s = (this.location.source && (typeof this.location.source.offset === "function"))
                            ? this.location.source.offset(s)
                            : s;
                        var loc = this.location.source + ":" + offset_s.line + ":" + offset_s.column;
                        if (src) {
                            var e = this.location.end;
                            var filler = peg$padEnd("", offset_s.line.toString().length, ' ');
                            var line = src[s.line - 1];
                            var last = s.line === e.line ? e.column : line.length + 1;
                            var hatLen = (last - s.column) || 1;
                            str += "\n --> " + loc + "\n"
                                + filler + " |\n"
                                + offset_s.line + " | " + line + "\n"
                                + filler + " | " + peg$padEnd("", s.column - 1, ' ')
                                + peg$padEnd("", hatLen, "^");
                        }
                        else {
                            str += "\n at " + loc;
                        }
                    }
                    return str;
                };
                peg$SyntaxError.buildMessage = function (expected, found) {
                    var DESCRIBE_EXPECTATION_FNS = {
                        literal: function (expectation) {
                            return "\"" + literalEscape(expectation.text) + "\"";
                        },
                        class: function (expectation) {
                            var escapedParts = expectation.parts.map(function (part) {
                                return Array.isArray(part)
                                    ? classEscape(part[0]) + "-" + classEscape(part[1])
                                    : classEscape(part);
                            });
                            return "[" + (expectation.inverted ? "^" : "") + escapedParts.join("") + "]";
                        },
                        any: function () {
                            return "any character";
                        },
                        end: function () {
                            return "end of input";
                        },
                        other: function (expectation) {
                            return expectation.description;
                        }
                    };
                    function hex(ch) {
                        return ch.charCodeAt(0).toString(16).toUpperCase();
                    }
                    function literalEscape(s) {
                        return s
                            .replace(/\\/g, "\\\\")
                            .replace(/"/g, "\\\"")
                            .replace(/\0/g, "\\0")
                            .replace(/\t/g, "\\t")
                            .replace(/\n/g, "\\n")
                            .replace(/\r/g, "\\r")
                            .replace(/[\x00-\x0F]/g, function (ch) { return "\\x0" + hex(ch); })
                            .replace(/[\x10-\x1F\x7F-\x9F]/g, function (ch) { return "\\x" + hex(ch); });
                    }
                    function classEscape(s) {
                        return s
                            .replace(/\\/g, "\\\\")
                            .replace(/\]/g, "\\]")
                            .replace(/\^/g, "\\^")
                            .replace(/-/g, "\\-")
                            .replace(/\0/g, "\\0")
                            .replace(/\t/g, "\\t")
                            .replace(/\n/g, "\\n")
                            .replace(/\r/g, "\\r")
                            .replace(/[\x00-\x0F]/g, function (ch) { return "\\x0" + hex(ch); })
                            .replace(/[\x10-\x1F\x7F-\x9F]/g, function (ch) { return "\\x" + hex(ch); });
                    }
                    function describeExpectation(expectation) {
                        return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);
                    }
                    function describeExpected(expected) {
                        var descriptions = expected.map(describeExpectation);
                        var i, j;
                        descriptions.sort();
                        if (descriptions.length > 0) {
                            for (i = 1, j = 1; i < descriptions.length; i++) {
                                if (descriptions[i - 1] !== descriptions[i]) {
                                    descriptions[j] = descriptions[i];
                                    j++;
                                }
                            }
                            descriptions.length = j;
                        }
                        switch (descriptions.length) {
                            case 1:
                                return descriptions[0];
                            case 2:
                                return descriptions[0] + " or " + descriptions[1];
                            default:
                                return descriptions.slice(0, -1).join(", ")
                                    + ", or "
                                    + descriptions[descriptions.length - 1];
                        }
                    }
                    function describeFound(found) {
                        return found ? "\"" + literalEscape(found) + "\"" : "end of input";
                    }
                    return "Expected " + describeExpected(expected) + " but " + describeFound(found) + " found.";
                };
                function peg$parse(input, options) {
                    options = options !== undefined ? options : {};
                    var peg$FAILED = {};
                    var peg$source = options.grammarSource;
                    var peg$startRuleFunctions = { expr: peg$parseexpr };
                    var peg$startRuleFunction = peg$parseexpr;
                    var peg$c0 = "average";
                    var peg$c1 = "months";
                    var peg$c2 = "month";
                    var peg$c3 = "year";
                    var peg$c4 = "years";
                    var peg$c5 = "hold";
                    var peg$c6 = "previous";
                    var peg$c7 = "spend";
                    var peg$c8 = "from";
                    var peg$c9 = "week";
                    var peg$c10 = "weeks";
                    var peg$c11 = "by";
                    var peg$c12 = "of";
                    var peg$c13 = "repeat";
                    var peg$c14 = "every";
                    var peg$c15 = "starting";
                    var peg$c16 = "up";
                    var peg$c17 = "to";
                    var peg$c18 = "schedule";
                    var peg$c19 = "full";
                    var peg$c20 = "-";
                    var peg$c21 = "remainder";
                    var peg$c22 = "#template";
                    var peg$c23 = "#goal";
                    var peg$c24 = " ";
                    var peg$c25 = ".";
                    var peg$c26 = "%";
                    var peg$r0 = /^[0-9]/;
                    var peg$r1 = /^[1-9]/;
                    var peg$r2 = /^[^\r\n\t]/;
                    var peg$e0 = peg$literalExpectation("average", true);
                    var peg$e1 = peg$literalExpectation("months", true);
                    var peg$e2 = peg$otherExpectation("repeat interval");
                    var peg$e3 = peg$literalExpectation("month", true);
                    var peg$e4 = peg$literalExpectation("year", true);
                    var peg$e5 = peg$literalExpectation("years", true);
                    var peg$e6 = peg$literalExpectation("hold", true);
                    var peg$e7 = peg$literalExpectation("previous", true);
                    var peg$e8 = peg$literalExpectation("spend", true);
                    var peg$e9 = peg$literalExpectation("from", true);
                    var peg$e10 = peg$literalExpectation("week", true);
                    var peg$e11 = peg$literalExpectation("weeks", true);
                    var peg$e12 = peg$literalExpectation("by", true);
                    var peg$e13 = peg$literalExpectation("of", true);
                    var peg$e14 = peg$literalExpectation("repeat", true);
                    var peg$e15 = peg$literalExpectation("every", true);
                    var peg$e16 = peg$literalExpectation("starting", true);
                    var peg$e17 = peg$literalExpectation("up", true);
                    var peg$e18 = peg$literalExpectation("to", true);
                    var peg$e19 = peg$literalExpectation("schedule", true);
                    var peg$e20 = peg$literalExpectation("full", true);
                    var peg$e21 = peg$literalExpectation("-", true);
                    var peg$e22 = peg$literalExpectation("remainder", true);
                    var peg$e23 = peg$literalExpectation("#template", false);
                    var peg$e24 = peg$literalExpectation("#goal", false);
                    var peg$e25 = peg$otherExpectation("space");
                    var peg$e26 = peg$literalExpectation(" ", false);
                    var peg$e27 = peg$otherExpectation("digit");
                    var peg$e28 = peg$classExpectation([["0", "9"]], false, false);
                    var peg$e29 = peg$otherExpectation("number");
                    var peg$e30 = peg$classExpectation([["1", "9"]], false, false);
                    var peg$e31 = peg$otherExpectation("amount");
                    var peg$e32 = peg$literalExpectation(".", false);
                    var peg$e33 = peg$otherExpectation("percentage");
                    var peg$e34 = peg$literalExpectation("%", false);
                    var peg$e35 = peg$otherExpectation("year");
                    var peg$e36 = peg$otherExpectation("month");
                    var peg$e37 = peg$literalExpectation("-", false);
                    var peg$e38 = peg$otherExpectation("day");
                    var peg$e39 = peg$otherExpectation("currency symbol");
                    var peg$e40 = peg$anyExpectation();
                    var peg$e41 = peg$otherExpectation("Name");
                    var peg$e42 = peg$classExpectation(["\r", "\n", "\t"], true, false);
                    var peg$f0 = function (template, percentOf, category) { return { type: 'percentage', percent: +percentOf.percent, previous: percentOf.prev, category, priority: template.priority, directive: template.directive }; };
                    var peg$f1 = function (template, amount, weeks, starting, limit) { return { type: 'week', amount, weeks, starting, limit, priority: template.priority, directive: template.directive }; };
                    var peg$f2 = function (template, amount, month, from, repeat) {
                        return {
                            type: from ? 'spend' : 'by',
                            amount,
                            month,
                            ...(repeat ? repeat[3] : {}),
                            from,
                            priority: template.priority, directive: template.directive
                        };
                    };
                    var peg$f3 = function (template, monthly, limit) { return { type: 'simple', monthly, limit, priority: template.priority, directive: template.directive }; };
                    var peg$f4 = function (template, limit) { return { type: 'simple', limit, priority: template.priority, directive: template.directive }; };
                    var peg$f5 = function (template, full, name) { return { type: 'schedule', name, priority: template.priority, directive: template.directive, full }; };
                    var peg$f6 = function (template, remainder, limit) { return { type: 'remainder', priority: null, directive: template.directive, weight: remainder, limit }; };
                    var peg$f7 = function (template, amount) { return { type: 'average', amount: +amount, priority: template.priority, directive: template.directive }; };
                    var peg$f8 = function (goal, amount) { return { type: 'simple', amount: amount, priority: null, directive: 'goal' }; };
                    var peg$f9 = function () { return { annual: false }; };
                    var peg$f10 = function (months) { return { annual: false, repeat: +months }; };
                    var peg$f11 = function () { return { annual: true }; };
                    var peg$f12 = function (years) { return { annual: true, repeat: +years }; };
                    var peg$f13 = function (amount) { return { amount: amount, hold: true }; };
                    var peg$f14 = function (amount) { return { amount: amount, hold: false }; };
                    var peg$f15 = function (percent) { return { percent: percent, prev: true }; };
                    var peg$f16 = function (percent) { return { percent: percent, prev: false }; };
                    var peg$f17 = function () { return null; };
                    var peg$f18 = function (n) { return +n; };
                    var peg$f19 = function (month) { return month; };
                    var peg$f20 = function () { return true; };
                    var peg$f21 = function (number) { return number; };
                    var peg$f22 = function (weight) { return +weight || 1; };
                    var peg$f23 = function (priority) { return { priority: +priority, directive: 'template' }; };
                    var peg$f24 = function (amount) { return +amount; };
                    var peg$f25 = function (percent) { return +percent; };
                    var peg$f26 = function (symbol) { return /\p{Sc}/u.test(symbol); };
                    var peg$currPos = 0;
                    var peg$savedPos = 0;
                    var peg$posDetailsCache = [{ line: 1, column: 1 }];
                    var peg$maxFailPos = 0;
                    var peg$maxFailExpected = [];
                    var peg$silentFails = 0;
                    var peg$result;
                    if ("startRule" in options) {
                        if (!(options.startRule in peg$startRuleFunctions)) {
                            throw new Error("Can't start parsing from rule \"" + options.startRule + "\".");
                        }
                        peg$startRuleFunction = peg$startRuleFunctions[options.startRule];
                    }
                    function text() {
                        return input.substring(peg$savedPos, peg$currPos);
                    }
                    function offset() {
                        return peg$savedPos;
                    }
                    function range() {
                        return {
                            source: peg$source,
                            start: peg$savedPos,
                            end: peg$currPos
                        };
                    }
                    function location() {
                        return peg$computeLocation(peg$savedPos, peg$currPos);
                    }
                    function expected(description, location) {
                        location = location !== undefined
                            ? location
                            : peg$computeLocation(peg$savedPos, peg$currPos);
                        throw peg$buildStructuredError([peg$otherExpectation(description)], input.substring(peg$savedPos, peg$currPos), location);
                    }
                    function error(message, location) {
                        location = location !== undefined
                            ? location
                            : peg$computeLocation(peg$savedPos, peg$currPos);
                        throw peg$buildSimpleError(message, location);
                    }
                    function peg$literalExpectation(text, ignoreCase) {
                        return { type: "literal", text: text, ignoreCase: ignoreCase };
                    }
                    function peg$classExpectation(parts, inverted, ignoreCase) {
                        return { type: "class", parts: parts, inverted: inverted, ignoreCase: ignoreCase };
                    }
                    function peg$anyExpectation() {
                        return { type: "any" };
                    }
                    function peg$endExpectation() {
                        return { type: "end" };
                    }
                    function peg$otherExpectation(description) {
                        return { type: "other", description: description };
                    }
                    function peg$computePosDetails(pos) {
                        var details = peg$posDetailsCache[pos];
                        var p;
                        if (details) {
                            return details;
                        }
                        else {
                            p = pos - 1;
                            while (!peg$posDetailsCache[p]) {
                                p--;
                            }
                            details = peg$posDetailsCache[p];
                            details = {
                                line: details.line,
                                column: details.column
                            };
                            while (p < pos) {
                                if (input.charCodeAt(p) === 10) {
                                    details.line++;
                                    details.column = 1;
                                }
                                else {
                                    details.column++;
                                }
                                p++;
                            }
                            peg$posDetailsCache[pos] = details;
                            return details;
                        }
                    }
                    function peg$computeLocation(startPos, endPos, offset) {
                        var startPosDetails = peg$computePosDetails(startPos);
                        var endPosDetails = peg$computePosDetails(endPos);
                        var res = {
                            source: peg$source,
                            start: {
                                offset: startPos,
                                line: startPosDetails.line,
                                column: startPosDetails.column
                            },
                            end: {
                                offset: endPos,
                                line: endPosDetails.line,
                                column: endPosDetails.column
                            }
                        };
                        if (offset && peg$source && (typeof peg$source.offset === "function")) {
                            res.start = peg$source.offset(res.start);
                            res.end = peg$source.offset(res.end);
                        }
                        return res;
                    }
                    function peg$fail(expected) {
                        if (peg$currPos < peg$maxFailPos) {
                            return;
                        }
                        if (peg$currPos > peg$maxFailPos) {
                            peg$maxFailPos = peg$currPos;
                            peg$maxFailExpected = [];
                        }
                        peg$maxFailExpected.push(expected);
                    }
                    function peg$buildSimpleError(message, location) {
                        return new peg$SyntaxError(message, null, null, location);
                    }
                    function peg$buildStructuredError(expected, found, location) {
                        return new peg$SyntaxError(peg$SyntaxError.buildMessage(expected, found), expected, found, location);
                    }
                    function peg$parseexpr() {
                        var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11, s12, s13;
                        s0 = peg$currPos;
                        s1 = peg$parsetemplate();
                        if (s1 !== peg$FAILED) {
                            s2 = peg$parse_();
                            if (s2 !== peg$FAILED) {
                                s3 = peg$parsepercentOf();
                                if (s3 !== peg$FAILED) {
                                    s4 = peg$parsename();
                                    if (s4 !== peg$FAILED) {
                                        peg$savedPos = s0;
                                        s0 = peg$f0(s1, s3, s4);
                                    }
                                    else {
                                        peg$currPos = s0;
                                        s0 = peg$FAILED;
                                    }
                                }
                                else {
                                    peg$currPos = s0;
                                    s0 = peg$FAILED;
                                }
                            }
                            else {
                                peg$currPos = s0;
                                s0 = peg$FAILED;
                            }
                        }
                        else {
                            peg$currPos = s0;
                            s0 = peg$FAILED;
                        }
                        if (s0 === peg$FAILED) {
                            s0 = peg$currPos;
                            s1 = peg$parsetemplate();
                            if (s1 !== peg$FAILED) {
                                s2 = peg$parse_();
                                if (s2 !== peg$FAILED) {
                                    s3 = peg$parseamount();
                                    if (s3 !== peg$FAILED) {
                                        s4 = peg$parse_();
                                        if (s4 !== peg$FAILED) {
                                            s5 = peg$parserepeatEvery();
                                            if (s5 !== peg$FAILED) {
                                                s6 = peg$parse_();
                                                if (s6 !== peg$FAILED) {
                                                    s7 = peg$parseweekCount();
                                                    if (s7 !== peg$FAILED) {
                                                        s8 = peg$parse_();
                                                        if (s8 !== peg$FAILED) {
                                                            s9 = peg$parsestarting();
                                                            if (s9 !== peg$FAILED) {
                                                                s10 = peg$parse_();
                                                                if (s10 !== peg$FAILED) {
                                                                    s11 = peg$parsedate();
                                                                    if (s11 !== peg$FAILED) {
                                                                        s12 = peg$parselimit();
                                                                        if (s12 === peg$FAILED) {
                                                                            s12 = null;
                                                                        }
                                                                        peg$savedPos = s0;
                                                                        s0 = peg$f1(s1, s3, s7, s11, s12);
                                                                    }
                                                                    else {
                                                                        peg$currPos = s0;
                                                                        s0 = peg$FAILED;
                                                                    }
                                                                }
                                                                else {
                                                                    peg$currPos = s0;
                                                                    s0 = peg$FAILED;
                                                                }
                                                            }
                                                            else {
                                                                peg$currPos = s0;
                                                                s0 = peg$FAILED;
                                                            }
                                                        }
                                                        else {
                                                            peg$currPos = s0;
                                                            s0 = peg$FAILED;
                                                        }
                                                    }
                                                    else {
                                                        peg$currPos = s0;
                                                        s0 = peg$FAILED;
                                                    }
                                                }
                                                else {
                                                    peg$currPos = s0;
                                                    s0 = peg$FAILED;
                                                }
                                            }
                                            else {
                                                peg$currPos = s0;
                                                s0 = peg$FAILED;
                                            }
                                        }
                                        else {
                                            peg$currPos = s0;
                                            s0 = peg$FAILED;
                                        }
                                    }
                                    else {
                                        peg$currPos = s0;
                                        s0 = peg$FAILED;
                                    }
                                }
                                else {
                                    peg$currPos = s0;
                                    s0 = peg$FAILED;
                                }
                            }
                            else {
                                peg$currPos = s0;
                                s0 = peg$FAILED;
                            }
                            if (s0 === peg$FAILED) {
                                s0 = peg$currPos;
                                s1 = peg$parsetemplate();
                                if (s1 !== peg$FAILED) {
                                    s2 = peg$parse_();
                                    if (s2 !== peg$FAILED) {
                                        s3 = peg$parseamount();
                                        if (s3 !== peg$FAILED) {
                                            s4 = peg$parse_();
                                            if (s4 !== peg$FAILED) {
                                                s5 = peg$parseby();
                                                if (s5 !== peg$FAILED) {
                                                    s6 = peg$parse_();
                                                    if (s6 !== peg$FAILED) {
                                                        s7 = peg$parsemonth();
                                                        if (s7 !== peg$FAILED) {
                                                            s8 = peg$parsespendFrom();
                                                            if (s8 === peg$FAILED) {
                                                                s8 = null;
                                                            }
                                                            s9 = peg$currPos;
                                                            s10 = peg$parse_();
                                                            if (s10 !== peg$FAILED) {
                                                                s11 = peg$parserepeatEvery();
                                                                if (s11 !== peg$FAILED) {
                                                                    s12 = peg$parse_();
                                                                    if (s12 !== peg$FAILED) {
                                                                        s13 = peg$parserepeat();
                                                                        if (s13 !== peg$FAILED) {
                                                                            s10 = [s10, s11, s12, s13];
                                                                            s9 = s10;
                                                                        }
                                                                        else {
                                                                            peg$currPos = s9;
                                                                            s9 = peg$FAILED;
                                                                        }
                                                                    }
                                                                    else {
                                                                        peg$currPos = s9;
                                                                        s9 = peg$FAILED;
                                                                    }
                                                                }
                                                                else {
                                                                    peg$currPos = s9;
                                                                    s9 = peg$FAILED;
                                                                }
                                                            }
                                                            else {
                                                                peg$currPos = s9;
                                                                s9 = peg$FAILED;
                                                            }
                                                            if (s9 === peg$FAILED) {
                                                                s9 = null;
                                                            }
                                                            peg$savedPos = s0;
                                                            s0 = peg$f2(s1, s3, s7, s8, s9);
                                                        }
                                                        else {
                                                            peg$currPos = s0;
                                                            s0 = peg$FAILED;
                                                        }
                                                    }
                                                    else {
                                                        peg$currPos = s0;
                                                        s0 = peg$FAILED;
                                                    }
                                                }
                                                else {
                                                    peg$currPos = s0;
                                                    s0 = peg$FAILED;
                                                }
                                            }
                                            else {
                                                peg$currPos = s0;
                                                s0 = peg$FAILED;
                                            }
                                        }
                                        else {
                                            peg$currPos = s0;
                                            s0 = peg$FAILED;
                                        }
                                    }
                                    else {
                                        peg$currPos = s0;
                                        s0 = peg$FAILED;
                                    }
                                }
                                else {
                                    peg$currPos = s0;
                                    s0 = peg$FAILED;
                                }
                                if (s0 === peg$FAILED) {
                                    s0 = peg$currPos;
                                    s1 = peg$parsetemplate();
                                    if (s1 !== peg$FAILED) {
                                        s2 = peg$parse_();
                                        if (s2 !== peg$FAILED) {
                                            s3 = peg$parseamount();
                                            if (s3 !== peg$FAILED) {
                                                s4 = peg$parselimit();
                                                if (s4 === peg$FAILED) {
                                                    s4 = null;
                                                }
                                                peg$savedPos = s0;
                                                s0 = peg$f3(s1, s3, s4);
                                            }
                                            else {
                                                peg$currPos = s0;
                                                s0 = peg$FAILED;
                                            }
                                        }
                                        else {
                                            peg$currPos = s0;
                                            s0 = peg$FAILED;
                                        }
                                    }
                                    else {
                                        peg$currPos = s0;
                                        s0 = peg$FAILED;
                                    }
                                    if (s0 === peg$FAILED) {
                                        s0 = peg$currPos;
                                        s1 = peg$parsetemplate();
                                        if (s1 !== peg$FAILED) {
                                            s2 = peg$parse_();
                                            if (s2 !== peg$FAILED) {
                                                s3 = peg$parselimit();
                                                if (s3 !== peg$FAILED) {
                                                    peg$savedPos = s0;
                                                    s0 = peg$f4(s1, s3);
                                                }
                                                else {
                                                    peg$currPos = s0;
                                                    s0 = peg$FAILED;
                                                }
                                            }
                                            else {
                                                peg$currPos = s0;
                                                s0 = peg$FAILED;
                                            }
                                        }
                                        else {
                                            peg$currPos = s0;
                                            s0 = peg$FAILED;
                                        }
                                        if (s0 === peg$FAILED) {
                                            s0 = peg$currPos;
                                            s1 = peg$parsetemplate();
                                            if (s1 !== peg$FAILED) {
                                                s2 = peg$parse_();
                                                if (s2 !== peg$FAILED) {
                                                    s3 = peg$parseschedule();
                                                    if (s3 !== peg$FAILED) {
                                                        s4 = peg$parse_();
                                                        if (s4 !== peg$FAILED) {
                                                            s5 = peg$parsefull();
                                                            if (s5 === peg$FAILED) {
                                                                s5 = null;
                                                            }
                                                            s6 = peg$parsename();
                                                            if (s6 !== peg$FAILED) {
                                                                peg$savedPos = s0;
                                                                s0 = peg$f5(s1, s5, s6);
                                                            }
                                                            else {
                                                                peg$currPos = s0;
                                                                s0 = peg$FAILED;
                                                            }
                                                        }
                                                        else {
                                                            peg$currPos = s0;
                                                            s0 = peg$FAILED;
                                                        }
                                                    }
                                                    else {
                                                        peg$currPos = s0;
                                                        s0 = peg$FAILED;
                                                    }
                                                }
                                                else {
                                                    peg$currPos = s0;
                                                    s0 = peg$FAILED;
                                                }
                                            }
                                            else {
                                                peg$currPos = s0;
                                                s0 = peg$FAILED;
                                            }
                                            if (s0 === peg$FAILED) {
                                                s0 = peg$currPos;
                                                s1 = peg$parsetemplate();
                                                if (s1 !== peg$FAILED) {
                                                    s2 = peg$parse_();
                                                    if (s2 !== peg$FAILED) {
                                                        s3 = peg$parseremainder();
                                                        if (s3 !== peg$FAILED) {
                                                            s4 = peg$parselimit();
                                                            if (s4 === peg$FAILED) {
                                                                s4 = null;
                                                            }
                                                            peg$savedPos = s0;
                                                            s0 = peg$f6(s1, s3, s4);
                                                        }
                                                        else {
                                                            peg$currPos = s0;
                                                            s0 = peg$FAILED;
                                                        }
                                                    }
                                                    else {
                                                        peg$currPos = s0;
                                                        s0 = peg$FAILED;
                                                    }
                                                }
                                                else {
                                                    peg$currPos = s0;
                                                    s0 = peg$FAILED;
                                                }
                                                if (s0 === peg$FAILED) {
                                                    s0 = peg$currPos;
                                                    s1 = peg$parsetemplate();
                                                    if (s1 !== peg$FAILED) {
                                                        s2 = peg$parse_();
                                                        if (s2 !== peg$FAILED) {
                                                            if (input.substr(peg$currPos, 7).toLowerCase() === peg$c0) {
                                                                s3 = input.substr(peg$currPos, 7);
                                                                peg$currPos += 7;
                                                            }
                                                            else {
                                                                s3 = peg$FAILED;
                                                                if (peg$silentFails === 0) {
                                                                    peg$fail(peg$e0);
                                                                }
                                                            }
                                                            if (s3 !== peg$FAILED) {
                                                                s4 = peg$parse_();
                                                                if (s4 !== peg$FAILED) {
                                                                    s5 = peg$parsepositive();
                                                                    if (s5 !== peg$FAILED) {
                                                                        s6 = peg$parse_();
                                                                        if (s6 !== peg$FAILED) {
                                                                            if (input.substr(peg$currPos, 6).toLowerCase() === peg$c1) {
                                                                                s7 = input.substr(peg$currPos, 6);
                                                                                peg$currPos += 6;
                                                                            }
                                                                            else {
                                                                                s7 = peg$FAILED;
                                                                                if (peg$silentFails === 0) {
                                                                                    peg$fail(peg$e1);
                                                                                }
                                                                            }
                                                                            if (s7 === peg$FAILED) {
                                                                                s7 = null;
                                                                            }
                                                                            peg$savedPos = s0;
                                                                            s0 = peg$f7(s1, s5);
                                                                        }
                                                                        else {
                                                                            peg$currPos = s0;
                                                                            s0 = peg$FAILED;
                                                                        }
                                                                    }
                                                                    else {
                                                                        peg$currPos = s0;
                                                                        s0 = peg$FAILED;
                                                                    }
                                                                }
                                                                else {
                                                                    peg$currPos = s0;
                                                                    s0 = peg$FAILED;
                                                                }
                                                            }
                                                            else {
                                                                peg$currPos = s0;
                                                                s0 = peg$FAILED;
                                                            }
                                                        }
                                                        else {
                                                            peg$currPos = s0;
                                                            s0 = peg$FAILED;
                                                        }
                                                    }
                                                    else {
                                                        peg$currPos = s0;
                                                        s0 = peg$FAILED;
                                                    }
                                                    if (s0 === peg$FAILED) {
                                                        s0 = peg$currPos;
                                                        s1 = peg$parsegoal();
                                                        if (s1 !== peg$FAILED) {
                                                            s2 = peg$parseamount();
                                                            if (s2 !== peg$FAILED) {
                                                                peg$savedPos = s0;
                                                                s0 = peg$f8(s1, s2);
                                                            }
                                                            else {
                                                                peg$currPos = s0;
                                                                s0 = peg$FAILED;
                                                            }
                                                        }
                                                        else {
                                                            peg$currPos = s0;
                                                            s0 = peg$FAILED;
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                        return s0;
                    }
                    function peg$parserepeat() {
                        var s0, s1, s2, s3;
                        peg$silentFails++;
                        s0 = peg$currPos;
                        if (input.substr(peg$currPos, 5).toLowerCase() === peg$c2) {
                            s1 = input.substr(peg$currPos, 5);
                            peg$currPos += 5;
                        }
                        else {
                            s1 = peg$FAILED;
                            if (peg$silentFails === 0) {
                                peg$fail(peg$e3);
                            }
                        }
                        if (s1 !== peg$FAILED) {
                            peg$savedPos = s0;
                            s1 = peg$f9();
                        }
                        s0 = s1;
                        if (s0 === peg$FAILED) {
                            s0 = peg$currPos;
                            s1 = peg$parsepositive();
                            if (s1 !== peg$FAILED) {
                                s2 = peg$parse_();
                                if (s2 !== peg$FAILED) {
                                    if (input.substr(peg$currPos, 6).toLowerCase() === peg$c1) {
                                        s3 = input.substr(peg$currPos, 6);
                                        peg$currPos += 6;
                                    }
                                    else {
                                        s3 = peg$FAILED;
                                        if (peg$silentFails === 0) {
                                            peg$fail(peg$e1);
                                        }
                                    }
                                    if (s3 !== peg$FAILED) {
                                        peg$savedPos = s0;
                                        s0 = peg$f10(s1);
                                    }
                                    else {
                                        peg$currPos = s0;
                                        s0 = peg$FAILED;
                                    }
                                }
                                else {
                                    peg$currPos = s0;
                                    s0 = peg$FAILED;
                                }
                            }
                            else {
                                peg$currPos = s0;
                                s0 = peg$FAILED;
                            }
                            if (s0 === peg$FAILED) {
                                s0 = peg$currPos;
                                if (input.substr(peg$currPos, 4).toLowerCase() === peg$c3) {
                                    s1 = input.substr(peg$currPos, 4);
                                    peg$currPos += 4;
                                }
                                else {
                                    s1 = peg$FAILED;
                                    if (peg$silentFails === 0) {
                                        peg$fail(peg$e4);
                                    }
                                }
                                if (s1 !== peg$FAILED) {
                                    peg$savedPos = s0;
                                    s1 = peg$f11();
                                }
                                s0 = s1;
                                if (s0 === peg$FAILED) {
                                    s0 = peg$currPos;
                                    s1 = peg$parsepositive();
                                    if (s1 !== peg$FAILED) {
                                        s2 = peg$parse_();
                                        if (s2 !== peg$FAILED) {
                                            if (input.substr(peg$currPos, 5).toLowerCase() === peg$c4) {
                                                s3 = input.substr(peg$currPos, 5);
                                                peg$currPos += 5;
                                            }
                                            else {
                                                s3 = peg$FAILED;
                                                if (peg$silentFails === 0) {
                                                    peg$fail(peg$e5);
                                                }
                                            }
                                            if (s3 !== peg$FAILED) {
                                                peg$savedPos = s0;
                                                s0 = peg$f12(s1);
                                            }
                                            else {
                                                peg$currPos = s0;
                                                s0 = peg$FAILED;
                                            }
                                        }
                                        else {
                                            peg$currPos = s0;
                                            s0 = peg$FAILED;
                                        }
                                    }
                                    else {
                                        peg$currPos = s0;
                                        s0 = peg$FAILED;
                                    }
                                }
                            }
                        }
                        peg$silentFails--;
                        if (s0 === peg$FAILED) {
                            s1 = peg$FAILED;
                            if (peg$silentFails === 0) {
                                peg$fail(peg$e2);
                            }
                        }
                        return s0;
                    }
                    function peg$parselimit() {
                        var s0, s1, s2, s3, s4, s5, s6;
                        s0 = peg$currPos;
                        s1 = peg$parse_();
                        if (s1 === peg$FAILED) {
                            s1 = null;
                        }
                        s2 = peg$parseupTo();
                        if (s2 !== peg$FAILED) {
                            s3 = peg$parse_();
                            if (s3 !== peg$FAILED) {
                                s4 = peg$parseamount();
                                if (s4 !== peg$FAILED) {
                                    s5 = peg$parse_();
                                    if (s5 !== peg$FAILED) {
                                        if (input.substr(peg$currPos, 4).toLowerCase() === peg$c5) {
                                            s6 = input.substr(peg$currPos, 4);
                                            peg$currPos += 4;
                                        }
                                        else {
                                            s6 = peg$FAILED;
                                            if (peg$silentFails === 0) {
                                                peg$fail(peg$e6);
                                            }
                                        }
                                        if (s6 !== peg$FAILED) {
                                            peg$savedPos = s0;
                                            s0 = peg$f13(s4);
                                        }
                                        else {
                                            peg$currPos = s0;
                                            s0 = peg$FAILED;
                                        }
                                    }
                                    else {
                                        peg$currPos = s0;
                                        s0 = peg$FAILED;
                                    }
                                }
                                else {
                                    peg$currPos = s0;
                                    s0 = peg$FAILED;
                                }
                            }
                            else {
                                peg$currPos = s0;
                                s0 = peg$FAILED;
                            }
                        }
                        else {
                            peg$currPos = s0;
                            s0 = peg$FAILED;
                        }
                        if (s0 === peg$FAILED) {
                            s0 = peg$currPos;
                            s1 = peg$parse_();
                            if (s1 === peg$FAILED) {
                                s1 = null;
                            }
                            s2 = peg$parseupTo();
                            if (s2 !== peg$FAILED) {
                                s3 = peg$parse_();
                                if (s3 !== peg$FAILED) {
                                    s4 = peg$parseamount();
                                    if (s4 !== peg$FAILED) {
                                        peg$savedPos = s0;
                                        s0 = peg$f14(s4);
                                    }
                                    else {
                                        peg$currPos = s0;
                                        s0 = peg$FAILED;
                                    }
                                }
                                else {
                                    peg$currPos = s0;
                                    s0 = peg$FAILED;
                                }
                            }
                            else {
                                peg$currPos = s0;
                                s0 = peg$FAILED;
                            }
                        }
                        return s0;
                    }
                    function peg$parsepercentOf() {
                        var s0, s1, s2, s3, s4, s5, s6;
                        s0 = peg$currPos;
                        s1 = peg$parsepercent();
                        if (s1 !== peg$FAILED) {
                            s2 = peg$parse_();
                            if (s2 !== peg$FAILED) {
                                s3 = peg$parseof();
                                if (s3 !== peg$FAILED) {
                                    s4 = peg$parse_();
                                    if (s4 !== peg$FAILED) {
                                        if (input.substr(peg$currPos, 8).toLowerCase() === peg$c6) {
                                            s5 = input.substr(peg$currPos, 8);
                                            peg$currPos += 8;
                                        }
                                        else {
                                            s5 = peg$FAILED;
                                            if (peg$silentFails === 0) {
                                                peg$fail(peg$e7);
                                            }
                                        }
                                        if (s5 !== peg$FAILED) {
                                            s6 = peg$parse_();
                                            if (s6 !== peg$FAILED) {
                                                peg$savedPos = s0;
                                                s0 = peg$f15(s1);
                                            }
                                            else {
                                                peg$currPos = s0;
                                                s0 = peg$FAILED;
                                            }
                                        }
                                        else {
                                            peg$currPos = s0;
                                            s0 = peg$FAILED;
                                        }
                                    }
                                    else {
                                        peg$currPos = s0;
                                        s0 = peg$FAILED;
                                    }
                                }
                                else {
                                    peg$currPos = s0;
                                    s0 = peg$FAILED;
                                }
                            }
                            else {
                                peg$currPos = s0;
                                s0 = peg$FAILED;
                            }
                        }
                        else {
                            peg$currPos = s0;
                            s0 = peg$FAILED;
                        }
                        if (s0 === peg$FAILED) {
                            s0 = peg$currPos;
                            s1 = peg$parsepercent();
                            if (s1 !== peg$FAILED) {
                                s2 = peg$parse_();
                                if (s2 !== peg$FAILED) {
                                    s3 = peg$parseof();
                                    if (s3 !== peg$FAILED) {
                                        s4 = peg$parse_();
                                        if (s4 !== peg$FAILED) {
                                            peg$savedPos = s0;
                                            s0 = peg$f16(s1);
                                        }
                                        else {
                                            peg$currPos = s0;
                                            s0 = peg$FAILED;
                                        }
                                    }
                                    else {
                                        peg$currPos = s0;
                                        s0 = peg$FAILED;
                                    }
                                }
                                else {
                                    peg$currPos = s0;
                                    s0 = peg$FAILED;
                                }
                            }
                            else {
                                peg$currPos = s0;
                                s0 = peg$FAILED;
                            }
                        }
                        return s0;
                    }
                    function peg$parseweekCount() {
                        var s0, s1, s2, s3;
                        s0 = peg$currPos;
                        s1 = peg$parseweek();
                        if (s1 !== peg$FAILED) {
                            peg$savedPos = s0;
                            s1 = peg$f17();
                        }
                        s0 = s1;
                        if (s0 === peg$FAILED) {
                            s0 = peg$currPos;
                            s1 = peg$parsenumber();
                            if (s1 !== peg$FAILED) {
                                s2 = peg$parse_();
                                if (s2 !== peg$FAILED) {
                                    s3 = peg$parseweeks();
                                    if (s3 !== peg$FAILED) {
                                        peg$savedPos = s0;
                                        s0 = peg$f18(s1);
                                    }
                                    else {
                                        peg$currPos = s0;
                                        s0 = peg$FAILED;
                                    }
                                }
                                else {
                                    peg$currPos = s0;
                                    s0 = peg$FAILED;
                                }
                            }
                            else {
                                peg$currPos = s0;
                                s0 = peg$FAILED;
                            }
                        }
                        return s0;
                    }
                    function peg$parsespendFrom() {
                        var s0, s1, s2, s3, s4, s5, s6;
                        s0 = peg$currPos;
                        s1 = peg$parse_();
                        if (s1 !== peg$FAILED) {
                            if (input.substr(peg$currPos, 5).toLowerCase() === peg$c7) {
                                s2 = input.substr(peg$currPos, 5);
                                peg$currPos += 5;
                            }
                            else {
                                s2 = peg$FAILED;
                                if (peg$silentFails === 0) {
                                    peg$fail(peg$e8);
                                }
                            }
                            if (s2 !== peg$FAILED) {
                                s3 = peg$parse_();
                                if (s3 !== peg$FAILED) {
                                    if (input.substr(peg$currPos, 4).toLowerCase() === peg$c8) {
                                        s4 = input.substr(peg$currPos, 4);
                                        peg$currPos += 4;
                                    }
                                    else {
                                        s4 = peg$FAILED;
                                        if (peg$silentFails === 0) {
                                            peg$fail(peg$e9);
                                        }
                                    }
                                    if (s4 !== peg$FAILED) {
                                        s5 = peg$parse_();
                                        if (s5 !== peg$FAILED) {
                                            s6 = peg$parsemonth();
                                            if (s6 !== peg$FAILED) {
                                                peg$savedPos = s0;
                                                s0 = peg$f19(s6);
                                            }
                                            else {
                                                peg$currPos = s0;
                                                s0 = peg$FAILED;
                                            }
                                        }
                                        else {
                                            peg$currPos = s0;
                                            s0 = peg$FAILED;
                                        }
                                    }
                                    else {
                                        peg$currPos = s0;
                                        s0 = peg$FAILED;
                                    }
                                }
                                else {
                                    peg$currPos = s0;
                                    s0 = peg$FAILED;
                                }
                            }
                            else {
                                peg$currPos = s0;
                                s0 = peg$FAILED;
                            }
                        }
                        else {
                            peg$currPos = s0;
                            s0 = peg$FAILED;
                        }
                        return s0;
                    }
                    function peg$parseweek() {
                        var s0;
                        if (input.substr(peg$currPos, 4).toLowerCase() === peg$c9) {
                            s0 = input.substr(peg$currPos, 4);
                            peg$currPos += 4;
                        }
                        else {
                            s0 = peg$FAILED;
                            if (peg$silentFails === 0) {
                                peg$fail(peg$e10);
                            }
                        }
                        return s0;
                    }
                    function peg$parseweeks() {
                        var s0;
                        if (input.substr(peg$currPos, 5).toLowerCase() === peg$c10) {
                            s0 = input.substr(peg$currPos, 5);
                            peg$currPos += 5;
                        }
                        else {
                            s0 = peg$FAILED;
                            if (peg$silentFails === 0) {
                                peg$fail(peg$e11);
                            }
                        }
                        return s0;
                    }
                    function peg$parseby() {
                        var s0;
                        if (input.substr(peg$currPos, 2).toLowerCase() === peg$c11) {
                            s0 = input.substr(peg$currPos, 2);
                            peg$currPos += 2;
                        }
                        else {
                            s0 = peg$FAILED;
                            if (peg$silentFails === 0) {
                                peg$fail(peg$e12);
                            }
                        }
                        return s0;
                    }
                    function peg$parseof() {
                        var s0;
                        if (input.substr(peg$currPos, 2).toLowerCase() === peg$c12) {
                            s0 = input.substr(peg$currPos, 2);
                            peg$currPos += 2;
                        }
                        else {
                            s0 = peg$FAILED;
                            if (peg$silentFails === 0) {
                                peg$fail(peg$e13);
                            }
                        }
                        return s0;
                    }
                    function peg$parserepeatEvery() {
                        var s0, s1, s2, s3;
                        s0 = peg$currPos;
                        if (input.substr(peg$currPos, 6).toLowerCase() === peg$c13) {
                            s1 = input.substr(peg$currPos, 6);
                            peg$currPos += 6;
                        }
                        else {
                            s1 = peg$FAILED;
                            if (peg$silentFails === 0) {
                                peg$fail(peg$e14);
                            }
                        }
                        if (s1 !== peg$FAILED) {
                            s2 = peg$parse_();
                            if (s2 !== peg$FAILED) {
                                if (input.substr(peg$currPos, 5).toLowerCase() === peg$c14) {
                                    s3 = input.substr(peg$currPos, 5);
                                    peg$currPos += 5;
                                }
                                else {
                                    s3 = peg$FAILED;
                                    if (peg$silentFails === 0) {
                                        peg$fail(peg$e15);
                                    }
                                }
                                if (s3 !== peg$FAILED) {
                                    s1 = [s1, s2, s3];
                                    s0 = s1;
                                }
                                else {
                                    peg$currPos = s0;
                                    s0 = peg$FAILED;
                                }
                            }
                            else {
                                peg$currPos = s0;
                                s0 = peg$FAILED;
                            }
                        }
                        else {
                            peg$currPos = s0;
                            s0 = peg$FAILED;
                        }
                        return s0;
                    }
                    function peg$parsestarting() {
                        var s0;
                        if (input.substr(peg$currPos, 8).toLowerCase() === peg$c15) {
                            s0 = input.substr(peg$currPos, 8);
                            peg$currPos += 8;
                        }
                        else {
                            s0 = peg$FAILED;
                            if (peg$silentFails === 0) {
                                peg$fail(peg$e16);
                            }
                        }
                        return s0;
                    }
                    function peg$parseupTo() {
                        var s0, s1, s2, s3;
                        s0 = peg$currPos;
                        if (input.substr(peg$currPos, 2).toLowerCase() === peg$c16) {
                            s1 = input.substr(peg$currPos, 2);
                            peg$currPos += 2;
                        }
                        else {
                            s1 = peg$FAILED;
                            if (peg$silentFails === 0) {
                                peg$fail(peg$e17);
                            }
                        }
                        if (s1 !== peg$FAILED) {
                            s2 = peg$parse_();
                            if (s2 !== peg$FAILED) {
                                if (input.substr(peg$currPos, 2).toLowerCase() === peg$c17) {
                                    s3 = input.substr(peg$currPos, 2);
                                    peg$currPos += 2;
                                }
                                else {
                                    s3 = peg$FAILED;
                                    if (peg$silentFails === 0) {
                                        peg$fail(peg$e18);
                                    }
                                }
                                if (s3 !== peg$FAILED) {
                                    s1 = [s1, s2, s3];
                                    s0 = s1;
                                }
                                else {
                                    peg$currPos = s0;
                                    s0 = peg$FAILED;
                                }
                            }
                            else {
                                peg$currPos = s0;
                                s0 = peg$FAILED;
                            }
                        }
                        else {
                            peg$currPos = s0;
                            s0 = peg$FAILED;
                        }
                        return s0;
                    }
                    function peg$parseschedule() {
                        var s0;
                        if (input.substr(peg$currPos, 8).toLowerCase() === peg$c18) {
                            s0 = input.substr(peg$currPos, 8);
                            peg$currPos += 8;
                        }
                        else {
                            s0 = peg$FAILED;
                            if (peg$silentFails === 0) {
                                peg$fail(peg$e19);
                            }
                        }
                        return s0;
                    }
                    function peg$parsefull() {
                        var s0, s1, s2;
                        s0 = peg$currPos;
                        if (input.substr(peg$currPos, 4).toLowerCase() === peg$c19) {
                            s1 = input.substr(peg$currPos, 4);
                            peg$currPos += 4;
                        }
                        else {
                            s1 = peg$FAILED;
                            if (peg$silentFails === 0) {
                                peg$fail(peg$e20);
                            }
                        }
                        if (s1 !== peg$FAILED) {
                            s2 = peg$parse_();
                            if (s2 !== peg$FAILED) {
                                peg$savedPos = s0;
                                s0 = peg$f20();
                            }
                            else {
                                peg$currPos = s0;
                                s0 = peg$FAILED;
                            }
                        }
                        else {
                            peg$currPos = s0;
                            s0 = peg$FAILED;
                        }
                        return s0;
                    }
                    function peg$parsepriority() {
                        var s0, s1, s2;
                        s0 = peg$currPos;
                        if (input.substr(peg$currPos, 1).toLowerCase() === peg$c20) {
                            s1 = input.charAt(peg$currPos);
                            peg$currPos++;
                        }
                        else {
                            s1 = peg$FAILED;
                            if (peg$silentFails === 0) {
                                peg$fail(peg$e21);
                            }
                        }
                        if (s1 !== peg$FAILED) {
                            s2 = peg$parsenumber();
                            if (s2 !== peg$FAILED) {
                                peg$savedPos = s0;
                                s0 = peg$f21(s2);
                            }
                            else {
                                peg$currPos = s0;
                                s0 = peg$FAILED;
                            }
                        }
                        else {
                            peg$currPos = s0;
                            s0 = peg$FAILED;
                        }
                        return s0;
                    }
                    function peg$parseremainder() {
                        var s0, s1, s2, s3;
                        s0 = peg$currPos;
                        if (input.substr(peg$currPos, 9).toLowerCase() === peg$c21) {
                            s1 = input.substr(peg$currPos, 9);
                            peg$currPos += 9;
                        }
                        else {
                            s1 = peg$FAILED;
                            if (peg$silentFails === 0) {
                                peg$fail(peg$e22);
                            }
                        }
                        if (s1 !== peg$FAILED) {
                            s2 = peg$parse_();
                            if (s2 === peg$FAILED) {
                                s2 = null;
                            }
                            s3 = peg$parsepositive();
                            if (s3 === peg$FAILED) {
                                s3 = null;
                            }
                            peg$savedPos = s0;
                            s0 = peg$f22(s3);
                        }
                        else {
                            peg$currPos = s0;
                            s0 = peg$FAILED;
                        }
                        return s0;
                    }
                    function peg$parsetemplate() {
                        var s0, s1, s2;
                        s0 = peg$currPos;
                        if (input.substr(peg$currPos, 9) === peg$c22) {
                            s1 = peg$c22;
                            peg$currPos += 9;
                        }
                        else {
                            s1 = peg$FAILED;
                            if (peg$silentFails === 0) {
                                peg$fail(peg$e23);
                            }
                        }
                        if (s1 !== peg$FAILED) {
                            s2 = peg$parsepriority();
                            if (s2 === peg$FAILED) {
                                s2 = null;
                            }
                            peg$savedPos = s0;
                            s0 = peg$f23(s2);
                        }
                        else {
                            peg$currPos = s0;
                            s0 = peg$FAILED;
                        }
                        return s0;
                    }
                    function peg$parsegoal() {
                        var s0;
                        if (input.substr(peg$currPos, 5) === peg$c23) {
                            s0 = peg$c23;
                            peg$currPos += 5;
                        }
                        else {
                            s0 = peg$FAILED;
                            if (peg$silentFails === 0) {
                                peg$fail(peg$e24);
                            }
                        }
                        return s0;
                    }
                    function peg$parse_() {
                        var s0, s1;
                        peg$silentFails++;
                        s0 = [];
                        if (input.charCodeAt(peg$currPos) === 32) {
                            s1 = peg$c24;
                            peg$currPos++;
                        }
                        else {
                            s1 = peg$FAILED;
                            if (peg$silentFails === 0) {
                                peg$fail(peg$e26);
                            }
                        }
                        if (s1 !== peg$FAILED) {
                            while (s1 !== peg$FAILED) {
                                s0.push(s1);
                                if (input.charCodeAt(peg$currPos) === 32) {
                                    s1 = peg$c24;
                                    peg$currPos++;
                                }
                                else {
                                    s1 = peg$FAILED;
                                    if (peg$silentFails === 0) {
                                        peg$fail(peg$e26);
                                    }
                                }
                            }
                        }
                        else {
                            s0 = peg$FAILED;
                        }
                        peg$silentFails--;
                        if (s0 === peg$FAILED) {
                            s1 = peg$FAILED;
                            if (peg$silentFails === 0) {
                                peg$fail(peg$e25);
                            }
                        }
                        return s0;
                    }
                    function peg$parsed() {
                        var s0, s1;
                        peg$silentFails++;
                        if (peg$r0.test(input.charAt(peg$currPos))) {
                            s0 = input.charAt(peg$currPos);
                            peg$currPos++;
                        }
                        else {
                            s0 = peg$FAILED;
                            if (peg$silentFails === 0) {
                                peg$fail(peg$e28);
                            }
                        }
                        peg$silentFails--;
                        if (s0 === peg$FAILED) {
                            s1 = peg$FAILED;
                            if (peg$silentFails === 0) {
                                peg$fail(peg$e27);
                            }
                        }
                        return s0;
                    }
                    function peg$parsenumber() {
                        var s0, s1, s2;
                        peg$silentFails++;
                        s0 = peg$currPos;
                        s1 = [];
                        s2 = peg$parsed();
                        if (s2 !== peg$FAILED) {
                            while (s2 !== peg$FAILED) {
                                s1.push(s2);
                                s2 = peg$parsed();
                            }
                        }
                        else {
                            s1 = peg$FAILED;
                        }
                        if (s1 !== peg$FAILED) {
                            s0 = input.substring(s0, peg$currPos);
                        }
                        else {
                            s0 = s1;
                        }
                        peg$silentFails--;
                        if (s0 === peg$FAILED) {
                            s1 = peg$FAILED;
                            if (peg$silentFails === 0) {
                                peg$fail(peg$e29);
                            }
                        }
                        return s0;
                    }
                    function peg$parsepositive() {
                        var s0, s1, s2, s3, s4;
                        s0 = peg$currPos;
                        s1 = peg$currPos;
                        if (peg$r1.test(input.charAt(peg$currPos))) {
                            s2 = input.charAt(peg$currPos);
                            peg$currPos++;
                        }
                        else {
                            s2 = peg$FAILED;
                            if (peg$silentFails === 0) {
                                peg$fail(peg$e30);
                            }
                        }
                        if (s2 !== peg$FAILED) {
                            s3 = [];
                            if (peg$r0.test(input.charAt(peg$currPos))) {
                                s4 = input.charAt(peg$currPos);
                                peg$currPos++;
                            }
                            else {
                                s4 = peg$FAILED;
                                if (peg$silentFails === 0) {
                                    peg$fail(peg$e28);
                                }
                            }
                            while (s4 !== peg$FAILED) {
                                s3.push(s4);
                                if (peg$r0.test(input.charAt(peg$currPos))) {
                                    s4 = input.charAt(peg$currPos);
                                    peg$currPos++;
                                }
                                else {
                                    s4 = peg$FAILED;
                                    if (peg$silentFails === 0) {
                                        peg$fail(peg$e28);
                                    }
                                }
                            }
                            s2 = [s2, s3];
                            s1 = s2;
                        }
                        else {
                            peg$currPos = s1;
                            s1 = peg$FAILED;
                        }
                        if (s1 !== peg$FAILED) {
                            s0 = input.substring(s0, peg$currPos);
                        }
                        else {
                            s0 = s1;
                        }
                        return s0;
                    }
                    function peg$parseamount() {
                        var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10;
                        peg$silentFails++;
                        s0 = peg$currPos;
                        s1 = peg$parsecurrencySymbol();
                        if (s1 === peg$FAILED) {
                            s1 = null;
                        }
                        s2 = peg$parse_();
                        if (s2 === peg$FAILED) {
                            s2 = null;
                        }
                        s3 = peg$currPos;
                        s4 = peg$currPos;
                        s5 = [];
                        s6 = peg$parsed();
                        if (s6 !== peg$FAILED) {
                            while (s6 !== peg$FAILED) {
                                s5.push(s6);
                                s6 = peg$parsed();
                            }
                        }
                        else {
                            s5 = peg$FAILED;
                        }
                        if (s5 !== peg$FAILED) {
                            s6 = peg$currPos;
                            if (input.charCodeAt(peg$currPos) === 46) {
                                s7 = peg$c25;
                                peg$currPos++;
                            }
                            else {
                                s7 = peg$FAILED;
                                if (peg$silentFails === 0) {
                                    peg$fail(peg$e32);
                                }
                            }
                            if (s7 !== peg$FAILED) {
                                s8 = peg$currPos;
                                s9 = peg$parsed();
                                if (s9 !== peg$FAILED) {
                                    s10 = peg$parsed();
                                    if (s10 === peg$FAILED) {
                                        s10 = null;
                                    }
                                    s9 = [s9, s10];
                                    s8 = s9;
                                }
                                else {
                                    peg$currPos = s8;
                                    s8 = peg$FAILED;
                                }
                                if (s8 === peg$FAILED) {
                                    s8 = null;
                                }
                                s7 = [s7, s8];
                                s6 = s7;
                            }
                            else {
                                peg$currPos = s6;
                                s6 = peg$FAILED;
                            }
                            if (s6 === peg$FAILED) {
                                s6 = null;
                            }
                            s5 = [s5, s6];
                            s4 = s5;
                        }
                        else {
                            peg$currPos = s4;
                            s4 = peg$FAILED;
                        }
                        if (s4 !== peg$FAILED) {
                            s3 = input.substring(s3, peg$currPos);
                        }
                        else {
                            s3 = s4;
                        }
                        if (s3 !== peg$FAILED) {
                            peg$savedPos = s0;
                            s0 = peg$f24(s3);
                        }
                        else {
                            peg$currPos = s0;
                            s0 = peg$FAILED;
                        }
                        peg$silentFails--;
                        if (s0 === peg$FAILED) {
                            s1 = peg$FAILED;
                            if (peg$silentFails === 0) {
                                peg$fail(peg$e31);
                            }
                        }
                        return s0;
                    }
                    function peg$parsepercent() {
                        var s0, s1, s2, s3, s4, s5, s6, s7;
                        peg$silentFails++;
                        s0 = peg$currPos;
                        s1 = peg$currPos;
                        s2 = peg$currPos;
                        s3 = [];
                        s4 = peg$parsed();
                        if (s4 !== peg$FAILED) {
                            while (s4 !== peg$FAILED) {
                                s3.push(s4);
                                s4 = peg$parsed();
                            }
                        }
                        else {
                            s3 = peg$FAILED;
                        }
                        if (s3 !== peg$FAILED) {
                            s4 = peg$currPos;
                            if (input.charCodeAt(peg$currPos) === 46) {
                                s5 = peg$c25;
                                peg$currPos++;
                            }
                            else {
                                s5 = peg$FAILED;
                                if (peg$silentFails === 0) {
                                    peg$fail(peg$e32);
                                }
                            }
                            if (s5 !== peg$FAILED) {
                                s6 = [];
                                s7 = peg$parsed();
                                if (s7 !== peg$FAILED) {
                                    while (s7 !== peg$FAILED) {
                                        s6.push(s7);
                                        s7 = peg$parsed();
                                    }
                                }
                                else {
                                    s6 = peg$FAILED;
                                }
                                if (s6 === peg$FAILED) {
                                    s6 = null;
                                }
                                s5 = [s5, s6];
                                s4 = s5;
                            }
                            else {
                                peg$currPos = s4;
                                s4 = peg$FAILED;
                            }
                            if (s4 === peg$FAILED) {
                                s4 = null;
                            }
                            s3 = [s3, s4];
                            s2 = s3;
                        }
                        else {
                            peg$currPos = s2;
                            s2 = peg$FAILED;
                        }
                        if (s2 !== peg$FAILED) {
                            s1 = input.substring(s1, peg$currPos);
                        }
                        else {
                            s1 = s2;
                        }
                        if (s1 !== peg$FAILED) {
                            s2 = peg$parse_();
                            if (s2 === peg$FAILED) {
                                s2 = null;
                            }
                            if (input.charCodeAt(peg$currPos) === 37) {
                                s3 = peg$c26;
                                peg$currPos++;
                            }
                            else {
                                s3 = peg$FAILED;
                                if (peg$silentFails === 0) {
                                    peg$fail(peg$e34);
                                }
                            }
                            if (s3 !== peg$FAILED) {
                                peg$savedPos = s0;
                                s0 = peg$f25(s1);
                            }
                            else {
                                peg$currPos = s0;
                                s0 = peg$FAILED;
                            }
                        }
                        else {
                            peg$currPos = s0;
                            s0 = peg$FAILED;
                        }
                        peg$silentFails--;
                        if (s0 === peg$FAILED) {
                            s1 = peg$FAILED;
                            if (peg$silentFails === 0) {
                                peg$fail(peg$e33);
                            }
                        }
                        return s0;
                    }
                    function peg$parseyear() {
                        var s0, s1, s2, s3, s4, s5;
                        peg$silentFails++;
                        s0 = peg$currPos;
                        s1 = peg$currPos;
                        s2 = peg$parsed();
                        if (s2 !== peg$FAILED) {
                            s3 = peg$parsed();
                            if (s3 !== peg$FAILED) {
                                s4 = peg$parsed();
                                if (s4 !== peg$FAILED) {
                                    s5 = peg$parsed();
                                    if (s5 !== peg$FAILED) {
                                        s2 = [s2, s3, s4, s5];
                                        s1 = s2;
                                    }
                                    else {
                                        peg$currPos = s1;
                                        s1 = peg$FAILED;
                                    }
                                }
                                else {
                                    peg$currPos = s1;
                                    s1 = peg$FAILED;
                                }
                            }
                            else {
                                peg$currPos = s1;
                                s1 = peg$FAILED;
                            }
                        }
                        else {
                            peg$currPos = s1;
                            s1 = peg$FAILED;
                        }
                        if (s1 !== peg$FAILED) {
                            s0 = input.substring(s0, peg$currPos);
                        }
                        else {
                            s0 = s1;
                        }
                        peg$silentFails--;
                        if (s0 === peg$FAILED) {
                            s1 = peg$FAILED;
                            if (peg$silentFails === 0) {
                                peg$fail(peg$e35);
                            }
                        }
                        return s0;
                    }
                    function peg$parsemonth() {
                        var s0, s1, s2, s3, s4, s5;
                        peg$silentFails++;
                        s0 = peg$currPos;
                        s1 = peg$currPos;
                        s2 = peg$parseyear();
                        if (s2 !== peg$FAILED) {
                            if (input.charCodeAt(peg$currPos) === 45) {
                                s3 = peg$c20;
                                peg$currPos++;
                            }
                            else {
                                s3 = peg$FAILED;
                                if (peg$silentFails === 0) {
                                    peg$fail(peg$e37);
                                }
                            }
                            if (s3 !== peg$FAILED) {
                                s4 = peg$parsed();
                                if (s4 !== peg$FAILED) {
                                    s5 = peg$parsed();
                                    if (s5 !== peg$FAILED) {
                                        s2 = [s2, s3, s4, s5];
                                        s1 = s2;
                                    }
                                    else {
                                        peg$currPos = s1;
                                        s1 = peg$FAILED;
                                    }
                                }
                                else {
                                    peg$currPos = s1;
                                    s1 = peg$FAILED;
                                }
                            }
                            else {
                                peg$currPos = s1;
                                s1 = peg$FAILED;
                            }
                        }
                        else {
                            peg$currPos = s1;
                            s1 = peg$FAILED;
                        }
                        if (s1 !== peg$FAILED) {
                            s0 = input.substring(s0, peg$currPos);
                        }
                        else {
                            s0 = s1;
                        }
                        peg$silentFails--;
                        if (s0 === peg$FAILED) {
                            s1 = peg$FAILED;
                            if (peg$silentFails === 0) {
                                peg$fail(peg$e36);
                            }
                        }
                        return s0;
                    }
                    function peg$parseday() {
                        var s0, s1, s2, s3;
                        peg$silentFails++;
                        s0 = peg$currPos;
                        s1 = peg$currPos;
                        s2 = peg$parsed();
                        if (s2 !== peg$FAILED) {
                            s3 = peg$parsed();
                            if (s3 !== peg$FAILED) {
                                s2 = [s2, s3];
                                s1 = s2;
                            }
                            else {
                                peg$currPos = s1;
                                s1 = peg$FAILED;
                            }
                        }
                        else {
                            peg$currPos = s1;
                            s1 = peg$FAILED;
                        }
                        if (s1 !== peg$FAILED) {
                            s0 = input.substring(s0, peg$currPos);
                        }
                        else {
                            s0 = s1;
                        }
                        peg$silentFails--;
                        if (s0 === peg$FAILED) {
                            s1 = peg$FAILED;
                            if (peg$silentFails === 0) {
                                peg$fail(peg$e38);
                            }
                        }
                        return s0;
                    }
                    function peg$parsedate() {
                        var s0, s1, s2, s3, s4;
                        s0 = peg$currPos;
                        s1 = peg$currPos;
                        s2 = peg$parsemonth();
                        if (s2 !== peg$FAILED) {
                            if (input.charCodeAt(peg$currPos) === 45) {
                                s3 = peg$c20;
                                peg$currPos++;
                            }
                            else {
                                s3 = peg$FAILED;
                                if (peg$silentFails === 0) {
                                    peg$fail(peg$e37);
                                }
                            }
                            if (s3 !== peg$FAILED) {
                                s4 = peg$parseday();
                                if (s4 !== peg$FAILED) {
                                    s2 = [s2, s3, s4];
                                    s1 = s2;
                                }
                                else {
                                    peg$currPos = s1;
                                    s1 = peg$FAILED;
                                }
                            }
                            else {
                                peg$currPos = s1;
                                s1 = peg$FAILED;
                            }
                        }
                        else {
                            peg$currPos = s1;
                            s1 = peg$FAILED;
                        }
                        if (s1 !== peg$FAILED) {
                            s0 = input.substring(s0, peg$currPos);
                        }
                        else {
                            s0 = s1;
                        }
                        return s0;
                    }
                    function peg$parsecurrencySymbol() {
                        var s0, s1, s2;
                        peg$silentFails++;
                        s0 = peg$currPos;
                        if (input.length > peg$currPos) {
                            s1 = input.charAt(peg$currPos);
                            peg$currPos++;
                        }
                        else {
                            s1 = peg$FAILED;
                            if (peg$silentFails === 0) {
                                peg$fail(peg$e40);
                            }
                        }
                        if (s1 !== peg$FAILED) {
                            peg$savedPos = peg$currPos;
                            s2 = peg$f26(s1);
                            if (s2) {
                                s2 = undefined;
                            }
                            else {
                                s2 = peg$FAILED;
                            }
                            if (s2 !== peg$FAILED) {
                                s1 = [s1, s2];
                                s0 = s1;
                            }
                            else {
                                peg$currPos = s0;
                                s0 = peg$FAILED;
                            }
                        }
                        else {
                            peg$currPos = s0;
                            s0 = peg$FAILED;
                        }
                        peg$silentFails--;
                        if (s0 === peg$FAILED) {
                            s1 = peg$FAILED;
                            if (peg$silentFails === 0) {
                                peg$fail(peg$e39);
                            }
                        }
                        return s0;
                    }
                    function peg$parsename() {
                        var s0, s1, s2;
                        peg$silentFails++;
                        s0 = peg$currPos;
                        s1 = [];
                        if (peg$r2.test(input.charAt(peg$currPos))) {
                            s2 = input.charAt(peg$currPos);
                            peg$currPos++;
                        }
                        else {
                            s2 = peg$FAILED;
                            if (peg$silentFails === 0) {
                                peg$fail(peg$e42);
                            }
                        }
                        if (s2 !== peg$FAILED) {
                            while (s2 !== peg$FAILED) {
                                s1.push(s2);
                                if (peg$r2.test(input.charAt(peg$currPos))) {
                                    s2 = input.charAt(peg$currPos);
                                    peg$currPos++;
                                }
                                else {
                                    s2 = peg$FAILED;
                                    if (peg$silentFails === 0) {
                                        peg$fail(peg$e42);
                                    }
                                }
                            }
                        }
                        else {
                            s1 = peg$FAILED;
                        }
                        if (s1 !== peg$FAILED) {
                            s0 = input.substring(s0, peg$currPos);
                        }
                        else {
                            s0 = s1;
                        }
                        peg$silentFails--;
                        if (s0 === peg$FAILED) {
                            s1 = peg$FAILED;
                            if (peg$silentFails === 0) {
                                peg$fail(peg$e41);
                            }
                        }
                        return s0;
                    }
                    peg$result = peg$startRuleFunction();
                    if (peg$result !== peg$FAILED && peg$currPos === input.length) {
                        return peg$result;
                    }
                    else {
                        if (peg$result !== peg$FAILED && peg$currPos < input.length) {
                            peg$fail(peg$endExpectation());
                        }
                        throw peg$buildStructuredError(peg$maxFailExpected, peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null, peg$maxFailPos < input.length
                            ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1)
                            : peg$computeLocation(peg$maxFailPos, peg$maxFailPos));
                    }
                }
                return {
                    SyntaxError: peg$SyntaxError,
                    parse: peg$parse
                };
            });
            /***/ 
        }),
        /***/ "@actual-app/crdt": 
        /*!***********************************!*\
          !*** external "@actual-app/crdt" ***!
          \***********************************/
        /***/ ((module) => {
            "use strict";
            module.exports = require("@actual-app/crdt");
            /***/ 
        }),
        /***/ "better-sqlite3": 
        /*!*********************************!*\
          !*** external "better-sqlite3" ***!
          \*********************************/
        /***/ ((module) => {
            "use strict";
            module.exports = require("better-sqlite3");
            /***/ 
        }),
        /***/ "crypto": 
        /*!*************************!*\
          !*** external "crypto" ***!
          \*************************/
        /***/ ((module) => {
            "use strict";
            module.exports = require("crypto");
            /***/ 
        }),
        /***/ "events": 
        /*!*************************!*\
          !*** external "events" ***!
          \*************************/
        /***/ ((module) => {
            "use strict";
            module.exports = require("events");
            /***/ 
        }),
        /***/ "fs": 
        /*!*********************!*\
          !*** external "fs" ***!
          \*********************/
        /***/ ((module) => {
            "use strict";
            module.exports = require("fs");
            /***/ 
        }),
        /***/ "os": 
        /*!*********************!*\
          !*** external "os" ***!
          \*********************/
        /***/ ((module) => {
            "use strict";
            module.exports = require("os");
            /***/ 
        }),
        /***/ "path": 
        /*!***********************!*\
          !*** external "path" ***!
          \***********************/
        /***/ ((module) => {
            "use strict";
            module.exports = require("path");
            /***/ 
        }),
        /***/ "stream": 
        /*!*************************!*\
          !*** external "stream" ***!
          \*************************/
        /***/ ((module) => {
            "use strict";
            module.exports = require("stream");
            /***/ 
        }),
        /***/ "string_decoder": 
        /*!*********************************!*\
          !*** external "string_decoder" ***!
          \*********************************/
        /***/ ((module) => {
            "use strict";
            module.exports = require("string_decoder");
            /***/ 
        }),
        /***/ "timers": 
        /*!*************************!*\
          !*** external "timers" ***!
          \*************************/
        /***/ ((module) => {
            "use strict";
            module.exports = require("timers");
            /***/ 
        }),
        /***/ "util": 
        /*!***********************!*\
          !*** external "util" ***!
          \***********************/
        /***/ ((module) => {
            "use strict";
            module.exports = require("util");
            /***/ 
        }),
        /***/ "zlib": 
        /*!***********************!*\
          !*** external "zlib" ***!
          \***********************/
        /***/ ((module) => {
            "use strict";
            module.exports = require("zlib");
            /***/ 
        }),
        /***/ "./node_modules/available-typed-arrays/index.js": 
        /*!******************************************************!*\
          !*** ./node_modules/available-typed-arrays/index.js ***!
          \******************************************************/
        /***/ ((module) => {
            "use strict";
            var possibleNames = [
                'BigInt64Array',
                'BigUint64Array',
                'Float32Array',
                'Float64Array',
                'Int16Array',
                'Int32Array',
                'Int8Array',
                'Uint16Array',
                'Uint32Array',
                'Uint8Array',
                'Uint8ClampedArray'
            ];
            var g = typeof globalThis === 'undefined' ? global : globalThis;
            module.exports = function availableTypedArrays() {
                var out = [];
                for (var i = 0; i < possibleNames.length; i++) {
                    if (typeof g[possibleNames[i]] === 'function') {
                        out[out.length] = possibleNames[i];
                    }
                }
                return out;
            };
            /***/ 
        }),
        /***/ "./node_modules/es-get-iterator/node.js": 
        /*!**********************************************!*\
          !*** ./node_modules/es-get-iterator/node.js ***!
          \**********************************************/
        /***/ ((module) => {
            "use strict";
            // this should only run in node >= 13.2, so it
            // does not need any of the intense fallbacks that old node/browsers do
            var $iterator = Symbol.iterator;
            module.exports = function getIterator(iterable) {
                // alternatively, `iterable[$iterator]?.()`
                if (iterable != null && typeof iterable[$iterator] !== 'undefined') {
                    return iterable[$iterator]();
                }
            };
            /***/ 
        }),
        /***/ "./node_modules/which-collection/index.js": 
        /*!************************************************!*\
          !*** ./node_modules/which-collection/index.js ***!
          \************************************************/
        /***/ ((module, __unused_webpack_exports, __webpack_require__) => {
            "use strict";
            var isMap = __webpack_require__(/*! is-map */ "./node_modules/is-map/index.js");
            var isSet = __webpack_require__(/*! is-set */ "./node_modules/is-set/index.js");
            var isWeakMap = __webpack_require__(/*! is-weakmap */ "./node_modules/is-weakmap/index.js");
            var isWeakSet = __webpack_require__(/*! is-weakset */ "./node_modules/is-weakset/index.js");
            module.exports = function whichCollection(value) {
                if (value && typeof value === 'object') {
                    if (isMap(value)) {
                        return 'Map';
                    }
                    if (isSet(value)) {
                        return 'Set';
                    }
                    if (isWeakMap(value)) {
                        return 'WeakMap';
                    }
                    if (isWeakSet(value)) {
                        return 'WeakSet';
                    }
                }
                return false;
            };
            /***/ 
        }),
        /***/ "./node_modules/@babel/runtime/helpers/esm/arrayLikeToArray.js": 
        /*!*********************************************************************!*\
          !*** ./node_modules/@babel/runtime/helpers/esm/arrayLikeToArray.js ***!
          \*********************************************************************/
        /***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony export */ __webpack_require__.d(__webpack_exports__, {
                /* harmony export */ "default": () => ( /* binding */_arrayLikeToArray)
                /* harmony export */ 
            });
            function _arrayLikeToArray(arr, len) {
                if (len == null || len > arr.length)
                    len = arr.length;
                for (var i = 0, arr2 = new Array(len); i < len; i++)
                    arr2[i] = arr[i];
                return arr2;
            }
            /***/ 
        }),
        /***/ "./node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js": 
        /*!**************************************************************************!*\
          !*** ./node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js ***!
          \**************************************************************************/
        /***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony export */ __webpack_require__.d(__webpack_exports__, {
                /* harmony export */ "default": () => ( /* binding */_assertThisInitialized)
                /* harmony export */ 
            });
            function _assertThisInitialized(self) {
                if (self === void 0) {
                    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                }
                return self;
            }
            /***/ 
        }),
        /***/ "./node_modules/@babel/runtime/helpers/esm/classCallCheck.js": 
        /*!*******************************************************************!*\
          !*** ./node_modules/@babel/runtime/helpers/esm/classCallCheck.js ***!
          \*******************************************************************/
        /***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony export */ __webpack_require__.d(__webpack_exports__, {
                /* harmony export */ "default": () => ( /* binding */_classCallCheck)
                /* harmony export */ 
            });
            function _classCallCheck(instance, Constructor) {
                if (!(instance instanceof Constructor)) {
                    throw new TypeError("Cannot call a class as a function");
                }
            }
            /***/ 
        }),
        /***/ "./node_modules/@babel/runtime/helpers/esm/createClass.js": 
        /*!****************************************************************!*\
          !*** ./node_modules/@babel/runtime/helpers/esm/createClass.js ***!
          \****************************************************************/
        /***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony export */ __webpack_require__.d(__webpack_exports__, {
                /* harmony export */ "default": () => ( /* binding */_createClass)
                /* harmony export */ 
            });
            /* harmony import */ var _toPropertyKey_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./toPropertyKey.js */ "./node_modules/@babel/runtime/helpers/esm/toPropertyKey.js");
            function _defineProperties(target, props) {
                for (var i = 0; i < props.length; i++) {
                    var descriptor = props[i];
                    descriptor.enumerable = descriptor.enumerable || false;
                    descriptor.configurable = true;
                    if ("value" in descriptor)
                        descriptor.writable = true;
                    Object.defineProperty(target, (0, _toPropertyKey_js__WEBPACK_IMPORTED_MODULE_0__["default"])(descriptor.key), descriptor);
                }
            }
            function _createClass(Constructor, protoProps, staticProps) {
                if (protoProps)
                    _defineProperties(Constructor.prototype, protoProps);
                if (staticProps)
                    _defineProperties(Constructor, staticProps);
                Object.defineProperty(Constructor, "prototype", {
                    writable: false
                });
                return Constructor;
            }
            /***/ 
        }),
        /***/ "./node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js": 
        /*!******************************************************************************!*\
          !*** ./node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js ***!
          \******************************************************************************/
        /***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony export */ __webpack_require__.d(__webpack_exports__, {
                /* harmony export */ "default": () => ( /* binding */_createForOfIteratorHelper)
                /* harmony export */ 
            });
            /* harmony import */ var _unsupportedIterableToArray_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./unsupportedIterableToArray.js */ "./node_modules/@babel/runtime/helpers/esm/unsupportedIterableToArray.js");
            function _createForOfIteratorHelper(o, allowArrayLike) {
                var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
                if (!it) {
                    if (Array.isArray(o) || (it = (0, _unsupportedIterableToArray_js__WEBPACK_IMPORTED_MODULE_0__["default"])(o)) || allowArrayLike && o && typeof o.length === "number") {
                        if (it)
                            o = it;
                        var i = 0;
                        var F = function F() { };
                        return {
                            s: F,
                            n: function n() {
                                if (i >= o.length)
                                    return {
                                        done: true
                                    };
                                return {
                                    done: false,
                                    value: o[i++]
                                };
                            },
                            e: function e(_e) {
                                throw _e;
                            },
                            f: F
                        };
                    }
                    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
                }
                var normalCompletion = true, didErr = false, err;
                return {
                    s: function s() {
                        it = it.call(o);
                    },
                    n: function n() {
                        var step = it.next();
                        normalCompletion = step.done;
                        return step;
                    },
                    e: function e(_e2) {
                        didErr = true;
                        err = _e2;
                    },
                    f: function f() {
                        try {
                            if (!normalCompletion && it["return"] != null)
                                it["return"]();
                        }
                        finally {
                            if (didErr)
                                throw err;
                        }
                    }
                };
            }
            /***/ 
        }),
        /***/ "./node_modules/@babel/runtime/helpers/esm/createSuper.js": 
        /*!****************************************************************!*\
          !*** ./node_modules/@babel/runtime/helpers/esm/createSuper.js ***!
          \****************************************************************/
        /***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony export */ __webpack_require__.d(__webpack_exports__, {
                /* harmony export */ "default": () => ( /* binding */_createSuper)
                /* harmony export */ 
            });
            /* harmony import */ var _getPrototypeOf_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./getPrototypeOf.js */ "./node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js");
            /* harmony import */ var _isNativeReflectConstruct_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./isNativeReflectConstruct.js */ "./node_modules/@babel/runtime/helpers/esm/isNativeReflectConstruct.js");
            /* harmony import */ var _possibleConstructorReturn_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./possibleConstructorReturn.js */ "./node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js");
            function _createSuper(Derived) {
                var hasNativeReflectConstruct = (0, _isNativeReflectConstruct_js__WEBPACK_IMPORTED_MODULE_1__["default"])();
                return function _createSuperInternal() {
                    var Super = (0, _getPrototypeOf_js__WEBPACK_IMPORTED_MODULE_0__["default"])(Derived), result;
                    if (hasNativeReflectConstruct) {
                        var NewTarget = (0, _getPrototypeOf_js__WEBPACK_IMPORTED_MODULE_0__["default"])(this).constructor;
                        result = Reflect.construct(Super, arguments, NewTarget);
                    }
                    else {
                        result = Super.apply(this, arguments);
                    }
                    return (0, _possibleConstructorReturn_js__WEBPACK_IMPORTED_MODULE_2__["default"])(this, result);
                };
            }
            /***/ 
        }),
        /***/ "./node_modules/@babel/runtime/helpers/esm/defineProperty.js": 
        /*!*******************************************************************!*\
          !*** ./node_modules/@babel/runtime/helpers/esm/defineProperty.js ***!
          \*******************************************************************/
        /***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony export */ __webpack_require__.d(__webpack_exports__, {
                /* harmony export */ "default": () => ( /* binding */_defineProperty)
                /* harmony export */ 
            });
            /* harmony import */ var _toPropertyKey_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./toPropertyKey.js */ "./node_modules/@babel/runtime/helpers/esm/toPropertyKey.js");
            function _defineProperty(obj, key, value) {
                key = (0, _toPropertyKey_js__WEBPACK_IMPORTED_MODULE_0__["default"])(key);
                if (key in obj) {
                    Object.defineProperty(obj, key, {
                        value: value,
                        enumerable: true,
                        configurable: true,
                        writable: true
                    });
                }
                else {
                    obj[key] = value;
                }
                return obj;
            }
            /***/ 
        }),
        /***/ "./node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js": 
        /*!*******************************************************************!*\
          !*** ./node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js ***!
          \*******************************************************************/
        /***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony export */ __webpack_require__.d(__webpack_exports__, {
                /* harmony export */ "default": () => ( /* binding */_getPrototypeOf)
                /* harmony export */ 
            });
            function _getPrototypeOf(o) {
                _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) {
                    return o.__proto__ || Object.getPrototypeOf(o);
                };
                return _getPrototypeOf(o);
            }
            /***/ 
        }),
        /***/ "./node_modules/@babel/runtime/helpers/esm/inherits.js": 
        /*!*************************************************************!*\
          !*** ./node_modules/@babel/runtime/helpers/esm/inherits.js ***!
          \*************************************************************/
        /***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony export */ __webpack_require__.d(__webpack_exports__, {
                /* harmony export */ "default": () => ( /* binding */_inherits)
                /* harmony export */ 
            });
            /* harmony import */ var _setPrototypeOf_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./setPrototypeOf.js */ "./node_modules/@babel/runtime/helpers/esm/setPrototypeOf.js");
            function _inherits(subClass, superClass) {
                if (typeof superClass !== "function" && superClass !== null) {
                    throw new TypeError("Super expression must either be null or a function");
                }
                subClass.prototype = Object.create(superClass && superClass.prototype, {
                    constructor: {
                        value: subClass,
                        writable: true,
                        configurable: true
                    }
                });
                Object.defineProperty(subClass, "prototype", {
                    writable: false
                });
                if (superClass)
                    (0, _setPrototypeOf_js__WEBPACK_IMPORTED_MODULE_0__["default"])(subClass, superClass);
            }
            /***/ 
        }),
        /***/ "./node_modules/@babel/runtime/helpers/esm/isNativeReflectConstruct.js": 
        /*!*****************************************************************************!*\
          !*** ./node_modules/@babel/runtime/helpers/esm/isNativeReflectConstruct.js ***!
          \*****************************************************************************/
        /***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony export */ __webpack_require__.d(__webpack_exports__, {
                /* harmony export */ "default": () => ( /* binding */_isNativeReflectConstruct)
                /* harmony export */ 
            });
            function _isNativeReflectConstruct() {
                try {
                    var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () { }));
                }
                catch (t) { }
                return (_isNativeReflectConstruct = function _isNativeReflectConstruct() {
                    return !!t;
                })();
            }
            /***/ 
        }),
        /***/ "./node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js": 
        /*!******************************************************************************!*\
          !*** ./node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js ***!
          \******************************************************************************/
        /***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony export */ __webpack_require__.d(__webpack_exports__, {
                /* harmony export */ "default": () => ( /* binding */_possibleConstructorReturn)
                /* harmony export */ 
            });
            /* harmony import */ var _typeof_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./typeof.js */ "./node_modules/@babel/runtime/helpers/esm/typeof.js");
            /* harmony import */ var _assertThisInitialized_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./assertThisInitialized.js */ "./node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js");
            function _possibleConstructorReturn(self, call) {
                if (call && ((0, _typeof_js__WEBPACK_IMPORTED_MODULE_0__["default"])(call) === "object" || typeof call === "function")) {
                    return call;
                }
                else if (call !== void 0) {
                    throw new TypeError("Derived constructors may only return object or undefined");
                }
                return (0, _assertThisInitialized_js__WEBPACK_IMPORTED_MODULE_1__["default"])(self);
            }
            /***/ 
        }),
        /***/ "./node_modules/@babel/runtime/helpers/esm/setPrototypeOf.js": 
        /*!*******************************************************************!*\
          !*** ./node_modules/@babel/runtime/helpers/esm/setPrototypeOf.js ***!
          \*******************************************************************/
        /***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony export */ __webpack_require__.d(__webpack_exports__, {
                /* harmony export */ "default": () => ( /* binding */_setPrototypeOf)
                /* harmony export */ 
            });
            function _setPrototypeOf(o, p) {
                _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {
                    o.__proto__ = p;
                    return o;
                };
                return _setPrototypeOf(o, p);
            }
            /***/ 
        }),
        /***/ "./node_modules/@babel/runtime/helpers/esm/toPrimitive.js": 
        /*!****************************************************************!*\
          !*** ./node_modules/@babel/runtime/helpers/esm/toPrimitive.js ***!
          \****************************************************************/
        /***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony export */ __webpack_require__.d(__webpack_exports__, {
                /* harmony export */ "default": () => ( /* binding */toPrimitive)
                /* harmony export */ 
            });
            /* harmony import */ var _typeof_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./typeof.js */ "./node_modules/@babel/runtime/helpers/esm/typeof.js");
            function toPrimitive(t, r) {
                if ("object" != (0, _typeof_js__WEBPACK_IMPORTED_MODULE_0__["default"])(t) || !t)
                    return t;
                var e = t[Symbol.toPrimitive];
                if (void 0 !== e) {
                    var i = e.call(t, r || "default");
                    if ("object" != (0, _typeof_js__WEBPACK_IMPORTED_MODULE_0__["default"])(i))
                        return i;
                    throw new TypeError("@@toPrimitive must return a primitive value.");
                }
                return ("string" === r ? String : Number)(t);
            }
            /***/ 
        }),
        /***/ "./node_modules/@babel/runtime/helpers/esm/toPropertyKey.js": 
        /*!******************************************************************!*\
          !*** ./node_modules/@babel/runtime/helpers/esm/toPropertyKey.js ***!
          \******************************************************************/
        /***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony export */ __webpack_require__.d(__webpack_exports__, {
                /* harmony export */ "default": () => ( /* binding */toPropertyKey)
                /* harmony export */ 
            });
            /* harmony import */ var _typeof_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./typeof.js */ "./node_modules/@babel/runtime/helpers/esm/typeof.js");
            /* harmony import */ var _toPrimitive_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./toPrimitive.js */ "./node_modules/@babel/runtime/helpers/esm/toPrimitive.js");
            function toPropertyKey(t) {
                var i = (0, _toPrimitive_js__WEBPACK_IMPORTED_MODULE_1__["default"])(t, "string");
                return "symbol" == (0, _typeof_js__WEBPACK_IMPORTED_MODULE_0__["default"])(i) ? i : String(i);
            }
            /***/ 
        }),
        /***/ "./node_modules/@babel/runtime/helpers/esm/typeof.js": 
        /*!***********************************************************!*\
          !*** ./node_modules/@babel/runtime/helpers/esm/typeof.js ***!
          \***********************************************************/
        /***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony export */ __webpack_require__.d(__webpack_exports__, {
                /* harmony export */ "default": () => ( /* binding */_typeof)
                /* harmony export */ 
            });
            function _typeof(o) {
                "@babel/helpers - typeof";
                return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) {
                    return typeof o;
                } : function (o) {
                    return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o;
                }, _typeof(o);
            }
            /***/ 
        }),
        /***/ "./node_modules/@babel/runtime/helpers/esm/unsupportedIterableToArray.js": 
        /*!*******************************************************************************!*\
          !*** ./node_modules/@babel/runtime/helpers/esm/unsupportedIterableToArray.js ***!
          \*******************************************************************************/
        /***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony export */ __webpack_require__.d(__webpack_exports__, {
                /* harmony export */ "default": () => ( /* binding */_unsupportedIterableToArray)
                /* harmony export */ 
            });
            /* harmony import */ var _arrayLikeToArray_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./arrayLikeToArray.js */ "./node_modules/@babel/runtime/helpers/esm/arrayLikeToArray.js");
            function _unsupportedIterableToArray(o, minLen) {
                if (!o)
                    return;
                if (typeof o === "string")
                    return (0, _arrayLikeToArray_js__WEBPACK_IMPORTED_MODULE_0__["default"])(o, minLen);
                var n = Object.prototype.toString.call(o).slice(8, -1);
                if (n === "Object" && o.constructor)
                    n = o.constructor.name;
                if (n === "Map" || n === "Set")
                    return Array.from(o);
                if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
                    return (0, _arrayLikeToArray_js__WEBPACK_IMPORTED_MODULE_0__["default"])(o, minLen);
            }
            /***/ 
        }),
        /***/ "./node_modules/mitt/dist/mitt.mjs": 
        /*!*****************************************!*\
          !*** ./node_modules/mitt/dist/mitt.mjs ***!
          \*****************************************/
        /***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony export */ __webpack_require__.d(__webpack_exports__, {
                /* harmony export */ "default": () => ( /* export default binding */__WEBPACK_DEFAULT_EXPORT__)
                /* harmony export */ 
            });
            /* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(n) { return { all: n = n || new Map, on: function (t, e) { var i = n.get(t); i ? i.push(e) : n.set(t, [e]); }, off: function (t, e) { var i = n.get(t); i && (e ? i.splice(i.indexOf(e) >>> 0, 1) : n.set(t, [])); }, emit: function (t, e) { var i = n.get(t); i && i.slice().map(function (n) { n(e); }), (i = n.get("*")) && i.slice().map(function (n) { n(t, e); }); } }; }
            //# sourceMappingURL=mitt.mjs.map
            /***/ 
        })
        /******/ 
    });
    /************************************************************************/
    /******/ // The module cache
    /******/ var __webpack_module_cache__ = {};
    /******/
    /******/ // The require function
    /******/ function __webpack_require__(moduleId) {
        /******/ // Check if module is in cache
        /******/ var cachedModule = __webpack_module_cache__[moduleId];
        /******/ if (cachedModule !== undefined) {
            /******/ return cachedModule.exports;
            /******/ }
        /******/ // Create a new module (and put it into the cache)
        /******/ var module = __webpack_module_cache__[moduleId] = {
            /******/ // no module.id needed
            /******/ // no module.loaded needed
            /******/ exports: {}
            /******/ 
        };
        /******/
        /******/ // Execute the module function
        /******/ __webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
        /******/
        /******/ // Return the exports of the module
        /******/ return module.exports;
        /******/ 
    }
    /******/
    /************************************************************************/
    /******/ /* webpack/runtime/compat get default export */
    /******/ (() => {
        /******/ // getDefaultExport function for compatibility with non-harmony modules
        /******/ __webpack_require__.n = (module) => {
            /******/ var getter = module && module.__esModule ?
                /******/ () => (module['default']) :
                /******/ () => (module);
            /******/ __webpack_require__.d(getter, { a: getter });
            /******/ return getter;
            /******/ 
        };
        /******/ 
    })();
    /******/
    /******/ /* webpack/runtime/define property getters */
    /******/ (() => {
        /******/ // define getter functions for harmony exports
        /******/ __webpack_require__.d = (exports, definition) => {
            /******/ for (var key in definition) {
                /******/ if (__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
                    /******/ Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
                    /******/ }
                /******/ }
            /******/ 
        };
        /******/ 
    })();
    /******/
    /******/ /* webpack/runtime/hasOwnProperty shorthand */
    /******/ (() => {
        /******/ __webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop));
        /******/ 
    })();
    /******/
    /******/ /* webpack/runtime/make namespace object */
    /******/ (() => {
        /******/ // define __esModule on exports
        /******/ __webpack_require__.r = (exports) => {
            /******/ if (typeof Symbol !== 'undefined' && Symbol.toStringTag) {
                /******/ Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
                /******/ }
            /******/ Object.defineProperty(exports, '__esModule', { value: true });
            /******/ 
        };
        /******/ 
    })();
    /******/
    /************************************************************************/
    /******/
    /******/ // startup
    /******/ // Load entry module and return exports
    /******/ // This entry module is referenced by other modules so it can't be inlined
    /******/ var __webpack_exports__ = __webpack_require__("./packages/loot-core/src/server/main.ts");
    /******/ module.exports = __webpack_exports__;
    /******/
    /******/ 
})();
//# sourceMappingURL=bundle.api.js.map
