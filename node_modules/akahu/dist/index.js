'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var tslib = require('tslib');
var axios = require('axios');
var uuid = require('uuid');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var axios__default = /*#__PURE__*/_interopDefaultLegacy(axios);

/**
 * Build a URL from constituent components.
 */
function buildUrl({ protocol, host, port, path = "", query = {}, }) {
    // If not specified, port will be chosen by browser based on protocol choice (http or https).
    const _port = port ? `:${port}` : "";
    // Clean `undefined` values from the query params
    const cleanedQuery = Object.fromEntries(Object.entries(query || {}).filter(([_, v]) => typeof v !== "undefined"));
    // Convert to URL encoded query string
    const queryString = Object.keys(cleanedQuery).length !== 0
        ? "?" + new URLSearchParams(cleanedQuery).toString()
        : "";
    return `${protocol}://${host}${_port}/${path}${queryString}`;
}
function pick(obj, ...props) {
    return Object.fromEntries(Object.entries(obj).filter(([k]) => props.includes(k)));
}
/**
 * Axios error interceptor to retry on network failures.
 * Dormant by default - is activated by including `retries` in the axios config.
 */
function axiosRetryOnNetworkError(error) {
    // Only handle axios errors.
    if (!error.isAxiosError)
        return Promise.reject(error);
    const { config } = error;
    const { method, headers, retries = 0, __retryCount = 0 } = config;
    // POST requests can only be retried if they include an idempotency key.
    // Other methods (i.e. get, patch, delete) are considered idempotent by default.
    const isIdempotent = method.toUpperCase() !== "POST" ||
        typeof headers["Idempotency-Key"] === "string";
    const shouldRetry = isIdempotent &&
        __retryCount < retries &&
        isNetworkError(error) && // Don't retry due to server errors
        isRetryAllowed(error); // Don't retry if the error is permanent (e.g. SSL related)
    if (!shouldRetry) {
        return Promise.reject(error);
    }
    config.__retryCount = __retryCount + 1;
    return axios__default['default'](config);
}
/**
 * Determine whether an axios error instance was caused by network error
 * (and should therefore be retryable).
 *
 * Borrowed from {@link https://github.com/softonic/axios-retry/blob/master/es/index.js}
 * with minor changes as we want to retry on timeout.
 */
function isNetworkError(error) {
    return (error.isAxiosError &&
        !error.response && // Network errors have no response
        !axios__default['default'].isCancel(error)); // Don't retry cancelled requests
}
/**
 * Inspect network error code from axios to determine if it makes sense to retry it.
 *
 * Borrowed from {@link https://github.com/sindresorhus/is-retry-allowed/blob/main/index.js}
 */
function isRetryAllowed(error) {
    return (error.code === undefined || // Errors due to timeout have no error code.
        !retryDenyList.has(error.code));
}
const retryDenyList = new Set([
    "ENOTFOUND",
    "ENETUNREACH",
    "UNABLE_TO_GET_ISSUER_CERT",
    "UNABLE_TO_GET_CRL",
    "UNABLE_TO_DECRYPT_CERT_SIGNATURE",
    "UNABLE_TO_DECRYPT_CRL_SIGNATURE",
    "UNABLE_TO_DECODE_ISSUER_PUBLIC_KEY",
    "CERT_SIGNATURE_FAILURE",
    "CRL_SIGNATURE_FAILURE",
    "CERT_NOT_YET_VALID",
    "CERT_HAS_EXPIRED",
    "CRL_NOT_YET_VALID",
    "CRL_HAS_EXPIRED",
    "ERROR_IN_CERT_NOT_BEFORE_FIELD",
    "ERROR_IN_CERT_NOT_AFTER_FIELD",
    "ERROR_IN_CRL_LAST_UPDATE_FIELD",
    "ERROR_IN_CRL_NEXT_UPDATE_FIELD",
    "OUT_OF_MEM",
    "DEPTH_ZERO_SELF_SIGNED_CERT",
    "SELF_SIGNED_CERT_IN_CHAIN",
    "UNABLE_TO_GET_ISSUER_CERT_LOCALLY",
    "UNABLE_TO_VERIFY_LEAF_SIGNATURE",
    "CERT_CHAIN_TOO_LONG",
    "CERT_REVOKED",
    "INVALID_CA",
    "PATH_LENGTH_EXCEEDED",
    "INVALID_PURPOSE",
    "CERT_UNTRUSTED",
    "CERT_REJECTED",
    "HOSTNAME_MISMATCH",
]);
// https://github.com/flexdinesh/browser-or-node/blob/master/src/index.js
const isBrowser = () => typeof window !== "undefined" && typeof window.document !== "undefined";
const isNode = () => {
    var _a;
    return typeof process === "object" &&
        Boolean((_a = process.versions) === null || _a === void 0 ? void 0 : _a.node) &&
        !isReactNative();
};
// https://github.com/facebook/react-native/commit/3c65e62183ce05893be0822da217cb803b121c61
const isReactNative = () => typeof navigator === "object" && navigator.product === "ReactNative";

const version = "1.15.3";

class AkahuError extends Error {
    constructor() {
        super(...arguments);
        /**
         * Flag that can be used to detect exceptions thrown by the Akahu SDK.
         */
        this.isAkahuError = true;
    }
}
/**
 * Legacy static property for backwards compatibility. Prefer the instance
 * property `isAkahuError` instead.
 * @deprecated
 */
AkahuError.isAkahuError = true;
/**
 * Error type for error responses received from the Akahu API.
 * An error response is characterised by a non 2XX status code and/or a body
 * payload that contains `success: false` along with an accompanying error message.
 *
 * @noInheritDoc
 * @category Error
 */
class AkahuErrorResponse extends AkahuError {
    /** @internal */
    constructor(response) {
        const { status, statusText, data = {} } = response;
        const { message, error, error_description } = data;
        let _message;
        // `error` and `error_description` are specific to the OAuth endpoints.
        // `error_description` is more user-friendly, but optional:
        // https://www.oauth.com/oauth2-servers/server-side-apps/possible-errors/
        if (typeof error_description === "string") {
            _message = error_description;
        }
        else if (error in AkahuErrorResponse.oAuthErrorCodeMap) {
            _message = AkahuErrorResponse.oAuthErrorCodeMap[error];
        }
        else {
            // Detail for other error responses are nested under the `message` key.
            // Include a fallback to statusText just in case things go really wrong.
            _message = message !== null && message !== void 0 ? message : statusText;
        }
        super(_message);
        this.status = status;
        this.response = response;
    }
}
/** @internal */
AkahuErrorResponse.oAuthErrorCodeMap = {
    invalid_request: "Invalid OAuth request.",
    unauthorized_client: "This application is not authorized to make this request.",
    unsupported_response_type: "Unsupported OAuth response type.",
    invalid_scope: "Unknown or invalid scope.",
    server_error: "Unknown server error.",
    temporarily_unavailable: "The authorization server is temporarily unavailable.",
    invalid_grant: "Invalid OAuth request.",
};
/**
 * Error type for errors that occur during the webhook validation process.
 *
 * @noInheritDoc
 * @category Error
 */
class AkahuWebhookValidationError extends AkahuError {
}

/**
 * @internal
 */
class BaseResource {
    /**
     * @internal
     */
    constructor(client) {
        this._client = client;
    }
}

/**
 * Utilities for authorizing users using OAuth2.
 *
 * {@link https://developers.akahu.nz/docs/authorizing-with-oauth2}
 *
 * @category Resource
 */
class AuthResource extends BaseResource {
    /**
     * Build the OAuth Authorization URL
     *
     * @param options Options for customising the generated URL.
     *
     * {@link https://developers.akahu.nz/docs/authorizing-with-oauth2#the-authorization-request}
     */
    buildAuthorizationUrl(options) {
        // Unpack options with defaults
        const { protocol, host, port, path, response_type, scope, redirect_uri, state, email, connection, } = Object.assign({ protocol: "https", host: "oauth.akahu.nz", path: "", response_type: "code", scope: "ENDURING_CONSENT" }, options);
        // Construct main OAuth query params
        const { appToken: client_id } = this._client.authConfig;
        const query = {
            response_type,
            redirect_uri,
            scope,
            client_id,
        };
        // Include optional params if specified in options
        if (email)
            query.email = email;
        if (connection)
            query.connection = connection;
        if (state)
            query.state = state;
        return buildUrl({ protocol, host, port, path, query });
    }
    /**
     * Exchange an OAuth authorization code for an access token.
     *
     * {@link https://developers.akahu.nz/docs/authorizing-with-oauth2#exchanging-the-authorization-code}
     * {@link https://developers.akahu.nz/reference/post_token}
     */
    exchange(code, redirect_uri, grant_type = "authorization_code") {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            // POST parameters for OAuth code exchange
            const { appToken: client_id, appSecret: client_secret } = this._client.authConfig;
            const data = { code, redirect_uri, grant_type, client_id, client_secret };
            return yield this._client._apiCall({
                path: "/token",
                method: "POST",
                data,
            });
        });
    }
    /**
     * Revoke the specified user auth token:
     *
     * {@link https://developers.akahu.nz/reference/delete_token}
     */
    revoke(token) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            return yield this._client._apiCall({
                path: "/token",
                method: "DELETE",
                auth: { token },
            });
        });
    }
}

/**
 * Utilities for requesting identity verification using OAuth2.
 *
 * {@link https://developers.akahu.nz/docs/identity-verification}
 *
 * @category Resource
 */
class IdentitiesResource extends BaseResource {
    /**
     * Build the Identity OAuth Authorization URL.
     *
     * {@link https://developers.akahu.nz/docs/identity-verification#the-authorization-request}
     */
    buildAuthorizationUrl(params) {
        // Borrow implementation from `OAuthResource.buildAuthorizationUrl`
        return this._client.auth.buildAuthorizationUrl(Object.assign({ scope: "ONEOFF" }, params));
    }
    /**
     * Retrieve an identity result using the code/id returned after successful authorization using the
     * OAuth identity verification flow.
     *
     * {@link https://developers.akahu.nz/docs/identity-verification#retrieving-identity-results-with-the-oauth-result-code}
     */
    get(code) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            return this._client._apiCall({
                path: `/identity/${code}`,
                auth: { basic: true },
            });
        });
    }
    /**
     * (**BETA**) Verify the user's name against an identity result.
     *
     * {@link https://developers.akahu.nz/docs/oneoff-verify-name}
     */
    verifyName(code, query) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            return this._client._apiCall({
                path: `/identity/${code}/verify/name`,
                method: "POST",
                data: query,
                auth: { basic: true },
            });
        });
    }
}

/**
 * Utilities for managing Akahu accounts that have been linked by users.
 *
 * {@link https://developers.akahu.nz/docs/accessing-account-data}
 *
 * @category Resource
 */
class AccountsResource extends BaseResource {
    /**
     * List all accounts that have been connected by the user associated with the specified `token`.
     *
     * {@link https://developers.akahu.nz/reference/get_accounts}
     */
    list(token) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            return yield this._client._apiCall({
                path: "/accounts",
                auth: { token },
            });
        });
    }
    /**
     * Get a single account that has been connected by the user associated with the specified `token`.
     *
     * {@link https://developers.akahu.nz/reference/get_accounts-id}
     */
    get(token, accountId) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            return yield this._client._apiCall({
                path: `/accounts/${accountId}`,
                auth: { token },
            });
        });
    }
    /**
     * List transactions for a specified account.
     *
     * {@link https://developers.akahu.nz/reference/get_accounts-id-transactions}
     */
    listTransactions(token, accountId, query = {}) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            return yield this._client._apiCall({
                path: `/accounts/${accountId}/transactions`,
                auth: { token },
                query,
            });
        });
    }
    /**
     * List pending transactions for a specified account.
     *
     * {@link https://developers.akahu.nz/reference/get_accounts-id-transactions-pending}
     */
    listPendingTransactions(token, accountId) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            return yield this._client._apiCall({
                path: `/accounts/${accountId}/transactions/pending`,
                auth: { token },
            });
        });
    }
    /**
     * Revoke a single account from the specified `token`.
     *
     * After this call the token will no longer have access to the specified account or it's associated data,
     * including transactions.
     *
     * {@link https://developers.akahu.nz/reference/delete_accounts-id}
     */
    revoke(token, accountId) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            return yield this._client._apiCall({
                path: `/accounts/${accountId}`,
                method: "DELETE",
                auth: { token },
            });
        });
    }
    /**
     * Refresh a single account that has been connected by the user associated with the specified `token`.
     *
     * {@link https://developers.akahu.nz/reference/post_refresh-id}
     */
    refresh(token, accountId) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            return yield this._client._apiCall({
                path: `/refresh/${accountId}`,
                method: "POST",
                auth: { token },
            });
        });
    }
    /**
     * Refresh all accounts that have been connected by the user associated with the specified `token`.
     *
     * {@link https://developers.akahu.nz/reference/post_refresh}
     */
    refreshAll(token) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            return yield this._client._apiCall({
                path: "/refresh",
                method: "POST",
                auth: { token },
            });
        });
    }
}

/**
 * Utilities to view connections that are available to your app, and refresh
 * accounts under a given connection.
 *
 * @category Resource
 */
class ConnectionsResource extends BaseResource {
    /**
     * List all connections that the app has access to.
     *
     * {@link https://developers.akahu.nz/reference/get_connections}
     */
    list() {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            return yield this._client._apiCall({
                path: "/connections",
                auth: { basic: true },
            });
        });
    }
    /**
     * Get an individual connection detail.
     *
     * {@link https://developers.akahu.nz/reference/get_connections-id}
     */
    get(connectionId) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            return yield this._client._apiCall({
                path: `/connections/${connectionId}`,
                auth: { basic: true },
            });
        });
    }
    /**
     * Refresh all accounts that are made using the given connection and have been
     * connected by the user associated with the specified `token`.
     *
     * {@link https://developers.akahu.nz/reference/post_refresh-id}
     */
    refresh(token, connectionId) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            return yield this._client._apiCall({
                path: `/refresh/${connectionId}`,
                method: "POST",
                auth: { token },
            });
        });
    }
}

/**
 * Utilities to view categories that are available to your app.
 *
 * @category Resource
 */
class CategoriesResource extends BaseResource {
    /**
     * List all categories that the app has access to.
     *
     * {@link https://developers.akahu.nz/reference/get_categories}
     */
    list() {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            return yield this._client._apiCall({
                path: "/categories",
                auth: { basic: true },
            });
        });
    }
    /**
     * Get an individual category.
     *
     * {@link https://developers.akahu.nz/reference/get_categories-id}
     */
    get(categoryId) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            return yield this._client._apiCall({
                path: `/categories/${categoryId}`,
                auth: { basic: true },
            });
        });
    }
}

/**
 * Utilities for managing bank account payments on behalf of users.
 *
 * {@link https://developers.akahu.nz/docs/making-a-payment}
 *
 * @category Resource
 */
class PaymentsResource extends BaseResource {
    /**
     * Get a single payment made by the user associated with the specified `token`.
     *
     * {@link https://developers.akahu.nz/reference/get_payments-id}
     */
    get(token, paymentId) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            return yield this._client._apiCall({
                path: `/payments/${paymentId}`,
                auth: { token },
            });
        });
    }
    /**
     * List all payments made in the provided date range by the user associated
     * with the specified `token`. Defaults to the last 30 days if no date range
     * is provided.
     *
     * {@link https://developers.akahu.nz/reference/get_payments}
     */
    list(token, query = {}) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            // List endpoint with optional query params for date range
            return yield this._client._apiCall({
                path: "/payments",
                auth: { token },
                query,
            });
        });
    }
    /**
     * Initiate a payment to an external bank account on behalf of the user associated
     * with the specified `token`.
     *
     * {@link https://developers.akahu.nz/reference/post_payments}
     */
    create(token, payment, requestOptions) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            return yield this._client._apiCall({
                path: "/payments",
                method: "POST",
                auth: { token },
                data: payment,
                options: requestOptions,
            });
        });
    }
    /**
     * Initiate a payment to the Inland Revenue Department on behalf of the user
     * associated with the specified `token`.
     *
     * {@link https://developers.akahu.nz/reference/post_payments-ird}
     */
    createToIrd(token, payment, requestOptions) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            return yield this._client._apiCall({
                path: "/payments/ird",
                method: "POST",
                auth: { token },
                data: payment,
                options: requestOptions,
            });
        });
    }
    /**
     * Cancel a payment that has a status of `PENDING_APPROVAL`.
     *
     * {@link https://developers.akahu.nz/reference/put_payments-id-cancel}
     * {@link https://developers.akahu.nz/docs/making-a-payment#manual-payment-approval}
     */
    cancel(token, paymentId) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            return this._client._apiCall({
                path: `/payments/${paymentId}`,
                method: "PUT",
                auth: { token },
            });
        });
    }
}

/**
 * Utilities for managing bank account transfers on behalf of users.
 *
 * {@link https://developers.akahu.nz/docs/making-a-transfer}
 *
 * @category Resource
 */
class TransfersResource extends BaseResource {
    /**
     * Get a single transfer made by the user associated with the specified `token`.
     *
     * {@link https://developers.akahu.nz/reference/get_transfers-id}
     */
    get(token, transferId) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            return yield this._client._apiCall({
                path: `/transfers/${transferId}`,
                auth: { token },
            });
        });
    }
    /**
     * List all transfers made in the provided date range by the user associated
     * with the specified `token`. Defaults to the last 30 days if no date range
     * is provided.
     *
     * {@link https://developers.akahu.nz/reference/get_transfers}
     */
    list(token, query = {}) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            // List endpoint with optional query params for date range
            return yield this._client._apiCall({
                path: "/transfers",
                auth: { token },
                query,
            });
        });
    }
    /**
     * Initiate a transfer between two of the users bank accounts.
     *
     * {@link https://developers.akahu.nz/reference/post_transfers}
     */
    create(token, transfer, requestOptions) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            return yield this._client._apiCall({
                path: "/transfers",
                method: "POST",
                auth: { token },
                data: transfer,
                options: requestOptions,
            });
        });
    }
}

/**
 * Utilities for retrieving bank transactions from connected user accounts.
 *
 * {@link https://developers.akahu.nz/docs/accessing-transactional-data}
 *
 * @category Resource
 */
class TransactionsResource extends BaseResource {
    /**
     * List all transactions for all accounts that have been connected by the user associated with the
     * specified `token`.
     *
     * {@link https://developers.akahu.nz/reference/get_transactions}
     */
    list(token, query = {}) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            // Paginated list endpoint with optional query params for date range & cursor
            return yield this._client._apiCall({
                path: "/transactions",
                auth: { token },
                query,
            });
        });
    }
    /**
     * List all pending transactions for all accounts that have been connected by the user associated with the
     * specified `token`.
     *
     * {@link https://developers.akahu.nz/reference/get_transactions-pending}
     */
    listPending(token) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            // Non-paginated list endpoint of pending transactions
            return yield this._client._apiCall({
                path: "/transactions/pending",
                auth: { token },
            });
        });
    }
    /**
     * Get a single transaction from an account that has been connected by the user associated with
     * the specified `token`.
     *
     * {@link https://developers.akahu.nz/reference/get_transactions-id}
     */
    get(token, transactionId) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            return yield this._client._apiCall({
                path: `/transactions/${transactionId}`,
                auth: { token },
            });
        });
    }
    /**
     * Get multiple transactions by id.
     *
     * All transactions must belong to the user associated with the specified `token`.
     *
     * This method may be useful to bulk refresh changed transaction data
     * in response to a webhook event.
     *
     * {@link https://developers.akahu.nz/reference/post_transactions-ids}
     */
    getMany(token, transactionIds) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            // Non-paginated list endpoint subset by transaction id
            return this._client._apiCall({
                path: "/transactions/ids",
                method: "POST",
                auth: { token },
                data: transactionIds,
            });
        });
    }
}

/**
 * Utilities for retrieving information about the Akahu user.
 *
 * @category Resource
 */
class UsersResource extends BaseResource {
    /**
     * Get the user associated with the specified `token`.
     *
     * {@link https://developers.akahu.nz/reference/get_me}
     */
    get(token) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            return yield this._client._apiCall({ path: "/me", auth: { token } });
        });
    }
}

// crypto may not be available on all platforms (e.g React Native).
// This is ok as we only need it server side. We just need to handle the import conditionally.
let crypto;
try {
    crypto = require("crypto");
}
catch (e) { }
/**
 * Default in-memory cache for caching the webhook signing key.
 */
class DefaultKeyCache {
    constructor() {
        this._cache = {};
    }
    get(key) {
        var _a;
        return tslib.__awaiter(this, void 0, void 0, function* () {
            return (_a = this._cache[key]) !== null && _a !== void 0 ? _a : null;
        });
    }
    set(key, value) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            this._cache[key] = value;
        });
    }
}
/**
 * Utilities for managing, retrieving, and validating webhooks.
 *
 * {@link https://developers.akahu.nz/docs/reference-webhooks}
 *
 * @category Resource
 */
class WebhooksResource extends BaseResource {
    constructor() {
        super(...arguments);
        this.defaultKeyCache = new DefaultKeyCache();
    }
    /**
     * Gets active webhooks for the user associated with the specified `token`.
     *
     * {@link https://developers.akahu.nz/reference/get_webhooks}
     */
    list(token) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            return yield this._client._apiCall({
                path: "/webhooks",
                auth: { token },
            });
        });
    }
    /**
     * Subscribe to a webhook.
     *
     * @returns The newly created webhook id.
     *
     * {@link https://developers.akahu.nz/reference/post_webhooks}
     */
    subscribe(token, webhook, requestOptions) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            return yield this._client._apiCall({
                path: "/webhooks",
                method: "POST",
                auth: { token },
                data: webhook,
                options: requestOptions,
            });
        });
    }
    /**
     * Unsubscribe from a previously created webhook.
     *
     * {@link https://developers.akahu.nz/reference/delete_webhooks-id}
     */
    unsubscribe(token, webhookId) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            return yield this._client._apiCall({
                path: `/webhooks/${webhookId}`,
                method: "DELETE",
                auth: { token },
            });
        });
    }
    /**
     * List all webhook events with the specified status in the specified date
     * range (defaults to last 30 days).
     *
     * {@link https://developers.akahu.nz/reference/get_webhook-events}
     */
    listEvents(query) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            return yield this._client._apiCall({
                path: "/webhook-events",
                auth: { basic: true },
                query,
            });
        });
    }
    /**
     * Get a webhook signing public-key by id.
     *
     * {@link https://developers.akahu.nz/reference/get_keys-id}
     */
    getPublicKey(keyId) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            return yield this._client._apiCall({
                path: `/keys/${keyId}`,
                auth: { basic: true },
            });
        });
    }
    /**
     * Helper to validate a webhook request payload.
     *
     * See the project README for example usage.
     *
     * @returns The deserialized webhook payload after successful validation
     *
     * @throws {@link AkahuWebhookValidationError}
     * if validation of the webhook fails due to invalid signature or expired signing key.
     *
     * @throws {@link AkahuErrorResponse}
     * if the client fails to fetch the specified signing key from the Akahu API.
     *
     * {@link https://developers.akahu.nz/docs/reference-webhooks}
     */
    validateWebhook(keyId, signature, webhookRequestBody, cacheConfig = {}) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            // Coerce keyId as a number
            const _keyId = Number(keyId);
            // Validate that keyId is an integer. Includes null check because Number(null) === 0
            if (!Number.isInteger(_keyId) || keyId === null) {
                throw new AkahuWebhookValidationError(`Can't validate webhook request. keyId must be an integer (received ${keyId}).`);
            }
            // Initialize cache config with defaults
            const _cacheConfig = Object.assign({ cache: this.defaultKeyCache, key: "akahu__webhook_key", maxAgeMs: 24 * 60 * 60 * 1000 }, cacheConfig);
            // Get the public key matching keyId - either from cache or API lookup
            const publicKey = yield this._getPublicKey(_keyId, _cacheConfig);
            // Validate the webhook signature using the retreived public key
            const isValid = this._validateWebhookSignature(publicKey, signature, webhookRequestBody);
            if (!isValid) {
                throw new AkahuWebhookValidationError("Webhook signature verificaton failed.");
            }
            return JSON.parse(webhookRequestBody);
        });
    }
    /**
     * Get the public key (by id) to validate a webhook signature.
     * The key will be retrieved from cache if possible, falling back to API lookup.
     * If a cached key exists with a newer id, an error will be thrown, as the existence of a newer
     * key implies that the key has been rotated and the requested key is no longer valid.
     *
     * {@link https://developers.akahu.nz/docs/reference-webhooks#caching}
     */
    _getPublicKey(keyId, cacheConfig) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            // Attempt to lookup key from cache
            const keyDataFromCache = yield this._getPublicKeyFromCache(cacheConfig);
            // Validate the cached key matches
            if (keyDataFromCache !== null) {
                const { id, key } = keyDataFromCache;
                // Validate that the cached key has same id as requested key
                if (keyId === id) {
                    return key;
                }
                // Throw an error if the requested key has been superseded
                if (keyId < id) {
                    throw new AkahuWebhookValidationError(`Webhook signing key (id: ${keyId}) has expired. Unable to validate webhook.`);
                }
                // Fallback to lookup via API
            }
            // Lookup key data from API
            const freshKeyData = {
                id: keyId,
                lastRefreshed: new Date().toISOString(),
                key: yield this.getPublicKey(keyId),
            };
            // Cache the updated key data
            yield this._cacheKeyData(freshKeyData, cacheConfig);
            return freshKeyData.key;
        });
    }
    /**
     * Lookup current active public key from the cache.
     * If the key has been in the cache for more than `maxAgeMs` milliseconds, it is considered
     * stale, and will be ignored - causing it to be re-fetched from Akahu. `maxAgeMs` defaults to 24 hours.
     *
     * {@link https://developers.akahu.nz/docs/reference-webhooks#caching}
     */
    _getPublicKeyFromCache(cacheConfig) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const { cache, key: cacheKey, maxAgeMs } = cacheConfig;
            // Lookup key data from cache
            const rawFromCache = yield cache.get(cacheKey);
            // Cache hit
            if (typeof rawFromCache === "string") {
                let keyData;
                // Deserialize key data JSON from cache
                try {
                    keyData = JSON.parse(rawFromCache);
                }
                catch (e) {
                    // Warn but no error if invalid JSON in cache data
                    console.warn(`akahu-sdk: Failed to deserialize webhook key data from cache (key: ${cacheKey}).`);
                }
                // Validate the key data from cache
                if (typeof keyData !== "undefined") {
                    // Ensure that the cache is at most `maxAgeMs` old
                    const cacheAgeMs = Date.now() - Date.parse(keyData.lastRefreshed);
                    // NaN check in case lastRefreshed is invalid date string or undefined somehow
                    if (!Number.isNaN(cacheAgeMs) && cacheAgeMs < maxAgeMs) {
                        return keyData;
                    }
                }
            }
            // Cache miss or invalid cache data
            return null;
        });
    }
    /**
     * Add the public key that has been fetched from the API to the cache.
     *
     * {@link https://developers.akahu.nz/docs/reference-webhooks#caching}
     */
    _cacheKeyData(keyData, cacheConfig) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const { cache, key } = cacheConfig;
            yield cache.set(key, JSON.stringify(keyData));
        });
    }
    /**
     * Validate a webhook and associated signature using the public key fetched from the Akahu API.
     *
     * {@link https://developers.akahu.nz/docs/reference-webhooks#verification}
     */
    _validateWebhookSignature(publicKey, signature, webhookBody) {
        if (typeof crypto === "undefined") {
            throw new Error("Webhook validation is only supported on Node.js environments.");
        }
        const verify = crypto.createVerify("sha256");
        verify.update(webhookBody);
        verify.end();
        return verify.verify(publicKey, signature, "base64");
    }
}

/**
 * Fetch identity data relating to the party that the user has logged-in to
 * their institution as when connecting accounts to Akahu. i.e. the user's
 * "profile" information at the connected institution.
 * @category Resource
 */
class PartiesResource extends BaseResource {
    /**
     * List all parties related to accounts which the user has shared with your
     * app.
     *
     * {@link https://developers.akahu.nz/reference/get_parties}
     */
    list(token) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            return yield this._client._apiCall({
                path: "/parties",
                auth: { token },
            });
        });
    }
}

// We will set this header to report SDK version
const X_AKAHU_SDK = `akahu-sdk-js/${version}`;
// We allow custom axios configuration using this subset of options
const allowedAxiosOptions = [
    "headers",
    "timeout",
    "proxy",
    "retries",
    "adapter",
];
/**
 * The AkahuClient provides a simple interface to the Akahu API and utilities
 * that assist with common usage patterns.
 *
 * AkahuClient uses {@link https://axios-http.com/docs/intro axios} under the hood to make
 * API requests. A subset of axios request options can be passed through to the underlying axios
 * instance using the options available in {@link AkahuClientConfig}.
 *
 * In the case of an error while making an API request, you can expect to handle one of the
 * following two exceptions:
 *
 * - {@link AkahuErrorResponse} When an error response is returned from the API
 * - {@link https://github.com/axios/axios/blob/v0.21.1/index.d.ts#L85 AxiosError} when an error
 *    occurred during the request process, but no response was received (i.e. due to network issues).
 *
 * @category API client
 */
class AkahuClient {
    constructor(config) {
        const _a = Object.assign({ apiVersion: "v1", protocol: "https", host: "api.akahu.io" }, config), { appToken, appSecret, apiVersion, protocol, host, port } = _a, axiosOptions = tslib.__rest(_a, ["appToken", "appSecret", "apiVersion", "protocol", "host", "port"]);
        // Sanity check to warn against insecure App Secret usage
        if (typeof appSecret !== "undefined" && !isNode()) {
            console.warn("Warning: do not use the appSecret option with AkahuClient in a client-side " +
                "application. This option is only intended to be used on a server environment.");
        }
        // Make sure the appToken is included and follows the expected format
        if (typeof appToken !== "string" || !appToken.startsWith("app_token_")) {
            throw new Error(`Invalid appToken value: ${appToken}. ` +
                "appToken must be a string beginning with app_token_");
        }
        this.authConfig = { appToken, appSecret };
        // Common headers that we will send with each request
        const akahuHeaders = {
            "X-Akahu-Sdk": X_AKAHU_SDK,
            "X-Akahu-Id": appToken, // Identify the calling app
        };
        // Also report SDK version in the User-Agent for convenience / visibility in logs. However
        // we don't want to set this in a browser environment as not all browsers support overriding
        // this header and it may result in un-suppressible errors in the browser console.
        // e.g: https://github.com/axios/axios/issues/1231
        if (!isBrowser()) {
            akahuHeaders["User-Agent"] = X_AKAHU_SDK;
        }
        // Filter user-provided config to ensure we only include supported options.
        const filteredAxiosOptions = pick(axiosOptions, ...allowedAxiosOptions);
        this.axios = axios__default['default'].create(Object.assign(Object.assign({}, filteredAxiosOptions), { baseURL: buildUrl({ protocol, host, port, path: apiVersion }), headers: Object.assign(Object.assign({}, filteredAxiosOptions.headers), akahuHeaders) }));
        this.axios.interceptors.response.use(undefined, axiosRetryOnNetworkError);
        // Initialise client resources
        this.auth = new AuthResource(this);
        this.identities = new IdentitiesResource(this);
        this.users = new UsersResource(this);
        this.connections = new ConnectionsResource(this);
        this.categories = new CategoriesResource(this);
        this.accounts = new AccountsResource(this);
        this.payments = new PaymentsResource(this);
        this.transfers = new TransfersResource(this);
        this.transactions = new TransactionsResource(this);
        this.webhooks = new WebhooksResource(this);
        this.parties = new PartiesResource(this);
    }
    _authorizeRequest(config, auth) {
        if (typeof auth !== "undefined") {
            // Basic HTTP auth is use for "app" endpoints
            if ("basic" in auth && auth.basic) {
                const { appToken, appSecret } = this.authConfig;
                if (typeof appSecret === "undefined") {
                    throw new Error("This resource requires authentication using your Akahu app secret. " +
                        "Include this using the `appSecret` option when initializing the AkahuClient.");
                }
                return Object.assign(Object.assign({}, config), { auth: { username: appToken, password: appSecret } });
            }
            // Token auth is used for user-specific endpoints
            if ("token" in auth) {
                return Object.assign(Object.assign({}, config), { headers: Object.assign(Object.assign({}, config.headers), { Authorization: `Bearer ${auth.token}` }) });
            }
        }
        return config;
    }
    _makeIdempotent(config, options) {
        var _a, _b;
        if (((_a = config.method) === null || _a === void 0 ? void 0 : _a.toUpperCase()) === "POST") {
            return Object.assign(Object.assign({}, config), { headers: Object.assign(Object.assign({}, config.headers), { "Idempotency-Key": (_b = options.idempotencyKey) !== null && _b !== void 0 ? _b : uuid.v4() }) });
        }
        return config;
    }
    _sanitizeQuery(query) {
        // Sanity check for attempts to paginate with a `null` cursor. This might
        // happen if the user blindly passes in the "next" cursor from a paginated
        // response without checking its value. `query.cursor` must either be
        // `undefined` or a string value.
        if (query.cursor === null) {
            throw new Error("Pagination cursor cannot be null. A null next cursor in an API " +
                "response indicates that the final page has been reached.");
        }
        return query;
    }
    /**
     * Generic API wrapper, exposed for use by client resources.
     * @internal
     */
    _apiCall({ path, method = "GET", query, data, auth, options = {}, }) {
        var _a, _b, _c;
        return tslib.__awaiter(this, void 0, void 0, function* () {
            let params = query;
            if (typeof params !== "undefined") {
                params = this._sanitizeQuery(params);
            }
            // Build up the request config object for axios
            let requestConfig = { url: path, method, params, data };
            requestConfig = this._authorizeRequest(requestConfig, auth);
            requestConfig = this._makeIdempotent(requestConfig, options);
            let response;
            try {
                response = yield this.axios.request(requestConfig);
            }
            catch (e) {
                const err = e;
                // Wrap error responses from the API
                if (typeof err.response !== "undefined") {
                    throw new AkahuErrorResponse(err.response);
                }
                // All other errors are re-raised.
                throw err;
            }
            // Unpack response:
            // - success will always be present
            // - cursor will be present in the case of paginated responses
            // - response value will generally be nested under `item`, `items`, or `item_id`
            const _d = response.data, { success, cursor } = _d, payload = tslib.__rest(_d, ["success", "cursor"]);
            // Check status flag from API. Generally we shouldn't hit this, as any response
            // with `success: false` should return a 4xx or 5xx status which would
            // cause an exception above.
            if (!success)
                throw new AkahuErrorResponse(response);
            // Results from paginated responses are always nested under `items`
            if (cursor) {
                return { cursor, items: payload.items };
            }
            // Unpacking of non-paginated response formats:
            // https://developers.akahu.nz/docs/response-formatting
            // Order is important here, as some endpoints return both `item` and
            // `item_id`, the latter of which is deprecated.
            return ((_c = (_b = (_a = payload.item) !== null && _a !== void 0 ? _a : payload.item_id) !== null && _b !== void 0 ? _b : payload.items) !== null && _c !== void 0 ? _c : (Object.keys(payload).length !== 0
                ? payload // OAuth response data is not nested to be spec-compliant
                : undefined)); // No response payload: no return value
        });
    }
}

exports.AkahuClient = AkahuClient;
//# sourceMappingURL=index.js.map
